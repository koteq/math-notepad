(function () {
   'use strict';

   /**
   The data structure for documents. @nonabstract
   */
   class Text {
       /**
       Get the line description around the given position.
       */
       lineAt(pos) {
           if (pos < 0 || pos > this.length)
               throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
           return this.lineInner(pos, false, 1, 0);
       }
       /**
       Get the description for the given (1-based) line number.
       */
       line(n) {
           if (n < 1 || n > this.lines)
               throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
           return this.lineInner(n, true, 1, 0);
       }
       /**
       Replace a range of the text with the given content.
       */
       replace(from, to, text) {
           let parts = [];
           this.decompose(0, from, parts, 2 /* Open.To */);
           if (text.length)
               text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
           this.decompose(to, this.length, parts, 1 /* Open.From */);
           return TextNode.from(parts, this.length - (to - from) + text.length);
       }
       /**
       Append another document to this one.
       */
       append(other) {
           return this.replace(this.length, this.length, other);
       }
       /**
       Retrieve the text between the given points.
       */
       slice(from, to = this.length) {
           let parts = [];
           this.decompose(from, to, parts, 0);
           return TextNode.from(parts, to - from);
       }
       /**
       Test whether this text is equal to another instance.
       */
       eq(other) {
           if (other == this)
               return true;
           if (other.length != this.length || other.lines != this.lines)
               return false;
           let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
           let a = new RawTextCursor(this), b = new RawTextCursor(other);
           for (let skip = start, pos = start;;) {
               a.next(skip);
               b.next(skip);
               skip = 0;
               if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                   return false;
               pos += a.value.length;
               if (a.done || pos >= end)
                   return true;
           }
       }
       /**
       Iterate over the text. When `dir` is `-1`, iteration happens
       from end to start. This will return lines and the breaks between
       them as separate strings.
       */
       iter(dir = 1) { return new RawTextCursor(this, dir); }
       /**
       Iterate over a range of the text. When `from` > `to`, the
       iterator will run in reverse.
       */
       iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
       /**
       Return a cursor that iterates over the given range of lines,
       _without_ returning the line breaks between, and yielding empty
       strings for empty lines.
       
       When `from` and `to` are given, they should be 1-based line numbers.
       */
       iterLines(from, to) {
           let inner;
           if (from == null) {
               inner = this.iter();
           }
           else {
               if (to == null)
                   to = this.lines + 1;
               let start = this.line(from).from;
               inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
           }
           return new LineCursor(inner);
       }
       /**
       Return the document as a string, using newline characters to
       separate lines.
       */
       toString() { return this.sliceString(0); }
       /**
       Convert the document to an array of lines (which can be
       deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
       */
       toJSON() {
           let lines = [];
           this.flatten(lines);
           return lines;
       }
       /**
       @internal
       */
       constructor() { }
       /**
       Create a `Text` instance for the given array of lines.
       */
       static of(text) {
           if (text.length == 0)
               throw new RangeError("A document must have at least one line");
           if (text.length == 1 && !text[0])
               return Text.empty;
           return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
       }
   }
   // Leaves store an array of line strings. There are always line breaks
   // between these strings. Leaves are limited in size and have to be
   // contained in TextNode instances for bigger documents.
   class TextLeaf extends Text {
       constructor(text, length = textLength(text)) {
           super();
           this.text = text;
           this.length = length;
       }
       get lines() { return this.text.length; }
       get children() { return null; }
       lineInner(target, isLine, line, offset) {
           for (let i = 0;; i++) {
               let string = this.text[i], end = offset + string.length;
               if ((isLine ? line : end) >= target)
                   return new Line(offset, end, line, string);
               offset = end + 1;
               line++;
           }
       }
       decompose(from, to, target, open) {
           let text = from <= 0 && to >= this.length ? this
               : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
           if (open & 1 /* Open.From */) {
               let prev = target.pop();
               let joined = appendText(text.text, prev.text.slice(), 0, text.length);
               if (joined.length <= 32 /* Tree.Branch */) {
                   target.push(new TextLeaf(joined, prev.length + text.length));
               }
               else {
                   let mid = joined.length >> 1;
                   target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
               }
           }
           else {
               target.push(text);
           }
       }
       replace(from, to, text) {
           if (!(text instanceof TextLeaf))
               return super.replace(from, to, text);
           let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
           let newLen = this.length + text.length - (to - from);
           if (lines.length <= 32 /* Tree.Branch */)
               return new TextLeaf(lines, newLen);
           return TextNode.from(TextLeaf.split(lines, []), newLen);
       }
       sliceString(from, to = this.length, lineSep = "\n") {
           let result = "";
           for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
               let line = this.text[i], end = pos + line.length;
               if (pos > from && i)
                   result += lineSep;
               if (from < end && to > pos)
                   result += line.slice(Math.max(0, from - pos), to - pos);
               pos = end + 1;
           }
           return result;
       }
       flatten(target) {
           for (let line of this.text)
               target.push(line);
       }
       scanIdentical() { return 0; }
       static split(text, target) {
           let part = [], len = -1;
           for (let line of text) {
               part.push(line);
               len += line.length + 1;
               if (part.length == 32 /* Tree.Branch */) {
                   target.push(new TextLeaf(part, len));
                   part = [];
                   len = -1;
               }
           }
           if (len > -1)
               target.push(new TextLeaf(part, len));
           return target;
       }
   }
   // Nodes provide the tree structure of the `Text` type. They store a
   // number of other nodes or leaves, taking care to balance themselves
   // on changes. There are implied line breaks _between_ the children of
   // a node (but not before the first or after the last child).
   class TextNode extends Text {
       constructor(children, length) {
           super();
           this.children = children;
           this.length = length;
           this.lines = 0;
           for (let child of children)
               this.lines += child.lines;
       }
       lineInner(target, isLine, line, offset) {
           for (let i = 0;; i++) {
               let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
               if ((isLine ? endLine : end) >= target)
                   return child.lineInner(target, isLine, line, offset);
               offset = end + 1;
               line = endLine + 1;
           }
       }
       decompose(from, to, target, open) {
           for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
               let child = this.children[i], end = pos + child.length;
               if (from <= end && to >= pos) {
                   let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
                   if (pos >= from && end <= to && !childOpen)
                       target.push(child);
                   else
                       child.decompose(from - pos, to - pos, target, childOpen);
               }
               pos = end + 1;
           }
       }
       replace(from, to, text) {
           if (text.lines < this.lines)
               for (let i = 0, pos = 0; i < this.children.length; i++) {
                   let child = this.children[i], end = pos + child.length;
                   // Fast path: if the change only affects one child and the
                   // child's size remains in the acceptable range, only update
                   // that child
                   if (from >= pos && to <= end) {
                       let updated = child.replace(from - pos, to - pos, text);
                       let totalLines = this.lines - child.lines + updated.lines;
                       if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&
                           updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {
                           let copy = this.children.slice();
                           copy[i] = updated;
                           return new TextNode(copy, this.length - (to - from) + text.length);
                       }
                       return super.replace(pos, end, updated);
                   }
                   pos = end + 1;
               }
           return super.replace(from, to, text);
       }
       sliceString(from, to = this.length, lineSep = "\n") {
           let result = "";
           for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
               let child = this.children[i], end = pos + child.length;
               if (pos > from && i)
                   result += lineSep;
               if (from < end && to > pos)
                   result += child.sliceString(from - pos, to - pos, lineSep);
               pos = end + 1;
           }
           return result;
       }
       flatten(target) {
           for (let child of this.children)
               child.flatten(target);
       }
       scanIdentical(other, dir) {
           if (!(other instanceof TextNode))
               return 0;
           let length = 0;
           let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
               : [this.children.length - 1, other.children.length - 1, -1, -1];
           for (;; iA += dir, iB += dir) {
               if (iA == eA || iB == eB)
                   return length;
               let chA = this.children[iA], chB = other.children[iB];
               if (chA != chB)
                   return length + chA.scanIdentical(chB, dir);
               length += chA.length + 1;
           }
       }
       static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
           let lines = 0;
           for (let ch of children)
               lines += ch.lines;
           if (lines < 32 /* Tree.Branch */) {
               let flat = [];
               for (let ch of children)
                   ch.flatten(flat);
               return new TextLeaf(flat, length);
           }
           let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
           let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
           function add(child) {
               let last;
               if (child.lines > maxChunk && child instanceof TextNode) {
                   for (let node of child.children)
                       add(node);
               }
               else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                   flush();
                   chunked.push(child);
               }
               else if (child instanceof TextLeaf && currentLines &&
                   (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                   child.lines + last.lines <= 32 /* Tree.Branch */) {
                   currentLines += child.lines;
                   currentLen += child.length + 1;
                   currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
               }
               else {
                   if (currentLines + child.lines > chunk)
                       flush();
                   currentLines += child.lines;
                   currentLen += child.length + 1;
                   currentChunk.push(child);
               }
           }
           function flush() {
               if (currentLines == 0)
                   return;
               chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
               currentLen = -1;
               currentLines = currentChunk.length = 0;
           }
           for (let child of children)
               add(child);
           flush();
           return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
       }
   }
   Text.empty = /*@__PURE__*/new TextLeaf([""], 0);
   function textLength(text) {
       let length = -1;
       for (let line of text)
           length += line.length + 1;
       return length;
   }
   function appendText(text, target, from = 0, to = 1e9) {
       for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
           let line = text[i], end = pos + line.length;
           if (end >= from) {
               if (end > to)
                   line = line.slice(0, to - pos);
               if (pos < from)
                   line = line.slice(from - pos);
               if (first) {
                   target[target.length - 1] += line;
                   first = false;
               }
               else
                   target.push(line);
           }
           pos = end + 1;
       }
       return target;
   }
   function sliceText(text, from, to) {
       return appendText(text, [""], from, to);
   }
   class RawTextCursor {
       constructor(text, dir = 1) {
           this.dir = dir;
           this.done = false;
           this.lineBreak = false;
           this.value = "";
           this.nodes = [text];
           this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
       }
       nextInner(skip, dir) {
           this.done = this.lineBreak = false;
           for (;;) {
               let last = this.nodes.length - 1;
               let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
               let size = top instanceof TextLeaf ? top.text.length : top.children.length;
               if (offset == (dir > 0 ? size : 0)) {
                   if (last == 0) {
                       this.done = true;
                       this.value = "";
                       return this;
                   }
                   if (dir > 0)
                       this.offsets[last - 1]++;
                   this.nodes.pop();
                   this.offsets.pop();
               }
               else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                   this.offsets[last] += dir;
                   if (skip == 0) {
                       this.lineBreak = true;
                       this.value = "\n";
                       return this;
                   }
                   skip--;
               }
               else if (top instanceof TextLeaf) {
                   // Move to the next string
                   let next = top.text[offset + (dir < 0 ? -1 : 0)];
                   this.offsets[last] += dir;
                   if (next.length > Math.max(0, skip)) {
                       this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                       return this;
                   }
                   skip -= next.length;
               }
               else {
                   let next = top.children[offset + (dir < 0 ? -1 : 0)];
                   if (skip > next.length) {
                       skip -= next.length;
                       this.offsets[last] += dir;
                   }
                   else {
                       if (dir < 0)
                           this.offsets[last]--;
                       this.nodes.push(next);
                       this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                   }
               }
           }
       }
       next(skip = 0) {
           if (skip < 0) {
               this.nextInner(-skip, (-this.dir));
               skip = this.value.length;
           }
           return this.nextInner(skip, this.dir);
       }
   }
   class PartialTextCursor {
       constructor(text, start, end) {
           this.value = "";
           this.done = false;
           this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
           this.pos = start > end ? text.length : 0;
           this.from = Math.min(start, end);
           this.to = Math.max(start, end);
       }
       nextInner(skip, dir) {
           if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
               this.value = "";
               this.done = true;
               return this;
           }
           skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
           let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
           if (skip > limit)
               skip = limit;
           limit -= skip;
           let { value } = this.cursor.next(skip);
           this.pos += (value.length + skip) * dir;
           this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
           this.done = !this.value;
           return this;
       }
       next(skip = 0) {
           if (skip < 0)
               skip = Math.max(skip, this.from - this.pos);
           else if (skip > 0)
               skip = Math.min(skip, this.to - this.pos);
           return this.nextInner(skip, this.cursor.dir);
       }
       get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
   }
   class LineCursor {
       constructor(inner) {
           this.inner = inner;
           this.afterBreak = true;
           this.value = "";
           this.done = false;
       }
       next(skip = 0) {
           let { done, lineBreak, value } = this.inner.next(skip);
           if (done) {
               this.done = true;
               this.value = "";
           }
           else if (lineBreak) {
               if (this.afterBreak) {
                   this.value = "";
               }
               else {
                   this.afterBreak = true;
                   this.next();
               }
           }
           else {
               this.value = value;
               this.afterBreak = false;
           }
           return this;
       }
       get lineBreak() { return false; }
   }
   if (typeof Symbol != "undefined") {
       Text.prototype[Symbol.iterator] = function () { return this.iter(); };
       RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
           LineCursor.prototype[Symbol.iterator] = function () { return this; };
   }
   /**
   This type describes a line in the document. It is created
   on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
   */
   class Line {
       /**
       @internal
       */
       constructor(
       /**
       The position of the start of the line.
       */
       from, 
       /**
       The position at the end of the line (_before_ the line break,
       or at the end of document for the last line).
       */
       to, 
       /**
       This line's line number (1-based).
       */
       number, 
       /**
       The line's content.
       */
       text) {
           this.from = from;
           this.to = to;
           this.number = number;
           this.text = text;
       }
       /**
       The length of the line (not including any line break after it).
       */
       get length() { return this.to - this.from; }
   }

   // Compressed representation of the Grapheme_Cluster_Break=Extend
   // information from
   // http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
   // Each pair of elements represents a range, as an offet from the
   // previous range and a length. Numbers are in base-36, with the empty
   // string being a shorthand for 1.
   let extend$1 = /*@__PURE__*/"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
   // Convert offsets into absolute values
   for (let i = 1; i < extend$1.length; i++)
       extend$1[i] += extend$1[i - 1];
   function isExtendingChar(code) {
       for (let i = 1; i < extend$1.length; i += 2)
           if (extend$1[i] > code)
               return extend$1[i - 1] <= code;
       return false;
   }
   function isRegionalIndicator(code) {
       return code >= 0x1F1E6 && code <= 0x1F1FF;
   }
   const ZWJ = 0x200d;
   /**
   Returns a next grapheme cluster break _after_ (not equal to)
   `pos`, if `forward` is true, or before otherwise. Returns `pos`
   itself if no further cluster break is available in the string.
   Moves across surrogate pairs, extending characters (when
   `includeExtending` is true), characters joined with zero-width
   joiners, and flag emoji.
   */
   function findClusterBreak(str, pos, forward = true, includeExtending = true) {
       return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
   }
   function nextClusterBreak(str, pos, includeExtending) {
       if (pos == str.length)
           return pos;
       // If pos is in the middle of a surrogate pair, move to its start
       if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
           pos--;
       let prev = codePointAt(str, pos);
       pos += codePointSize(prev);
       while (pos < str.length) {
           let next = codePointAt(str, pos);
           if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
               pos += codePointSize(next);
               prev = next;
           }
           else if (isRegionalIndicator(next)) {
               let countBefore = 0, i = pos - 2;
               while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                   countBefore++;
                   i -= 2;
               }
               if (countBefore % 2 == 0)
                   break;
               else
                   pos += 2;
           }
           else {
               break;
           }
       }
       return pos;
   }
   function prevClusterBreak(str, pos, includeExtending) {
       while (pos > 0) {
           let found = nextClusterBreak(str, pos - 2, includeExtending);
           if (found < pos)
               return found;
           pos--;
       }
       return 0;
   }
   function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
   function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
   /**
   Find the code point at the given position in a string (like the
   [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
   string method).
   */
   function codePointAt(str, pos) {
       let code0 = str.charCodeAt(pos);
       if (!surrogateHigh(code0) || pos + 1 == str.length)
           return code0;
       let code1 = str.charCodeAt(pos + 1);
       if (!surrogateLow(code1))
           return code0;
       return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
   }
   /**
   Given a Unicode codepoint, return the JavaScript string that
   respresents it (like
   [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
   */
   function fromCodePoint(code) {
       if (code <= 0xffff)
           return String.fromCharCode(code);
       code -= 0x10000;
       return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
   }
   /**
   The amount of positions a character takes up a JavaScript string.
   */
   function codePointSize(code) { return code < 0x10000 ? 1 : 2; }

   const DefaultSplit = /\r\n?|\n/;
   /**
   Distinguishes different ways in which positions can be mapped.
   */
   var MapMode = /*@__PURE__*/(function (MapMode) {
       /**
       Map a position to a valid new position, even when its context
       was deleted.
       */
       MapMode[MapMode["Simple"] = 0] = "Simple";
       /**
       Return null if deletion happens across the position.
       */
       MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
       /**
       Return null if the character _before_ the position is deleted.
       */
       MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
       /**
       Return null if the character _after_ the position is deleted.
       */
       MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
   return MapMode})(MapMode || (MapMode = {}));
   /**
   A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
   that doesn't store the inserted text. As such, it can't be
   applied, but is cheaper to store and manipulate.
   */
   class ChangeDesc {
       // Sections are encoded as pairs of integers. The first is the
       // length in the current document, and the second is -1 for
       // unaffected sections, and the length of the replacement content
       // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
       // 0), and a replacement two positive numbers.
       /**
       @internal
       */
       constructor(
       /**
       @internal
       */
       sections) {
           this.sections = sections;
       }
       /**
       The length of the document before the change.
       */
       get length() {
           let result = 0;
           for (let i = 0; i < this.sections.length; i += 2)
               result += this.sections[i];
           return result;
       }
       /**
       The length of the document after the change.
       */
       get newLength() {
           let result = 0;
           for (let i = 0; i < this.sections.length; i += 2) {
               let ins = this.sections[i + 1];
               result += ins < 0 ? this.sections[i] : ins;
           }
           return result;
       }
       /**
       False when there are actual changes in this set.
       */
       get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
       /**
       Iterate over the unchanged parts left by these changes. `posA`
       provides the position of the range in the old document, `posB`
       the new position in the changed document.
       */
       iterGaps(f) {
           for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
               let len = this.sections[i++], ins = this.sections[i++];
               if (ins < 0) {
                   f(posA, posB, len);
                   posB += len;
               }
               else {
                   posB += ins;
               }
               posA += len;
           }
       }
       /**
       Iterate over the ranges changed by these changes. (See
       [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
       variant that also provides you with the inserted text.)
       `fromA`/`toA` provides the extent of the change in the starting
       document, `fromB`/`toB` the extent of the replacement in the
       changed document.
       
       When `individual` is true, adjacent changes (which are kept
       separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
       reported separately.
       */
       iterChangedRanges(f, individual = false) {
           iterChanges(this, f, individual);
       }
       /**
       Get a description of the inverted form of these changes.
       */
       get invertedDesc() {
           let sections = [];
           for (let i = 0; i < this.sections.length;) {
               let len = this.sections[i++], ins = this.sections[i++];
               if (ins < 0)
                   sections.push(len, ins);
               else
                   sections.push(ins, len);
           }
           return new ChangeDesc(sections);
       }
       /**
       Compute the combined effect of applying another set of changes
       after this one. The length of the document after this set should
       match the length before `other`.
       */
       composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
       /**
       Map this description, which should start with the same document
       as `other`, over another set of changes, so that it can be
       applied after it. When `before` is true, map as if the changes
       in `other` happened before the ones in `this`.
       */
       mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
       mapPos(pos, assoc = -1, mode = MapMode.Simple) {
           let posA = 0, posB = 0;
           for (let i = 0; i < this.sections.length;) {
               let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
               if (ins < 0) {
                   if (endA > pos)
                       return posB + (pos - posA);
                   posB += len;
               }
               else {
                   if (mode != MapMode.Simple && endA >= pos &&
                       (mode == MapMode.TrackDel && posA < pos && endA > pos ||
                           mode == MapMode.TrackBefore && posA < pos ||
                           mode == MapMode.TrackAfter && endA > pos))
                       return null;
                   if (endA > pos || endA == pos && assoc < 0 && !len)
                       return pos == posA || assoc < 0 ? posB : posB + ins;
                   posB += ins;
               }
               posA = endA;
           }
           if (pos > posA)
               throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
           return posB;
       }
       /**
       Check whether these changes touch a given range. When one of the
       changes entirely covers the range, the string `"cover"` is
       returned.
       */
       touchesRange(from, to = from) {
           for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
               let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
               if (ins >= 0 && pos <= to && end >= from)
                   return pos < from && end > to ? "cover" : true;
               pos = end;
           }
           return false;
       }
       /**
       @internal
       */
       toString() {
           let result = "";
           for (let i = 0; i < this.sections.length;) {
               let len = this.sections[i++], ins = this.sections[i++];
               result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
           }
           return result;
       }
       /**
       Serialize this change desc to a JSON-representable value.
       */
       toJSON() { return this.sections; }
       /**
       Create a change desc from its JSON representation (as produced
       by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
       */
       static fromJSON(json) {
           if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
               throw new RangeError("Invalid JSON representation of ChangeDesc");
           return new ChangeDesc(json);
       }
       /**
       @internal
       */
       static create(sections) { return new ChangeDesc(sections); }
   }
   /**
   A change set represents a group of modifications to a document. It
   stores the document length, and can only be applied to documents
   with exactly that length.
   */
   class ChangeSet extends ChangeDesc {
       constructor(sections, 
       /**
       @internal
       */
       inserted) {
           super(sections);
           this.inserted = inserted;
       }
       /**
       Apply the changes to a document, returning the modified
       document.
       */
       apply(doc) {
           if (this.length != doc.length)
               throw new RangeError("Applying change set to a document with the wrong length");
           iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
           return doc;
       }
       mapDesc(other, before = false) { return mapSet(this, other, before, true); }
       /**
       Given the document as it existed _before_ the changes, return a
       change set that represents the inverse of this set, which could
       be used to go from the document created by the changes back to
       the document as it existed before the changes.
       */
       invert(doc) {
           let sections = this.sections.slice(), inserted = [];
           for (let i = 0, pos = 0; i < sections.length; i += 2) {
               let len = sections[i], ins = sections[i + 1];
               if (ins >= 0) {
                   sections[i] = ins;
                   sections[i + 1] = len;
                   let index = i >> 1;
                   while (inserted.length < index)
                       inserted.push(Text.empty);
                   inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
               }
               pos += len;
           }
           return new ChangeSet(sections, inserted);
       }
       /**
       Combine two subsequent change sets into a single set. `other`
       must start in the document produced by `this`. If `this` goes
       `docA` → `docB` and `other` represents `docB` → `docC`, the
       returned value will represent the change `docA` → `docC`.
       */
       compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
       /**
       Given another change set starting in the same document, maps this
       change set over the other, producing a new change set that can be
       applied to the document produced by applying `other`. When
       `before` is `true`, order changes as if `this` comes before
       `other`, otherwise (the default) treat `other` as coming first.
       
       Given two changes `A` and `B`, `A.compose(B.map(A))` and
       `B.compose(A.map(B, true))` will produce the same document. This
       provides a basic form of [operational
       transformation](https://en.wikipedia.org/wiki/Operational_transformation),
       and can be used for collaborative editing.
       */
       map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
       /**
       Iterate over the changed ranges in the document, calling `f` for
       each, with the range in the original document (`fromA`-`toA`)
       and the range that replaces it in the new document
       (`fromB`-`toB`).
       
       When `individual` is true, adjacent changes are reported
       separately.
       */
       iterChanges(f, individual = false) {
           iterChanges(this, f, individual);
       }
       /**
       Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
       set.
       */
       get desc() { return ChangeDesc.create(this.sections); }
       /**
       @internal
       */
       filter(ranges) {
           let resultSections = [], resultInserted = [], filteredSections = [];
           let iter = new SectionIter(this);
           done: for (let i = 0, pos = 0;;) {
               let next = i == ranges.length ? 1e9 : ranges[i++];
               while (pos < next || pos == next && iter.len == 0) {
                   if (iter.done)
                       break done;
                   let len = Math.min(iter.len, next - pos);
                   addSection(filteredSections, len, -1);
                   let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                   addSection(resultSections, len, ins);
                   if (ins > 0)
                       addInsert(resultInserted, resultSections, iter.text);
                   iter.forward(len);
                   pos += len;
               }
               let end = ranges[i++];
               while (pos < end) {
                   if (iter.done)
                       break done;
                   let len = Math.min(iter.len, end - pos);
                   addSection(resultSections, len, -1);
                   addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                   iter.forward(len);
                   pos += len;
               }
           }
           return { changes: new ChangeSet(resultSections, resultInserted),
               filtered: ChangeDesc.create(filteredSections) };
       }
       /**
       Serialize this change set to a JSON-representable value.
       */
       toJSON() {
           let parts = [];
           for (let i = 0; i < this.sections.length; i += 2) {
               let len = this.sections[i], ins = this.sections[i + 1];
               if (ins < 0)
                   parts.push(len);
               else if (ins == 0)
                   parts.push([len]);
               else
                   parts.push([len].concat(this.inserted[i >> 1].toJSON()));
           }
           return parts;
       }
       /**
       Create a change set for the given changes, for a document of the
       given length, using `lineSep` as line separator.
       */
       static of(changes, length, lineSep) {
           let sections = [], inserted = [], pos = 0;
           let total = null;
           function flush(force = false) {
               if (!force && !sections.length)
                   return;
               if (pos < length)
                   addSection(sections, length - pos, -1);
               let set = new ChangeSet(sections, inserted);
               total = total ? total.compose(set.map(total)) : set;
               sections = [];
               inserted = [];
               pos = 0;
           }
           function process(spec) {
               if (Array.isArray(spec)) {
                   for (let sub of spec)
                       process(sub);
               }
               else if (spec instanceof ChangeSet) {
                   if (spec.length != length)
                       throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                   flush();
                   total = total ? total.compose(spec.map(total)) : spec;
               }
               else {
                   let { from, to = from, insert } = spec;
                   if (from > to || from < 0 || to > length)
                       throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                   let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                   let insLen = insText.length;
                   if (from == to && insLen == 0)
                       return;
                   if (from < pos)
                       flush();
                   if (from > pos)
                       addSection(sections, from - pos, -1);
                   addSection(sections, to - from, insLen);
                   addInsert(inserted, sections, insText);
                   pos = to;
               }
           }
           process(changes);
           flush(!total);
           return total;
       }
       /**
       Create an empty changeset of the given length.
       */
       static empty(length) {
           return new ChangeSet(length ? [length, -1] : [], []);
       }
       /**
       Create a changeset from its JSON representation (as produced by
       [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
       */
       static fromJSON(json) {
           if (!Array.isArray(json))
               throw new RangeError("Invalid JSON representation of ChangeSet");
           let sections = [], inserted = [];
           for (let i = 0; i < json.length; i++) {
               let part = json[i];
               if (typeof part == "number") {
                   sections.push(part, -1);
               }
               else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                   throw new RangeError("Invalid JSON representation of ChangeSet");
               }
               else if (part.length == 1) {
                   sections.push(part[0], 0);
               }
               else {
                   while (inserted.length < i)
                       inserted.push(Text.empty);
                   inserted[i] = Text.of(part.slice(1));
                   sections.push(part[0], inserted[i].length);
               }
           }
           return new ChangeSet(sections, inserted);
       }
       /**
       @internal
       */
       static createSet(sections, inserted) {
           return new ChangeSet(sections, inserted);
       }
   }
   function addSection(sections, len, ins, forceJoin = false) {
       if (len == 0 && ins <= 0)
           return;
       let last = sections.length - 2;
       if (last >= 0 && ins <= 0 && ins == sections[last + 1])
           sections[last] += len;
       else if (len == 0 && sections[last] == 0)
           sections[last + 1] += ins;
       else if (forceJoin) {
           sections[last] += len;
           sections[last + 1] += ins;
       }
       else
           sections.push(len, ins);
   }
   function addInsert(values, sections, value) {
       if (value.length == 0)
           return;
       let index = (sections.length - 2) >> 1;
       if (index < values.length) {
           values[values.length - 1] = values[values.length - 1].append(value);
       }
       else {
           while (values.length < index)
               values.push(Text.empty);
           values.push(value);
       }
   }
   function iterChanges(desc, f, individual) {
       let inserted = desc.inserted;
       for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
           let len = desc.sections[i++], ins = desc.sections[i++];
           if (ins < 0) {
               posA += len;
               posB += len;
           }
           else {
               let endA = posA, endB = posB, text = Text.empty;
               for (;;) {
                   endA += len;
                   endB += ins;
                   if (ins && inserted)
                       text = text.append(inserted[(i - 2) >> 1]);
                   if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                       break;
                   len = desc.sections[i++];
                   ins = desc.sections[i++];
               }
               f(posA, endA, posB, endB, text);
               posA = endA;
               posB = endB;
           }
       }
   }
   function mapSet(setA, setB, before, mkSet = false) {
       // Produce a copy of setA that applies to the document after setB
       // has been applied (assuming both start at the same document).
       let sections = [], insert = mkSet ? [] : null;
       let a = new SectionIter(setA), b = new SectionIter(setB);
       // Iterate over both sets in parallel. inserted tracks, for changes
       // in A that have to be processed piece-by-piece, whether their
       // content has been inserted already, and refers to the section
       // index.
       for (let inserted = -1;;) {
           if (a.ins == -1 && b.ins == -1) {
               // Move across ranges skipped by both sets.
               let len = Math.min(a.len, b.len);
               addSection(sections, len, -1);
               a.forward(len);
               b.forward(len);
           }
           else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
               // If there's a change in B that comes before the next change in
               // A (ordered by start pos, then len, then before flag), skip
               // that (and process any changes in A it covers).
               let len = b.len;
               addSection(sections, b.ins, -1);
               while (len) {
                   let piece = Math.min(a.len, len);
                   if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                       addSection(sections, 0, a.ins);
                       if (insert)
                           addInsert(insert, sections, a.text);
                       inserted = a.i;
                   }
                   a.forward(piece);
                   len -= piece;
               }
               b.next();
           }
           else if (a.ins >= 0) {
               // Process the part of a change in A up to the start of the next
               // non-deletion change in B (if overlapping).
               let len = 0, left = a.len;
               while (left) {
                   if (b.ins == -1) {
                       let piece = Math.min(left, b.len);
                       len += piece;
                       left -= piece;
                       b.forward(piece);
                   }
                   else if (b.ins == 0 && b.len < left) {
                       left -= b.len;
                       b.next();
                   }
                   else {
                       break;
                   }
               }
               addSection(sections, len, inserted < a.i ? a.ins : 0);
               if (insert && inserted < a.i)
                   addInsert(insert, sections, a.text);
               inserted = a.i;
               a.forward(a.len - left);
           }
           else if (a.done && b.done) {
               return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
           }
           else {
               throw new Error("Mismatched change set lengths");
           }
       }
   }
   function composeSets(setA, setB, mkSet = false) {
       let sections = [];
       let insert = mkSet ? [] : null;
       let a = new SectionIter(setA), b = new SectionIter(setB);
       for (let open = false;;) {
           if (a.done && b.done) {
               return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
           }
           else if (a.ins == 0) { // Deletion in A
               addSection(sections, a.len, 0, open);
               a.next();
           }
           else if (b.len == 0 && !b.done) { // Insertion in B
               addSection(sections, 0, b.ins, open);
               if (insert)
                   addInsert(insert, sections, b.text);
               b.next();
           }
           else if (a.done || b.done) {
               throw new Error("Mismatched change set lengths");
           }
           else {
               let len = Math.min(a.len2, b.len), sectionLen = sections.length;
               if (a.ins == -1) {
                   let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                   addSection(sections, len, insB, open);
                   if (insert && insB)
                       addInsert(insert, sections, b.text);
               }
               else if (b.ins == -1) {
                   addSection(sections, a.off ? 0 : a.len, len, open);
                   if (insert)
                       addInsert(insert, sections, a.textBit(len));
               }
               else {
                   addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                   if (insert && !b.off)
                       addInsert(insert, sections, b.text);
               }
               open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
               a.forward2(len);
               b.forward(len);
           }
       }
   }
   class SectionIter {
       constructor(set) {
           this.set = set;
           this.i = 0;
           this.next();
       }
       next() {
           let { sections } = this.set;
           if (this.i < sections.length) {
               this.len = sections[this.i++];
               this.ins = sections[this.i++];
           }
           else {
               this.len = 0;
               this.ins = -2;
           }
           this.off = 0;
       }
       get done() { return this.ins == -2; }
       get len2() { return this.ins < 0 ? this.len : this.ins; }
       get text() {
           let { inserted } = this.set, index = (this.i - 2) >> 1;
           return index >= inserted.length ? Text.empty : inserted[index];
       }
       textBit(len) {
           let { inserted } = this.set, index = (this.i - 2) >> 1;
           return index >= inserted.length && !len ? Text.empty
               : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
       }
       forward(len) {
           if (len == this.len)
               this.next();
           else {
               this.len -= len;
               this.off += len;
           }
       }
       forward2(len) {
           if (this.ins == -1)
               this.forward(len);
           else if (len == this.ins)
               this.next();
           else {
               this.ins -= len;
               this.off += len;
           }
       }
   }

   /**
   A single selection range. When
   [`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
   is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
   multiple ranges. By default, selections hold exactly one range.
   */
   class SelectionRange {
       constructor(
       /**
       The lower boundary of the range.
       */
       from, 
       /**
       The upper boundary of the range.
       */
       to, flags) {
           this.from = from;
           this.to = to;
           this.flags = flags;
       }
       /**
       The anchor of the range—the side that doesn't move when you
       extend it.
       */
       get anchor() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from; }
       /**
       The head of the range, which is moved when the range is
       [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
       */
       get head() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to; }
       /**
       True when `anchor` and `head` are at the same position.
       */
       get empty() { return this.from == this.to; }
       /**
       If this is a cursor that is explicitly associated with the
       character on one of its sides, this returns the side. -1 means
       the character before its position, 1 the character after, and 0
       means no association.
       */
       get assoc() { return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0; }
       /**
       The bidirectional text level associated with this cursor, if
       any.
       */
       get bidiLevel() {
           let level = this.flags & 3 /* RangeFlag.BidiLevelMask */;
           return level == 3 ? null : level;
       }
       /**
       The goal column (stored vertical offset) associated with a
       cursor. This is used to preserve the vertical position when
       [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
       lines of different length.
       */
       get goalColumn() {
           let value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;
           return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;
       }
       /**
       Map this range through a change, producing a valid range in the
       updated document.
       */
       map(change, assoc = -1) {
           let from, to;
           if (this.empty) {
               from = to = change.mapPos(this.from, assoc);
           }
           else {
               from = change.mapPos(this.from, 1);
               to = change.mapPos(this.to, -1);
           }
           return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
       }
       /**
       Extend this range to cover at least `from` to `to`.
       */
       extend(from, to = from) {
           if (from <= this.anchor && to >= this.anchor)
               return EditorSelection.range(from, to);
           let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
           return EditorSelection.range(this.anchor, head);
       }
       /**
       Compare this range to another range.
       */
       eq(other) {
           return this.anchor == other.anchor && this.head == other.head;
       }
       /**
       Return a JSON-serializable object representing the range.
       */
       toJSON() { return { anchor: this.anchor, head: this.head }; }
       /**
       Convert a JSON representation of a range to a `SelectionRange`
       instance.
       */
       static fromJSON(json) {
           if (!json || typeof json.anchor != "number" || typeof json.head != "number")
               throw new RangeError("Invalid JSON representation for SelectionRange");
           return EditorSelection.range(json.anchor, json.head);
       }
       /**
       @internal
       */
       static create(from, to, flags) {
           return new SelectionRange(from, to, flags);
       }
   }
   /**
   An editor selection holds one or more selection ranges.
   */
   class EditorSelection {
       constructor(
       /**
       The ranges in the selection, sorted by position. Ranges cannot
       overlap (but they may touch, if they aren't empty).
       */
       ranges, 
       /**
       The index of the _main_ range in the selection (which is
       usually the range that was added last).
       */
       mainIndex) {
           this.ranges = ranges;
           this.mainIndex = mainIndex;
       }
       /**
       Map a selection through a change. Used to adjust the selection
       position for changes.
       */
       map(change, assoc = -1) {
           if (change.empty)
               return this;
           return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
       }
       /**
       Compare this selection to another selection.
       */
       eq(other) {
           if (this.ranges.length != other.ranges.length ||
               this.mainIndex != other.mainIndex)
               return false;
           for (let i = 0; i < this.ranges.length; i++)
               if (!this.ranges[i].eq(other.ranges[i]))
                   return false;
           return true;
       }
       /**
       Get the primary selection range. Usually, you should make sure
       your code applies to _all_ ranges, by using methods like
       [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
       */
       get main() { return this.ranges[this.mainIndex]; }
       /**
       Make sure the selection only has one range. Returns a selection
       holding only the main range from this selection.
       */
       asSingle() {
           return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
       }
       /**
       Extend this selection with an extra range.
       */
       addRange(range, main = true) {
           return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
       }
       /**
       Replace a given range with another range, and then normalize the
       selection to merge and sort ranges if necessary.
       */
       replaceRange(range, which = this.mainIndex) {
           let ranges = this.ranges.slice();
           ranges[which] = range;
           return EditorSelection.create(ranges, this.mainIndex);
       }
       /**
       Convert this selection to an object that can be serialized to
       JSON.
       */
       toJSON() {
           return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
       }
       /**
       Create a selection from a JSON representation.
       */
       static fromJSON(json) {
           if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
               throw new RangeError("Invalid JSON representation for EditorSelection");
           return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
       }
       /**
       Create a selection holding a single range.
       */
       static single(anchor, head = anchor) {
           return new EditorSelection([EditorSelection.range(anchor, head)], 0);
       }
       /**
       Sort and merge the given set of ranges, creating a valid
       selection.
       */
       static create(ranges, mainIndex = 0) {
           if (ranges.length == 0)
               throw new RangeError("A selection needs at least one range");
           for (let pos = 0, i = 0; i < ranges.length; i++) {
               let range = ranges[i];
               if (range.empty ? range.from <= pos : range.from < pos)
                   return EditorSelection.normalized(ranges.slice(), mainIndex);
               pos = range.to;
           }
           return new EditorSelection(ranges, mainIndex);
       }
       /**
       Create a cursor selection range at the given position. You can
       safely ignore the optional arguments in most situations.
       */
       static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
           return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) |
               (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |
               ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */));
       }
       /**
       Create a selection range.
       */
       static range(anchor, head, goalColumn, bidiLevel) {
           let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */) |
               (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
           return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | 8 /* RangeFlag.AssocAfter */ | flags)
               : SelectionRange.create(anchor, head, (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0) | flags);
       }
       /**
       @internal
       */
       static normalized(ranges, mainIndex = 0) {
           let main = ranges[mainIndex];
           ranges.sort((a, b) => a.from - b.from);
           mainIndex = ranges.indexOf(main);
           for (let i = 1; i < ranges.length; i++) {
               let range = ranges[i], prev = ranges[i - 1];
               if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                   let from = prev.from, to = Math.max(range.to, prev.to);
                   if (i <= mainIndex)
                       mainIndex--;
                   ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
               }
           }
           return new EditorSelection(ranges, mainIndex);
       }
   }
   function checkSelection(selection, docLength) {
       for (let range of selection.ranges)
           if (range.to > docLength)
               throw new RangeError("Selection points outside of document");
   }

   let nextID = 0;
   /**
   A facet is a labeled value that is associated with an editor
   state. It takes inputs from any number of extensions, and combines
   those into a single output value.

   Examples of uses of facets are the [tab
   size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
   attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
   listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).
   */
   class Facet {
       constructor(
       /**
       @internal
       */
       combine, 
       /**
       @internal
       */
       compareInput, 
       /**
       @internal
       */
       compare, isStatic, enables) {
           this.combine = combine;
           this.compareInput = compareInput;
           this.compare = compare;
           this.isStatic = isStatic;
           /**
           @internal
           */
           this.id = nextID++;
           this.default = combine([]);
           this.extensions = typeof enables == "function" ? enables(this) : enables;
       }
       /**
       Define a new facet.
       */
       static define(config = {}) {
           return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray$1 : (a, b) => a === b), !!config.static, config.enables);
       }
       /**
       Returns an extension that adds the given value to this facet.
       */
       of(value) {
           return new FacetProvider([], this, 0 /* Provider.Static */, value);
       }
       /**
       Create an extension that computes a value for the facet from a
       state. You must take care to declare the parts of the state that
       this value depends on, since your function is only called again
       for a new state when one of those parts changed.
       
       In cases where your value depends only on a single field, you'll
       want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
       */
       compute(deps, get) {
           if (this.isStatic)
               throw new Error("Can't compute a static facet");
           return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
       }
       /**
       Create an extension that computes zero or more values for this
       facet from a state.
       */
       computeN(deps, get) {
           if (this.isStatic)
               throw new Error("Can't compute a static facet");
           return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
       }
       from(field, get) {
           if (!get)
               get = x => x;
           return this.compute([field], state => get(state.field(field)));
       }
   }
   function sameArray$1(a, b) {
       return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
   }
   class FacetProvider {
       constructor(dependencies, facet, type, value) {
           this.dependencies = dependencies;
           this.facet = facet;
           this.type = type;
           this.value = value;
           this.id = nextID++;
       }
       dynamicSlot(addresses) {
           var _a;
           let getter = this.value;
           let compare = this.facet.compareInput;
           let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;
           let depDoc = false, depSel = false, depAddrs = [];
           for (let dep of this.dependencies) {
               if (dep == "doc")
                   depDoc = true;
               else if (dep == "selection")
                   depSel = true;
               else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                   depAddrs.push(addresses[dep.id]);
           }
           return {
               create(state) {
                   state.values[idx] = getter(state);
                   return 1 /* SlotStatus.Changed */;
               },
               update(state, tr) {
                   if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                       let newVal = getter(state);
                       if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                           state.values[idx] = newVal;
                           return 1 /* SlotStatus.Changed */;
                       }
                   }
                   return 0;
               },
               reconfigure: (state, oldState) => {
                   let newVal, oldAddr = oldState.config.address[id];
                   if (oldAddr != null) {
                       let oldVal = getAddr(oldState, oldAddr);
                       if (this.dependencies.every(dep => {
                           return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                               dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                       }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                           state.values[idx] = oldVal;
                           return 0;
                       }
                   }
                   else {
                       newVal = getter(state);
                   }
                   state.values[idx] = newVal;
                   return 1 /* SlotStatus.Changed */;
               }
           };
       }
   }
   function compareArray(a, b, compare) {
       if (a.length != b.length)
           return false;
       for (let i = 0; i < a.length; i++)
           if (!compare(a[i], b[i]))
               return false;
       return true;
   }
   function ensureAll(state, addrs) {
       let changed = false;
       for (let addr of addrs)
           if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)
               changed = true;
       return changed;
   }
   function dynamicFacetSlot(addresses, facet, providers) {
       let providerAddrs = providers.map(p => addresses[p.id]);
       let providerTypes = providers.map(p => p.type);
       let dynamic = providerAddrs.filter(p => !(p & 1));
       let idx = addresses[facet.id] >> 1;
       function get(state) {
           let values = [];
           for (let i = 0; i < providerAddrs.length; i++) {
               let value = getAddr(state, providerAddrs[i]);
               if (providerTypes[i] == 2 /* Provider.Multi */)
                   for (let val of value)
                       values.push(val);
               else
                   values.push(value);
           }
           return facet.combine(values);
       }
       return {
           create(state) {
               for (let addr of providerAddrs)
                   ensureAddr(state, addr);
               state.values[idx] = get(state);
               return 1 /* SlotStatus.Changed */;
           },
           update(state, tr) {
               if (!ensureAll(state, dynamic))
                   return 0;
               let value = get(state);
               if (facet.compare(value, state.values[idx]))
                   return 0;
               state.values[idx] = value;
               return 1 /* SlotStatus.Changed */;
           },
           reconfigure(state, oldState) {
               let depChanged = ensureAll(state, providerAddrs);
               let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
               if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
                   state.values[idx] = oldValue;
                   return 0;
               }
               let value = get(state);
               if (facet.compare(value, oldValue)) {
                   state.values[idx] = oldValue;
                   return 0;
               }
               state.values[idx] = value;
               return 1 /* SlotStatus.Changed */;
           }
       };
   }
   const initField = /*@__PURE__*/Facet.define({ static: true });
   /**
   Fields can store additional information in an editor state, and
   keep it in sync with the rest of the state.
   */
   class StateField {
       constructor(
       /**
       @internal
       */
       id, createF, updateF, compareF, 
       /**
       @internal
       */
       spec) {
           this.id = id;
           this.createF = createF;
           this.updateF = updateF;
           this.compareF = compareF;
           this.spec = spec;
           /**
           @internal
           */
           this.provides = undefined;
       }
       /**
       Define a state field.
       */
       static define(config) {
           let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
           if (config.provide)
               field.provides = config.provide(field);
           return field;
       }
       create(state) {
           let init = state.facet(initField).find(i => i.field == this);
           return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
       }
       /**
       @internal
       */
       slot(addresses) {
           let idx = addresses[this.id] >> 1;
           return {
               create: (state) => {
                   state.values[idx] = this.create(state);
                   return 1 /* SlotStatus.Changed */;
               },
               update: (state, tr) => {
                   let oldVal = state.values[idx];
                   let value = this.updateF(oldVal, tr);
                   if (this.compareF(oldVal, value))
                       return 0;
                   state.values[idx] = value;
                   return 1 /* SlotStatus.Changed */;
               },
               reconfigure: (state, oldState) => {
                   if (oldState.config.address[this.id] != null) {
                       state.values[idx] = oldState.field(this);
                       return 0;
                   }
                   state.values[idx] = this.create(state);
                   return 1 /* SlotStatus.Changed */;
               }
           };
       }
       /**
       Returns an extension that enables this field and overrides the
       way it is initialized. Can be useful when you need to provide a
       non-default starting value for the field.
       */
       init(create) {
           return [this, initField.of({ field: this, create })];
       }
       /**
       State field instances can be used as
       [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
       given state.
       */
       get extension() { return this; }
   }
   const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
   function prec(value) {
       return (ext) => new PrecExtension(ext, value);
   }
   /**
   By default extensions are registered in the order they are found
   in the flattened form of nested array that was provided.
   Individual extension values can be assigned a precedence to
   override this. Extensions that do not have a precedence set get
   the precedence of the nearest parent with a precedence, or
   [`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
   final ordering of extensions is determined by first sorting by
   precedence and then by order within each precedence.
   */
   const Prec = {
       /**
       The highest precedence level, for extensions that should end up
       near the start of the precedence ordering.
       */
       highest: /*@__PURE__*/prec(Prec_.highest),
       /**
       A higher-than-default precedence, for extensions that should
       come before those with default precedence.
       */
       high: /*@__PURE__*/prec(Prec_.high),
       /**
       The default precedence, which is also used for extensions
       without an explicit precedence.
       */
       default: /*@__PURE__*/prec(Prec_.default),
       /**
       A lower-than-default precedence.
       */
       low: /*@__PURE__*/prec(Prec_.low),
       /**
       The lowest precedence level. Meant for things that should end up
       near the end of the extension order.
       */
       lowest: /*@__PURE__*/prec(Prec_.lowest)
   };
   class PrecExtension {
       constructor(inner, prec) {
           this.inner = inner;
           this.prec = prec;
       }
   }
   /**
   Extension compartments can be used to make a configuration
   dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
   configuration in a compartment, you can later
   [replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
   transaction.
   */
   class Compartment {
       /**
       Create an instance of this compartment to add to your [state
       configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
       */
       of(ext) { return new CompartmentInstance(this, ext); }
       /**
       Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
       reconfigures this compartment.
       */
       reconfigure(content) {
           return Compartment.reconfigure.of({ compartment: this, extension: content });
       }
       /**
       Get the current content of the compartment in the state, or
       `undefined` if it isn't present.
       */
       get(state) {
           return state.config.compartments.get(this);
       }
   }
   class CompartmentInstance {
       constructor(compartment, inner) {
           this.compartment = compartment;
           this.inner = inner;
       }
   }
   class Configuration {
       constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
           this.base = base;
           this.compartments = compartments;
           this.dynamicSlots = dynamicSlots;
           this.address = address;
           this.staticValues = staticValues;
           this.facets = facets;
           this.statusTemplate = [];
           while (this.statusTemplate.length < dynamicSlots.length)
               this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
       }
       staticFacet(facet) {
           let addr = this.address[facet.id];
           return addr == null ? facet.default : this.staticValues[addr >> 1];
       }
       static resolve(base, compartments, oldState) {
           let fields = [];
           let facets = Object.create(null);
           let newCompartments = new Map();
           for (let ext of flatten$2(base, compartments, newCompartments)) {
               if (ext instanceof StateField)
                   fields.push(ext);
               else
                   (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
           }
           let address = Object.create(null);
           let staticValues = [];
           let dynamicSlots = [];
           for (let field of fields) {
               address[field.id] = dynamicSlots.length << 1;
               dynamicSlots.push(a => field.slot(a));
           }
           let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
           for (let id in facets) {
               let providers = facets[id], facet = providers[0].facet;
               let oldProviders = oldFacets && oldFacets[id] || [];
               if (providers.every(p => p.type == 0 /* Provider.Static */)) {
                   address[facet.id] = (staticValues.length << 1) | 1;
                   if (sameArray$1(oldProviders, providers)) {
                       staticValues.push(oldState.facet(facet));
                   }
                   else {
                       let value = facet.combine(providers.map(p => p.value));
                       staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                   }
               }
               else {
                   for (let p of providers) {
                       if (p.type == 0 /* Provider.Static */) {
                           address[p.id] = (staticValues.length << 1) | 1;
                           staticValues.push(p.value);
                       }
                       else {
                           address[p.id] = dynamicSlots.length << 1;
                           dynamicSlots.push(a => p.dynamicSlot(a));
                       }
                   }
                   address[facet.id] = dynamicSlots.length << 1;
                   dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
               }
           }
           let dynamic = dynamicSlots.map(f => f(address));
           return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
       }
   }
   function flatten$2(extension, compartments, newCompartments) {
       let result = [[], [], [], [], []];
       let seen = new Map();
       function inner(ext, prec) {
           let known = seen.get(ext);
           if (known != null) {
               if (known <= prec)
                   return;
               let found = result[known].indexOf(ext);
               if (found > -1)
                   result[known].splice(found, 1);
               if (ext instanceof CompartmentInstance)
                   newCompartments.delete(ext.compartment);
           }
           seen.set(ext, prec);
           if (Array.isArray(ext)) {
               for (let e of ext)
                   inner(e, prec);
           }
           else if (ext instanceof CompartmentInstance) {
               if (newCompartments.has(ext.compartment))
                   throw new RangeError(`Duplicate use of compartment in extensions`);
               let content = compartments.get(ext.compartment) || ext.inner;
               newCompartments.set(ext.compartment, content);
               inner(content, prec);
           }
           else if (ext instanceof PrecExtension) {
               inner(ext.inner, ext.prec);
           }
           else if (ext instanceof StateField) {
               result[prec].push(ext);
               if (ext.provides)
                   inner(ext.provides, prec);
           }
           else if (ext instanceof FacetProvider) {
               result[prec].push(ext);
               if (ext.facet.extensions)
                   inner(ext.facet.extensions, Prec_.default);
           }
           else {
               let content = ext.extension;
               if (!content)
                   throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
               inner(content, prec);
           }
       }
       inner(extension, Prec_.default);
       return result.reduce((a, b) => a.concat(b));
   }
   function ensureAddr(state, addr) {
       if (addr & 1)
           return 2 /* SlotStatus.Computed */;
       let idx = addr >> 1;
       let status = state.status[idx];
       if (status == 4 /* SlotStatus.Computing */)
           throw new Error("Cyclic dependency between fields and/or facets");
       if (status & 2 /* SlotStatus.Computed */)
           return status;
       state.status[idx] = 4 /* SlotStatus.Computing */;
       let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
       return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
   }
   function getAddr(state, addr) {
       return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
   }

   const languageData = /*@__PURE__*/Facet.define();
   const allowMultipleSelections = /*@__PURE__*/Facet.define({
       combine: values => values.some(v => v),
       static: true
   });
   const lineSeparator = /*@__PURE__*/Facet.define({
       combine: values => values.length ? values[0] : undefined,
       static: true
   });
   const changeFilter = /*@__PURE__*/Facet.define();
   const transactionFilter = /*@__PURE__*/Facet.define();
   const transactionExtender = /*@__PURE__*/Facet.define();
   const readOnly = /*@__PURE__*/Facet.define({
       combine: values => values.length ? values[0] : false
   });

   /**
   Annotations are tagged values that are used to add metadata to
   transactions in an extensible way. They should be used to model
   things that effect the entire transaction (such as its [time
   stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
   [origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
   _alongside_ the other changes made by the transaction, [state
   effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
   */
   class Annotation {
       /**
       @internal
       */
       constructor(
       /**
       The annotation type.
       */
       type, 
       /**
       The value of this annotation.
       */
       value) {
           this.type = type;
           this.value = value;
       }
       /**
       Define a new type of annotation.
       */
       static define() { return new AnnotationType(); }
   }
   /**
   Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
   */
   class AnnotationType {
       /**
       Create an instance of this annotation.
       */
       of(value) { return new Annotation(this, value); }
   }
   /**
   Representation of a type of state effect. Defined with
   [`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
   */
   class StateEffectType {
       /**
       @internal
       */
       constructor(
       // The `any` types in these function types are there to work
       // around TypeScript issue #37631, where the type guard on
       // `StateEffect.is` mysteriously stops working when these properly
       // have type `Value`.
       /**
       @internal
       */
       map) {
           this.map = map;
       }
       /**
       Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
       type.
       */
       of(value) { return new StateEffect(this, value); }
   }
   /**
   State effects can be used to represent additional effects
   associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
   are often useful to model changes to custom [state
   fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
   document or selection changes.
   */
   class StateEffect {
       /**
       @internal
       */
       constructor(
       /**
       @internal
       */
       type, 
       /**
       The value of this effect.
       */
       value) {
           this.type = type;
           this.value = value;
       }
       /**
       Map this effect through a position mapping. Will return
       `undefined` when that ends up deleting the effect.
       */
       map(mapping) {
           let mapped = this.type.map(this.value, mapping);
           return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
       }
       /**
       Tells you whether this effect object is of a given
       [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
       */
       is(type) { return this.type == type; }
       /**
       Define a new effect type. The type parameter indicates the type
       of values that his effect holds. It should be a type that
       doesn't include `undefined`, since that is used in
       [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
       removed.
       */
       static define(spec = {}) {
           return new StateEffectType(spec.map || (v => v));
       }
       /**
       Map an array of effects through a change set.
       */
       static mapEffects(effects, mapping) {
           if (!effects.length)
               return effects;
           let result = [];
           for (let effect of effects) {
               let mapped = effect.map(mapping);
               if (mapped)
                   result.push(mapped);
           }
           return result;
       }
   }
   /**
   This effect can be used to reconfigure the root extensions of
   the editor. Doing this will discard any extensions
   [appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
   the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
   compartments.
   */
   StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
   /**
   Append extensions to the top-level configuration of the editor.
   */
   StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
   /**
   Changes to the editor state are grouped into transactions.
   Typically, a user action creates a single transaction, which may
   contain any number of document changes, may change the selection,
   or have other effects. Create a transaction by calling
   [`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
   dispatch one by calling
   [`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
   */
   class Transaction {
       constructor(
       /**
       The state from which the transaction starts.
       */
       startState, 
       /**
       The document changes made by this transaction.
       */
       changes, 
       /**
       The selection set by this transaction, or undefined if it
       doesn't explicitly set a selection.
       */
       selection, 
       /**
       The effects added to the transaction.
       */
       effects, 
       /**
       @internal
       */
       annotations, 
       /**
       Whether the selection should be scrolled into view after this
       transaction is dispatched.
       */
       scrollIntoView) {
           this.startState = startState;
           this.changes = changes;
           this.selection = selection;
           this.effects = effects;
           this.annotations = annotations;
           this.scrollIntoView = scrollIntoView;
           /**
           @internal
           */
           this._doc = null;
           /**
           @internal
           */
           this._state = null;
           if (selection)
               checkSelection(selection, changes.newLength);
           if (!annotations.some((a) => a.type == Transaction.time))
               this.annotations = annotations.concat(Transaction.time.of(Date.now()));
       }
       /**
       @internal
       */
       static create(startState, changes, selection, effects, annotations, scrollIntoView) {
           return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
       }
       /**
       The new document produced by the transaction. Contrary to
       [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
       force the entire new state to be computed right away, so it is
       recommended that [transaction
       filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
       when they need to look at the new document.
       */
       get newDoc() {
           return this._doc || (this._doc = this.changes.apply(this.startState.doc));
       }
       /**
       The new selection produced by the transaction. If
       [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
       this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
       current selection through the changes made by the transaction.
       */
       get newSelection() {
           return this.selection || this.startState.selection.map(this.changes);
       }
       /**
       The new state created by the transaction. Computed on demand
       (but retained for subsequent access), so it is recommended not to
       access it in [transaction
       filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
       */
       get state() {
           if (!this._state)
               this.startState.applyTransaction(this);
           return this._state;
       }
       /**
       Get the value of the given annotation type, if any.
       */
       annotation(type) {
           for (let ann of this.annotations)
               if (ann.type == type)
                   return ann.value;
           return undefined;
       }
       /**
       Indicates whether the transaction changed the document.
       */
       get docChanged() { return !this.changes.empty; }
       /**
       Indicates whether this transaction reconfigures the state
       (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
       with a top-level configuration
       [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
       */
       get reconfigured() { return this.startState.config != this.state.config; }
       /**
       Returns true if the transaction has a [user
       event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
       or more specific than `event`. For example, if the transaction
       has `"select.pointer"` as user event, `"select"` and
       `"select.pointer"` will match it.
       */
       isUserEvent(event) {
           let e = this.annotation(Transaction.userEvent);
           return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
       }
   }
   /**
   Annotation used to store transaction timestamps. Automatically
   added to every transaction, holding `Date.now()`.
   */
   Transaction.time = /*@__PURE__*/Annotation.define();
   /**
   Annotation used to associate a transaction with a user interface
   event. Holds a string identifying the event, using a
   dot-separated format to support attaching more specific
   information. The events used by the core libraries are:

    - `"input"` when content is entered
      - `"input.type"` for typed input
        - `"input.type.compose"` for composition
      - `"input.paste"` for pasted input
      - `"input.drop"` when adding content with drag-and-drop
      - `"input.complete"` when autocompleting
    - `"delete"` when the user deletes content
      - `"delete.selection"` when deleting the selection
      - `"delete.forward"` when deleting forward from the selection
      - `"delete.backward"` when deleting backward from the selection
      - `"delete.cut"` when cutting to the clipboard
    - `"move"` when content is moved
      - `"move.drop"` when content is moved within the editor through drag-and-drop
    - `"select"` when explicitly changing the selection
      - `"select.pointer"` when selecting with a mouse or other pointing device
    - `"undo"` and `"redo"` for history actions

   Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
   whether the annotation matches a given event.
   */
   Transaction.userEvent = /*@__PURE__*/Annotation.define();
   /**
   Annotation indicating whether a transaction should be added to
   the undo history or not.
   */
   Transaction.addToHistory = /*@__PURE__*/Annotation.define();
   /**
   Annotation indicating (when present and true) that a transaction
   represents a change made by some other actor, not the user. This
   is used, for example, to tag other people's changes in
   collaborative editing.
   */
   Transaction.remote = /*@__PURE__*/Annotation.define();
   function joinRanges(a, b) {
       let result = [];
       for (let iA = 0, iB = 0;;) {
           let from, to;
           if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
               from = a[iA++];
               to = a[iA++];
           }
           else if (iB < b.length) {
               from = b[iB++];
               to = b[iB++];
           }
           else
               return result;
           if (!result.length || result[result.length - 1] < from)
               result.push(from, to);
           else if (result[result.length - 1] < to)
               result[result.length - 1] = to;
       }
   }
   function mergeTransaction(a, b, sequential) {
       var _a;
       let mapForA, mapForB, changes;
       if (sequential) {
           mapForA = b.changes;
           mapForB = ChangeSet.empty(b.changes.length);
           changes = a.changes.compose(b.changes);
       }
       else {
           mapForA = b.changes.map(a.changes);
           mapForB = a.changes.mapDesc(b.changes, true);
           changes = a.changes.compose(mapForA);
       }
       return {
           changes,
           selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
           effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
           annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
           scrollIntoView: a.scrollIntoView || b.scrollIntoView
       };
   }
   function resolveTransactionInner(state, spec, docSize) {
       let sel = spec.selection, annotations = asArray$1(spec.annotations);
       if (spec.userEvent)
           annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
       return {
           changes: spec.changes instanceof ChangeSet ? spec.changes
               : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
           selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
           effects: asArray$1(spec.effects),
           annotations,
           scrollIntoView: !!spec.scrollIntoView
       };
   }
   function resolveTransaction(state, specs, filter) {
       let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
       if (specs.length && specs[0].filter === false)
           filter = false;
       for (let i = 1; i < specs.length; i++) {
           if (specs[i].filter === false)
               filter = false;
           let seq = !!specs[i].sequential;
           s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
       }
       let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
       return extendTransaction(filter ? filterTransaction(tr) : tr);
   }
   // Finish a transaction by applying filters if necessary.
   function filterTransaction(tr) {
       let state = tr.startState;
       // Change filters
       let result = true;
       for (let filter of state.facet(changeFilter)) {
           let value = filter(tr);
           if (value === false) {
               result = false;
               break;
           }
           if (Array.isArray(value))
               result = result === true ? value : joinRanges(result, value);
       }
       if (result !== true) {
           let changes, back;
           if (result === false) {
               back = tr.changes.invertedDesc;
               changes = ChangeSet.empty(state.doc.length);
           }
           else {
               let filtered = tr.changes.filter(result);
               changes = filtered.changes;
               back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
           }
           tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
       }
       // Transaction filters
       let filters = state.facet(transactionFilter);
       for (let i = filters.length - 1; i >= 0; i--) {
           let filtered = filters[i](tr);
           if (filtered instanceof Transaction)
               tr = filtered;
           else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
               tr = filtered[0];
           else
               tr = resolveTransaction(state, asArray$1(filtered), false);
       }
       return tr;
   }
   function extendTransaction(tr) {
       let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
       for (let i = extenders.length - 1; i >= 0; i--) {
           let extension = extenders[i](tr);
           if (extension && Object.keys(extension).length)
               spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
       }
       return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
   }
   const none$2 = [];
   function asArray$1(value) {
       return value == null ? none$2 : Array.isArray(value) ? value : [value];
   }

   /**
   The categories produced by a [character
   categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
   do things like selecting by word.
   */
   var CharCategory = /*@__PURE__*/(function (CharCategory) {
       /**
       Word characters.
       */
       CharCategory[CharCategory["Word"] = 0] = "Word";
       /**
       Whitespace.
       */
       CharCategory[CharCategory["Space"] = 1] = "Space";
       /**
       Anything else.
       */
       CharCategory[CharCategory["Other"] = 2] = "Other";
   return CharCategory})(CharCategory || (CharCategory = {}));
   const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
   let wordChar;
   try {
       wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
   }
   catch (_) { }
   function hasWordChar(str) {
       if (wordChar)
           return wordChar.test(str);
       for (let i = 0; i < str.length; i++) {
           let ch = str[i];
           if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
               return true;
       }
       return false;
   }
   function makeCategorizer(wordChars) {
       return (char) => {
           if (!/\S/.test(char))
               return CharCategory.Space;
           if (hasWordChar(char))
               return CharCategory.Word;
           for (let i = 0; i < wordChars.length; i++)
               if (char.indexOf(wordChars[i]) > -1)
                   return CharCategory.Word;
           return CharCategory.Other;
       };
   }

   /**
   The editor state class is a persistent (immutable) data structure.
   To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
   [transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
   instance, without modifying the original object.

   As such, _never_ mutate properties of a state directly. That'll
   just break things.
   */
   class EditorState {
       constructor(
       /**
       @internal
       */
       config, 
       /**
       The current document.
       */
       doc, 
       /**
       The current selection.
       */
       selection, 
       /**
       @internal
       */
       values, computeSlot, tr) {
           this.config = config;
           this.doc = doc;
           this.selection = selection;
           this.values = values;
           this.status = config.statusTemplate.slice();
           this.computeSlot = computeSlot;
           // Fill in the computed state immediately, so that further queries
           // for it made during the update return this state
           if (tr)
               tr._state = this;
           for (let i = 0; i < this.config.dynamicSlots.length; i++)
               ensureAddr(this, i << 1);
           this.computeSlot = null;
       }
       field(field, require = true) {
           let addr = this.config.address[field.id];
           if (addr == null) {
               if (require)
                   throw new RangeError("Field is not present in this state");
               return undefined;
           }
           ensureAddr(this, addr);
           return getAddr(this, addr);
       }
       /**
       Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
       state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
       can be passed. Unless
       [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
       [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
       are assumed to start in the _current_ document (not the document
       produced by previous specs), and its
       [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
       [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
       to the document created by its _own_ changes. The resulting
       transaction contains the combined effect of all the different
       specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
       specs take precedence over earlier ones.
       */
       update(...specs) {
           return resolveTransaction(this, specs, true);
       }
       /**
       @internal
       */
       applyTransaction(tr) {
           let conf = this.config, { base, compartments } = conf;
           for (let effect of tr.effects) {
               if (effect.is(Compartment.reconfigure)) {
                   if (conf) {
                       compartments = new Map;
                       conf.compartments.forEach((val, key) => compartments.set(key, val));
                       conf = null;
                   }
                   compartments.set(effect.value.compartment, effect.value.extension);
               }
               else if (effect.is(StateEffect.reconfigure)) {
                   conf = null;
                   base = effect.value;
               }
               else if (effect.is(StateEffect.appendConfig)) {
                   conf = null;
                   base = asArray$1(base).concat(effect.value);
               }
           }
           let startValues;
           if (!conf) {
               conf = Configuration.resolve(base, compartments, this);
               let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
               startValues = intermediateState.values;
           }
           else {
               startValues = tr.startState.values.slice();
           }
           new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
       }
       /**
       Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
       replaces every selection range with the given content.
       */
       replaceSelection(text) {
           if (typeof text == "string")
               text = this.toText(text);
           return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
               range: EditorSelection.cursor(range.from + text.length) }));
       }
       /**
       Create a set of changes and a new selection by running the given
       function for each range in the active selection. The function
       can return an optional set of changes (in the coordinate space
       of the start document), plus an updated range (in the coordinate
       space of the document produced by the call's own changes). This
       method will merge all the changes and ranges into a single
       changeset and selection, and return it as a [transaction
       spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
       [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
       */
       changeByRange(f) {
           let sel = this.selection;
           let result1 = f(sel.ranges[0]);
           let changes = this.changes(result1.changes), ranges = [result1.range];
           let effects = asArray$1(result1.effects);
           for (let i = 1; i < sel.ranges.length; i++) {
               let result = f(sel.ranges[i]);
               let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
               for (let j = 0; j < i; j++)
                   ranges[j] = ranges[j].map(newMapped);
               let mapBy = changes.mapDesc(newChanges, true);
               ranges.push(result.range.map(mapBy));
               changes = changes.compose(newMapped);
               effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
           }
           return {
               changes,
               selection: EditorSelection.create(ranges, sel.mainIndex),
               effects
           };
       }
       /**
       Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
       description, taking the state's document length and line
       separator into account.
       */
       changes(spec = []) {
           if (spec instanceof ChangeSet)
               return spec;
           return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
       }
       /**
       Using the state's [line
       separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
       [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
       */
       toText(string) {
           return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
       }
       /**
       Return the given range of the document as a string.
       */
       sliceDoc(from = 0, to = this.doc.length) {
           return this.doc.sliceString(from, to, this.lineBreak);
       }
       /**
       Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
       */
       facet(facet) {
           let addr = this.config.address[facet.id];
           if (addr == null)
               return facet.default;
           ensureAddr(this, addr);
           return getAddr(this, addr);
       }
       /**
       Convert this state to a JSON-serializable object. When custom
       fields should be serialized, you can pass them in as an object
       mapping property names (in the resulting object, which should
       not use `doc` or `selection`) to fields.
       */
       toJSON(fields) {
           let result = {
               doc: this.sliceDoc(),
               selection: this.selection.toJSON()
           };
           if (fields)
               for (let prop in fields) {
                   let value = fields[prop];
                   if (value instanceof StateField && this.config.address[value.id] != null)
                       result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
               }
           return result;
       }
       /**
       Deserialize a state from its JSON representation. When custom
       fields should be deserialized, pass the same object you passed
       to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
       third argument.
       */
       static fromJSON(json, config = {}, fields) {
           if (!json || typeof json.doc != "string")
               throw new RangeError("Invalid JSON representation for EditorState");
           let fieldInit = [];
           if (fields)
               for (let prop in fields) {
                   if (Object.prototype.hasOwnProperty.call(json, prop)) {
                       let field = fields[prop], value = json[prop];
                       fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                   }
               }
           return EditorState.create({
               doc: json.doc,
               selection: EditorSelection.fromJSON(json.selection),
               extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
           });
       }
       /**
       Create a new state. You'll usually only need this when
       initializing an editor—updated states are created by applying
       transactions.
       */
       static create(config = {}) {
           let configuration = Configuration.resolve(config.extensions || [], new Map);
           let doc = config.doc instanceof Text ? config.doc
               : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
           let selection = !config.selection ? EditorSelection.single(0)
               : config.selection instanceof EditorSelection ? config.selection
                   : EditorSelection.single(config.selection.anchor, config.selection.head);
           checkSelection(selection, doc.length);
           if (!configuration.staticFacet(allowMultipleSelections))
               selection = selection.asSingle();
           return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
       }
       /**
       The size (in columns) of a tab in the document, determined by
       the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
       */
       get tabSize() { return this.facet(EditorState.tabSize); }
       /**
       Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
       string for this state.
       */
       get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
       /**
       Returns true when the editor is
       [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
       */
       get readOnly() { return this.facet(readOnly); }
       /**
       Look up a translation for the given phrase (via the
       [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
       original string if no translation is found.
       
       If additional arguments are passed, they will be inserted in
       place of markers like `$1` (for the first value) and `$2`, etc.
       A single `$` is equivalent to `$1`, and `$$` will produce a
       literal dollar sign.
       */
       phrase(phrase, ...insert) {
           for (let map of this.facet(EditorState.phrases))
               if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                   phrase = map[phrase];
                   break;
               }
           if (insert.length)
               phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                   if (i == "$")
                       return "$";
                   let n = +(i || 1);
                   return !n || n > insert.length ? m : insert[n - 1];
               });
           return phrase;
       }
       /**
       Find the values for a given language data field, provided by the
       the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
       
       Examples of language data fields are...
       
       - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
         comment syntax.
       - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
         for providing language-specific completion sources.
       - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
         characters that should be considered part of words in this
         language.
       - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
         bracket closing behavior.
       */
       languageDataAt(name, pos, side = -1) {
           let values = [];
           for (let provider of this.facet(languageData)) {
               for (let result of provider(this, pos, side)) {
                   if (Object.prototype.hasOwnProperty.call(result, name))
                       values.push(result[name]);
               }
           }
           return values;
       }
       /**
       Return a function that can categorize strings (expected to
       represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
       into one of:
       
        - Word (contains an alphanumeric character or a character
          explicitly listed in the local language's `"wordChars"`
          language data, which should be a string)
        - Space (contains only whitespace)
        - Other (anything else)
       */
       charCategorizer(at) {
           return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
       }
       /**
       Find the word at the given position, meaning the range
       containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
       around it. If no word characters are adjacent to the position,
       this returns null.
       */
       wordAt(pos) {
           let { text, from, length } = this.doc.lineAt(pos);
           let cat = this.charCategorizer(pos);
           let start = pos - from, end = pos - from;
           while (start > 0) {
               let prev = findClusterBreak(text, start, false);
               if (cat(text.slice(prev, start)) != CharCategory.Word)
                   break;
               start = prev;
           }
           while (end < length) {
               let next = findClusterBreak(text, end);
               if (cat(text.slice(end, next)) != CharCategory.Word)
                   break;
               end = next;
           }
           return start == end ? null : EditorSelection.range(start + from, end + from);
       }
   }
   /**
   A facet that, when enabled, causes the editor to allow multiple
   ranges to be selected. Be careful though, because by default the
   editor relies on the native DOM selection, which cannot handle
   multiple selections. An extension like
   [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
   secondary selections visible to the user.
   */
   EditorState.allowMultipleSelections = allowMultipleSelections;
   /**
   Configures the tab size to use in this state. The first
   (highest-precedence) value of the facet is used. If no value is
   given, this defaults to 4.
   */
   EditorState.tabSize = /*@__PURE__*/Facet.define({
       combine: values => values.length ? values[0] : 4
   });
   /**
   The line separator to use. By default, any of `"\n"`, `"\r\n"`
   and `"\r"` is treated as a separator when splitting lines, and
   lines are joined with `"\n"`.

   When you configure a value here, only that precise separator
   will be used, allowing you to round-trip documents through the
   editor without normalizing line separators.
   */
   EditorState.lineSeparator = lineSeparator;
   /**
   This facet controls the value of the
   [`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
   consulted by commands and extensions that implement editing
   functionality to determine whether they should apply. It
   defaults to false, but when its highest-precedence value is
   `true`, such functionality disables itself.

   Not to be confused with
   [`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
   controls whether the editor's DOM is set to be editable (and
   thus focusable).
   */
   EditorState.readOnly = readOnly;
   /**
   Registers translation phrases. The
   [`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
   all objects registered with this facet to find translations for
   its argument.
   */
   EditorState.phrases = /*@__PURE__*/Facet.define({
       compare(a, b) {
           let kA = Object.keys(a), kB = Object.keys(b);
           return kA.length == kB.length && kA.every(k => a[k] == b[k]);
       }
   });
   /**
   A facet used to register [language
   data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
   */
   EditorState.languageData = languageData;
   /**
   Facet used to register change filters, which are called for each
   transaction (unless explicitly
   [disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
   part of the transaction's changes.

   Such a function can return `true` to indicate that it doesn't
   want to do anything, `false` to completely stop the changes in
   the transaction, or a set of ranges in which changes should be
   suppressed. Such ranges are represented as an array of numbers,
   with each pair of two numbers indicating the start and end of a
   range. So for example `[10, 20, 100, 110]` suppresses changes
   between 10 and 20, and between 100 and 110.
   */
   EditorState.changeFilter = changeFilter;
   /**
   Facet used to register a hook that gets a chance to update or
   replace transaction specs before they are applied. This will
   only be applied for transactions that don't have
   [`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
   can either return a single transaction spec (possibly the input
   transaction), or an array of specs (which will be combined in
   the same way as the arguments to
   [`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

   When possible, it is recommended to avoid accessing
   [`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
   since it will force creation of a state that will then be
   discarded again, if the transaction is actually filtered.

   (This functionality should be used with care. Indiscriminately
   modifying transaction is likely to break something or degrade
   the user experience.)
   */
   EditorState.transactionFilter = transactionFilter;
   /**
   This is a more limited form of
   [`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
   which can only add
   [annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
   [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
   of filter runs even if the transaction has disabled regular
   [filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
   for effects that don't need to touch the changes or selection,
   but do want to process every transaction.

   Extenders run _after_ filters, when both are present.
   */
   EditorState.transactionExtender = transactionExtender;
   Compartment.reconfigure = /*@__PURE__*/StateEffect.define();

   /**
   Utility function for combining behaviors to fill in a config
   object from an array of provided configs. `defaults` should hold
   default values for all optional fields in `Config`.

   The function will, by default, error
   when a field gets two values that aren't `===`-equal, but you can
   provide combine functions per field to do something else.
   */
   function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
   combine = {}) {
       let result = {};
       for (let config of configs)
           for (let key of Object.keys(config)) {
               let value = config[key], current = result[key];
               if (current === undefined)
                   result[key] = value;
               else if (current === value || value === undefined) ; // No conflict
               else if (Object.hasOwnProperty.call(combine, key))
                   result[key] = combine[key](current, value);
               else
                   throw new Error("Config merge conflict for field " + key);
           }
       for (let key in defaults)
           if (result[key] === undefined)
               result[key] = defaults[key];
       return result;
   }

   /**
   Each range is associated with a value, which must inherit from
   this class.
   */
   class RangeValue {
       /**
       Compare this value with another value. Used when comparing
       rangesets. The default implementation compares by identity.
       Unless you are only creating a fixed number of unique instances
       of your value type, it is a good idea to implement this
       properly.
       */
       eq(other) { return this == other; }
       /**
       Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
       */
       range(from, to = from) { return Range$2.create(from, to, this); }
   }
   RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
   RangeValue.prototype.point = false;
   RangeValue.prototype.mapMode = MapMode.TrackDel;
   /**
   A range associates a value with a range of positions.
   */
   let Range$2 = class Range {
       constructor(
       /**
       The range's start position.
       */
       from, 
       /**
       Its end position.
       */
       to, 
       /**
       The value associated with this range.
       */
       value) {
           this.from = from;
           this.to = to;
           this.value = value;
       }
       /**
       @internal
       */
       static create(from, to, value) {
           return new Range(from, to, value);
       }
   };
   function cmpRange(a, b) {
       return a.from - b.from || a.value.startSide - b.value.startSide;
   }
   class Chunk {
       constructor(from, to, value, 
       // Chunks are marked with the largest point that occurs
       // in them (or -1 for no points), so that scans that are
       // only interested in points (such as the
       // heightmap-related logic) can skip range-only chunks.
       maxPoint) {
           this.from = from;
           this.to = to;
           this.value = value;
           this.maxPoint = maxPoint;
       }
       get length() { return this.to[this.to.length - 1]; }
       // Find the index of the given position and side. Use the ranges'
       // `from` pos when `end == false`, `to` when `end == true`.
       findIndex(pos, side, end, startAt = 0) {
           let arr = end ? this.to : this.from;
           for (let lo = startAt, hi = arr.length;;) {
               if (lo == hi)
                   return lo;
               let mid = (lo + hi) >> 1;
               let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
               if (mid == lo)
                   return diff >= 0 ? lo : hi;
               if (diff >= 0)
                   hi = mid;
               else
                   lo = mid + 1;
           }
       }
       between(offset, from, to, f) {
           for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)
               if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                   return false;
       }
       map(offset, changes) {
           let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
           for (let i = 0; i < this.value.length; i++) {
               let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
               if (curFrom == curTo) {
                   let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                   if (mapped == null)
                       continue;
                   newFrom = newTo = mapped;
                   if (val.startSide != val.endSide) {
                       newTo = changes.mapPos(curFrom, val.endSide);
                       if (newTo < newFrom)
                           continue;
                   }
               }
               else {
                   newFrom = changes.mapPos(curFrom, val.startSide);
                   newTo = changes.mapPos(curTo, val.endSide);
                   if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                       continue;
               }
               if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                   continue;
               if (newPos < 0)
                   newPos = newFrom;
               if (val.point)
                   maxPoint = Math.max(maxPoint, newTo - newFrom);
               value.push(val);
               from.push(newFrom - newPos);
               to.push(newTo - newPos);
           }
           return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
       }
   }
   /**
   A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
   way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
   [update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
   structure.
   */
   class RangeSet {
       constructor(
       /**
       @internal
       */
       chunkPos, 
       /**
       @internal
       */
       chunk, 
       /**
       @internal
       */
       nextLayer, 
       /**
       @internal
       */
       maxPoint) {
           this.chunkPos = chunkPos;
           this.chunk = chunk;
           this.nextLayer = nextLayer;
           this.maxPoint = maxPoint;
       }
       /**
       @internal
       */
       static create(chunkPos, chunk, nextLayer, maxPoint) {
           return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
       }
       /**
       @internal
       */
       get length() {
           let last = this.chunk.length - 1;
           return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
       }
       /**
       The number of ranges in the set.
       */
       get size() {
           if (this.isEmpty)
               return 0;
           let size = this.nextLayer.size;
           for (let chunk of this.chunk)
               size += chunk.value.length;
           return size;
       }
       /**
       @internal
       */
       chunkEnd(index) {
           return this.chunkPos[index] + this.chunk[index].length;
       }
       /**
       Update the range set, optionally adding new ranges or filtering
       out existing ones.
       
       (Note: The type parameter is just there as a kludge to work
       around TypeScript variance issues that prevented `RangeSet<X>`
       from being a subtype of `RangeSet<Y>` when `X` is a subtype of
       `Y`.)
       */
       update(updateSpec) {
           let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
           let filter = updateSpec.filter;
           if (add.length == 0 && !filter)
               return this;
           if (sort)
               add = add.slice().sort(cmpRange);
           if (this.isEmpty)
               return add.length ? RangeSet.of(add) : this;
           let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
           let builder = new RangeSetBuilder();
           while (cur.value || i < add.length) {
               if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                   let range = add[i++];
                   if (!builder.addInner(range.from, range.to, range.value))
                       spill.push(range);
               }
               else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                   (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                   (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                   builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                   cur.nextChunk();
               }
               else {
                   if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                       if (!builder.addInner(cur.from, cur.to, cur.value))
                           spill.push(Range$2.create(cur.from, cur.to, cur.value));
                   }
                   cur.next();
               }
           }
           return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty
               : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
       }
       /**
       Map this range set through a set of changes, return the new set.
       */
       map(changes) {
           if (changes.empty || this.isEmpty)
               return this;
           let chunks = [], chunkPos = [], maxPoint = -1;
           for (let i = 0; i < this.chunk.length; i++) {
               let start = this.chunkPos[i], chunk = this.chunk[i];
               let touch = changes.touchesRange(start, start + chunk.length);
               if (touch === false) {
                   maxPoint = Math.max(maxPoint, chunk.maxPoint);
                   chunks.push(chunk);
                   chunkPos.push(changes.mapPos(start));
               }
               else if (touch === true) {
                   let { mapped, pos } = chunk.map(start, changes);
                   if (mapped) {
                       maxPoint = Math.max(maxPoint, mapped.maxPoint);
                       chunks.push(mapped);
                       chunkPos.push(pos);
                   }
               }
           }
           let next = this.nextLayer.map(changes);
           return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
       }
       /**
       Iterate over the ranges that touch the region `from` to `to`,
       calling `f` for each. There is no guarantee that the ranges will
       be reported in any specific order. When the callback returns
       `false`, iteration stops.
       */
       between(from, to, f) {
           if (this.isEmpty)
               return;
           for (let i = 0; i < this.chunk.length; i++) {
               let start = this.chunkPos[i], chunk = this.chunk[i];
               if (to >= start && from <= start + chunk.length &&
                   chunk.between(start, from - start, to - start, f) === false)
                   return;
           }
           this.nextLayer.between(from, to, f);
       }
       /**
       Iterate over the ranges in this set, in order, including all
       ranges that end at or after `from`.
       */
       iter(from = 0) {
           return HeapCursor.from([this]).goto(from);
       }
       /**
       @internal
       */
       get isEmpty() { return this.nextLayer == this; }
       /**
       Iterate over the ranges in a collection of sets, in order,
       starting from `from`.
       */
       static iter(sets, from = 0) {
           return HeapCursor.from(sets).goto(from);
       }
       /**
       Iterate over two groups of sets, calling methods on `comparator`
       to notify it of possible differences.
       */
       static compare(oldSets, newSets, 
       /**
       This indicates how the underlying data changed between these
       ranges, and is needed to synchronize the iteration.
       */
       textDiff, comparator, 
       /**
       Can be used to ignore all non-point ranges, and points below
       the given size. When -1, all ranges are compared.
       */
       minPointSize = -1) {
           let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
           let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
           let sharedChunks = findSharedChunks(a, b, textDiff);
           let sideA = new SpanCursor(a, sharedChunks, minPointSize);
           let sideB = new SpanCursor(b, sharedChunks, minPointSize);
           textDiff.iterGaps((fromA, fromB, length) => compare$1(sideA, fromA, sideB, fromB, length, comparator));
           if (textDiff.empty && textDiff.length == 0)
               compare$1(sideA, 0, sideB, 0, 0, comparator);
       }
       /**
       Compare the contents of two groups of range sets, returning true
       if they are equivalent in the given range.
       */
       static eq(oldSets, newSets, from = 0, to) {
           if (to == null)
               to = 1000000000 /* C.Far */ - 1;
           let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
           let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
           if (a.length != b.length)
               return false;
           if (!a.length)
               return true;
           let sharedChunks = findSharedChunks(a, b);
           let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
           for (;;) {
               if (sideA.to != sideB.to ||
                   !sameValues(sideA.active, sideB.active) ||
                   sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                   return false;
               if (sideA.to > to)
                   return true;
               sideA.next();
               sideB.next();
           }
       }
       /**
       Iterate over a group of range sets at the same time, notifying
       the iterator about the ranges covering every given piece of
       content. Returns the open count (see
       [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
       of the iteration.
       */
       static spans(sets, from, to, iterator, 
       /**
       When given and greater than -1, only points of at least this
       size are taken into account.
       */
       minPointSize = -1) {
           let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
           let openRanges = cursor.openStart;
           for (;;) {
               let curTo = Math.min(cursor.to, to);
               if (cursor.point) {
                   let active = cursor.activeForPoint(cursor.to);
                   let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
                   iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                   openRanges = Math.min(cursor.openEnd(curTo), active.length);
               }
               else if (curTo > pos) {
                   iterator.span(pos, curTo, cursor.active, openRanges);
                   openRanges = cursor.openEnd(curTo);
               }
               if (cursor.to > to)
                   return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
               pos = cursor.to;
               cursor.next();
           }
       }
       /**
       Create a range set for the given range or array of ranges. By
       default, this expects the ranges to be _sorted_ (by start
       position and, if two start at the same position,
       `value.startSide`). You can pass `true` as second argument to
       cause the method to sort them.
       */
       static of(ranges, sort = false) {
           let build = new RangeSetBuilder();
           for (let range of ranges instanceof Range$2 ? [ranges] : sort ? lazySort(ranges) : ranges)
               build.add(range.from, range.to, range.value);
           return build.finish();
       }
   }
   /**
   The empty set of ranges.
   */
   RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);
   function lazySort(ranges) {
       if (ranges.length > 1)
           for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
               let cur = ranges[i];
               if (cmpRange(prev, cur) > 0)
                   return ranges.slice().sort(cmpRange);
               prev = cur;
           }
       return ranges;
   }
   RangeSet.empty.nextLayer = RangeSet.empty;
   /**
   A range set builder is a data structure that helps build up a
   [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
   an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
   */
   class RangeSetBuilder {
       finishChunk(newArrays) {
           this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
           this.chunkPos.push(this.chunkStart);
           this.chunkStart = -1;
           this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
           this.maxPoint = -1;
           if (newArrays) {
               this.from = [];
               this.to = [];
               this.value = [];
           }
       }
       /**
       Create an empty builder.
       */
       constructor() {
           this.chunks = [];
           this.chunkPos = [];
           this.chunkStart = -1;
           this.last = null;
           this.lastFrom = -1000000000 /* C.Far */;
           this.lastTo = -1000000000 /* C.Far */;
           this.from = [];
           this.to = [];
           this.value = [];
           this.maxPoint = -1;
           this.setMaxPoint = -1;
           this.nextLayer = null;
       }
       /**
       Add a range. Ranges should be added in sorted (by `from` and
       `value.startSide`) order.
       */
       add(from, to, value) {
           if (!this.addInner(from, to, value))
               (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
       }
       /**
       @internal
       */
       addInner(from, to, value) {
           let diff = from - this.lastTo || value.startSide - this.last.endSide;
           if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
               throw new Error("Ranges must be added sorted by `from` position and `startSide`");
           if (diff < 0)
               return false;
           if (this.from.length == 250 /* C.ChunkSize */)
               this.finishChunk(true);
           if (this.chunkStart < 0)
               this.chunkStart = from;
           this.from.push(from - this.chunkStart);
           this.to.push(to - this.chunkStart);
           this.last = value;
           this.lastFrom = from;
           this.lastTo = to;
           this.value.push(value);
           if (value.point)
               this.maxPoint = Math.max(this.maxPoint, to - from);
           return true;
       }
       /**
       @internal
       */
       addChunk(from, chunk) {
           if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
               return false;
           if (this.from.length)
               this.finishChunk(true);
           this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
           this.chunks.push(chunk);
           this.chunkPos.push(from);
           let last = chunk.value.length - 1;
           this.last = chunk.value[last];
           this.lastFrom = chunk.from[last] + from;
           this.lastTo = chunk.to[last] + from;
           return true;
       }
       /**
       Finish the range set. Returns the new set. The builder can't be
       used anymore after this has been called.
       */
       finish() { return this.finishInner(RangeSet.empty); }
       /**
       @internal
       */
       finishInner(next) {
           if (this.from.length)
               this.finishChunk(false);
           if (this.chunks.length == 0)
               return next;
           let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
           this.from = null; // Make sure further `add` calls produce errors
           return result;
       }
   }
   function findSharedChunks(a, b, textDiff) {
       let inA = new Map();
       for (let set of a)
           for (let i = 0; i < set.chunk.length; i++)
               if (set.chunk[i].maxPoint <= 0)
                   inA.set(set.chunk[i], set.chunkPos[i]);
       let shared = new Set();
       for (let set of b)
           for (let i = 0; i < set.chunk.length; i++) {
               let known = inA.get(set.chunk[i]);
               if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                   !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                   shared.add(set.chunk[i]);
           }
       return shared;
   }
   class LayerCursor {
       constructor(layer, skip, minPoint, rank = 0) {
           this.layer = layer;
           this.skip = skip;
           this.minPoint = minPoint;
           this.rank = rank;
       }
       get startSide() { return this.value ? this.value.startSide : 0; }
       get endSide() { return this.value ? this.value.endSide : 0; }
       goto(pos, side = -1000000000 /* C.Far */) {
           this.chunkIndex = this.rangeIndex = 0;
           this.gotoInner(pos, side, false);
           return this;
       }
       gotoInner(pos, side, forward) {
           while (this.chunkIndex < this.layer.chunk.length) {
               let next = this.layer.chunk[this.chunkIndex];
               if (!(this.skip && this.skip.has(next) ||
                   this.layer.chunkEnd(this.chunkIndex) < pos ||
                   next.maxPoint < this.minPoint))
                   break;
               this.chunkIndex++;
               forward = false;
           }
           if (this.chunkIndex < this.layer.chunk.length) {
               let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
               if (!forward || this.rangeIndex < rangeIndex)
                   this.setRangeIndex(rangeIndex);
           }
           this.next();
       }
       forward(pos, side) {
           if ((this.to - pos || this.endSide - side) < 0)
               this.gotoInner(pos, side, true);
       }
       next() {
           for (;;) {
               if (this.chunkIndex == this.layer.chunk.length) {
                   this.from = this.to = 1000000000 /* C.Far */;
                   this.value = null;
                   break;
               }
               else {
                   let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                   let from = chunkPos + chunk.from[this.rangeIndex];
                   this.from = from;
                   this.to = chunkPos + chunk.to[this.rangeIndex];
                   this.value = chunk.value[this.rangeIndex];
                   this.setRangeIndex(this.rangeIndex + 1);
                   if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                       break;
               }
           }
       }
       setRangeIndex(index) {
           if (index == this.layer.chunk[this.chunkIndex].value.length) {
               this.chunkIndex++;
               if (this.skip) {
                   while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                       this.chunkIndex++;
               }
               this.rangeIndex = 0;
           }
           else {
               this.rangeIndex = index;
           }
       }
       nextChunk() {
           this.chunkIndex++;
           this.rangeIndex = 0;
           this.next();
       }
       compare(other) {
           return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
               this.to - other.to || this.endSide - other.endSide;
       }
   }
   class HeapCursor {
       constructor(heap) {
           this.heap = heap;
       }
       static from(sets, skip = null, minPoint = -1) {
           let heap = [];
           for (let i = 0; i < sets.length; i++) {
               for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                   if (cur.maxPoint >= minPoint)
                       heap.push(new LayerCursor(cur, skip, minPoint, i));
               }
           }
           return heap.length == 1 ? heap[0] : new HeapCursor(heap);
       }
       get startSide() { return this.value ? this.value.startSide : 0; }
       goto(pos, side = -1000000000 /* C.Far */) {
           for (let cur of this.heap)
               cur.goto(pos, side);
           for (let i = this.heap.length >> 1; i >= 0; i--)
               heapBubble(this.heap, i);
           this.next();
           return this;
       }
       forward(pos, side) {
           for (let cur of this.heap)
               cur.forward(pos, side);
           for (let i = this.heap.length >> 1; i >= 0; i--)
               heapBubble(this.heap, i);
           if ((this.to - pos || this.value.endSide - side) < 0)
               this.next();
       }
       next() {
           if (this.heap.length == 0) {
               this.from = this.to = 1000000000 /* C.Far */;
               this.value = null;
               this.rank = -1;
           }
           else {
               let top = this.heap[0];
               this.from = top.from;
               this.to = top.to;
               this.value = top.value;
               this.rank = top.rank;
               if (top.value)
                   top.next();
               heapBubble(this.heap, 0);
           }
       }
   }
   function heapBubble(heap, index) {
       for (let cur = heap[index];;) {
           let childIndex = (index << 1) + 1;
           if (childIndex >= heap.length)
               break;
           let child = heap[childIndex];
           if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
               child = heap[childIndex + 1];
               childIndex++;
           }
           if (cur.compare(child) < 0)
               break;
           heap[childIndex] = cur;
           heap[index] = child;
           index = childIndex;
       }
   }
   class SpanCursor {
       constructor(sets, skip, minPoint) {
           this.minPoint = minPoint;
           this.active = [];
           this.activeTo = [];
           this.activeRank = [];
           this.minActive = -1;
           // A currently active point range, if any
           this.point = null;
           this.pointFrom = 0;
           this.pointRank = 0;
           this.to = -1000000000 /* C.Far */;
           this.endSide = 0;
           // The amount of open active ranges at the start of the iterator.
           // Not including points.
           this.openStart = -1;
           this.cursor = HeapCursor.from(sets, skip, minPoint);
       }
       goto(pos, side = -1000000000 /* C.Far */) {
           this.cursor.goto(pos, side);
           this.active.length = this.activeTo.length = this.activeRank.length = 0;
           this.minActive = -1;
           this.to = pos;
           this.endSide = side;
           this.openStart = -1;
           this.next();
           return this;
       }
       forward(pos, side) {
           while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
               this.removeActive(this.minActive);
           this.cursor.forward(pos, side);
       }
       removeActive(index) {
           remove(this.active, index);
           remove(this.activeTo, index);
           remove(this.activeRank, index);
           this.minActive = findMinIndex(this.active, this.activeTo);
       }
       addActive(trackOpen) {
           let i = 0, { value, to, rank } = this.cursor;
           while (i < this.activeRank.length && this.activeRank[i] <= rank)
               i++;
           insert(this.active, i, value);
           insert(this.activeTo, i, to);
           insert(this.activeRank, i, rank);
           if (trackOpen)
               insert(trackOpen, i, this.cursor.from);
           this.minActive = findMinIndex(this.active, this.activeTo);
       }
       // After calling this, if `this.point` != null, the next range is a
       // point. Otherwise, it's a regular range, covered by `this.active`.
       next() {
           let from = this.to, wasPoint = this.point;
           this.point = null;
           let trackOpen = this.openStart < 0 ? [] : null;
           for (;;) {
               let a = this.minActive;
               if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                   if (this.activeTo[a] > from) {
                       this.to = this.activeTo[a];
                       this.endSide = this.active[a].endSide;
                       break;
                   }
                   this.removeActive(a);
                   if (trackOpen)
                       remove(trackOpen, a);
               }
               else if (!this.cursor.value) {
                   this.to = this.endSide = 1000000000 /* C.Far */;
                   break;
               }
               else if (this.cursor.from > from) {
                   this.to = this.cursor.from;
                   this.endSide = this.cursor.startSide;
                   break;
               }
               else {
                   let nextVal = this.cursor.value;
                   if (!nextVal.point) { // Opening a range
                       this.addActive(trackOpen);
                       this.cursor.next();
                   }
                   else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                       // Ignore any non-empty points that end precisely at the end of the prev point
                       this.cursor.next();
                   }
                   else { // New point
                       this.point = nextVal;
                       this.pointFrom = this.cursor.from;
                       this.pointRank = this.cursor.rank;
                       this.to = this.cursor.to;
                       this.endSide = nextVal.endSide;
                       this.cursor.next();
                       this.forward(this.to, this.endSide);
                       break;
                   }
               }
           }
           if (trackOpen) {
               this.openStart = 0;
               for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                   this.openStart++;
           }
       }
       activeForPoint(to) {
           if (!this.active.length)
               return this.active;
           let active = [];
           for (let i = this.active.length - 1; i >= 0; i--) {
               if (this.activeRank[i] < this.pointRank)
                   break;
               if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                   active.push(this.active[i]);
           }
           return active.reverse();
       }
       openEnd(to) {
           let open = 0;
           for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
               open++;
           return open;
       }
   }
   function compare$1(a, startA, b, startB, length, comparator) {
       a.goto(startA);
       b.goto(startB);
       let endB = startB + length;
       let pos = startB, dPos = startB - startA;
       for (;;) {
           let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;
           let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
           if (a.point || b.point) {
               if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                   sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
                   comparator.comparePoint(pos, clipEnd, a.point, b.point);
           }
           else {
               if (clipEnd > pos && !sameValues(a.active, b.active))
                   comparator.compareRange(pos, clipEnd, a.active, b.active);
           }
           if (end > endB)
               break;
           pos = end;
           if (diff <= 0)
               a.next();
           if (diff >= 0)
               b.next();
       }
   }
   function sameValues(a, b) {
       if (a.length != b.length)
           return false;
       for (let i = 0; i < a.length; i++)
           if (a[i] != b[i] && !a[i].eq(b[i]))
               return false;
       return true;
   }
   function remove(array, index) {
       for (let i = index, e = array.length - 1; i < e; i++)
           array[i] = array[i + 1];
       array.pop();
   }
   function insert(array, index, value) {
       for (let i = array.length - 1; i >= index; i--)
           array[i + 1] = array[i];
       array[index] = value;
   }
   function findMinIndex(value, array) {
       let found = -1, foundPos = 1000000000 /* C.Far */;
       for (let i = 0; i < array.length; i++)
           if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
               found = i;
               foundPos = array[i];
           }
       return found;
   }

   /**
   Count the column position at the given offset into the string,
   taking extending characters and tab size into account.
   */
   function countColumn(string, tabSize, to = string.length) {
       let n = 0;
       for (let i = 0; i < to;) {
           if (string.charCodeAt(i) == 9) {
               n += tabSize - (n % tabSize);
               i++;
           }
           else {
               n++;
               i = findClusterBreak(string, i);
           }
       }
       return n;
   }
   /**
   Find the offset that corresponds to the given column position in a
   string, taking extending characters and tab size into account. By
   default, the string length is returned when it is too short to
   reach the column. Pass `strict` true to make it return -1 in that
   situation.
   */
   function findColumn(string, col, tabSize, strict) {
       for (let i = 0, n = 0;;) {
           if (n >= col)
               return i;
           if (i == string.length)
               break;
           n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
           i = findClusterBreak(string, i);
       }
       return strict === true ? -1 : string.length;
   }

   const C = "\u037c";
   const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
   const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
   const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};

   // :: - Style modules encapsulate a set of CSS rules defined from
   // JavaScript. Their definitions are only available in a given DOM
   // root after it has been _mounted_ there with `StyleModule.mount`.
   //
   // Style modules should be created once and stored somewhere, as
   // opposed to re-creating them every time you need them. The amount of
   // CSS rules generated for a given DOM root is bounded by the amount
   // of style modules that were used. So to avoid leaking rules, don't
   // create these dynamically, but treat them as one-time allocations.
   class StyleModule {
     // :: (Object<Style>, ?{finish: ?(string) → string})
     // Create a style module from the given spec.
     //
     // When `finish` is given, it is called on regular (non-`@`)
     // selectors (after `&` expansion) to compute the final selector.
     constructor(spec, options) {
       this.rules = [];
       let {finish} = options || {};

       function splitSelector(selector) {
         return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
       }

       function render(selectors, spec, target, isKeyframes) {
         let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
         if (isAt && spec == null) return target.push(selectors[0] + ";")
         for (let prop in spec) {
           let value = spec[prop];
           if (/&/.test(prop)) {
             render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
                    value, target);
           } else if (value && typeof value == "object") {
             if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.")
             render(splitSelector(prop), value, local, keyframes);
           } else if (value != null) {
             local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";");
           }
         }
         if (local.length || keyframes) {
           target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                       " {" + local.join(" ") + "}");
         }
       }

       for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
     }

     // :: () → string
     // Returns a string containing the module's CSS rules.
     getRules() { return this.rules.join("\n") }

     // :: () → string
     // Generate a new unique CSS class name.
     static newName() {
       let id = top[COUNT] || 1;
       top[COUNT] = id + 1;
       return C + id.toString(36)
     }

     // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
     //
     // Mount the given set of modules in the given DOM root, which ensures
     // that the CSS rules defined by the module are available in that
     // context.
     //
     // Rules are only added to the document once per root.
     //
     // Rule order will follow the order of the modules, so that rules from
     // modules later in the array take precedence of those from earlier
     // modules. If you call this function multiple times for the same root
     // in a way that changes the order of already mounted modules, the old
     // order will be changed.
     //
     // If a Content Security Policy nonce is provided, it is added to
     // the `<style>` tag generated by the library.
     static mount(root, modules, options) {
       let set = root[SET], nonce = options && options.nonce;
       if (!set) set = new StyleSet(root, nonce);
       else if (nonce) set.setNonce(nonce);
       set.mount(Array.isArray(modules) ? modules : [modules]);
     }
   }

   let adoptedSet = new Map; //<Document, StyleSet>

   class StyleSet {
     constructor(root, nonce) {
       let doc = root.ownerDocument || root, win = doc.defaultView;
       if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
         let adopted = adoptedSet.get(doc);
         if (adopted) {
           root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets];
           return root[SET] = adopted
         }
         this.sheet = new win.CSSStyleSheet;
         root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
         adoptedSet.set(doc, this);
       } else {
         this.styleTag = doc.createElement("style");
         if (nonce) this.styleTag.setAttribute("nonce", nonce);
         let target = root.head || root;
         target.insertBefore(this.styleTag, target.firstChild);
       }
       this.modules = [];
       root[SET] = this;
     }

     mount(modules) {
       let sheet = this.sheet;
       let pos = 0 /* Current rule offset */, j = 0; /* Index into this.modules */
       for (let i = 0; i < modules.length; i++) {
         let mod = modules[i], index = this.modules.indexOf(mod);
         if (index < j && index > -1) { // Ordering conflict
           this.modules.splice(index, 1);
           j--;
           index = -1;
         }
         if (index == -1) {
           this.modules.splice(j++, 0, mod);
           if (sheet) for (let k = 0; k < mod.rules.length; k++)
             sheet.insertRule(mod.rules[k], pos++);
         } else {
           while (j < index) pos += this.modules[j++].rules.length;
           pos += mod.rules.length;
           j++;
         }
       }

       if (!sheet) {
         let text = "";
         for (let i = 0; i < this.modules.length; i++)
           text += this.modules[i].getRules() + "\n";
         this.styleTag.textContent = text;
       }
     }

     setNonce(nonce) {
       if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
         this.styleTag.setAttribute("nonce", nonce);
     }
   }

   // Style::Object<union<Style,string>>
   //
   // A style is an object that, in the simple case, maps CSS property
   // names to strings holding their values, as in `{color: "red",
   // fontWeight: "bold"}`. The property names can be given in
   // camel-case—the library will insert a dash before capital letters
   // when converting them to CSS.
   //
   // If you include an underscore in a property name, it and everything
   // after it will be removed from the output, which can be useful when
   // providing a property multiple times, for browser compatibility
   // reasons.
   //
   // A property in a style object can also be a sub-selector, which
   // extends the current context to add a pseudo-selector or a child
   // selector. Such a property should contain a `&` character, which
   // will be replaced by the current selector. For example `{"&:before":
   // {content: '"hi"'}}`. Sub-selectors and regular properties can
   // freely be mixed in a given object. Any property containing a `&` is
   // assumed to be a sub-selector.
   //
   // Finally, a property can specify an @-block to be wrapped around the
   // styles defined inside the object that's the property's value. For
   // example to create a media query you can do `{"@media screen and
   // (min-width: 400px)": {...}}`.

   var base = {
     8: "Backspace",
     9: "Tab",
     10: "Enter",
     12: "NumLock",
     13: "Enter",
     16: "Shift",
     17: "Control",
     18: "Alt",
     20: "CapsLock",
     27: "Escape",
     32: " ",
     33: "PageUp",
     34: "PageDown",
     35: "End",
     36: "Home",
     37: "ArrowLeft",
     38: "ArrowUp",
     39: "ArrowRight",
     40: "ArrowDown",
     44: "PrintScreen",
     45: "Insert",
     46: "Delete",
     59: ";",
     61: "=",
     91: "Meta",
     92: "Meta",
     106: "*",
     107: "+",
     108: ",",
     109: "-",
     110: ".",
     111: "/",
     144: "NumLock",
     145: "ScrollLock",
     160: "Shift",
     161: "Shift",
     162: "Control",
     163: "Control",
     164: "Alt",
     165: "Alt",
     173: "-",
     186: ";",
     187: "=",
     188: ",",
     189: "-",
     190: ".",
     191: "/",
     192: "`",
     219: "[",
     220: "\\",
     221: "]",
     222: "'"
   };

   var shift = {
     48: ")",
     49: "!",
     50: "@",
     51: "#",
     52: "$",
     53: "%",
     54: "^",
     55: "&",
     56: "*",
     57: "(",
     59: ":",
     61: "+",
     173: "_",
     186: ":",
     187: "+",
     188: "<",
     189: "_",
     190: ">",
     191: "?",
     192: "~",
     219: "{",
     220: "|",
     221: "}",
     222: "\""
   };

   var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
   var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

   // Fill in the digit keys
   for (var i$1 = 0; i$1 < 10; i$1++) base[48 + i$1] = base[96 + i$1] = String(i$1);

   // The function keys
   for (var i$1 = 1; i$1 <= 24; i$1++) base[i$1 + 111] = "F" + i$1;

   // And the alphabetic keys
   for (var i$1 = 65; i$1 <= 90; i$1++) {
     base[i$1] = String.fromCharCode(i$1 + 32);
     shift[i$1] = String.fromCharCode(i$1);
   }

   // For each code that doesn't have a shift-equivalent, copy the base name
   for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

   function keyName(event) {
     // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
     // On IE, shift effect is never included in `.key`.
     var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
         ie$1 && event.shiftKey && event.key && event.key.length == 1 ||
         event.key == "Unidentified";
     var name = (!ignoreKey && event.key) ||
       (event.shiftKey ? shift : base)[event.keyCode] ||
       event.key || "Unidentified";
     // Edge sometimes produces wrong names (Issue #3)
     if (name == "Esc") name = "Escape";
     if (name == "Del") name = "Delete";
     // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
     if (name == "Left") name = "ArrowLeft";
     if (name == "Up") name = "ArrowUp";
     if (name == "Right") name = "ArrowRight";
     if (name == "Down") name = "ArrowDown";
     return name
   }

   function getSelection(root) {
       let target;
       // Browsers differ on whether shadow roots have a getSelection
       // method. If it exists, use that, otherwise, call it on the
       // document.
       if (root.nodeType == 11) { // Shadow root
           target = root.getSelection ? root : root.ownerDocument;
       }
       else {
           target = root;
       }
       return target.getSelection();
   }
   function contains(dom, node) {
       return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
   }
   function deepActiveElement(doc) {
       let elt = doc.activeElement;
       while (elt && elt.shadowRoot)
           elt = elt.shadowRoot.activeElement;
       return elt;
   }
   function hasSelection(dom, selection) {
       if (!selection.anchorNode)
           return false;
       try {
           // Firefox will raise 'permission denied' errors when accessing
           // properties of `sel.anchorNode` when it's in a generated CSS
           // element.
           return contains(dom, selection.anchorNode);
       }
       catch (_) {
           return false;
       }
   }
   function clientRectsFor(dom) {
       if (dom.nodeType == 3)
           return textRange(dom, 0, dom.nodeValue.length).getClientRects();
       else if (dom.nodeType == 1)
           return dom.getClientRects();
       else
           return [];
   }
   // Scans forward and backward through DOM positions equivalent to the
   // given one to see if the two are in the same place (i.e. after a
   // text node vs at the end of that text node)
   function isEquivalentPosition(node, off, targetNode, targetOff) {
       return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
           scanFor(node, off, targetNode, targetOff, 1)) : false;
   }
   function domIndex(node) {
       for (var index = 0;; index++) {
           node = node.previousSibling;
           if (!node)
               return index;
       }
   }
   function scanFor(node, off, targetNode, targetOff, dir) {
       for (;;) {
           if (node == targetNode && off == targetOff)
               return true;
           if (off == (dir < 0 ? 0 : maxOffset(node))) {
               if (node.nodeName == "DIV")
                   return false;
               let parent = node.parentNode;
               if (!parent || parent.nodeType != 1)
                   return false;
               off = domIndex(node) + (dir < 0 ? 0 : 1);
               node = parent;
           }
           else if (node.nodeType == 1) {
               node = node.childNodes[off + (dir < 0 ? -1 : 0)];
               if (node.nodeType == 1 && node.contentEditable == "false")
                   return false;
               off = dir < 0 ? maxOffset(node) : 0;
           }
           else {
               return false;
           }
       }
   }
   function maxOffset(node) {
       return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
   }
   function flattenRect(rect, left) {
       let x = left ? rect.left : rect.right;
       return { left: x, right: x, top: rect.top, bottom: rect.bottom };
   }
   function windowRect(win) {
       return { left: 0, right: win.innerWidth,
           top: 0, bottom: win.innerHeight };
   }
   function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
       let doc = dom.ownerDocument, win = doc.defaultView || window;
       for (let cur = dom, stop = false; cur && !stop;) {
           if (cur.nodeType == 1) { // Element
               let bounding, top = cur == doc.body;
               let scaleX = 1, scaleY = 1;
               if (top) {
                   bounding = windowRect(win);
               }
               else {
                   if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                       stop = true;
                   if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                       cur = cur.assignedSlot || cur.parentNode;
                       continue;
                   }
                   let rect = cur.getBoundingClientRect();
                   scaleX = rect.width / cur.offsetWidth;
                   scaleY = rect.height / cur.offsetHeight;
                   // Make sure scrollbar width isn't included in the rectangle
                   bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                       top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
               }
               let moveX = 0, moveY = 0;
               if (y == "nearest") {
                   if (rect.top < bounding.top) {
                       moveY = -(bounding.top - rect.top + yMargin);
                       if (side > 0 && rect.bottom > bounding.bottom + moveY)
                           moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                   }
                   else if (rect.bottom > bounding.bottom) {
                       moveY = rect.bottom - bounding.bottom + yMargin;
                       if (side < 0 && (rect.top - moveY) < bounding.top)
                           moveY = -(bounding.top + moveY - rect.top + yMargin);
                   }
               }
               else {
                   let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                   let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                       y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                           rect.bottom - boundingHeight + yMargin;
                   moveY = targetTop - bounding.top;
               }
               if (x == "nearest") {
                   if (rect.left < bounding.left) {
                       moveX = -(bounding.left - rect.left + xMargin);
                       if (side > 0 && rect.right > bounding.right + moveX)
                           moveX = rect.right - bounding.right + moveX + xMargin;
                   }
                   else if (rect.right > bounding.right) {
                       moveX = rect.right - bounding.right + xMargin;
                       if (side < 0 && rect.left < bounding.left + moveX)
                           moveX = -(bounding.left + moveX - rect.left + xMargin);
                   }
               }
               else {
                   let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                       (x == "start") == ltr ? rect.left - xMargin :
                           rect.right - (bounding.right - bounding.left) + xMargin;
                   moveX = targetLeft - bounding.left;
               }
               if (moveX || moveY) {
                   if (top) {
                       win.scrollBy(moveX, moveY);
                   }
                   else {
                       let movedX = 0, movedY = 0;
                       if (moveY) {
                           let start = cur.scrollTop;
                           cur.scrollTop += moveY / scaleY;
                           movedY = (cur.scrollTop - start) * scaleY;
                       }
                       if (moveX) {
                           let start = cur.scrollLeft;
                           cur.scrollLeft += moveX / scaleX;
                           movedX = (cur.scrollLeft - start) * scaleX;
                       }
                       rect = { left: rect.left - movedX, top: rect.top - movedY,
                           right: rect.right - movedX, bottom: rect.bottom - movedY };
                       if (movedX && Math.abs(movedX - moveX) < 1)
                           x = "nearest";
                       if (movedY && Math.abs(movedY - moveY) < 1)
                           y = "nearest";
                   }
               }
               if (top)
                   break;
               cur = cur.assignedSlot || cur.parentNode;
           }
           else if (cur.nodeType == 11) { // A shadow root
               cur = cur.host;
           }
           else {
               break;
           }
       }
   }
   function scrollableParent(dom) {
       let doc = dom.ownerDocument;
       for (let cur = dom.parentNode; cur;) {
           if (cur == doc.body) {
               break;
           }
           else if (cur.nodeType == 1) {
               if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
                   return cur;
               cur = cur.assignedSlot || cur.parentNode;
           }
           else if (cur.nodeType == 11) {
               cur = cur.host;
           }
           else {
               break;
           }
       }
       return null;
   }
   class DOMSelectionState {
       constructor() {
           this.anchorNode = null;
           this.anchorOffset = 0;
           this.focusNode = null;
           this.focusOffset = 0;
       }
       eq(domSel) {
           return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
               this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
       }
       setRange(range) {
           let { anchorNode, focusNode } = range;
           // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
           this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
       }
       set(anchorNode, anchorOffset, focusNode, focusOffset) {
           this.anchorNode = anchorNode;
           this.anchorOffset = anchorOffset;
           this.focusNode = focusNode;
           this.focusOffset = focusOffset;
       }
   }
   let preventScrollSupported = null;
   // Feature-detects support for .focus({preventScroll: true}), and uses
   // a fallback kludge when not supported.
   function focusPreventScroll(dom) {
       if (dom.setActive)
           return dom.setActive(); // in IE
       if (preventScrollSupported)
           return dom.focus(preventScrollSupported);
       let stack = [];
       for (let cur = dom; cur; cur = cur.parentNode) {
           stack.push(cur, cur.scrollTop, cur.scrollLeft);
           if (cur == cur.ownerDocument)
               break;
       }
       dom.focus(preventScrollSupported == null ? {
           get preventScroll() {
               preventScrollSupported = { preventScroll: true };
               return true;
           }
       } : undefined);
       if (!preventScrollSupported) {
           preventScrollSupported = false;
           for (let i = 0; i < stack.length;) {
               let elt = stack[i++], top = stack[i++], left = stack[i++];
               if (elt.scrollTop != top)
                   elt.scrollTop = top;
               if (elt.scrollLeft != left)
                   elt.scrollLeft = left;
           }
       }
   }
   let scratchRange;
   function textRange(node, from, to = from) {
       let range = scratchRange || (scratchRange = document.createRange());
       range.setEnd(node, to);
       range.setStart(node, from);
       return range;
   }
   function dispatchKey(elt, name, code) {
       let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
       let down = new KeyboardEvent("keydown", options);
       down.synthetic = true;
       elt.dispatchEvent(down);
       let up = new KeyboardEvent("keyup", options);
       up.synthetic = true;
       elt.dispatchEvent(up);
       return down.defaultPrevented || up.defaultPrevented;
   }
   function getRoot(node) {
       while (node) {
           if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
               return node;
           node = node.assignedSlot || node.parentNode;
       }
       return null;
   }
   function clearAttributes(node) {
       while (node.attributes.length)
           node.removeAttributeNode(node.attributes[0]);
   }
   function atElementStart(doc, selection) {
       let node = selection.focusNode, offset = selection.focusOffset;
       if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
           return false;
       // Safari can report bogus offsets (#1152)
       offset = Math.min(offset, maxOffset(node));
       for (;;) {
           if (offset) {
               if (node.nodeType != 1)
                   return false;
               let prev = node.childNodes[offset - 1];
               if (prev.contentEditable == "false")
                   offset--;
               else {
                   node = prev;
                   offset = maxOffset(node);
               }
           }
           else if (node == doc) {
               return true;
           }
           else {
               offset = domIndex(node);
               node = node.parentNode;
           }
       }
   }
   function isScrolledToBottom(elt) {
       return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
   }

   class DOMPos {
       constructor(node, offset, precise = true) {
           this.node = node;
           this.offset = offset;
           this.precise = precise;
       }
       static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
       static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
   }
   const noChildren = [];
   class ContentView {
       constructor() {
           this.parent = null;
           this.dom = null;
           this.flags = 2 /* ViewFlag.NodeDirty */;
       }
       get overrideDOMText() { return null; }
       get posAtStart() {
           return this.parent ? this.parent.posBefore(this) : 0;
       }
       get posAtEnd() {
           return this.posAtStart + this.length;
       }
       posBefore(view) {
           let pos = this.posAtStart;
           for (let child of this.children) {
               if (child == view)
                   return pos;
               pos += child.length + child.breakAfter;
           }
           throw new RangeError("Invalid child in posBefore");
       }
       posAfter(view) {
           return this.posBefore(view) + view.length;
       }
       sync(view, track) {
           if (this.flags & 2 /* ViewFlag.NodeDirty */) {
               let parent = this.dom;
               let prev = null, next;
               for (let child of this.children) {
                   if (child.flags & 7 /* ViewFlag.Dirty */) {
                       if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                           let contentView = ContentView.get(next);
                           if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                               child.reuseDOM(next);
                       }
                       child.sync(view, track);
                       child.flags &= ~7 /* ViewFlag.Dirty */;
                   }
                   next = prev ? prev.nextSibling : parent.firstChild;
                   if (track && !track.written && track.node == parent && next != child.dom)
                       track.written = true;
                   if (child.dom.parentNode == parent) {
                       while (next && next != child.dom)
                           next = rm$1(next);
                   }
                   else {
                       parent.insertBefore(child.dom, next);
                   }
                   prev = child.dom;
               }
               next = prev ? prev.nextSibling : parent.firstChild;
               if (next && track && track.node == parent)
                   track.written = true;
               while (next)
                   next = rm$1(next);
           }
           else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
               for (let child of this.children)
                   if (child.flags & 7 /* ViewFlag.Dirty */) {
                       child.sync(view, track);
                       child.flags &= ~7 /* ViewFlag.Dirty */;
                   }
           }
       }
       reuseDOM(_dom) { }
       localPosFromDOM(node, offset) {
           let after;
           if (node == this.dom) {
               after = this.dom.childNodes[offset];
           }
           else {
               let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
               for (;;) {
                   let parent = node.parentNode;
                   if (parent == this.dom)
                       break;
                   if (bias == 0 && parent.firstChild != parent.lastChild) {
                       if (node == parent.firstChild)
                           bias = -1;
                       else
                           bias = 1;
                   }
                   node = parent;
               }
               if (bias < 0)
                   after = node;
               else
                   after = node.nextSibling;
           }
           if (after == this.dom.firstChild)
               return 0;
           while (after && !ContentView.get(after))
               after = after.nextSibling;
           if (!after)
               return this.length;
           for (let i = 0, pos = 0;; i++) {
               let child = this.children[i];
               if (child.dom == after)
                   return pos;
               pos += child.length + child.breakAfter;
           }
       }
       domBoundsAround(from, to, offset = 0) {
           let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
           for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
               let child = this.children[i], end = pos + child.length;
               if (pos < from && end > to)
                   return child.domBoundsAround(from, to, pos);
               if (end >= from && fromI == -1) {
                   fromI = i;
                   fromStart = pos;
               }
               if (pos > to && child.dom.parentNode == this.dom) {
                   toI = i;
                   toEnd = prevEnd;
                   break;
               }
               prevEnd = end;
               pos = end + child.breakAfter;
           }
           return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
               startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
               endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
       }
       markDirty(andParent = false) {
           this.flags |= 2 /* ViewFlag.NodeDirty */;
           this.markParentsDirty(andParent);
       }
       markParentsDirty(childList) {
           for (let parent = this.parent; parent; parent = parent.parent) {
               if (childList)
                   parent.flags |= 2 /* ViewFlag.NodeDirty */;
               if (parent.flags & 1 /* ViewFlag.ChildDirty */)
                   return;
               parent.flags |= 1 /* ViewFlag.ChildDirty */;
               childList = false;
           }
       }
       setParent(parent) {
           if (this.parent != parent) {
               this.parent = parent;
               if (this.flags & 7 /* ViewFlag.Dirty */)
                   this.markParentsDirty(true);
           }
       }
       setDOM(dom) {
           if (this.dom)
               this.dom.cmView = null;
           this.dom = dom;
           dom.cmView = this;
       }
       get rootView() {
           for (let v = this;;) {
               let parent = v.parent;
               if (!parent)
                   return v;
               v = parent;
           }
       }
       replaceChildren(from, to, children = noChildren) {
           this.markDirty();
           for (let i = from; i < to; i++) {
               let child = this.children[i];
               if (child.parent == this)
                   child.destroy();
           }
           this.children.splice(from, to - from, ...children);
           for (let i = 0; i < children.length; i++)
               children[i].setParent(this);
       }
       ignoreMutation(_rec) { return false; }
       ignoreEvent(_event) { return false; }
       childCursor(pos = this.length) {
           return new ChildCursor(this.children, pos, this.children.length);
       }
       childPos(pos, bias = 1) {
           return this.childCursor().findPos(pos, bias);
       }
       toString() {
           let name = this.constructor.name.replace("View", "");
           return name + (this.children.length ? "(" + this.children.join() + ")" :
               this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
               (this.breakAfter ? "#" : "");
       }
       static get(node) { return node.cmView; }
       get isEditable() { return true; }
       get isWidget() { return false; }
       get isHidden() { return false; }
       merge(from, to, source, hasStart, openStart, openEnd) {
           return false;
       }
       become(other) { return false; }
       canReuseDOM(other) {
           return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
       }
       // When this is a zero-length view with a side, this should return a
       // number <= 0 to indicate it is before its position, or a
       // number > 0 when after its position.
       getSide() { return 0; }
       destroy() {
           this.parent = null;
       }
   }
   ContentView.prototype.breakAfter = 0;
   // Remove a DOM node and return its next sibling.
   function rm$1(dom) {
       let next = dom.nextSibling;
       dom.parentNode.removeChild(dom);
       return next;
   }
   class ChildCursor {
       constructor(children, pos, i) {
           this.children = children;
           this.pos = pos;
           this.i = i;
           this.off = 0;
       }
       findPos(pos, bias = 1) {
           for (;;) {
               if (pos > this.pos || pos == this.pos &&
                   (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                   this.off = pos - this.pos;
                   return this;
               }
               let next = this.children[--this.i];
               this.pos -= next.length + next.breakAfter;
           }
       }
   }
   function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
       let { children } = parent;
       let before = children.length ? children[fromI] : null;
       let last = insert.length ? insert[insert.length - 1] : null;
       let breakAtEnd = last ? last.breakAfter : breakAtStart;
       // Change within a single child
       if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
           before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
           return;
       if (toI < children.length) {
           let after = children[toI];
           // Make sure the end of the child after the update is preserved in `after`
           if (after && toOff < after.length) {
               // If we're splitting a child, separate part of it to avoid that
               // being mangled when updating the child before the update.
               if (fromI == toI) {
                   after = after.split(toOff);
                   toOff = 0;
               }
               // If the element after the replacement should be merged with
               // the last replacing element, update `content`
               if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                   insert[insert.length - 1] = after;
               }
               else {
                   // Remove the start of the after element, if necessary, and
                   // add it to `content`.
                   if (toOff)
                       after.merge(0, toOff, null, false, 0, openEnd);
                   insert.push(after);
               }
           }
           else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
               // The element at `toI` is entirely covered by this range.
               // Preserve its line break, if any.
               if (last)
                   last.breakAfter = 1;
               else
                   breakAtStart = 1;
           }
           // Since we've handled the next element from the current elements
           // now, make sure `toI` points after that.
           toI++;
       }
       if (before) {
           before.breakAfter = breakAtStart;
           if (fromOff > 0) {
               if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                   before.breakAfter = insert.shift().breakAfter;
               }
               else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                   before.merge(fromOff, before.length, null, false, openStart, 0);
               }
               fromI++;
           }
       }
       // Try to merge widgets on the boundaries of the replacement
       while (fromI < toI && insert.length) {
           if (children[toI - 1].become(insert[insert.length - 1])) {
               toI--;
               insert.pop();
               openEnd = insert.length ? 0 : openStart;
           }
           else if (children[fromI].become(insert[0])) {
               fromI++;
               insert.shift();
               openStart = insert.length ? 0 : openEnd;
           }
           else {
               break;
           }
       }
       if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
           children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
           fromI--;
       if (fromI < toI || insert.length)
           parent.replaceChildren(fromI, toI, insert);
   }
   function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
       let cur = parent.childCursor();
       let { i: toI, off: toOff } = cur.findPos(to, 1);
       let { i: fromI, off: fromOff } = cur.findPos(from, -1);
       let dLen = from - to;
       for (let view of insert)
           dLen += view.length;
       parent.length += dLen;
       replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
   }

   const LineBreakPlaceholder = "\uffff";
   class DOMReader {
       constructor(points, state) {
           this.points = points;
           this.text = "";
           this.lineSeparator = state.facet(EditorState.lineSeparator);
       }
       append(text) {
           this.text += text;
       }
       lineBreak() {
           this.text += LineBreakPlaceholder;
       }
       readRange(start, end) {
           if (!start)
               return this;
           let parent = start.parentNode;
           for (let cur = start;;) {
               this.findPointBefore(parent, cur);
               let oldLen = this.text.length;
               this.readNode(cur);
               let next = cur.nextSibling;
               if (next == end)
                   break;
               let view = ContentView.get(cur), nextView = ContentView.get(next);
               if (view && nextView ? view.breakAfter :
                   (view ? view.breakAfter : isBlockElement(cur)) ||
                       (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                   this.lineBreak();
               cur = next;
           }
           this.findPointBefore(parent, end);
           return this;
       }
       readTextNode(node) {
           let text = node.nodeValue;
           for (let point of this.points)
               if (point.node == node)
                   point.pos = this.text.length + Math.min(point.offset, text.length);
           for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
               let nextBreak = -1, breakSize = 1, m;
               if (this.lineSeparator) {
                   nextBreak = text.indexOf(this.lineSeparator, off);
                   breakSize = this.lineSeparator.length;
               }
               else if (m = re.exec(text)) {
                   nextBreak = m.index;
                   breakSize = m[0].length;
               }
               this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
               if (nextBreak < 0)
                   break;
               this.lineBreak();
               if (breakSize > 1)
                   for (let point of this.points)
                       if (point.node == node && point.pos > this.text.length)
                           point.pos -= breakSize - 1;
               off = nextBreak + breakSize;
           }
       }
       readNode(node) {
           if (node.cmIgnore)
               return;
           let view = ContentView.get(node);
           let fromView = view && view.overrideDOMText;
           if (fromView != null) {
               this.findPointInside(node, fromView.length);
               for (let i = fromView.iter(); !i.next().done;) {
                   if (i.lineBreak)
                       this.lineBreak();
                   else
                       this.append(i.value);
               }
           }
           else if (node.nodeType == 3) {
               this.readTextNode(node);
           }
           else if (node.nodeName == "BR") {
               if (node.nextSibling)
                   this.lineBreak();
           }
           else if (node.nodeType == 1) {
               this.readRange(node.firstChild, null);
           }
       }
       findPointBefore(node, next) {
           for (let point of this.points)
               if (point.node == node && node.childNodes[point.offset] == next)
                   point.pos = this.text.length;
       }
       findPointInside(node, maxLen) {
           for (let point of this.points)
               if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                   point.pos = this.text.length + Math.min(maxLen, point.offset);
       }
   }
   function isBlockElement(node) {
       return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
   }
   class DOMPoint {
       constructor(node, offset) {
           this.node = node;
           this.offset = offset;
           this.pos = -1;
       }
   }

   let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
   let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
   const ie_edge = /*@__PURE__*//Edge\/(\d+)/.exec(nav.userAgent);
   const ie_upto10 = /*@__PURE__*//MSIE \d/.test(nav.userAgent);
   const ie_11up = /*@__PURE__*//Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
   const ie = !!(ie_upto10 || ie_11up || ie_edge);
   const gecko = !ie && /*@__PURE__*//gecko\/(\d+)/i.test(nav.userAgent);
   const chrome = !ie && /*@__PURE__*//Chrome\/(\d+)/.exec(nav.userAgent);
   const webkit = "webkitFontSmoothing" in doc.documentElement.style;
   const safari = !ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);
   const ios = safari && (/*@__PURE__*//Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
   var browser = {
       mac: ios || /*@__PURE__*//Mac/.test(nav.platform),
       windows: /*@__PURE__*//Win/.test(nav.platform),
       linux: /*@__PURE__*//Linux|X11/.test(nav.platform),
       ie,
       ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
       gecko,
       gecko_version: gecko ? +(/*@__PURE__*//Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
       chrome: !!chrome,
       chrome_version: chrome ? +chrome[1] : 0,
       ios,
       android: /*@__PURE__*//Android\b/.test(nav.userAgent),
       webkit,
       safari,
       webkit_version: webkit ? +(/*@__PURE__*//\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
       tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
   };

   const MaxJoinLen = 256;
   class TextView extends ContentView {
       constructor(text) {
           super();
           this.text = text;
       }
       get length() { return this.text.length; }
       createDOM(textDOM) {
           this.setDOM(textDOM || document.createTextNode(this.text));
       }
       sync(view, track) {
           if (!this.dom)
               this.createDOM();
           if (this.dom.nodeValue != this.text) {
               if (track && track.node == this.dom)
                   track.written = true;
               this.dom.nodeValue = this.text;
           }
       }
       reuseDOM(dom) {
           if (dom.nodeType == 3)
               this.createDOM(dom);
       }
       merge(from, to, source) {
           if ((this.flags & 8 /* ViewFlag.Composition */) ||
               source && (!(source instanceof TextView) ||
                   this.length - (to - from) + source.length > MaxJoinLen ||
                   (source.flags & 8 /* ViewFlag.Composition */)))
               return false;
           this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
           this.markDirty();
           return true;
       }
       split(from) {
           let result = new TextView(this.text.slice(from));
           this.text = this.text.slice(0, from);
           this.markDirty();
           result.flags |= this.flags & 8 /* ViewFlag.Composition */;
           return result;
       }
       localPosFromDOM(node, offset) {
           return node == this.dom ? offset : offset ? this.text.length : 0;
       }
       domAtPos(pos) { return new DOMPos(this.dom, pos); }
       domBoundsAround(_from, _to, offset) {
           return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
       }
       coordsAt(pos, side) {
           return textCoords(this.dom, pos, side);
       }
   }
   class MarkView extends ContentView {
       constructor(mark, children = [], length = 0) {
           super();
           this.mark = mark;
           this.children = children;
           this.length = length;
           for (let ch of children)
               ch.setParent(this);
       }
       setAttrs(dom) {
           clearAttributes(dom);
           if (this.mark.class)
               dom.className = this.mark.class;
           if (this.mark.attrs)
               for (let name in this.mark.attrs)
                   dom.setAttribute(name, this.mark.attrs[name]);
           return dom;
       }
       canReuseDOM(other) {
           return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
       }
       reuseDOM(node) {
           if (node.nodeName == this.mark.tagName.toUpperCase()) {
               this.setDOM(node);
               this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
           }
       }
       sync(view, track) {
           if (!this.dom)
               this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
           else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
               this.setAttrs(this.dom);
           super.sync(view, track);
       }
       merge(from, to, source, _hasStart, openStart, openEnd) {
           if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
               (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
               return false;
           mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
           this.markDirty();
           return true;
       }
       split(from) {
           let result = [], off = 0, detachFrom = -1, i = 0;
           for (let elt of this.children) {
               let end = off + elt.length;
               if (end > from)
                   result.push(off < from ? elt.split(from - off) : elt);
               if (detachFrom < 0 && off >= from)
                   detachFrom = i;
               off = end;
               i++;
           }
           let length = this.length - from;
           this.length = from;
           if (detachFrom > -1) {
               this.children.length = detachFrom;
               this.markDirty();
           }
           return new MarkView(this.mark, result, length);
       }
       domAtPos(pos) {
           return inlineDOMAtPos(this, pos);
       }
       coordsAt(pos, side) {
           return coordsInChildren(this, pos, side);
       }
   }
   function textCoords(text, pos, side) {
       let length = text.nodeValue.length;
       if (pos > length)
           pos = length;
       let from = pos, to = pos, flatten = 0;
       if (pos == 0 && side < 0 || pos == length && side >= 0) {
           if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
               if (pos) {
                   from--;
                   flatten = 1;
               } // FIXME this is wrong in RTL text
               else if (to < length) {
                   to++;
                   flatten = -1;
               }
           }
       }
       else {
           if (side < 0)
               from--;
           else if (to < length)
               to++;
       }
       let rects = textRange(text, from, to).getClientRects();
       if (!rects.length)
           return null;
       let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
       if (browser.safari && !flatten && rect.width == 0)
           rect = Array.prototype.find.call(rects, r => r.width) || rect;
       return flatten ? flattenRect(rect, flatten < 0) : rect || null;
   }
   // Also used for collapsed ranges that don't have a placeholder widget!
   class WidgetView extends ContentView {
       static create(widget, length, side) {
           return new WidgetView(widget, length, side);
       }
       constructor(widget, length, side) {
           super();
           this.widget = widget;
           this.length = length;
           this.side = side;
           this.prevWidget = null;
       }
       split(from) {
           let result = WidgetView.create(this.widget, this.length - from, this.side);
           this.length -= from;
           return result;
       }
       sync(view) {
           if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
               if (this.dom && this.prevWidget)
                   this.prevWidget.destroy(this.dom);
               this.prevWidget = null;
               this.setDOM(this.widget.toDOM(view));
               this.dom.contentEditable = "false";
           }
       }
       getSide() { return this.side; }
       merge(from, to, source, hasStart, openStart, openEnd) {
           if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
               from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
               return false;
           this.length = from + (source ? source.length : 0) + (this.length - to);
           return true;
       }
       become(other) {
           if (other instanceof WidgetView && other.side == this.side &&
               this.widget.constructor == other.widget.constructor) {
               if (!this.widget.compare(other.widget))
                   this.markDirty(true);
               if (this.dom && !this.prevWidget)
                   this.prevWidget = this.widget;
               this.widget = other.widget;
               this.length = other.length;
               return true;
           }
           return false;
       }
       ignoreMutation() { return true; }
       ignoreEvent(event) { return this.widget.ignoreEvent(event); }
       get overrideDOMText() {
           if (this.length == 0)
               return Text.empty;
           let top = this;
           while (top.parent)
               top = top.parent;
           let { view } = top, text = view && view.state.doc, start = this.posAtStart;
           return text ? text.slice(start, start + this.length) : Text.empty;
       }
       domAtPos(pos) {
           return (this.length ? pos == 0 : this.side > 0)
               ? DOMPos.before(this.dom)
               : DOMPos.after(this.dom, pos == this.length);
       }
       domBoundsAround() { return null; }
       coordsAt(pos, side) {
           let custom = this.widget.coordsAt(this.dom, pos, side);
           if (custom)
               return custom;
           let rects = this.dom.getClientRects(), rect = null;
           if (!rects.length)
               return null;
           let fromBack = this.side ? this.side < 0 : pos > 0;
           for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
               rect = rects[i];
               if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                   break;
           }
           return flattenRect(rect, !fromBack);
       }
       get isEditable() { return false; }
       get isWidget() { return true; }
       get isHidden() { return this.widget.isHidden; }
       destroy() {
           super.destroy();
           if (this.dom)
               this.widget.destroy(this.dom);
       }
   }
   // These are drawn around uneditable widgets to avoid a number of
   // browser bugs that show up when the cursor is directly next to
   // uneditable inline content.
   class WidgetBufferView extends ContentView {
       constructor(side) {
           super();
           this.side = side;
       }
       get length() { return 0; }
       merge() { return false; }
       become(other) {
           return other instanceof WidgetBufferView && other.side == this.side;
       }
       split() { return new WidgetBufferView(this.side); }
       sync() {
           if (!this.dom) {
               let dom = document.createElement("img");
               dom.className = "cm-widgetBuffer";
               dom.setAttribute("aria-hidden", "true");
               this.setDOM(dom);
           }
       }
       getSide() { return this.side; }
       domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
       localPosFromDOM() { return 0; }
       domBoundsAround() { return null; }
       coordsAt(pos) {
           return this.dom.getBoundingClientRect();
       }
       get overrideDOMText() {
           return Text.empty;
       }
       get isHidden() { return true; }
   }
   TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
   function inlineDOMAtPos(parent, pos) {
       let dom = parent.dom, { children } = parent, i = 0;
       for (let off = 0; i < children.length; i++) {
           let child = children[i], end = off + child.length;
           if (end == off && child.getSide() <= 0)
               continue;
           if (pos > off && pos < end && child.dom.parentNode == dom)
               return child.domAtPos(pos - off);
           if (pos <= off)
               break;
           off = end;
       }
       for (let j = i; j > 0; j--) {
           let prev = children[j - 1];
           if (prev.dom.parentNode == dom)
               return prev.domAtPos(prev.length);
       }
       for (let j = i; j < children.length; j++) {
           let next = children[j];
           if (next.dom.parentNode == dom)
               return next.domAtPos(0);
       }
       return new DOMPos(dom, 0);
   }
   // Assumes `view`, if a mark view, has precisely 1 child.
   function joinInlineInto(parent, view, open) {
       let last, { children } = parent;
       if (open > 0 && view instanceof MarkView && children.length &&
           (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
           joinInlineInto(last, view.children[0], open - 1);
       }
       else {
           children.push(view);
           view.setParent(parent);
       }
       parent.length += view.length;
   }
   function coordsInChildren(view, pos, side) {
       let before = null, beforePos = -1, after = null, afterPos = -1;
       function scan(view, pos) {
           for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
               let child = view.children[i], end = off + child.length;
               if (end >= pos) {
                   if (child.children.length) {
                       scan(child, pos - off);
                   }
                   else if ((!after || after.isHidden && side > 0) &&
                       (end > pos || off == end && child.getSide() > 0)) {
                       after = child;
                       afterPos = pos - off;
                   }
                   else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                       before = child;
                       beforePos = pos - off;
                   }
               }
               off = end;
           }
       }
       scan(view, pos);
       let target = (side < 0 ? before : after) || before || after;
       if (target)
           return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
       return fallbackRect(view);
   }
   function fallbackRect(view) {
       let last = view.dom.lastChild;
       if (!last)
           return view.dom.getBoundingClientRect();
       let rects = clientRectsFor(last);
       return rects[rects.length - 1] || null;
   }

   function combineAttrs(source, target) {
       for (let name in source) {
           if (name == "class" && target.class)
               target.class += " " + source.class;
           else if (name == "style" && target.style)
               target.style += ";" + source.style;
           else
               target[name] = source[name];
       }
       return target;
   }
   const noAttrs = /*@__PURE__*/Object.create(null);
   function attrsEq(a, b, ignore) {
       if (a == b)
           return true;
       if (!a)
           a = noAttrs;
       if (!b)
           b = noAttrs;
       let keysA = Object.keys(a), keysB = Object.keys(b);
       if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
           keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
           return false;
       for (let key of keysA) {
           if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
               return false;
       }
       return true;
   }
   function updateAttrs(dom, prev, attrs) {
       let changed = false;
       if (prev)
           for (let name in prev)
               if (!(attrs && name in attrs)) {
                   changed = true;
                   if (name == "style")
                       dom.style.cssText = "";
                   else
                       dom.removeAttribute(name);
               }
       if (attrs)
           for (let name in attrs)
               if (!(prev && prev[name] == attrs[name])) {
                   changed = true;
                   if (name == "style")
                       dom.style.cssText = attrs[name];
                   else
                       dom.setAttribute(name, attrs[name]);
               }
       return changed;
   }
   function getAttrs(dom) {
       let attrs = Object.create(null);
       for (let i = 0; i < dom.attributes.length; i++) {
           let attr = dom.attributes[i];
           attrs[attr.name] = attr.value;
       }
       return attrs;
   }

   /**
   Widgets added to the content are described by subclasses of this
   class. Using a description object like that makes it possible to
   delay creating of the DOM structure for a widget until it is
   needed, and to avoid redrawing widgets even if the decorations
   that define them are recreated.
   */
   class WidgetType {
       /**
       Compare this instance to another instance of the same type.
       (TypeScript can't express this, but only instances of the same
       specific class will be passed to this method.) This is used to
       avoid redrawing widgets when they are replaced by a new
       decoration of the same type. The default implementation just
       returns `false`, which will cause new instances of the widget to
       always be redrawn.
       */
       eq(widget) { return false; }
       /**
       Update a DOM element created by a widget of the same type (but
       different, non-`eq` content) to reflect this widget. May return
       true to indicate that it could update, false to indicate it
       couldn't (in which case the widget will be redrawn). The default
       implementation just returns false.
       */
       updateDOM(dom, view) { return false; }
       /**
       @internal
       */
       compare(other) {
           return this == other || this.constructor == other.constructor && this.eq(other);
       }
       /**
       The estimated height this widget will have, to be used when
       estimating the height of content that hasn't been drawn. May
       return -1 to indicate you don't know. The default implementation
       returns -1.
       */
       get estimatedHeight() { return -1; }
       /**
       For inline widgets that are displayed inline (as opposed to
       `inline-block`) and introduce line breaks (through `<br>` tags
       or textual newlines), this must indicate the amount of line
       breaks they introduce. Defaults to 0.
       */
       get lineBreaks() { return 0; }
       /**
       Can be used to configure which kinds of events inside the widget
       should be ignored by the editor. The default is to ignore all
       events.
       */
       ignoreEvent(event) { return true; }
       /**
       Override the way screen coordinates for positions at/in the
       widget are found. `pos` will be the offset into the widget, and
       `side` the side of the position that is being queried—less than
       zero for before, greater than zero for after, and zero for
       directly at that position.
       */
       coordsAt(dom, pos, side) { return null; }
       /**
       @internal
       */
       get isHidden() { return false; }
       /**
       This is called when the an instance of the widget is removed
       from the editor view.
       */
       destroy(dom) { }
   }
   /**
   The different types of blocks that can occur in an editor view.
   */
   var BlockType = /*@__PURE__*/(function (BlockType) {
       /**
       A line of text.
       */
       BlockType[BlockType["Text"] = 0] = "Text";
       /**
       A block widget associated with the position after it.
       */
       BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
       /**
       A block widget associated with the position before it.
       */
       BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
       /**
       A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
       */
       BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
   return BlockType})(BlockType || (BlockType = {}));
   /**
   A decoration provides information on how to draw or style a piece
   of content. You'll usually use it wrapped in a
   [`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
   @nonabstract
   */
   class Decoration extends RangeValue {
       constructor(
       /**
       @internal
       */
       startSide, 
       /**
       @internal
       */
       endSide, 
       /**
       @internal
       */
       widget, 
       /**
       The config object used to create this decoration. You can
       include additional properties in there to store metadata about
       your decoration.
       */
       spec) {
           super();
           this.startSide = startSide;
           this.endSide = endSide;
           this.widget = widget;
           this.spec = spec;
       }
       /**
       @internal
       */
       get heightRelevant() { return false; }
       /**
       Create a mark decoration, which influences the styling of the
       content in its range. Nested mark decorations will cause nested
       DOM elements to be created. Nesting order is determined by
       precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
       the higher-precedence decorations creating the inner DOM nodes.
       Such elements are split on line boundaries and on the boundaries
       of lower-precedence decorations.
       */
       static mark(spec) {
           return new MarkDecoration(spec);
       }
       /**
       Create a widget decoration, which displays a DOM element at the
       given position.
       */
       static widget(spec) {
           let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
           side += (block && !spec.inlineOrder)
               ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)
               : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
           return new PointDecoration(spec, side, side, block, spec.widget || null, false);
       }
       /**
       Create a replace decoration which replaces the given range with
       a widget, or simply hides it.
       */
       static replace(spec) {
           let block = !!spec.block, startSide, endSide;
           if (spec.isBlockGap) {
               startSide = -500000000 /* Side.GapStart */;
               endSide = 400000000 /* Side.GapEnd */;
           }
           else {
               let { start, end } = getInclusive(spec, block);
               startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
               endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
           }
           return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
       }
       /**
       Create a line decoration, which can add DOM attributes to the
       line starting at the given position.
       */
       static line(spec) {
           return new LineDecoration(spec);
       }
       /**
       Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
       decorated range or ranges. If the ranges aren't already sorted,
       pass `true` for `sort` to make the library sort them for you.
       */
       static set(of, sort = false) {
           return RangeSet.of(of, sort);
       }
       /**
       @internal
       */
       hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
   }
   /**
   The empty set of decorations.
   */
   Decoration.none = RangeSet.empty;
   class MarkDecoration extends Decoration {
       constructor(spec) {
           let { start, end } = getInclusive(spec);
           super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
           this.tagName = spec.tagName || "span";
           this.class = spec.class || "";
           this.attrs = spec.attributes || null;
       }
       eq(other) {
           var _a, _b;
           return this == other ||
               other instanceof MarkDecoration &&
                   this.tagName == other.tagName &&
                   (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                   attrsEq(this.attrs, other.attrs, "class");
       }
       range(from, to = from) {
           if (from >= to)
               throw new RangeError("Mark decorations may not be empty");
           return super.range(from, to);
       }
   }
   MarkDecoration.prototype.point = false;
   class LineDecoration extends Decoration {
       constructor(spec) {
           super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
       }
       eq(other) {
           return other instanceof LineDecoration &&
               this.spec.class == other.spec.class &&
               attrsEq(this.spec.attributes, other.spec.attributes);
       }
       range(from, to = from) {
           if (to != from)
               throw new RangeError("Line decoration ranges must be zero-length");
           return super.range(from, to);
       }
   }
   LineDecoration.prototype.mapMode = MapMode.TrackBefore;
   LineDecoration.prototype.point = true;
   class PointDecoration extends Decoration {
       constructor(spec, startSide, endSide, block, widget, isReplace) {
           super(startSide, endSide, widget, spec);
           this.block = block;
           this.isReplace = isReplace;
           this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
       }
       // Only relevant when this.block == true
       get type() {
           return this.startSide < this.endSide ? BlockType.WidgetRange
               : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
       }
       get heightRelevant() {
           return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
       }
       eq(other) {
           return other instanceof PointDecoration &&
               widgetsEq(this.widget, other.widget) &&
               this.block == other.block &&
               this.startSide == other.startSide && this.endSide == other.endSide;
       }
       range(from, to = from) {
           if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
               throw new RangeError("Invalid range for replacement decoration");
           if (!this.isReplace && to != from)
               throw new RangeError("Widget decorations can only have zero-length ranges");
           return super.range(from, to);
       }
   }
   PointDecoration.prototype.point = true;
   function getInclusive(spec, block = false) {
       let { inclusiveStart: start, inclusiveEnd: end } = spec;
       if (start == null)
           start = spec.inclusive;
       if (end == null)
           end = spec.inclusive;
       return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
   }
   function widgetsEq(a, b) {
       return a == b || !!(a && b && a.compare(b));
   }
   function addRange(from, to, ranges, margin = 0) {
       let last = ranges.length - 1;
       if (last >= 0 && ranges[last] + margin >= from)
           ranges[last] = Math.max(ranges[last], to);
       else
           ranges.push(from, to);
   }

   class LineView extends ContentView {
       constructor() {
           super(...arguments);
           this.children = [];
           this.length = 0;
           this.prevAttrs = undefined;
           this.attrs = null;
           this.breakAfter = 0;
       }
       // Consumes source
       merge(from, to, source, hasStart, openStart, openEnd) {
           if (source) {
               if (!(source instanceof LineView))
                   return false;
               if (!this.dom)
                   source.transferDOM(this); // Reuse source.dom when appropriate
           }
           if (hasStart)
               this.setDeco(source ? source.attrs : null);
           mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
           return true;
       }
       split(at) {
           let end = new LineView;
           end.breakAfter = this.breakAfter;
           if (this.length == 0)
               return end;
           let { i, off } = this.childPos(at);
           if (off) {
               end.append(this.children[i].split(off), 0);
               this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
               i++;
           }
           for (let j = i; j < this.children.length; j++)
               end.append(this.children[j], 0);
           while (i > 0 && this.children[i - 1].length == 0)
               this.children[--i].destroy();
           this.children.length = i;
           this.markDirty();
           this.length = at;
           return end;
       }
       transferDOM(other) {
           if (!this.dom)
               return;
           this.markDirty();
           other.setDOM(this.dom);
           other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
           this.prevAttrs = undefined;
           this.dom = null;
       }
       setDeco(attrs) {
           if (!attrsEq(this.attrs, attrs)) {
               if (this.dom) {
                   this.prevAttrs = this.attrs;
                   this.markDirty();
               }
               this.attrs = attrs;
           }
       }
       append(child, openStart) {
           joinInlineInto(this, child, openStart);
       }
       // Only called when building a line view in ContentBuilder
       addLineDeco(deco) {
           let attrs = deco.spec.attributes, cls = deco.spec.class;
           if (attrs)
               this.attrs = combineAttrs(attrs, this.attrs || {});
           if (cls)
               this.attrs = combineAttrs({ class: cls }, this.attrs || {});
       }
       domAtPos(pos) {
           return inlineDOMAtPos(this, pos);
       }
       reuseDOM(node) {
           if (node.nodeName == "DIV") {
               this.setDOM(node);
               this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
           }
       }
       sync(view, track) {
           var _a;
           if (!this.dom) {
               this.setDOM(document.createElement("div"));
               this.dom.className = "cm-line";
               this.prevAttrs = this.attrs ? null : undefined;
           }
           else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
               clearAttributes(this.dom);
               this.dom.className = "cm-line";
               this.prevAttrs = this.attrs ? null : undefined;
           }
           if (this.prevAttrs !== undefined) {
               updateAttrs(this.dom, this.prevAttrs, this.attrs);
               this.dom.classList.add("cm-line");
               this.prevAttrs = undefined;
           }
           super.sync(view, track);
           let last = this.dom.lastChild;
           while (last && ContentView.get(last) instanceof MarkView)
               last = last.lastChild;
           if (!last || !this.length ||
               last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                   (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
               let hack = document.createElement("BR");
               hack.cmIgnore = true;
               this.dom.appendChild(hack);
           }
       }
       measureTextSize() {
           if (this.children.length == 0 || this.length > 20)
               return null;
           let totalWidth = 0, textHeight;
           for (let child of this.children) {
               if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                   return null;
               let rects = clientRectsFor(child.dom);
               if (rects.length != 1)
                   return null;
               totalWidth += rects[0].width;
               textHeight = rects[0].height;
           }
           return !totalWidth ? null : {
               lineHeight: this.dom.getBoundingClientRect().height,
               charWidth: totalWidth / this.length,
               textHeight
           };
       }
       coordsAt(pos, side) {
           let rect = coordsInChildren(this, pos, side);
           // Correct rectangle height for empty lines when the returned
           // height is larger than the text height.
           if (!this.children.length && rect && this.parent) {
               let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
               if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                   let dist = (height - heightOracle.textHeight) / 2;
                   return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
               }
           }
           return rect;
       }
       become(_other) { return false; }
       get type() { return BlockType.Text; }
       static find(docView, pos) {
           for (let i = 0, off = 0; i < docView.children.length; i++) {
               let block = docView.children[i], end = off + block.length;
               if (end >= pos) {
                   if (block instanceof LineView)
                       return block;
                   if (end > pos)
                       break;
               }
               off = end + block.breakAfter;
           }
           return null;
       }
   }
   class BlockWidgetView extends ContentView {
       constructor(widget, length, type) {
           super();
           this.widget = widget;
           this.length = length;
           this.type = type;
           this.breakAfter = 0;
           this.prevWidget = null;
       }
       merge(from, to, source, _takeDeco, openStart, openEnd) {
           if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
               from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
               return false;
           this.length = from + (source ? source.length : 0) + (this.length - to);
           return true;
       }
       domAtPos(pos) {
           return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
       }
       split(at) {
           let len = this.length - at;
           this.length = at;
           let end = new BlockWidgetView(this.widget, len, this.type);
           end.breakAfter = this.breakAfter;
           return end;
       }
       get children() { return noChildren; }
       sync(view) {
           if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
               if (this.dom && this.prevWidget)
                   this.prevWidget.destroy(this.dom);
               this.prevWidget = null;
               this.setDOM(this.widget.toDOM(view));
               this.dom.contentEditable = "false";
           }
       }
       get overrideDOMText() {
           return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
       }
       domBoundsAround() { return null; }
       become(other) {
           if (other instanceof BlockWidgetView &&
               other.widget.constructor == this.widget.constructor) {
               if (!other.widget.compare(this.widget))
                   this.markDirty(true);
               if (this.dom && !this.prevWidget)
                   this.prevWidget = this.widget;
               this.widget = other.widget;
               this.length = other.length;
               this.type = other.type;
               this.breakAfter = other.breakAfter;
               return true;
           }
           return false;
       }
       ignoreMutation() { return true; }
       ignoreEvent(event) { return this.widget.ignoreEvent(event); }
       get isEditable() { return false; }
       get isWidget() { return true; }
       coordsAt(pos, side) {
           return this.widget.coordsAt(this.dom, pos, side);
       }
       destroy() {
           super.destroy();
           if (this.dom)
               this.widget.destroy(this.dom);
       }
   }

   class ContentBuilder {
       constructor(doc, pos, end, disallowBlockEffectsFor) {
           this.doc = doc;
           this.pos = pos;
           this.end = end;
           this.disallowBlockEffectsFor = disallowBlockEffectsFor;
           this.content = [];
           this.curLine = null;
           this.breakAtStart = 0;
           this.pendingBuffer = 0 /* Buf.No */;
           this.bufferMarks = [];
           // Set to false directly after a widget that covers the position after it
           this.atCursorPos = true;
           this.openStart = -1;
           this.openEnd = -1;
           this.text = "";
           this.textOff = 0;
           this.cursor = doc.iter();
           this.skip = pos;
       }
       posCovered() {
           if (this.content.length == 0)
               return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
           let last = this.content[this.content.length - 1];
           return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
       }
       getLine() {
           if (!this.curLine) {
               this.content.push(this.curLine = new LineView);
               this.atCursorPos = true;
           }
           return this.curLine;
       }
       flushBuffer(active = this.bufferMarks) {
           if (this.pendingBuffer) {
               this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
               this.pendingBuffer = 0 /* Buf.No */;
           }
       }
       addBlockWidget(view) {
           this.flushBuffer();
           this.curLine = null;
           this.content.push(view);
       }
       finish(openEnd) {
           if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
               this.flushBuffer();
           else
               this.pendingBuffer = 0 /* Buf.No */;
           if (!this.posCovered())
               this.getLine();
       }
       buildText(length, active, openStart) {
           while (length > 0) {
               if (this.textOff == this.text.length) {
                   let { value, lineBreak, done } = this.cursor.next(this.skip);
                   this.skip = 0;
                   if (done)
                       throw new Error("Ran out of text content when drawing inline views");
                   if (lineBreak) {
                       if (!this.posCovered())
                           this.getLine();
                       if (this.content.length)
                           this.content[this.content.length - 1].breakAfter = 1;
                       else
                           this.breakAtStart = 1;
                       this.flushBuffer();
                       this.curLine = null;
                       this.atCursorPos = true;
                       length--;
                       continue;
                   }
                   else {
                       this.text = value;
                       this.textOff = 0;
                   }
               }
               let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
               this.flushBuffer(active.slice(active.length - openStart));
               this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
               this.atCursorPos = true;
               this.textOff += take;
               length -= take;
               openStart = 0;
           }
       }
       span(from, to, active, openStart) {
           this.buildText(to - from, active, openStart);
           this.pos = to;
           if (this.openStart < 0)
               this.openStart = openStart;
       }
       point(from, to, deco, active, openStart, index) {
           if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
               if (deco.block)
                   throw new RangeError("Block decorations may not be specified via plugins");
               if (to > this.doc.lineAt(this.pos).to)
                   throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
           }
           let len = to - from;
           if (deco instanceof PointDecoration) {
               if (deco.block) {
                   let { type } = deco;
                   if (type == BlockType.WidgetAfter && !this.posCovered())
                       this.getLine();
                   this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
               }
               else {
                   let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
                   let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                       (from < to || deco.startSide > 0);
                   let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                   let line = this.getLine();
                   if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)
                       this.pendingBuffer = 0 /* Buf.No */;
                   this.flushBuffer(active);
                   if (cursorBefore) {
                       line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                       openStart = active.length + Math.max(0, openStart - active.length);
                   }
                   line.append(wrapMarks(view, active), openStart);
                   this.atCursorPos = cursorAfter;
                   this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
                   if (this.pendingBuffer)
                       this.bufferMarks = active.slice();
               }
           }
           else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
               this.getLine().addLineDeco(deco);
           }
           if (len) {
               // Advance the iterator past the replaced content
               if (this.textOff + len <= this.text.length) {
                   this.textOff += len;
               }
               else {
                   this.skip += len - (this.text.length - this.textOff);
                   this.text = "";
                   this.textOff = 0;
               }
               this.pos = to;
           }
           if (this.openStart < 0)
               this.openStart = openStart;
       }
       static build(text, from, to, decorations, dynamicDecorationMap) {
           let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
           builder.openEnd = RangeSet.spans(decorations, from, to, builder);
           if (builder.openStart < 0)
               builder.openStart = builder.openEnd;
           builder.finish(builder.openEnd);
           return builder;
       }
   }
   function wrapMarks(view, active) {
       for (let mark of active)
           view = new MarkView(mark, [view], view.length);
       return view;
   }
   class NullWidget extends WidgetType {
       constructor(tag) {
           super();
           this.tag = tag;
       }
       eq(other) { return other.tag == this.tag; }
       toDOM() { return document.createElement(this.tag); }
       updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
       get isHidden() { return true; }
   }

   const clickAddsSelectionRange = /*@__PURE__*/Facet.define();
   const dragMovesSelection$1 = /*@__PURE__*/Facet.define();
   const mouseSelectionStyle = /*@__PURE__*/Facet.define();
   const exceptionSink = /*@__PURE__*/Facet.define();
   const updateListener = /*@__PURE__*/Facet.define();
   const inputHandler$1 = /*@__PURE__*/Facet.define();
   const focusChangeEffect = /*@__PURE__*/Facet.define();
   const perLineTextDirection = /*@__PURE__*/Facet.define({
       combine: values => values.some(x => x)
   });
   const nativeSelectionHidden = /*@__PURE__*/Facet.define({
       combine: values => values.some(x => x)
   });
   class ScrollTarget {
       constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
           this.range = range;
           this.y = y;
           this.x = x;
           this.yMargin = yMargin;
           this.xMargin = xMargin;
       }
       map(changes) {
           return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
       }
   }
   const scrollIntoView$1 = /*@__PURE__*/StateEffect.define({ map: (t, ch) => t.map(ch) });
   /**
   Log or report an unhandled exception in client code. Should
   probably only be used by extension code that allows client code to
   provide functions, and calls those functions in a context where an
   exception can't be propagated to calling code in a reasonable way
   (for example when in an event handler).

   Either calls a handler registered with
   [`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
   `window.onerror`, if defined, or `console.error` (in which case
   it'll pass `context`, when given, as first argument).
   */
   function logException(state, exception, context) {
       let handler = state.facet(exceptionSink);
       if (handler.length)
           handler[0](exception);
       else if (window.onerror)
           window.onerror(String(exception), context, undefined, undefined, exception);
       else if (context)
           console.error(context + ":", exception);
       else
           console.error(exception);
   }
   const editable = /*@__PURE__*/Facet.define({ combine: values => values.length ? values[0] : true });
   let nextPluginID = 0;
   const viewPlugin = /*@__PURE__*/Facet.define();
   /**
   View plugins associate stateful values with a view. They can
   influence the way the content is drawn, and are notified of things
   that happen in the view.
   */
   class ViewPlugin {
       constructor(
       /**
       @internal
       */
       id, 
       /**
       @internal
       */
       create, 
       /**
       @internal
       */
       domEventHandlers, buildExtensions) {
           this.id = id;
           this.create = create;
           this.domEventHandlers = domEventHandlers;
           this.extension = buildExtensions(this);
       }
       /**
       Define a plugin from a constructor function that creates the
       plugin's value, given an editor view.
       */
       static define(create, spec) {
           const { eventHandlers, provide, decorations: deco } = spec || {};
           return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {
               let ext = [viewPlugin.of(plugin)];
               if (deco)
                   ext.push(decorations.of(view => {
                       let pluginInst = view.plugin(plugin);
                       return pluginInst ? deco(pluginInst) : Decoration.none;
                   }));
               if (provide)
                   ext.push(provide(plugin));
               return ext;
           });
       }
       /**
       Create a plugin for a class whose constructor takes a single
       editor view as argument.
       */
       static fromClass(cls, spec) {
           return ViewPlugin.define(view => new cls(view), spec);
       }
   }
   class PluginInstance {
       constructor(spec) {
           this.spec = spec;
           // When starting an update, all plugins have this field set to the
           // update object, indicating they need to be updated. When finished
           // updating, it is set to `false`. Retrieving a plugin that needs to
           // be updated with `view.plugin` forces an eager update.
           this.mustUpdate = null;
           // This is null when the plugin is initially created, but
           // initialized on the first update.
           this.value = null;
       }
       update(view) {
           if (!this.value) {
               if (this.spec) {
                   try {
                       this.value = this.spec.create(view);
                   }
                   catch (e) {
                       logException(view.state, e, "CodeMirror plugin crashed");
                       this.deactivate();
                   }
               }
           }
           else if (this.mustUpdate) {
               let update = this.mustUpdate;
               this.mustUpdate = null;
               if (this.value.update) {
                   try {
                       this.value.update(update);
                   }
                   catch (e) {
                       logException(update.state, e, "CodeMirror plugin crashed");
                       if (this.value.destroy)
                           try {
                               this.value.destroy();
                           }
                           catch (_) { }
                       this.deactivate();
                   }
               }
           }
           return this;
       }
       destroy(view) {
           var _a;
           if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
               try {
                   this.value.destroy();
               }
               catch (e) {
                   logException(view.state, e, "CodeMirror plugin crashed");
               }
           }
       }
       deactivate() {
           this.spec = this.value = null;
       }
   }
   const editorAttributes = /*@__PURE__*/Facet.define();
   const contentAttributes = /*@__PURE__*/Facet.define();
   // Provide decorations
   const decorations = /*@__PURE__*/Facet.define();
   const atomicRanges = /*@__PURE__*/Facet.define();
   const bidiIsolatedRanges = /*@__PURE__*/Facet.define();
   function getIsolatedRanges(view, from, to) {
       let isolates = view.state.facet(bidiIsolatedRanges);
       if (!isolates.length)
           return isolates;
       let sets = isolates.map(i => i instanceof Function ? i(view) : i);
       let result = [];
       RangeSet.spans(sets, from, to, {
           point() { },
           span(from, to, active, open) {
               let level = result;
               for (let i = active.length - 1; i >= 0; i--, open--) {
                   let iso = active[i].spec.bidiIsolate, update;
                   if (iso == null)
                       continue;
                   if (open > 0 && level.length &&
                       (update = level[level.length - 1]).to == from && update.direction == iso) {
                       update.to = to;
                       level = update.inner;
                   }
                   else {
                       let add = { from, to, direction: iso, inner: [] };
                       level.push(add);
                       level = add.inner;
                   }
               }
           }
       });
       return result;
   }
   const scrollMargins = /*@__PURE__*/Facet.define();
   function getScrollMargins(view) {
       let left = 0, right = 0, top = 0, bottom = 0;
       for (let source of view.state.facet(scrollMargins)) {
           let m = source(view);
           if (m) {
               if (m.left != null)
                   left = Math.max(left, m.left);
               if (m.right != null)
                   right = Math.max(right, m.right);
               if (m.top != null)
                   top = Math.max(top, m.top);
               if (m.bottom != null)
                   bottom = Math.max(bottom, m.bottom);
           }
       }
       return { left, right, top, bottom };
   }
   const styleModule = /*@__PURE__*/Facet.define();
   class ChangedRange {
       constructor(fromA, toA, fromB, toB) {
           this.fromA = fromA;
           this.toA = toA;
           this.fromB = fromB;
           this.toB = toB;
       }
       join(other) {
           return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
       }
       addToSet(set) {
           let i = set.length, me = this;
           for (; i > 0; i--) {
               let range = set[i - 1];
               if (range.fromA > me.toA)
                   continue;
               if (range.toA < me.fromA)
                   break;
               me = me.join(range);
               set.splice(i - 1, 1);
           }
           set.splice(i, 0, me);
           return set;
       }
       static extendWithRanges(diff, ranges) {
           if (ranges.length == 0)
               return diff;
           let result = [];
           for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
               let next = dI == diff.length ? null : diff[dI], off = posA - posB;
               let end = next ? next.fromB : 1e9;
               while (rI < ranges.length && ranges[rI] < end) {
                   let from = ranges[rI], to = ranges[rI + 1];
                   let fromB = Math.max(posB, from), toB = Math.min(end, to);
                   if (fromB <= toB)
                       new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                   if (to > end)
                       break;
                   else
                       rI += 2;
               }
               if (!next)
                   return result;
               new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
               posA = next.toA;
               posB = next.toB;
           }
       }
   }
   /**
   View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
   class, which describe what happened, whenever the view is updated.
   */
   class ViewUpdate {
       constructor(
       /**
       The editor view that the update is associated with.
       */
       view, 
       /**
       The new editor state.
       */
       state, 
       /**
       The transactions involved in the update. May be empty.
       */
       transactions) {
           this.view = view;
           this.state = state;
           this.transactions = transactions;
           /**
           @internal
           */
           this.flags = 0;
           this.startState = view.state;
           this.changes = ChangeSet.empty(this.startState.doc.length);
           for (let tr of transactions)
               this.changes = this.changes.compose(tr.changes);
           let changedRanges = [];
           this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
           this.changedRanges = changedRanges;
       }
       /**
       @internal
       */
       static create(view, state, transactions) {
           return new ViewUpdate(view, state, transactions);
       }
       /**
       Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
       [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
       update.
       */
       get viewportChanged() {
           return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
       }
       /**
       Indicates whether the height of a block element in the editor
       changed in this update.
       */
       get heightChanged() {
           return (this.flags & 2 /* UpdateFlag.Height */) > 0;
       }
       /**
       Returns true when the document was modified or the size of the
       editor, or elements within the editor, changed.
       */
       get geometryChanged() {
           return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
       }
       /**
       True when this update indicates a focus change.
       */
       get focusChanged() {
           return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
       }
       /**
       Whether the document changed in this update.
       */
       get docChanged() {
           return !this.changes.empty;
       }
       /**
       Whether the selection was explicitly set in this update.
       */
       get selectionSet() {
           return this.transactions.some(tr => tr.selection);
       }
       /**
       @internal
       */
       get empty() { return this.flags == 0 && this.transactions.length == 0; }
   }

   /**
   Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
   */
   var Direction = /*@__PURE__*/(function (Direction) {
       // (These are chosen to match the base levels, in bidi algorithm
       // terms, of spans in that direction.)
       /**
       Left-to-right.
       */
       Direction[Direction["LTR"] = 0] = "LTR";
       /**
       Right-to-left.
       */
       Direction[Direction["RTL"] = 1] = "RTL";
   return Direction})(Direction || (Direction = {}));
   const LTR = Direction.LTR, RTL = Direction.RTL;
   // Decode a string with each type encoded as log2(type)
   function dec(str) {
       let result = [];
       for (let i = 0; i < str.length; i++)
           result.push(1 << +str[i]);
       return result;
   }
   // Character types for codepoints 0 to 0xf8
   const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
   // Character types for codepoints 0x600 to 0x6f9
   const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
   const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];
   // There's a lot more in
   // https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
   // which are left out to keep code size down.
   for (let p of ["()", "[]", "{}"]) {
       let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);
       Brackets[l] = r;
       Brackets[r] = -l;
   }
   function charType(ch) {
       return ch <= 0xf7 ? LowTypes[ch] :
           0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
               0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                   0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                       0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ :
                           0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ :
                               ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;
   }
   const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
   /**
   Represents a contiguous range of text that has a single direction
   (as in left-to-right or right-to-left).
   */
   class BidiSpan {
       /**
       The direction of this span.
       */
       get dir() { return this.level % 2 ? RTL : LTR; }
       /**
       @internal
       */
       constructor(
       /**
       The start of the span (relative to the start of the line).
       */
       from, 
       /**
       The end of the span.
       */
       to, 
       /**
       The ["bidi
       level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
       of the span (in this context, 0 means
       left-to-right, 1 means right-to-left, 2 means left-to-right
       number inside right-to-left text).
       */
       level) {
           this.from = from;
           this.to = to;
           this.level = level;
       }
       /**
       @internal
       */
       side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
       /**
       @internal
       */
       static find(order, index, level, assoc) {
           let maybe = -1;
           for (let i = 0; i < order.length; i++) {
               let span = order[i];
               if (span.from <= index && span.to >= index) {
                   if (span.level == level)
                       return i;
                   // When multiple spans match, if assoc != 0, take the one that
                   // covers that side, otherwise take the one with the minimum
                   // level.
                   if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                       maybe = i;
               }
           }
           if (maybe < 0)
               throw new RangeError("Index out of range");
           return maybe;
       }
   }
   function isolatesEq(a, b) {
       if (a.length != b.length)
           return false;
       for (let i = 0; i < a.length; i++) {
           let iA = a[i], iB = b[i];
           if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
               return false;
       }
       return true;
   }
   // Reused array of character types
   const types = [];
   // Fill in the character types (in `types`) from `from` to `to` and
   // apply W normalization rules.
   function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
       for (let iI = 0; iI <= isolates.length; iI++) {
           let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
           let prevType = iI ? 256 /* T.NI */ : outerType;
           // W1. Examine each non-spacing mark (NSM) in the level run, and
           // change the type of the NSM to the type of the previous
           // character. If the NSM is at the start of the level run, it will
           // get the type of sor.
           // W2. Search backwards from each instance of a European number
           // until the first strong type (R, L, AL, or sor) is found. If an
           // AL is found, change the type of the European number to Arabic
           // number.
           // W3. Change all ALs to R.
           // (Left after this: L, R, EN, AN, ET, CS, NI)
           for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
               let type = charType(line.charCodeAt(i));
               if (type == 512 /* T.NSM */)
                   type = prev;
               else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
                   type = 16 /* T.AN */;
               types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
               if (type & 7 /* T.Strong */)
                   prevStrong = type;
               prev = type;
           }
           // W5. A sequence of European terminators adjacent to European
           // numbers changes to all European numbers.
           // W6. Otherwise, separators and terminators change to Other
           // Neutral.
           // W7. Search backwards from each instance of a European number
           // until the first strong type (R, L, or sor) is found. If an L is
           // found, then change the type of the European number to L.
           // (Left after this: L, R, EN+AN, NI)
           for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
               let type = types[i];
               if (type == 128 /* T.CS */) {
                   if (i < to - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))
                       type = types[i] = prev;
                   else
                       types[i] = 256 /* T.NI */;
               }
               else if (type == 64 /* T.ET */) {
                   let end = i + 1;
                   while (end < to && types[end] == 64 /* T.ET */)
                       end++;
                   let replace = (i && prev == 8 /* T.EN */) || (end < rTo && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
                   for (let j = i; j < end; j++)
                       types[j] = replace;
                   i = end - 1;
               }
               else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
                   types[i] = 1 /* T.L */;
               }
               prev = type;
               if (type & 7 /* T.Strong */)
                   prevStrong = type;
           }
       }
   }
   // Process brackets throughout a run sequence.
   function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
       let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
       for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
           let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
           // N0. Process bracket pairs in an isolating run sequence
           // sequentially in the logical order of the text positions of the
           // opening paired brackets using the logic given below. Within this
           // scope, bidirectional types EN and AN are treated as R.
           for (let i = from, ch, br, type; i < to; i++) {
               // Keeps [startIndex, type, strongSeen] triples for each open
               // bracket on BracketStack.
               if (br = Brackets[ch = line.charCodeAt(i)]) {
                   if (br < 0) { // Closing bracket
                       for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                           if (BracketStack[sJ + 1] == -br) {
                               let flags = BracketStack[sJ + 2];
                               let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                                   !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                       (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                               if (type)
                                   types[i] = types[BracketStack[sJ]] = type;
                               sI = sJ;
                               break;
                           }
                       }
                   }
                   else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                       break;
                   }
                   else {
                       BracketStack[sI++] = i;
                       BracketStack[sI++] = ch;
                       BracketStack[sI++] = context;
                   }
               }
               else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
                   let embed = type == outerType;
                   context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
                   for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                       let cur = BracketStack[sJ + 2];
                       if (cur & 2 /* Bracketed.EmbedInside */)
                           break;
                       if (embed) {
                           BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                       }
                       else {
                           if (cur & 4 /* Bracketed.OppositeInside */)
                               break;
                           BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                       }
                   }
               }
           }
       }
   }
   function processNeutrals(rFrom, rTo, isolates, outerType) {
       for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
           let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
           // N1. A sequence of neutrals takes the direction of the
           // surrounding strong text if the text on both sides has the same
           // direction. European and Arabic numbers act as if they were R in
           // terms of their influence on neutrals. Start-of-level-run (sor)
           // and end-of-level-run (eor) are used at level run boundaries.
           // N2. Any remaining neutrals take the embedding direction.
           // (Left after this: L, R, EN+AN)
           for (let i = from; i < to;) {
               let type = types[i];
               if (type == 256 /* T.NI */) {
                   let end = i + 1;
                   for (;;) {
                       if (end == to) {
                           if (iI == isolates.length)
                               break;
                           end = isolates[iI++].to;
                           to = iI < isolates.length ? isolates[iI].from : rTo;
                       }
                       else if (types[end] == 256 /* T.NI */) {
                           end++;
                       }
                       else {
                           break;
                       }
                   }
                   let beforeL = prev == 1 /* T.L */;
                   let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;
                   let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
                   for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                       if (j == fromJ) {
                           j = isolates[--jI].from;
                           fromJ = jI ? isolates[jI - 1].to : rFrom;
                       }
                       types[--j] = replace;
                   }
                   i = end;
               }
               else {
                   prev = type;
                   i++;
               }
           }
       }
   }
   // Find the contiguous ranges of character types in a given range, and
   // emit spans for them. Flip the order of the spans as appropriate
   // based on the level, and call through to compute the spans for
   // isolates at the proper point.
   function emitSpans(line, from, to, level, baseLevel, isolates, order) {
       let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
       if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip
           for (let iCh = from, iI = 0; iCh < to;) {
               // Scan a section of characters in direction ourType, unless
               // there's another type of char right after iCh, in which case
               // we scan a section of other characters (which, if ourType ==
               // T.L, may contain both T.R and T.AN chars).
               let sameDir = true, isNum = false;
               if (iI == isolates.length || iCh < isolates[iI].from) {
                   let next = types[iCh];
                   if (next != ourType) {
                       sameDir = false;
                       isNum = next == 16 /* T.AN */;
                   }
               }
               // Holds an array of isolates to pass to a recursive call if we
               // must recurse (to distinguish T.AN inside an RTL section in
               // LTR text), null if we can emit directly
               let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
               let localLevel = sameDir ? level : level + 1;
               let iScan = iCh;
               run: for (;;) {
                   if (iI < isolates.length && iScan == isolates[iI].from) {
                       if (isNum)
                           break run;
                       let iso = isolates[iI];
                       // Scan ahead to verify that there is another char in this dir after the isolate(s)
                       if (!sameDir)
                           for (let upto = iso.to, jI = iI + 1;;) {
                               if (upto == to)
                                   break run;
                               if (jI < isolates.length && isolates[jI].from == upto)
                                   upto = isolates[jI++].to;
                               else if (types[upto] == ourType)
                                   break run;
                               else
                                   break;
                           }
                       iI++;
                       if (recurse) {
                           recurse.push(iso);
                       }
                       else {
                           if (iso.from > iCh)
                               order.push(new BidiSpan(iCh, iso.from, localLevel));
                           let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                           computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                           iCh = iso.to;
                       }
                       iScan = iso.to;
                   }
                   else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                       break;
                   }
                   else {
                       iScan++;
                   }
               }
               if (recurse)
                   emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
               else if (iCh < iScan)
                   order.push(new BidiSpan(iCh, iScan, localLevel));
               iCh = iScan;
           }
       }
       else {
           // Iterate in reverse to flip the span order. Same code again, but
           // going from the back of the section to the front
           for (let iCh = to, iI = isolates.length; iCh > from;) {
               let sameDir = true, isNum = false;
               if (!iI || iCh > isolates[iI - 1].to) {
                   let next = types[iCh - 1];
                   if (next != ourType) {
                       sameDir = false;
                       isNum = next == 16 /* T.AN */;
                   }
               }
               let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
               let localLevel = sameDir ? level : level + 1;
               let iScan = iCh;
               run: for (;;) {
                   if (iI && iScan == isolates[iI - 1].to) {
                       if (isNum)
                           break run;
                       let iso = isolates[--iI];
                       // Scan ahead to verify that there is another char in this dir after the isolate(s)
                       if (!sameDir)
                           for (let upto = iso.from, jI = iI;;) {
                               if (upto == from)
                                   break run;
                               if (jI && isolates[jI - 1].to == upto)
                                   upto = isolates[--jI].from;
                               else if (types[upto - 1] == ourType)
                                   break run;
                               else
                                   break;
                           }
                       if (recurse) {
                           recurse.push(iso);
                       }
                       else {
                           if (iso.to < iCh)
                               order.push(new BidiSpan(iso.to, iCh, localLevel));
                           let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                           computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                           iCh = iso.from;
                       }
                       iScan = iso.from;
                   }
                   else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                       break;
                   }
                   else {
                       iScan--;
                   }
               }
               if (recurse)
                   emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
               else if (iScan < iCh)
                   order.push(new BidiSpan(iScan, iCh, localLevel));
               iCh = iScan;
           }
       }
   }
   function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
       let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);
       computeCharTypes(line, from, to, isolates, outerType);
       processBracketPairs(line, from, to, isolates, outerType);
       processNeutrals(from, to, isolates, outerType);
       emitSpans(line, from, to, level, baseLevel, isolates, order);
   }
   function computeOrder(line, direction, isolates) {
       if (!line)
           return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
       if (direction == LTR && !isolates.length && !BidiRE.test(line))
           return trivialOrder(line.length);
       if (isolates.length)
           while (line.length > types.length)
               types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps
       let order = [], level = direction == LTR ? 0 : 1;
       computeSectionOrder(line, level, level, isolates, 0, line.length, order);
       return order;
   }
   function trivialOrder(length) {
       return [new BidiSpan(0, length, 0)];
   }
   let movedOver = "";
   function moveVisually(line, order, dir, start, forward) {
       var _a;
       let startIndex = start.head - line.from, spanI = -1;
       if (startIndex == 0) {
           if (!forward || !line.length)
               return null;
           if (order[0].level != dir) {
               startIndex = order[0].side(false, dir);
               spanI = 0;
           }
       }
       else if (startIndex == line.length) {
           if (forward)
               return null;
           let last = order[order.length - 1];
           if (last.level != dir) {
               startIndex = last.side(true, dir);
               spanI = order.length - 1;
           }
       }
       if (spanI < 0)
           spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
       let span = order[spanI];
       // End of span. (But not end of line--that was checked for above.)
       if (startIndex == span.side(forward, dir)) {
           span = order[spanI += forward ? 1 : -1];
           startIndex = span.side(!forward, dir);
       }
       let indexForward = forward == (span.dir == dir);
       let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
       movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
       if (nextIndex != span.side(forward, dir))
           return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
       let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
       if (!nextSpan && span.level != dir)
           return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
       if (nextSpan && nextSpan.level < span.level)
           return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
       return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
   }

   class DocView extends ContentView {
       get length() { return this.view.state.doc.length; }
       constructor(view) {
           super();
           this.view = view;
           this.decorations = [];
           this.dynamicDecorationMap = [];
           this.hasComposition = null;
           this.markedForComposition = new Set;
           // Track a minimum width for the editor. When measuring sizes in
           // measureVisibleLineHeights, this is updated to point at the width
           // of a given element and its extent in the document. When a change
           // happens in that range, these are reset. That way, once we've seen
           // a line/element of a given length, we keep the editor wide enough
           // to fit at least that element, until it is changed, at which point
           // we forget it again.
           this.minWidth = 0;
           this.minWidthFrom = 0;
           this.minWidthTo = 0;
           // Track whether the DOM selection was set in a lossy way, so that
           // we don't mess it up when reading it back it
           this.impreciseAnchor = null;
           this.impreciseHead = null;
           this.forceSelection = false;
           // Used by the resize observer to ignore resizes that we caused
           // ourselves
           this.lastUpdate = Date.now();
           this.setDOM(view.contentDOM);
           this.children = [new LineView];
           this.children[0].setParent(this);
           this.updateDeco();
           this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
       }
       // Update the document view to a given state.
       update(update) {
           let changedRanges = update.changedRanges;
           if (this.minWidth > 0 && changedRanges.length) {
               if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                   this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
               }
               else {
                   this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                   this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
               }
           }
           let composition = this.view.inputState.composing < 0 ? null : findCompositionRange(this.view, update.changes);
           if (this.hasComposition) {
               this.markedForComposition.clear();
               let { from, to } = this.hasComposition;
               changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                   .addToSet(changedRanges.slice());
           }
           this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
           // When the DOM nodes around the selection are moved to another
           // parent, Chrome sometimes reports a different selection through
           // getSelection than the one that it actually shows to the user.
           // This forces a selection update when lines are joined to work
           // around that. Issue #54
           if ((browser.ie || browser.chrome) && !composition && update &&
               update.state.doc.lines != update.startState.doc.lines)
               this.forceSelection = true;
           let prevDeco = this.decorations, deco = this.updateDeco();
           let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
           changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
           if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
               return false;
           }
           else {
               this.updateInner(changedRanges, update.startState.doc.length, composition);
               if (update.transactions.length)
                   this.lastUpdate = Date.now();
               return true;
           }
       }
       // Used by update and the constructor do perform the actual DOM
       // update
       updateInner(changes, oldLength, composition) {
           this.view.viewState.mustMeasureContent = true;
           this.updateChildren(changes, oldLength, composition);
           let { observer } = this.view;
           observer.ignore(() => {
               // Lock the height during redrawing, since Chrome sometimes
               // messes with the scroll position during DOM mutation (though
               // no relayout is triggered and I cannot imagine how it can
               // recompute the scroll position without a layout)
               this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
               this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
               // Chrome will sometimes, when DOM mutations occur directly
               // around the selection, get confused and report a different
               // selection from the one it displays (issue #218). This tries
               // to detect that situation.
               let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
               this.sync(this.view, track);
               this.flags &= ~7 /* ViewFlag.Dirty */;
               if (track && (track.written || observer.selectionRange.focusNode != track.node))
                   this.forceSelection = true;
               this.dom.style.height = "";
           });
           this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);
           let gaps = [];
           if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
               for (let child of this.children)
                   if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                       gaps.push(child.dom);
           observer.updateGaps(gaps);
       }
       updateChildren(changes, oldLength, composition) {
           let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
           let cursor = this.childCursor(oldLength);
           for (let i = ranges.length - 1;; i--) {
               let next = i >= 0 ? ranges[i] : null;
               if (!next)
                   break;
               let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
               if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                   let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                   let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                   breakAtStart = before.breakAtStart;
                   openStart = before.openStart;
                   openEnd = after.openEnd;
                   let compLine = this.compositionView(composition);
                   if (after.breakAtStart) {
                       compLine.breakAfter = 1;
                   }
                   else if (after.content.length &&
                       compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                       compLine.breakAfter = after.content[0].breakAfter;
                       after.content.shift();
                   }
                   if (before.content.length &&
                       compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                       before.content.pop();
                   }
                   content = before.content.concat(compLine).concat(after.content);
               }
               else {
                   ({ content, breakAtStart, openStart, openEnd } =
                       ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
               }
               let { i: toI, off: toOff } = cursor.findPos(toA, 1);
               let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
               replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
           }
           if (composition)
               this.fixCompositionDOM(composition);
       }
       compositionView(composition) {
           let cur = new TextView(composition.text.nodeValue);
           cur.flags |= 8 /* ViewFlag.Composition */;
           for (let { deco } of composition.marks)
               cur = new MarkView(deco, [cur], cur.length);
           let line = new LineView;
           line.append(cur, 0);
           return line;
       }
       fixCompositionDOM(composition) {
           let fix = (dom, cView) => {
               cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
               this.markedForComposition.add(cView);
               let prev = ContentView.get(dom);
               if (prev != cView) {
                   if (prev)
                       prev.dom = null;
                   cView.setDOM(dom);
               }
           };
           let pos = this.childPos(composition.range.fromB, 1);
           let cView = this.children[pos.i];
           fix(composition.line, cView);
           for (let i = composition.marks.length - 1; i >= -1; i--) {
               pos = cView.childPos(pos.off, 1);
               cView = cView.children[pos.i];
               fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
           }
       }
       // Sync the DOM selection to this.state.selection
       updateSelection(mustRead = false, fromPointer = false) {
           if (mustRead || !this.view.observer.selectionRange.focusNode)
               this.view.observer.readSelectionRange();
           let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
           let selectionNotFocus = !focused &&
               hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
           if (!(focused || fromPointer || selectionNotFocus))
               return;
           let force = this.forceSelection;
           this.forceSelection = false;
           let main = this.view.state.selection.main;
           // FIXME need to handle the case where the selection falls inside a block range
           let anchor = this.domAtPos(main.anchor);
           let head = main.empty ? anchor : this.domAtPos(main.head);
           // Always reset on Firefox when next to an uneditable node to
           // avoid invisible cursor bugs (#111)
           if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
               let dummy = document.createTextNode("");
               this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
               anchor = head = new DOMPos(dummy, 0);
               force = true;
           }
           let domSel = this.view.observer.selectionRange;
           // If the selection is already here, or in an equivalent position, don't touch it
           if (force || !domSel.focusNode ||
               !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
               !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
               this.view.observer.ignore(() => {
                   // Chrome Android will hide the virtual keyboard when tapping
                   // inside an uneditable node, and not bring it back when we
                   // move the cursor to its proper position. This tries to
                   // restore the keyboard by cycling focus.
                   if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                       inUneditable(domSel.focusNode, this.dom)) {
                       this.dom.blur();
                       this.dom.focus({ preventScroll: true });
                   }
                   let rawSel = getSelection(this.view.root);
                   if (!rawSel) ;
                   else if (main.empty) {
                       // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                       if (browser.gecko) {
                           let nextTo = nextToUneditable(anchor.node, anchor.offset);
                           if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                               let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);
                               if (text)
                                   anchor = new DOMPos(text, nextTo == 1 /* NextTo.Before */ ? 0 : text.nodeValue.length);
                           }
                       }
                       rawSel.collapse(anchor.node, anchor.offset);
                       if (main.bidiLevel != null && domSel.caretBidiLevel != null)
                           domSel.caretBidiLevel = main.bidiLevel;
                   }
                   else if (rawSel.extend) {
                       // Selection.extend can be used to create an 'inverted' selection
                       // (one where the focus is before the anchor), but not all
                       // browsers support it yet.
                       rawSel.collapse(anchor.node, anchor.offset);
                       // Safari will ignore the call above when the editor is
                       // hidden, and then raise an error on the call to extend
                       // (#940).
                       try {
                           rawSel.extend(head.node, head.offset);
                       }
                       catch (_) { }
                   }
                   else {
                       // Primitive (IE) way
                       let range = document.createRange();
                       if (main.anchor > main.head)
                           [anchor, head] = [head, anchor];
                       range.setEnd(head.node, head.offset);
                       range.setStart(anchor.node, anchor.offset);
                       rawSel.removeAllRanges();
                       rawSel.addRange(range);
                   }
                   if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                       this.dom.blur();
                       if (activeElt)
                           activeElt.focus();
                   }
               });
               this.view.observer.setSelectionRange(anchor, head);
           }
           this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
           this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
       }
       enforceCursorAssoc() {
           if (this.hasComposition)
               return;
           let { view } = this, cursor = view.state.selection.main;
           let sel = getSelection(view.root);
           let { anchorNode, anchorOffset } = view.observer.selectionRange;
           if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
               return;
           let line = LineView.find(this, cursor.head);
           if (!line)
               return;
           let lineStart = line.posAtStart;
           if (cursor.head == lineStart || cursor.head == lineStart + line.length)
               return;
           let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
           if (!before || !after || before.bottom > after.top)
               return;
           let dom = this.domAtPos(cursor.head + cursor.assoc);
           sel.collapse(dom.node, dom.offset);
           sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
           // This can go wrong in corner cases like single-character lines,
           // so check and reset if necessary.
           view.observer.readSelectionRange();
           let newRange = view.observer.selectionRange;
           if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
               sel.collapse(anchorNode, anchorOffset);
       }
       nearest(dom) {
           for (let cur = dom; cur;) {
               let domView = ContentView.get(cur);
               if (domView && domView.rootView == this)
                   return domView;
               cur = cur.parentNode;
           }
           return null;
       }
       posFromDOM(node, offset) {
           let view = this.nearest(node);
           if (!view)
               throw new RangeError("Trying to find position for a DOM position outside of the document");
           return view.localPosFromDOM(node, offset) + view.posAtStart;
       }
       domAtPos(pos) {
           let { i, off } = this.childCursor().findPos(pos, -1);
           for (; i < this.children.length - 1;) {
               let child = this.children[i];
               if (off < child.length || child instanceof LineView)
                   break;
               i++;
               off = 0;
           }
           return this.children[i].domAtPos(off);
       }
       coordsAt(pos, side) {
           for (let off = this.length, i = this.children.length - 1;; i--) {
               let child = this.children[i], start = off - child.breakAfter - child.length;
               if (pos > start ||
                   (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter &&
                       (!i || side == 2 || this.children[i - 1].breakAfter ||
                           (this.children[i - 1].type == BlockType.WidgetBefore && side > -2))))
                   return child.coordsAt(pos - start, side);
               off = start;
           }
       }
       coordsForChar(pos) {
           let { i, off } = this.childPos(pos, 1), child = this.children[i];
           if (!(child instanceof LineView))
               return null;
           while (child.children.length) {
               let { i, off: childOff } = child.childPos(off, 1);
               for (;; i++) {
                   if (i == child.children.length)
                       return null;
                   if ((child = child.children[i]).length)
                       break;
               }
               off = childOff;
           }
           if (!(child instanceof TextView))
               return null;
           let end = findClusterBreak(child.text, off);
           if (end == off)
               return null;
           let rects = textRange(child.dom, off, end).getClientRects();
           return !rects.length || rects[0].top >= rects[0].bottom ? null : rects[0];
       }
       measureVisibleLineHeights(viewport) {
           let result = [], { from, to } = viewport;
           let contentWidth = this.view.contentDOM.clientWidth;
           let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
           let widest = -1, ltr = this.view.textDirection == Direction.LTR;
           for (let pos = 0, i = 0; i < this.children.length; i++) {
               let child = this.children[i], end = pos + child.length;
               if (end > to)
                   break;
               if (pos >= from) {
                   let childRect = child.dom.getBoundingClientRect();
                   result.push(childRect.height);
                   if (isWider) {
                       let last = child.dom.lastChild;
                       let rects = last ? clientRectsFor(last) : [];
                       if (rects.length) {
                           let rect = rects[rects.length - 1];
                           let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                           if (width > widest) {
                               widest = width;
                               this.minWidth = contentWidth;
                               this.minWidthFrom = pos;
                               this.minWidthTo = end;
                           }
                       }
                   }
               }
               pos = end + child.breakAfter;
           }
           return result;
       }
       textDirectionAt(pos) {
           let { i } = this.childPos(pos, 1);
           return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
       }
       measureTextSize() {
           for (let child of this.children) {
               if (child instanceof LineView) {
                   let measure = child.measureTextSize();
                   if (measure)
                       return measure;
               }
           }
           // If no workable line exists, force a layout of a measurable element
           let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
           dummy.className = "cm-line";
           dummy.style.width = "99999px";
           dummy.style.position = "absolute";
           dummy.textContent = "abc def ghi jkl mno pqr stu";
           this.view.observer.ignore(() => {
               this.dom.appendChild(dummy);
               let rect = clientRectsFor(dummy.firstChild)[0];
               lineHeight = dummy.getBoundingClientRect().height;
               charWidth = rect ? rect.width / 27 : 7;
               textHeight = rect ? rect.height : lineHeight;
               dummy.remove();
           });
           return { lineHeight, charWidth, textHeight };
       }
       childCursor(pos = this.length) {
           // Move back to start of last element when possible, so that
           // `ChildCursor.findPos` doesn't have to deal with the edge case
           // of being after the last element.
           let i = this.children.length;
           if (i)
               pos -= this.children[--i].length;
           return new ChildCursor(this.children, pos, i);
       }
       computeBlockGapDeco() {
           let deco = [], vs = this.view.viewState;
           for (let pos = 0, i = 0;; i++) {
               let next = i == vs.viewports.length ? null : vs.viewports[i];
               let end = next ? next.from - 1 : this.length;
               if (end > pos) {
                   let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                   deco.push(Decoration.replace({
                       widget: new BlockGapWidget(height),
                       block: true,
                       inclusive: true,
                       isBlockGap: true,
                   }).range(pos, end));
               }
               if (!next)
                   break;
               pos = next.to + 1;
           }
           return Decoration.set(deco);
       }
       updateDeco() {
           let allDeco = this.view.state.facet(decorations).map((d, i) => {
               let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
               return dynamic ? d(this.view) : d;
           });
           for (let i = allDeco.length; i < allDeco.length + 3; i++)
               this.dynamicDecorationMap[i] = false;
           return this.decorations = [
               ...allDeco,
               this.computeBlockGapDeco(),
               this.view.viewState.lineGapDeco
           ];
       }
       scrollIntoView(target) {
           let { range } = target;
           let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
           if (!rect)
               return;
           if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
               rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                   right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
           let margins = getScrollMargins(this.view);
           let targetRect = {
               left: rect.left - margins.left, top: rect.top - margins.top,
               right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
           };
           scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
       }
   }
   function betweenUneditable(pos) {
       return pos.node.nodeType == 1 && pos.node.firstChild &&
           (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
           (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
   }
   class BlockGapWidget extends WidgetType {
       constructor(height) {
           super();
           this.height = height;
       }
       toDOM() {
           let elt = document.createElement("div");
           this.updateDOM(elt);
           return elt;
       }
       eq(other) { return other.height == this.height; }
       updateDOM(elt) {
           elt.style.height = this.height + "px";
           return true;
       }
       get estimatedHeight() { return this.height; }
   }
   function findCompositionNode(view, dLen) {
       let sel = view.observer.selectionRange;
       let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
       if (!textNode)
           return null;
       let cView = ContentView.get(textNode);
       let from, to;
       if (cView instanceof TextView) {
           from = cView.posAtStart;
           to = from + cView.length;
       }
       else {
           let oldLen = Math.max(0, textNode.nodeValue.length - dLen);
           up: for (let offset = 0, node = textNode;;) {
               for (let sibling = node.previousSibling, cView; sibling; sibling = sibling.previousSibling) {
                   if (cView = ContentView.get(sibling)) {
                       to = cView.posAtEnd + offset;
                       from = Math.max(0, to - oldLen);
                       break up;
                   }
                   let reader = new DOMReader([], view.state);
                   reader.readNode(sibling);
                   if (reader.text.indexOf(LineBreakPlaceholder) > -1)
                       return null;
                   offset += reader.text.length;
               }
               node = node.parentNode;
               if (!node)
                   return null;
               let parentView = ContentView.get(node);
               if (parentView) {
                   from = parentView.posAtStart + offset;
                   to = from + oldLen;
                   break;
               }
           }
       }
       return { from, to: to, node: textNode };
   }
   function findCompositionRange(view, changes) {
       let found = findCompositionNode(view, changes.newLength - changes.length);
       if (!found)
           return null;
       let { from: fromA, to: toA, node: textNode } = found;
       let fromB = changes.mapPos(fromA, -1), toB = changes.mapPos(toA, 1);
       let text = textNode.nodeValue;
       // Don't try to preserve multi-line compositions
       if (/[\n\r]/.test(text))
           return null;
       if (toB - fromB != text.length) {
           // If there is a length mismatch, see if mapping non-inclusively helps
           let fromB2 = changes.mapPos(fromA, 1), toB2 = changes.mapPos(toA, -1);
           if (toB2 - fromB2 == text.length)
               fromB = fromB2, toB = toB2;
           // See if we can find an instance of the text at either side
           else if (view.state.doc.sliceString(toB - text.length, toB) == text)
               fromB = toB - text.length;
           else if (view.state.doc.sliceString(fromB, fromB + text.length) == text)
               toB = fromB + text.length;
           // Not found
           else
               return null;
       }
       let { main } = view.state.selection;
       if (view.state.doc.sliceString(fromB, toB) != text || fromB > main.head || toB < main.head)
           return null;
       let marks = [];
       let range = new ChangedRange(fromA, toA, fromB, toB);
       for (let parent = textNode.parentNode;; parent = parent.parentNode) {
           let parentView = ContentView.get(parent);
           if (parentView instanceof MarkView)
               marks.push({ node: parent, deco: parentView.mark });
           else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
               return { range, text: textNode, marks, line: parent };
           else if (parent != view.contentDOM)
               marks.push({ node: parent, deco: new MarkDecoration({
                       inclusive: true,
                       attributes: getAttrs(parent),
                       tagName: parent.tagName.toLowerCase()
                   }) });
           else
               return null;
       }
   }
   function nearbyTextNode(startNode, startOffset, side) {
       if (side <= 0)
           for (let node = startNode, offset = startOffset;;) {
               if (node.nodeType == 3)
                   return node;
               if (node.nodeType == 1 && offset > 0) {
                   node = node.childNodes[offset - 1];
                   offset = maxOffset(node);
               }
               else {
                   break;
               }
           }
       if (side >= 0)
           for (let node = startNode, offset = startOffset;;) {
               if (node.nodeType == 3)
                   return node;
               if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
                   node = node.childNodes[offset];
                   offset = 0;
               }
               else {
                   break;
               }
           }
       return null;
   }
   function nextToUneditable(node, offset) {
       if (node.nodeType != 1)
           return 0;
       return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
           (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
   }
   let DecorationComparator$1 = class DecorationComparator {
       constructor() {
           this.changes = [];
       }
       compareRange(from, to) { addRange(from, to, this.changes); }
       comparePoint(from, to) { addRange(from, to, this.changes); }
   };
   function findChangedDeco(a, b, diff) {
       let comp = new DecorationComparator$1;
       RangeSet.compare(a, b, diff, comp);
       return comp.changes;
   }
   function inUneditable(node, inside) {
       for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
           if (cur.nodeType == 1 && cur.contentEditable == 'false') {
               return true;
           }
       }
       return false;
   }

   function groupAt(state, pos, bias = 1) {
       let categorize = state.charCategorizer(pos);
       let line = state.doc.lineAt(pos), linePos = pos - line.from;
       if (line.length == 0)
           return EditorSelection.cursor(pos);
       if (linePos == 0)
           bias = 1;
       else if (linePos == line.length)
           bias = -1;
       let from = linePos, to = linePos;
       if (bias < 0)
           from = findClusterBreak(line.text, linePos, false);
       else
           to = findClusterBreak(line.text, linePos);
       let cat = categorize(line.text.slice(from, to));
       while (from > 0) {
           let prev = findClusterBreak(line.text, from, false);
           if (categorize(line.text.slice(prev, from)) != cat)
               break;
           from = prev;
       }
       while (to < line.length) {
           let next = findClusterBreak(line.text, to);
           if (categorize(line.text.slice(to, next)) != cat)
               break;
           to = next;
       }
       return EditorSelection.range(from + line.from, to + line.from);
   }
   // Search the DOM for the {node, offset} position closest to the given
   // coordinates. Very inefficient and crude, but can usually be avoided
   // by calling caret(Position|Range)FromPoint instead.
   function getdx(x, rect) {
       return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
   }
   function getdy(y, rect) {
       return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
   }
   function yOverlap(a, b) {
       return a.top < b.bottom - 1 && a.bottom > b.top + 1;
   }
   function upTop(rect, top) {
       return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
   }
   function upBot(rect, bottom) {
       return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
   }
   function domPosAtCoords(parent, x, y) {
       let closest, closestRect, closestX, closestY, closestOverlap = false;
       let above, below, aboveRect, belowRect;
       for (let child = parent.firstChild; child; child = child.nextSibling) {
           let rects = clientRectsFor(child);
           for (let i = 0; i < rects.length; i++) {
               let rect = rects[i];
               if (closestRect && yOverlap(closestRect, rect))
                   rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
               let dx = getdx(x, rect), dy = getdy(y, rect);
               if (dx == 0 && dy == 0)
                   return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
               if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                   closest = child;
                   closestRect = rect;
                   closestX = dx;
                   closestY = dy;
                   let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;
                   closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
               }
               if (dx == 0) {
                   if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                       above = child;
                       aboveRect = rect;
                   }
                   else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                       below = child;
                       belowRect = rect;
                   }
               }
               else if (aboveRect && yOverlap(aboveRect, rect)) {
                   aboveRect = upBot(aboveRect, rect.bottom);
               }
               else if (belowRect && yOverlap(belowRect, rect)) {
                   belowRect = upTop(belowRect, rect.top);
               }
           }
       }
       if (aboveRect && aboveRect.bottom >= y) {
           closest = above;
           closestRect = aboveRect;
       }
       else if (belowRect && belowRect.top <= y) {
           closest = below;
           closestRect = belowRect;
       }
       if (!closest)
           return { node: parent, offset: 0 };
       let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
       if (closest.nodeType == 3)
           return domPosInText(closest, clipX, y);
       if (closestOverlap && closest.contentEditable != "false")
           return domPosAtCoords(closest, clipX, y);
       let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
           (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
       return { node: parent, offset };
   }
   function domPosInText(node, x, y) {
       let len = node.nodeValue.length;
       let closestOffset = -1, closestDY = 1e9, generalSide = 0;
       for (let i = 0; i < len; i++) {
           let rects = textRange(node, i, i + 1).getClientRects();
           for (let j = 0; j < rects.length; j++) {
               let rect = rects[j];
               if (rect.top == rect.bottom)
                   continue;
               if (!generalSide)
                   generalSide = x - rect.left;
               let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
               if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                   let right = x >= (rect.left + rect.right) / 2, after = right;
                   if (browser.chrome || browser.gecko) {
                       // Check for RTL on browsers that support getting client
                       // rects for empty ranges.
                       let rectBefore = textRange(node, i).getBoundingClientRect();
                       if (rectBefore.left == rect.right)
                           after = !right;
                   }
                   if (dy <= 0)
                       return { node, offset: i + (after ? 1 : 0) };
                   closestOffset = i + (after ? 1 : 0);
                   closestDY = dy;
               }
           }
       }
       return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
   }
   function posAtCoords(view, coords, precise, bias = -1) {
       var _a, _b;
       let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
       let block, { docHeight } = view.viewState;
       let { x, y } = coords, yOffset = y - docTop;
       if (yOffset < 0)
           return 0;
       if (yOffset > docHeight)
           return view.state.doc.length;
       // Scan for a text block near the queried y position
       for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
           block = view.elementAtHeight(yOffset);
           if (block.type == BlockType.Text)
               break;
           for (;;) {
               // Move the y position out of this block
               yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
               if (yOffset >= 0 && yOffset <= docHeight)
                   break;
               // If the document consists entirely of replaced widgets, we
               // won't find a text block, so return 0
               if (bounced)
                   return precise ? null : 0;
               bounced = true;
               bias = -bias;
           }
       }
       y = docTop + yOffset;
       let lineStart = block.from;
       // If this is outside of the rendered viewport, we can't determine a position
       if (lineStart < view.viewport.from)
           return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
       if (lineStart > view.viewport.to)
           return view.viewport.to == view.state.doc.length ? view.state.doc.length :
               precise ? null : posAtCoordsImprecise(view, content, block, x, y);
       // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
       let doc = view.dom.ownerDocument;
       let root = view.root.elementFromPoint ? view.root : doc;
       let element = root.elementFromPoint(x, y);
       if (element && !view.contentDOM.contains(element))
           element = null;
       // If the element is unexpected, clip x at the sides of the content area and try again
       if (!element) {
           x = Math.max(content.left + 1, Math.min(content.right - 1, x));
           element = root.elementFromPoint(x, y);
           if (element && !view.contentDOM.contains(element))
               element = null;
       }
       // There's visible editor content under the point, so we can try
       // using caret(Position|Range)FromPoint as a shortcut
       let node, offset = -1;
       if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
           if (doc.caretPositionFromPoint) {
               let pos = doc.caretPositionFromPoint(x, y);
               if (pos)
                   ({ offsetNode: node, offset } = pos);
           }
           else if (doc.caretRangeFromPoint) {
               let range = doc.caretRangeFromPoint(x, y);
               if (range) {
                   ({ startContainer: node, startOffset: offset } = range);
                   if (!view.contentDOM.contains(node) ||
                       browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                       browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                       node = undefined;
               }
           }
       }
       // No luck, do our own (potentially expensive) search
       if (!node || !view.docView.dom.contains(node)) {
           let line = LineView.find(view.docView, lineStart);
           if (!line)
               return yOffset > block.top + block.height / 2 ? block.to : block.from;
           ({ node, offset } = domPosAtCoords(line.dom, x, y));
       }
       let nearest = view.docView.nearest(node);
       if (!nearest)
           return null;
       if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
           let rect = nearest.dom.getBoundingClientRect();
           return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
               ? nearest.posAtStart : nearest.posAtEnd;
       }
       else {
           return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
       }
   }
   function posAtCoordsImprecise(view, contentRect, block, x, y) {
       let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
       if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
           let textHeight = view.viewState.heightOracle.textHeight;
           let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
           into += line * view.viewState.heightOracle.lineLength;
       }
       let content = view.state.sliceDoc(block.from, block.to);
       return block.from + findColumn(content, into, view.state.tabSize);
   }
   // In case of a high line height, Safari's caretRangeFromPoint treats
   // the space between lines as belonging to the last character of the
   // line before. This is used to detect such a result so that it can be
   // ignored (issue #401).
   function isSuspiciousSafariCaretResult(node, offset, x) {
       let len;
       if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
           return false;
       for (let next = node.nextSibling; next; next = next.nextSibling)
           if (next.nodeType != 1 || next.nodeName != "BR")
               return false;
       return textRange(node, len - 1, len).getBoundingClientRect().left > x;
   }
   // Chrome will move positions between lines to the start of the next line
   function isSuspiciousChromeCaretResult(node, offset, x) {
       if (offset != 0)
           return false;
       for (let cur = node;;) {
           let parent = cur.parentNode;
           if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
               return false;
           if (parent.classList.contains("cm-line"))
               break;
           cur = parent;
       }
       let rect = node.nodeType == 1 ? node.getBoundingClientRect()
           : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
       return x - rect.left > 5;
   }
   function blockAt(view, pos) {
       let line = view.lineBlockAt(pos);
       if (Array.isArray(line.type))
           for (let l of line.type) {
               if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                   return l;
           }
       return line;
   }
   function moveToLineBoundary(view, start, forward, includeWrap) {
       let line = blockAt(view, start.head);
       let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
           : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
       if (coords) {
           let editorRect = view.dom.getBoundingClientRect();
           let direction = view.textDirectionAt(line.from);
           let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
               y: (coords.top + coords.bottom) / 2 });
           if (pos != null)
               return EditorSelection.cursor(pos, forward ? -1 : 1);
       }
       return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
   }
   function moveByChar(view, start, forward, by) {
       let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
       let direction = view.textDirectionAt(line.from);
       for (let cur = start, check = null;;) {
           let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
           if (!next) {
               if (line.number == (forward ? view.state.doc.lines : 1))
                   return cur;
               char = "\n";
               line = view.state.doc.line(line.number + (forward ? 1 : -1));
               spans = view.bidiSpans(line);
               next = EditorSelection.cursor(forward ? line.from : line.to);
           }
           if (!check) {
               if (!by)
                   return next;
               check = by(char);
           }
           else if (!check(char)) {
               return cur;
           }
           cur = next;
       }
   }
   function byGroup(view, pos, start) {
       let categorize = view.state.charCategorizer(pos);
       let cat = categorize(start);
       return (next) => {
           let nextCat = categorize(next);
           if (cat == CharCategory.Space)
               cat = nextCat;
           return cat == nextCat;
       };
   }
   function moveVertically(view, start, forward, distance) {
       let startPos = start.head, dir = forward ? 1 : -1;
       if (startPos == (forward ? view.state.doc.length : 0))
           return EditorSelection.cursor(startPos, start.assoc);
       let goal = start.goalColumn, startY;
       let rect = view.contentDOM.getBoundingClientRect();
       let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
       if (startCoords) {
           if (goal == null)
               goal = startCoords.left - rect.left;
           startY = dir < 0 ? startCoords.top : startCoords.bottom;
       }
       else {
           let line = view.viewState.lineBlockAt(startPos);
           if (goal == null)
               goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
           startY = (dir < 0 ? line.top : line.bottom) + docTop;
       }
       let resolvedGoal = rect.left + goal;
       let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
       for (let extra = 0;; extra += 10) {
           let curY = startY + (dist + extra) * dir;
           let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
           if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
               return EditorSelection.cursor(pos, start.assoc, undefined, goal);
       }
   }
   function skipAtomicRanges(atoms, pos, bias) {
       for (;;) {
           let moved = 0;
           for (let set of atoms) {
               set.between(pos - 1, pos + 1, (from, to, value) => {
                   if (pos > from && pos < to) {
                       let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                       pos = side < 0 ? from : to;
                       moved = side;
                   }
               });
           }
           if (!moved)
               return pos;
       }
   }
   function skipAtoms(view, oldPos, pos) {
       let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
       return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
   }

   // This will also be where dragging info and such goes
   class InputState {
       setSelectionOrigin(origin) {
           this.lastSelectionOrigin = origin;
           this.lastSelectionTime = Date.now();
       }
       constructor(view) {
           this.lastKeyCode = 0;
           this.lastKeyTime = 0;
           this.lastTouchTime = 0;
           this.lastFocusTime = 0;
           this.lastScrollTop = 0;
           this.lastScrollLeft = 0;
           this.chromeScrollHack = -1;
           // On iOS, some keys need to have their default behavior happen
           // (after which we retroactively handle them and reset the DOM) to
           // avoid messing up the virtual keyboard state.
           this.pendingIOSKey = undefined;
           this.lastSelectionOrigin = null;
           this.lastSelectionTime = 0;
           this.lastEscPress = 0;
           this.lastContextMenu = 0;
           this.scrollHandlers = [];
           this.registeredEvents = [];
           this.customHandlers = [];
           // -1 means not in a composition. Otherwise, this counts the number
           // of changes made during the composition. The count is used to
           // avoid treating the start state of the composition, before any
           // changes have been made, as part of the composition.
           this.composing = -1;
           // Tracks whether the next change should be marked as starting the
           // composition (null means no composition, true means next is the
           // first, false means first has already been marked for this
           // composition)
           this.compositionFirstChange = null;
           // End time of the previous composition
           this.compositionEndedAt = 0;
           // Used in a kludge to detect when an Enter keypress should be
           // considered part of the composition on Safari, which fires events
           // in the wrong order
           this.compositionPendingKey = false;
           // Used to categorize changes as part of a composition, even when
           // the mutation events fire shortly after the compositionend event
           this.compositionPendingChange = false;
           this.mouseSelection = null;
           let handleEvent = (handler, event) => {
               if (this.ignoreDuringComposition(event))
                   return;
               if (event.type == "keydown" && this.keydown(view, event))
                   return;
               if (this.mustFlushObserver(event))
                   view.observer.forceFlush();
               if (this.runCustomHandlers(event.type, view, event))
                   event.preventDefault();
               else
                   handler(view, event);
           };
           for (let type in handlers) {
               let handler = handlers[type];
               view.contentDOM.addEventListener(type, event => {
                   if (eventBelongsToEditor(view, event))
                       handleEvent(handler, event);
               }, handlerOptions[type]);
               this.registeredEvents.push(type);
           }
           view.scrollDOM.addEventListener("mousedown", (event) => {
               if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) {
                   handleEvent(handlers.mousedown, event);
                   if (!event.defaultPrevented && event.button == 2) {
                       // Make sure the content covers the entire scroller height, in order
                       // to catch a native context menu click below it
                       let start = view.contentDOM.style.minHeight;
                       view.contentDOM.style.minHeight = "100%";
                       setTimeout(() => view.contentDOM.style.minHeight = start, 200);
                   }
               }
           });
           view.scrollDOM.addEventListener("drop", (event) => {
               if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom)
                   handleEvent(handlers.drop, event);
           });
           if (browser.chrome && browser.chrome_version == 102) { // FIXME remove at some point
               // On Chrome 102, viewport updates somehow stop wheel-based
               // scrolling. Turning off pointer events during the scroll seems
               // to avoid the issue.
               view.scrollDOM.addEventListener("wheel", () => {
                   if (this.chromeScrollHack < 0)
                       view.contentDOM.style.pointerEvents = "none";
                   else
                       window.clearTimeout(this.chromeScrollHack);
                   this.chromeScrollHack = setTimeout(() => {
                       this.chromeScrollHack = -1;
                       view.contentDOM.style.pointerEvents = "";
                   }, 100);
               }, { passive: true });
           }
           this.notifiedFocused = view.hasFocus;
           // On Safari adding an input event handler somehow prevents an
           // issue where the composition vanishes when you press enter.
           if (browser.safari)
               view.contentDOM.addEventListener("input", () => null);
           if (browser.gecko)
               firefoxCopyCutHack(view.contentDOM.ownerDocument);
       }
       ensureHandlers(view, plugins) {
           var _a;
           let handlers;
           this.customHandlers = [];
           for (let plugin of plugins)
               if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {
                   this.customHandlers.push({ plugin: plugin.value, handlers });
                   for (let type in handlers)
                       if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                           this.registeredEvents.push(type);
                           view.contentDOM.addEventListener(type, (event) => {
                               if (!eventBelongsToEditor(view, event))
                                   return;
                               if (this.runCustomHandlers(type, view, event))
                                   event.preventDefault();
                           });
                       }
               }
       }
       runCustomHandlers(type, view, event) {
           for (let set of this.customHandlers) {
               let handler = set.handlers[type];
               if (handler) {
                   try {
                       if (handler.call(set.plugin, event, view) || event.defaultPrevented)
                           return true;
                   }
                   catch (e) {
                       logException(view.state, e);
                   }
               }
           }
           return false;
       }
       runScrollHandlers(view, event) {
           this.lastScrollTop = view.scrollDOM.scrollTop;
           this.lastScrollLeft = view.scrollDOM.scrollLeft;
           for (let set of this.customHandlers) {
               let handler = set.handlers.scroll;
               if (handler) {
                   try {
                       handler.call(set.plugin, event, view);
                   }
                   catch (e) {
                       logException(view.state, e);
                   }
               }
           }
       }
       keydown(view, event) {
           // Must always run, even if a custom handler handled the event
           this.lastKeyCode = event.keyCode;
           this.lastKeyTime = Date.now();
           if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)
               return true;
           if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
               view.inputState.lastEscPress = 0;
           // Chrome for Android usually doesn't fire proper key events, but
           // occasionally does, usually surrounded by a bunch of complicated
           // composition changes. When an enter or backspace key event is
           // seen, hold off on handling DOM events for a bit, and then
           // dispatch it.
           if (browser.android && browser.chrome && !event.synthetic &&
               (event.keyCode == 13 || event.keyCode == 8)) {
               view.observer.delayAndroidKey(event.key, event.keyCode);
               return true;
           }
           // Prevent the default behavior of Enter on iOS makes the
           // virtual keyboard get stuck in the wrong (lowercase)
           // state. So we let it go through, and then, in
           // applyDOMChange, notify key handlers of it and reset to
           // the state they produce.
           let pending;
           if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
               ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                   EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
               this.pendingIOSKey = pending || event;
               setTimeout(() => this.flushIOSKey(view), 250);
               return true;
           }
           return false;
       }
       flushIOSKey(view) {
           let key = this.pendingIOSKey;
           if (!key)
               return false;
           this.pendingIOSKey = undefined;
           return dispatchKey(view.contentDOM, key.key, key.keyCode);
       }
       ignoreDuringComposition(event) {
           if (!/^key/.test(event.type))
               return false;
           if (this.composing > 0)
               return true;
           // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
           // On some input method editors (IMEs), the Enter key is used to
           // confirm character selection. On Safari, when Enter is pressed,
           // compositionend and keydown events are sometimes emitted in the
           // wrong order. The key event should still be ignored, even when
           // it happens after the compositionend event.
           if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
               this.compositionPendingKey = false;
               return true;
           }
           return false;
       }
       mustFlushObserver(event) {
           return event.type == "keydown" && event.keyCode != 229;
       }
       startMouseSelection(mouseSelection) {
           if (this.mouseSelection)
               this.mouseSelection.destroy();
           this.mouseSelection = mouseSelection;
       }
       update(update) {
           if (this.mouseSelection)
               this.mouseSelection.update(update);
           if (update.transactions.length)
               this.lastKeyCode = this.lastSelectionTime = 0;
       }
       destroy() {
           if (this.mouseSelection)
               this.mouseSelection.destroy();
       }
   }
   const PendingKeys = [
       { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
       { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
       { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
       { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
   ];
   const EmacsyPendingKeys = "dthko";
   // Key codes for modifier keys
   const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
   const dragScrollMargin = 6;
   function dragScrollSpeed(dist) {
       return Math.max(0, dist) * 0.7 + 8;
   }
   function dist$1(a, b) {
       return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
   }
   class MouseSelection {
       constructor(view, startEvent, style, mustSelect) {
           this.view = view;
           this.startEvent = startEvent;
           this.style = style;
           this.mustSelect = mustSelect;
           this.scrollSpeed = { x: 0, y: 0 };
           this.scrolling = -1;
           this.lastEvent = startEvent;
           this.scrollParent = scrollableParent(view.contentDOM);
           this.atoms = view.state.facet(atomicRanges).map(f => f(view));
           let doc = view.contentDOM.ownerDocument;
           doc.addEventListener("mousemove", this.move = this.move.bind(this));
           doc.addEventListener("mouseup", this.up = this.up.bind(this));
           this.extend = startEvent.shiftKey;
           this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
           this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
       }
       start(event) {
           // When clicking outside of the selection, immediately apply the
           // effect of starting the selection
           if (this.dragging === false) {
               event.preventDefault();
               this.select(event);
           }
       }
       move(event) {
           var _a;
           if (event.buttons == 0)
               return this.destroy();
           if (this.dragging || this.dragging == null && dist$1(this.startEvent, event) < 10)
               return;
           this.select(this.lastEvent = event);
           let sx = 0, sy = 0;
           let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect())
               || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
           let margins = getScrollMargins(this.view);
           if (event.clientX - margins.left <= rect.left + dragScrollMargin)
               sx = -dragScrollSpeed(rect.left - event.clientX);
           else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
               sx = dragScrollSpeed(event.clientX - rect.right);
           if (event.clientY - margins.top <= rect.top + dragScrollMargin)
               sy = -dragScrollSpeed(rect.top - event.clientY);
           else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
               sy = dragScrollSpeed(event.clientY - rect.bottom);
           this.setScrollSpeed(sx, sy);
       }
       up(event) {
           if (this.dragging == null)
               this.select(this.lastEvent);
           if (!this.dragging)
               event.preventDefault();
           this.destroy();
       }
       destroy() {
           this.setScrollSpeed(0, 0);
           let doc = this.view.contentDOM.ownerDocument;
           doc.removeEventListener("mousemove", this.move);
           doc.removeEventListener("mouseup", this.up);
           this.view.inputState.mouseSelection = null;
       }
       setScrollSpeed(sx, sy) {
           this.scrollSpeed = { x: sx, y: sy };
           if (sx || sy) {
               if (this.scrolling < 0)
                   this.scrolling = setInterval(() => this.scroll(), 50);
           }
           else if (this.scrolling > -1) {
               clearInterval(this.scrolling);
               this.scrolling = -1;
           }
       }
       scroll() {
           if (this.scrollParent) {
               this.scrollParent.scrollLeft += this.scrollSpeed.x;
               this.scrollParent.scrollTop += this.scrollSpeed.y;
           }
           else {
               this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
           }
           if (this.dragging === false)
               this.select(this.lastEvent);
       }
       skipAtoms(sel) {
           let ranges = null;
           for (let i = 0; i < sel.ranges.length; i++) {
               let range = sel.ranges[i], updated = null;
               if (range.empty) {
                   let pos = skipAtomicRanges(this.atoms, range.from, 0);
                   if (pos != range.from)
                       updated = EditorSelection.cursor(pos, -1);
               }
               else {
                   let from = skipAtomicRanges(this.atoms, range.from, -1);
                   let to = skipAtomicRanges(this.atoms, range.to, 1);
                   if (from != range.from || to != range.to)
                       updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
               }
               if (updated) {
                   if (!ranges)
                       ranges = sel.ranges.slice();
                   ranges[i] = updated;
               }
           }
           return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
       }
       select(event) {
           let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
           if (this.mustSelect || !selection.eq(view.state.selection) ||
               selection.main.assoc != view.state.selection.main.assoc && this.dragging === false)
               this.view.dispatch({
                   selection,
                   userEvent: "select.pointer"
               });
           this.mustSelect = false;
       }
       update(update) {
           if (update.docChanged && this.dragging)
               this.dragging = this.dragging.map(update.changes);
           if (this.style.update(update))
               setTimeout(() => this.select(this.lastEvent), 20);
       }
   }
   function addsSelectionRange(view, event) {
       let facet = view.state.facet(clickAddsSelectionRange);
       return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
   }
   function dragMovesSelection(view, event) {
       let facet = view.state.facet(dragMovesSelection$1);
       return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
   }
   function isInPrimarySelection(view, event) {
       let { main } = view.state.selection;
       if (main.empty)
           return false;
       // On boundary clicks, check whether the coordinates are inside the
       // selection's client rectangles
       let sel = getSelection(view.root);
       if (!sel || sel.rangeCount == 0)
           return true;
       let rects = sel.getRangeAt(0).getClientRects();
       for (let i = 0; i < rects.length; i++) {
           let rect = rects[i];
           if (rect.left <= event.clientX && rect.right >= event.clientX &&
               rect.top <= event.clientY && rect.bottom >= event.clientY)
               return true;
       }
       return false;
   }
   function eventBelongsToEditor(view, event) {
       if (!event.bubbles)
           return true;
       if (event.defaultPrevented)
           return false;
       for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
           if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
               return false;
       return true;
   }
   const handlers = /*@__PURE__*/Object.create(null);
   const handlerOptions = /*@__PURE__*/Object.create(null);
   // This is very crude, but unfortunately both these browsers _pretend_
   // that they have a clipboard API—all the objects and methods are
   // there, they just don't work, and they are hard to test.
   const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
       (browser.ios && browser.webkit_version < 604);
   function capturePaste(view) {
       let parent = view.dom.parentNode;
       if (!parent)
           return;
       let target = parent.appendChild(document.createElement("textarea"));
       target.style.cssText = "position: fixed; left: -10000px; top: 10px";
       target.focus();
       setTimeout(() => {
           view.focus();
           target.remove();
           doPaste(view, target.value);
       }, 50);
   }
   function doPaste(view, input) {
       let { state } = view, changes, i = 1, text = state.toText(input);
       let byLine = text.lines == state.selection.ranges.length;
       let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
       if (linewise) {
           let lastLine = -1;
           changes = state.changeByRange(range => {
               let line = state.doc.lineAt(range.from);
               if (line.from == lastLine)
                   return { range };
               lastLine = line.from;
               let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
               return { changes: { from: line.from, insert },
                   range: EditorSelection.cursor(range.from + insert.length) };
           });
       }
       else if (byLine) {
           changes = state.changeByRange(range => {
               let line = text.line(i++);
               return { changes: { from: range.from, to: range.to, insert: line.text },
                   range: EditorSelection.cursor(range.from + line.length) };
           });
       }
       else {
           changes = state.replaceSelection(text);
       }
       view.dispatch(changes, {
           userEvent: "input.paste",
           scrollIntoView: true
       });
   }
   handlers.keydown = (view, event) => {
       view.inputState.setSelectionOrigin("select");
       if (event.keyCode == 27)
           view.inputState.lastEscPress = Date.now();
   };
   handlers.touchstart = (view, e) => {
       view.inputState.lastTouchTime = Date.now();
       view.inputState.setSelectionOrigin("select.pointer");
   };
   handlers.touchmove = view => {
       view.inputState.setSelectionOrigin("select.pointer");
   };
   handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
   handlers.mousedown = (view, event) => {
       view.observer.flush();
       if (view.inputState.lastTouchTime > Date.now() - 2000)
           return; // Ignore touch interaction
       let style = null;
       for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
           style = makeStyle(view, event);
           if (style)
               break;
       }
       if (!style && event.button == 0)
           style = basicMouseSelection(view, event);
       if (style) {
           let mustFocus = !view.hasFocus;
           view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
           if (mustFocus)
               view.observer.ignore(() => focusPreventScroll(view.contentDOM));
           if (view.inputState.mouseSelection)
               view.inputState.mouseSelection.start(event);
       }
   };
   function rangeForClick(view, pos, bias, type) {
       if (type == 1) { // Single click
           return EditorSelection.cursor(pos, bias);
       }
       else if (type == 2) { // Double click
           return groupAt(view.state, pos, bias);
       }
       else { // Triple click
           let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
           let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
           if (to < view.state.doc.length && to == line.to)
               to++;
           return EditorSelection.range(from, to);
       }
   }
   let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
   let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
   // Try to determine, for the given coordinates, associated with the
   // given position, whether they are related to the element before or
   // the element after the position.
   function findPositionSide(view, pos, x, y) {
       let line = LineView.find(view.docView, pos);
       if (!line)
           return 1;
       let off = pos - line.posAtStart;
       // Line boundaries point into the line
       if (off == 0)
           return 1;
       if (off == line.length)
           return -1;
       // Positions on top of an element point at that element
       let before = line.coordsAt(off, -1);
       if (before && inside(x, y, before))
           return -1;
       let after = line.coordsAt(off, 1);
       if (after && inside(x, y, after))
           return 1;
       // This is probably a line wrap point. Pick before if the point is
       // beside it.
       return before && insideY(y, before) ? -1 : 1;
   }
   function queryPos(view, event) {
       let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
       return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
   }
   const BadMouseDetail = browser.ie && browser.ie_version <= 11;
   let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
   function getClickType(event) {
       if (!BadMouseDetail)
           return event.detail;
       let last = lastMouseDown, lastTime = lastMouseDownTime;
       lastMouseDown = event;
       lastMouseDownTime = Date.now();
       return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
           Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
   }
   function basicMouseSelection(view, event) {
       let start = queryPos(view, event), type = getClickType(event);
       let startSel = view.state.selection;
       return {
           update(update) {
               if (update.docChanged) {
                   start.pos = update.changes.mapPos(start.pos);
                   startSel = startSel.map(update.changes);
               }
           },
           get(event, extend, multiple) {
               let cur = queryPos(view, event), removed;
               let range = rangeForClick(view, cur.pos, cur.bias, type);
               if (start.pos != cur.pos && !extend) {
                   let startRange = rangeForClick(view, start.pos, start.bias, type);
                   let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                   range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
               }
               if (extend)
                   return startSel.replaceRange(startSel.main.extend(range.from, range.to));
               else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                   return removed;
               else if (multiple)
                   return startSel.addRange(range);
               else
                   return EditorSelection.create([range]);
           }
       };
   }
   function removeRangeAround(sel, pos) {
       for (let i = 0; i < sel.ranges.length; i++) {
           let { from, to } = sel.ranges[i];
           if (from <= pos && to >= pos)
               return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
       }
       return null;
   }
   handlers.dragstart = (view, event) => {
       let { selection: { main } } = view.state;
       let { mouseSelection } = view.inputState;
       if (mouseSelection)
           mouseSelection.dragging = main;
       if (event.dataTransfer) {
           event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
           event.dataTransfer.effectAllowed = "copyMove";
       }
   };
   function dropText(view, event, text, direct) {
       if (!text)
           return;
       let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
       event.preventDefault();
       let { mouseSelection } = view.inputState;
       let del = direct && mouseSelection && mouseSelection.dragging && dragMovesSelection(view, event) ?
           { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
       let ins = { from: dropPos, insert: text };
       let changes = view.state.changes(del ? [del, ins] : ins);
       view.focus();
       view.dispatch({
           changes,
           selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
           userEvent: del ? "move.drop" : "input.drop"
       });
   }
   handlers.drop = (view, event) => {
       if (!event.dataTransfer)
           return;
       if (view.state.readOnly)
           return event.preventDefault();
       let files = event.dataTransfer.files;
       if (files && files.length) { // For a file drop, read the file's text.
           event.preventDefault();
           let text = Array(files.length), read = 0;
           let finishFile = () => {
               if (++read == files.length)
                   dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
           };
           for (let i = 0; i < files.length; i++) {
               let reader = new FileReader;
               reader.onerror = finishFile;
               reader.onload = () => {
                   if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                       text[i] = reader.result;
                   finishFile();
               };
               reader.readAsText(files[i]);
           }
       }
       else {
           dropText(view, event, event.dataTransfer.getData("Text"), true);
       }
   };
   handlers.paste = (view, event) => {
       if (view.state.readOnly)
           return event.preventDefault();
       view.observer.flush();
       let data = brokenClipboardAPI ? null : event.clipboardData;
       if (data) {
           doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
           event.preventDefault();
       }
       else {
           capturePaste(view);
       }
   };
   function captureCopy(view, text) {
       // The extra wrapper is somehow necessary on IE/Edge to prevent the
       // content from being mangled when it is put onto the clipboard
       let parent = view.dom.parentNode;
       if (!parent)
           return;
       let target = parent.appendChild(document.createElement("textarea"));
       target.style.cssText = "position: fixed; left: -10000px; top: 10px";
       target.value = text;
       target.focus();
       target.selectionEnd = text.length;
       target.selectionStart = 0;
       setTimeout(() => {
           target.remove();
           view.focus();
       }, 50);
   }
   function copiedRange(state) {
       let content = [], ranges = [], linewise = false;
       for (let range of state.selection.ranges)
           if (!range.empty) {
               content.push(state.sliceDoc(range.from, range.to));
               ranges.push(range);
           }
       if (!content.length) {
           // Nothing selected, do a line-wise copy
           let upto = -1;
           for (let { from } of state.selection.ranges) {
               let line = state.doc.lineAt(from);
               if (line.number > upto) {
                   content.push(line.text);
                   ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
               }
               upto = line.number;
           }
           linewise = true;
       }
       return { text: content.join(state.lineBreak), ranges, linewise };
   }
   let lastLinewiseCopy = null;
   handlers.copy = handlers.cut = (view, event) => {
       let { text, ranges, linewise } = copiedRange(view.state);
       if (!text && !linewise)
           return;
       lastLinewiseCopy = linewise ? text : null;
       let data = brokenClipboardAPI ? null : event.clipboardData;
       if (data) {
           event.preventDefault();
           data.clearData();
           data.setData("text/plain", text);
       }
       else {
           captureCopy(view, text);
       }
       if (event.type == "cut" && !view.state.readOnly)
           view.dispatch({
               changes: ranges,
               scrollIntoView: true,
               userEvent: "delete.cut"
           });
   };
   const isFocusChange = /*@__PURE__*/Annotation.define();
   function focusChangeTransaction(state, focus) {
       let effects = [];
       for (let getEffect of state.facet(focusChangeEffect)) {
           let effect = getEffect(state, focus);
           if (effect)
               effects.push(effect);
       }
       return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
   }
   function updateForFocusChange(view) {
       setTimeout(() => {
           let focus = view.hasFocus;
           if (focus != view.inputState.notifiedFocused) {
               let tr = focusChangeTransaction(view.state, focus);
               if (tr)
                   view.dispatch(tr);
               else
                   view.update([]);
           }
       }, 10);
   }
   handlers.focus = view => {
       view.inputState.lastFocusTime = Date.now();
       // When focusing reset the scroll position, move it back to where it was
       if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
           view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
           view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
       }
       updateForFocusChange(view);
   };
   handlers.blur = view => {
       view.observer.clearSelectionRange();
       updateForFocusChange(view);
   };
   handlers.compositionstart = handlers.compositionupdate = view => {
       if (view.inputState.compositionFirstChange == null)
           view.inputState.compositionFirstChange = true;
       if (view.inputState.composing < 0) {
           // FIXME possibly set a timeout to clear it again on Android
           view.inputState.composing = 0;
       }
   };
   handlers.compositionend = view => {
       view.inputState.composing = -1;
       view.inputState.compositionEndedAt = Date.now();
       view.inputState.compositionPendingKey = true;
       view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
       view.inputState.compositionFirstChange = null;
       if (browser.chrome && browser.android) {
           // Delay flushing for a bit on Android because it'll often fire a
           // bunch of contradictory changes in a row at end of compositon
           view.observer.flushSoon();
       }
       else if (view.inputState.compositionPendingChange) {
           // If we found pending records, schedule a flush.
           Promise.resolve().then(() => view.observer.flush());
       }
       else {
           // Otherwise, make sure that, if no changes come in soon, the
           // composition view is cleared.
           setTimeout(() => {
               if (view.inputState.composing < 0 && view.docView.hasComposition)
                   view.update([]);
           }, 50);
       }
   };
   handlers.contextmenu = view => {
       view.inputState.lastContextMenu = Date.now();
   };
   handlers.beforeinput = (view, event) => {
       var _a;
       // Because Chrome Android doesn't fire useful key events, use
       // beforeinput to detect backspace (and possibly enter and delete,
       // but those usually don't even seem to fire beforeinput events at
       // the moment) and fake a key event for it.
       //
       // (preventDefault on beforeinput, though supported in the spec,
       // seems to do nothing at all on Chrome).
       let pending;
       if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
           view.observer.delayAndroidKey(pending.key, pending.keyCode);
           if (pending.key == "Backspace" || pending.key == "Delete") {
               let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
               setTimeout(() => {
                   var _a;
                   // Backspacing near uneditable nodes on Chrome Android sometimes
                   // closes the virtual keyboard. This tries to crudely detect
                   // that and refocus to get it back.
                   if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                       view.contentDOM.blur();
                       view.focus();
                   }
               }, 100);
           }
       }
   };
   const appliedFirefoxHack = /*@__PURE__*/new Set;
   // In Firefox, when cut/copy handlers are added to the document, that
   // somehow avoids a bug where those events aren't fired when the
   // selection is empty. See https://github.com/codemirror/dev/issues/1082
   // and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
   function firefoxCopyCutHack(doc) {
       if (!appliedFirefoxHack.has(doc)) {
           appliedFirefoxHack.add(doc);
           doc.addEventListener("copy", () => { });
           doc.addEventListener("cut", () => { });
       }
   }

   const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
   class HeightOracle {
       constructor(lineWrapping) {
           this.lineWrapping = lineWrapping;
           this.doc = Text.empty;
           this.heightSamples = {};
           this.lineHeight = 14; // The height of an entire line (line-height)
           this.charWidth = 7;
           this.textHeight = 14; // The height of the actual font (font-size)
           this.lineLength = 30;
           // Used to track, during updateHeight, if any actual heights changed
           this.heightChanged = false;
       }
       heightForGap(from, to) {
           let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
           if (this.lineWrapping)
               lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
           return this.lineHeight * lines;
       }
       heightForLine(length) {
           if (!this.lineWrapping)
               return this.lineHeight;
           let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
           return lines * this.lineHeight;
       }
       setDoc(doc) { this.doc = doc; return this; }
       mustRefreshForWrapping(whiteSpace) {
           return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
       }
       mustRefreshForHeights(lineHeights) {
           let newHeight = false;
           for (let i = 0; i < lineHeights.length; i++) {
               let h = lineHeights[i];
               if (h < 0) {
                   i++;
               }
               else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                   newHeight = true;
                   this.heightSamples[Math.floor(h * 10)] = true;
               }
           }
           return newHeight;
       }
       refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
           let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
           let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
           this.lineWrapping = lineWrapping;
           this.lineHeight = lineHeight;
           this.charWidth = charWidth;
           this.textHeight = textHeight;
           this.lineLength = lineLength;
           if (changed) {
               this.heightSamples = {};
               for (let i = 0; i < knownHeights.length; i++) {
                   let h = knownHeights[i];
                   if (h < 0)
                       i++;
                   else
                       this.heightSamples[Math.floor(h * 10)] = true;
               }
           }
           return changed;
       }
   }
   // This object is used by `updateHeight` to make DOM measurements
   // arrive at the right nides. The `heights` array is a sequence of
   // block heights, starting from position `from`.
   class MeasuredHeights {
       constructor(from, heights) {
           this.from = from;
           this.heights = heights;
           this.index = 0;
       }
       get more() { return this.index < this.heights.length; }
   }
   /**
   Record used to represent information about a block-level element
   in the editor view.
   */
   class BlockInfo {
       /**
       @internal
       */
       constructor(
       /**
       The start of the element in the document.
       */
       from, 
       /**
       The length of the element.
       */
       length, 
       /**
       The top position of the element (relative to the top of the
       document).
       */
       top, 
       /**
       Its height.
       */
       height, 
       /**
       @internal Weird packed field that holds an array of children
       for composite blocks, a decoration for block widgets, and a
       number indicating the amount of widget-create line breaks for
       text blocks.
       */
       _content) {
           this.from = from;
           this.length = length;
           this.top = top;
           this.height = height;
           this._content = _content;
       }
       /**
       The type of element this is. When querying lines, this may be
       an array of all the blocks that make up the line.
       */
       get type() {
           return typeof this._content == "number" ? BlockType.Text :
               Array.isArray(this._content) ? this._content : this._content.type;
       }
       /**
       The end of the element as a document position.
       */
       get to() { return this.from + this.length; }
       /**
       The bottom position of the element.
       */
       get bottom() { return this.top + this.height; }
       /**
       If this is a widget block, this will return the widget
       associated with it.
       */
       get widget() {
           return this._content instanceof PointDecoration ? this._content.widget : null;
       }
       /**
       If this is a textblock, this holds the number of line breaks
       that appear in widgets inside the block.
       */
       get widgetLineBreaks() {
           return typeof this._content == "number" ? this._content : 0;
       }
       /**
       @internal
       */
       join(other) {
           let content = (Array.isArray(this._content) ? this._content : [this])
               .concat(Array.isArray(other._content) ? other._content : [other]);
           return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
       }
   }
   var QueryType$1 = /*@__PURE__*/(function (QueryType) {
       QueryType[QueryType["ByPos"] = 0] = "ByPos";
       QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
       QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
   return QueryType})(QueryType$1 || (QueryType$1 = {}));
   const Epsilon = 1e-3;
   class HeightMap {
       constructor(length, // The number of characters covered
       height, // Height of this part of the document
       flags = 2 /* Flag.Outdated */) {
           this.length = length;
           this.height = height;
           this.flags = flags;
       }
       get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
       set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
       setHeight(oracle, height) {
           if (this.height != height) {
               if (Math.abs(this.height - height) > Epsilon)
                   oracle.heightChanged = true;
               this.height = height;
           }
       }
       // Base case is to replace a leaf node, which simply builds a tree
       // from the new nodes and returns that (HeightMapBranch and
       // HeightMapGap override this to actually use from/to)
       replace(_from, _to, nodes) {
           return HeightMap.of(nodes);
       }
       // Again, these are base cases, and are overridden for branch and gap nodes.
       decomposeLeft(_to, result) { result.push(this); }
       decomposeRight(_from, result) { result.push(this); }
       applyChanges(decorations, oldDoc, oracle, changes) {
           let me = this, doc = oracle.doc;
           for (let i = changes.length - 1; i >= 0; i--) {
               let { fromA, toA, fromB, toB } = changes[i];
               let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
               let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
               toB += end.to - toA;
               toA = end.to;
               while (i > 0 && start.from <= changes[i - 1].toA) {
                   fromA = changes[i - 1].fromA;
                   fromB = changes[i - 1].fromB;
                   i--;
                   if (fromA < start.from)
                       start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
               }
               fromB += start.from - fromA;
               fromA = start.from;
               let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
               me = me.replace(fromA, toA, nodes);
           }
           return me.updateHeight(oracle, 0);
       }
       static empty() { return new HeightMapText(0, 0); }
       // nodes uses null values to indicate the position of line breaks.
       // There are never line breaks at the start or end of the array, or
       // two line breaks next to each other, and the array isn't allowed
       // to be empty (same restrictions as return value from the builder).
       static of(nodes) {
           if (nodes.length == 1)
               return nodes[0];
           let i = 0, j = nodes.length, before = 0, after = 0;
           for (;;) {
               if (i == j) {
                   if (before > after * 2) {
                       let split = nodes[i - 1];
                       if (split.break)
                           nodes.splice(--i, 1, split.left, null, split.right);
                       else
                           nodes.splice(--i, 1, split.left, split.right);
                       j += 1 + split.break;
                       before -= split.size;
                   }
                   else if (after > before * 2) {
                       let split = nodes[j];
                       if (split.break)
                           nodes.splice(j, 1, split.left, null, split.right);
                       else
                           nodes.splice(j, 1, split.left, split.right);
                       j += 2 + split.break;
                       after -= split.size;
                   }
                   else {
                       break;
                   }
               }
               else if (before < after) {
                   let next = nodes[i++];
                   if (next)
                       before += next.size;
               }
               else {
                   let next = nodes[--j];
                   if (next)
                       after += next.size;
               }
           }
           let brk = 0;
           if (nodes[i - 1] == null) {
               brk = 1;
               i--;
           }
           else if (nodes[i] == null) {
               brk = 1;
               j++;
           }
           return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
       }
   }
   HeightMap.prototype.size = 1;
   class HeightMapBlock extends HeightMap {
       constructor(length, height, deco) {
           super(length, height);
           this.deco = deco;
       }
       blockAt(_height, _oracle, top, offset) {
           return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
       }
       lineAt(_value, _type, oracle, top, offset) {
           return this.blockAt(0, oracle, top, offset);
       }
       forEachLine(from, to, oracle, top, offset, f) {
           if (from <= offset + this.length && to >= offset)
               f(this.blockAt(0, oracle, top, offset));
       }
       updateHeight(oracle, offset = 0, _force = false, measured) {
           if (measured && measured.from <= offset && measured.more)
               this.setHeight(oracle, measured.heights[measured.index++]);
           this.outdated = false;
           return this;
       }
       toString() { return `block(${this.length})`; }
   }
   class HeightMapText extends HeightMapBlock {
       constructor(length, height) {
           super(length, height, null);
           this.collapsed = 0; // Amount of collapsed content in the line
           this.widgetHeight = 0; // Maximum inline widget height
           this.breaks = 0; // Number of widget-introduced line breaks on the line
       }
       blockAt(_height, _oracle, top, offset) {
           return new BlockInfo(offset, this.length, top, this.height, this.breaks);
       }
       replace(_from, _to, nodes) {
           let node = nodes[0];
           if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
               Math.abs(this.length - node.length) < 10) {
               if (node instanceof HeightMapGap)
                   node = new HeightMapText(node.length, this.height);
               else
                   node.height = this.height;
               if (!this.outdated)
                   node.outdated = false;
               return node;
           }
           else {
               return HeightMap.of(nodes);
           }
       }
       updateHeight(oracle, offset = 0, force = false, measured) {
           if (measured && measured.from <= offset && measured.more)
               this.setHeight(oracle, measured.heights[measured.index++]);
           else if (force || this.outdated)
               this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                   this.breaks * oracle.lineHeight);
           this.outdated = false;
           return this;
       }
       toString() {
           return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
       }
   }
   class HeightMapGap extends HeightMap {
       constructor(length) { super(length, 0); }
       heightMetrics(oracle, offset) {
           let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
           let lines = lastLine - firstLine + 1;
           let perLine, perChar = 0;
           if (oracle.lineWrapping) {
               let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
               perLine = totalPerLine / lines;
               if (this.length > lines + 1)
                   perChar = (this.height - totalPerLine) / (this.length - lines - 1);
           }
           else {
               perLine = this.height / lines;
           }
           return { firstLine, lastLine, perLine, perChar };
       }
       blockAt(height, oracle, top, offset) {
           let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
           if (oracle.lineWrapping) {
               let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);
               let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
               let lineTop = Math.max(top, height - lineHeight / 2);
               return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
           }
           else {
               let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
               let { from, length } = oracle.doc.line(firstLine + line);
               return new BlockInfo(from, length, top + perLine * line, perLine, 0);
           }
       }
       lineAt(value, type, oracle, top, offset) {
           if (type == QueryType$1.ByHeight)
               return this.blockAt(value, oracle, top, offset);
           if (type == QueryType$1.ByPosNoHeight) {
               let { from, to } = oracle.doc.lineAt(value);
               return new BlockInfo(from, to - from, 0, 0, 0);
           }
           let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
           let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
           let linesAbove = line.number - firstLine;
           let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
           return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
       }
       forEachLine(from, to, oracle, top, offset, f) {
           from = Math.max(from, offset);
           to = Math.min(to, offset + this.length);
           let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
           for (let pos = from, lineTop = top; pos <= to;) {
               let line = oracle.doc.lineAt(pos);
               if (pos == from) {
                   let linesAbove = line.number - firstLine;
                   lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
               }
               let lineHeight = perLine + perChar * line.length;
               f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
               lineTop += lineHeight;
               pos = line.to + 1;
           }
       }
       replace(from, to, nodes) {
           let after = this.length - to;
           if (after > 0) {
               let last = nodes[nodes.length - 1];
               if (last instanceof HeightMapGap)
                   nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
               else
                   nodes.push(null, new HeightMapGap(after - 1));
           }
           if (from > 0) {
               let first = nodes[0];
               if (first instanceof HeightMapGap)
                   nodes[0] = new HeightMapGap(from + first.length);
               else
                   nodes.unshift(new HeightMapGap(from - 1), null);
           }
           return HeightMap.of(nodes);
       }
       decomposeLeft(to, result) {
           result.push(new HeightMapGap(to - 1), null);
       }
       decomposeRight(from, result) {
           result.push(null, new HeightMapGap(this.length - from - 1));
       }
       updateHeight(oracle, offset = 0, force = false, measured) {
           let end = offset + this.length;
           if (measured && measured.from <= offset + this.length && measured.more) {
               // Fill in part of this gap with measured lines. We know there
               // can't be widgets or collapsed ranges in those lines, because
               // they would already have been added to the heightmap (gaps
               // only contain plain text).
               let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
               if (measured.from > offset)
                   nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
               while (pos <= end && measured.more) {
                   let len = oracle.doc.lineAt(pos).length;
                   if (nodes.length)
                       nodes.push(null);
                   let height = measured.heights[measured.index++];
                   if (singleHeight == -1)
                       singleHeight = height;
                   else if (Math.abs(height - singleHeight) >= Epsilon)
                       singleHeight = -2;
                   let line = new HeightMapText(len, height);
                   line.outdated = false;
                   nodes.push(line);
                   pos += len + 1;
               }
               if (pos <= end)
                   nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
               let result = HeightMap.of(nodes);
               if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                   Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                   oracle.heightChanged = true;
               return result;
           }
           else if (force || this.outdated) {
               this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
               this.outdated = false;
           }
           return this;
       }
       toString() { return `gap(${this.length})`; }
   }
   class HeightMapBranch extends HeightMap {
       constructor(left, brk, right) {
           super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
           this.left = left;
           this.right = right;
           this.size = left.size + right.size;
       }
       get break() { return this.flags & 1 /* Flag.Break */; }
       blockAt(height, oracle, top, offset) {
           let mid = top + this.left.height;
           return height < mid ? this.left.blockAt(height, oracle, top, offset)
               : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
       }
       lineAt(value, type, oracle, top, offset) {
           let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
           let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
           let base = left ? this.left.lineAt(value, type, oracle, top, offset)
               : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
           if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
               return base;
           let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
           if (left)
               return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
           else
               return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
       }
       forEachLine(from, to, oracle, top, offset, f) {
           let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
           if (this.break) {
               if (from < rightOffset)
                   this.left.forEachLine(from, to, oracle, top, offset, f);
               if (to >= rightOffset)
                   this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
           }
           else {
               let mid = this.lineAt(rightOffset, QueryType$1.ByPos, oracle, top, offset);
               if (from < mid.from)
                   this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
               if (mid.to >= from && mid.from <= to)
                   f(mid);
               if (to > mid.to)
                   this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
           }
       }
       replace(from, to, nodes) {
           let rightStart = this.left.length + this.break;
           if (to < rightStart)
               return this.balanced(this.left.replace(from, to, nodes), this.right);
           if (from > this.left.length)
               return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
           let result = [];
           if (from > 0)
               this.decomposeLeft(from, result);
           let left = result.length;
           for (let node of nodes)
               result.push(node);
           if (from > 0)
               mergeGaps(result, left - 1);
           if (to < this.length) {
               let right = result.length;
               this.decomposeRight(to, result);
               mergeGaps(result, right);
           }
           return HeightMap.of(result);
       }
       decomposeLeft(to, result) {
           let left = this.left.length;
           if (to <= left)
               return this.left.decomposeLeft(to, result);
           result.push(this.left);
           if (this.break) {
               left++;
               if (to >= left)
                   result.push(null);
           }
           if (to > left)
               this.right.decomposeLeft(to - left, result);
       }
       decomposeRight(from, result) {
           let left = this.left.length, right = left + this.break;
           if (from >= right)
               return this.right.decomposeRight(from - right, result);
           if (from < left)
               this.left.decomposeRight(from, result);
           if (this.break && from < right)
               result.push(null);
           result.push(this.right);
       }
       balanced(left, right) {
           if (left.size > 2 * right.size || right.size > 2 * left.size)
               return HeightMap.of(this.break ? [left, null, right] : [left, right]);
           this.left = left;
           this.right = right;
           this.height = left.height + right.height;
           this.outdated = left.outdated || right.outdated;
           this.size = left.size + right.size;
           this.length = left.length + this.break + right.length;
           return this;
       }
       updateHeight(oracle, offset = 0, force = false, measured) {
           let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
           if (measured && measured.from <= offset + left.length && measured.more)
               rebalance = left = left.updateHeight(oracle, offset, force, measured);
           else
               left.updateHeight(oracle, offset, force);
           if (measured && measured.from <= rightStart + right.length && measured.more)
               rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
           else
               right.updateHeight(oracle, rightStart, force);
           if (rebalance)
               return this.balanced(left, right);
           this.height = this.left.height + this.right.height;
           this.outdated = false;
           return this;
       }
       toString() { return this.left + (this.break ? " " : "-") + this.right; }
   }
   function mergeGaps(nodes, around) {
       let before, after;
       if (nodes[around] == null &&
           (before = nodes[around - 1]) instanceof HeightMapGap &&
           (after = nodes[around + 1]) instanceof HeightMapGap)
           nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
   }
   const relevantWidgetHeight = 5;
   class NodeBuilder {
       constructor(pos, oracle) {
           this.pos = pos;
           this.oracle = oracle;
           this.nodes = [];
           this.lineStart = -1;
           this.lineEnd = -1;
           this.covering = null;
           this.writtenTo = pos;
       }
       get isCovered() {
           return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
       }
       span(_from, to) {
           if (this.lineStart > -1) {
               let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
               if (last instanceof HeightMapText)
                   last.length += end - this.pos;
               else if (end > this.pos || !this.isCovered)
                   this.nodes.push(new HeightMapText(end - this.pos, -1));
               this.writtenTo = end;
               if (to > end) {
                   this.nodes.push(null);
                   this.writtenTo++;
                   this.lineStart = -1;
               }
           }
           this.pos = to;
       }
       point(from, to, deco) {
           if (from < to || deco.heightRelevant) {
               let height = deco.widget ? deco.widget.estimatedHeight : 0;
               let breaks = deco.widget ? deco.widget.lineBreaks : 0;
               if (height < 0)
                   height = this.oracle.lineHeight;
               let len = to - from;
               if (deco.block) {
                   this.addBlock(new HeightMapBlock(len, height, deco));
               }
               else if (len || breaks || height >= relevantWidgetHeight) {
                   this.addLineDeco(height, breaks, len);
               }
           }
           else if (to > from) {
               this.span(from, to);
           }
           if (this.lineEnd > -1 && this.lineEnd < this.pos)
               this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
       }
       enterLine() {
           if (this.lineStart > -1)
               return;
           let { from, to } = this.oracle.doc.lineAt(this.pos);
           this.lineStart = from;
           this.lineEnd = to;
           if (this.writtenTo < from) {
               if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                   this.nodes.push(this.blankContent(this.writtenTo, from - 1));
               this.nodes.push(null);
           }
           if (this.pos > from)
               this.nodes.push(new HeightMapText(this.pos - from, -1));
           this.writtenTo = this.pos;
       }
       blankContent(from, to) {
           let gap = new HeightMapGap(to - from);
           if (this.oracle.doc.lineAt(from).to == to)
               gap.flags |= 4 /* Flag.SingleLine */;
           return gap;
       }
       ensureLine() {
           this.enterLine();
           let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
           if (last instanceof HeightMapText)
               return last;
           let line = new HeightMapText(0, -1);
           this.nodes.push(line);
           return line;
       }
       addBlock(block) {
           var _a;
           this.enterLine();
           let type = (_a = block.deco) === null || _a === void 0 ? void 0 : _a.type;
           if (type == BlockType.WidgetAfter && !this.isCovered)
               this.ensureLine();
           this.nodes.push(block);
           this.writtenTo = this.pos = this.pos + block.length;
           if (type != BlockType.WidgetBefore)
               this.covering = block;
       }
       addLineDeco(height, breaks, length) {
           let line = this.ensureLine();
           line.length += length;
           line.collapsed += length;
           line.widgetHeight = Math.max(line.widgetHeight, height);
           line.breaks += breaks;
           this.writtenTo = this.pos = this.pos + length;
       }
       finish(from) {
           let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
           if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
               this.nodes.push(new HeightMapText(0, -1));
           else if (this.writtenTo < this.pos || last == null)
               this.nodes.push(this.blankContent(this.writtenTo, this.pos));
           let pos = from;
           for (let node of this.nodes) {
               if (node instanceof HeightMapText)
                   node.updateHeight(this.oracle, pos);
               pos += node ? node.length : 1;
           }
           return this.nodes;
       }
       // Always called with a region that on both sides either stretches
       // to a line break or the end of the document.
       // The returned array uses null to indicate line breaks, but never
       // starts or ends in a line break, or has multiple line breaks next
       // to each other.
       static build(oracle, decorations, from, to) {
           let builder = new NodeBuilder(from, oracle);
           RangeSet.spans(decorations, from, to, builder, 0);
           return builder.finish(from);
       }
   }
   function heightRelevantDecoChanges(a, b, diff) {
       let comp = new DecorationComparator;
       RangeSet.compare(a, b, diff, comp, 0);
       return comp.changes;
   }
   class DecorationComparator {
       constructor() {
           this.changes = [];
       }
       compareRange() { }
       comparePoint(from, to, a, b) {
           if (from < to || a && a.heightRelevant || b && b.heightRelevant)
               addRange(from, to, this.changes, 5);
       }
   }

   function visiblePixelRange(dom, paddingTop) {
       let rect = dom.getBoundingClientRect();
       let doc = dom.ownerDocument, win = doc.defaultView || window;
       let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
       let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
       for (let parent = dom.parentNode; parent && parent != doc.body;) {
           if (parent.nodeType == 1) {
               let elt = parent;
               let style = window.getComputedStyle(elt);
               if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                   style.overflow != "visible") {
                   let parentRect = elt.getBoundingClientRect();
                   left = Math.max(left, parentRect.left);
                   right = Math.min(right, parentRect.right);
                   top = Math.max(top, parentRect.top);
                   bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
               }
               parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
           }
           else if (parent.nodeType == 11) { // Shadow root
               parent = parent.host;
           }
           else {
               break;
           }
       }
       return { left: left - rect.left, right: Math.max(left, right) - rect.left,
           top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
   }
   function fullPixelRange(dom, paddingTop) {
       let rect = dom.getBoundingClientRect();
       return { left: 0, right: rect.right - rect.left,
           top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
   }
   // Line gaps are placeholder widgets used to hide pieces of overlong
   // lines within the viewport, as a kludge to keep the editor
   // responsive when a ridiculously long line is loaded into it.
   class LineGap {
       constructor(from, to, size) {
           this.from = from;
           this.to = to;
           this.size = size;
       }
       static same(a, b) {
           if (a.length != b.length)
               return false;
           for (let i = 0; i < a.length; i++) {
               let gA = a[i], gB = b[i];
               if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                   return false;
           }
           return true;
       }
       draw(viewState, wrapping) {
           return Decoration.replace({
               widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
           }).range(this.from, this.to);
       }
   }
   class LineGapWidget extends WidgetType {
       constructor(size, vertical) {
           super();
           this.size = size;
           this.vertical = vertical;
       }
       eq(other) { return other.size == this.size && other.vertical == this.vertical; }
       toDOM() {
           let elt = document.createElement("div");
           if (this.vertical) {
               elt.style.height = this.size + "px";
           }
           else {
               elt.style.width = this.size + "px";
               elt.style.height = "2px";
               elt.style.display = "inline-block";
           }
           return elt;
       }
       get estimatedHeight() { return this.vertical ? this.size : -1; }
   }
   class ViewState {
       constructor(state) {
           this.state = state;
           // These are contentDOM-local coordinates
           this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
           this.inView = true;
           this.paddingTop = 0; // Padding above the document, scaled
           this.paddingBottom = 0; // Padding below the document, scaled
           this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
           this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
           this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
           this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
           this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
           this.scrolledToBottom = true;
           // The CSS-transformation scale of the editor (transformed size /
           // concrete size)
           this.scaleX = 1;
           this.scaleY = 1;
           // The vertical position (document-relative) to which to anchor the
           // scroll position. -1 means anchor to the end of the document.
           this.scrollAnchorPos = 0;
           // The height at the anchor position. Set by the DOM update phase.
           // -1 means no height available.
           this.scrollAnchorHeight = -1;
           // See VP.MaxDOMHeight
           this.scaler = IdScaler;
           this.scrollTarget = null;
           // Briefly set to true when printing, to disable viewport limiting
           this.printing = false;
           // Flag set when editor content was redrawn, so that the next
           // measure stage knows it must read DOM layout
           this.mustMeasureContent = true;
           this.defaultTextDirection = Direction.LTR;
           this.visibleRanges = [];
           // Cursor 'assoc' is only significant when the cursor is on a line
           // wrap point, where it must stick to the character that it is
           // associated with. Since browsers don't provide a reasonable
           // interface to set or query this, when a selection is set that
           // might cause this to be significant, this flag is set. The next
           // measure phase will check whether the cursor is on a line-wrapping
           // boundary and, if so, reset it to make sure it is positioned in
           // the right place.
           this.mustEnforceCursorAssoc = false;
           let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
           this.heightOracle = new HeightOracle(guessWrapping);
           this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
           this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
           this.viewport = this.getViewport(0, null);
           this.updateViewportLines();
           this.updateForViewport();
           this.lineGaps = this.ensureLineGaps([]);
           this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
           this.computeVisibleRanges();
       }
       updateForViewport() {
           let viewports = [this.viewport], { main } = this.state.selection;
           for (let i = 0; i <= 1; i++) {
               let pos = i ? main.head : main.anchor;
               if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                   let { from, to } = this.lineBlockAt(pos);
                   viewports.push(new Viewport(from, to));
               }
           }
           this.viewports = viewports.sort((a, b) => a.from - b.from);
           this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
               new BigScaler(this.heightOracle, this.heightMap, this.viewports);
       }
       updateViewportLines() {
           this.viewportLines = [];
           this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
               this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
           });
       }
       update(update, scrollTarget = null) {
           this.state = update.state;
           let prevDeco = this.stateDeco;
           this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
           let contentChanges = update.changedRanges;
           let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
           let prevHeight = this.heightMap.height;
           let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
           this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
           if (this.heightMap.height != prevHeight)
               update.flags |= 2 /* UpdateFlag.Height */;
           if (scrollAnchor) {
               this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
               this.scrollAnchorHeight = scrollAnchor.top;
           }
           else {
               this.scrollAnchorPos = -1;
               this.scrollAnchorHeight = this.heightMap.height;
           }
           let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
           if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
               !this.viewportIsAppropriate(viewport))
               viewport = this.getViewport(0, scrollTarget);
           let updateLines = !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */) ||
               viewport.from != this.viewport.from || viewport.to != this.viewport.to;
           this.viewport = viewport;
           this.updateForViewport();
           if (updateLines)
               this.updateViewportLines();
           if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
               this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
           update.flags |= this.computeVisibleRanges();
           if (scrollTarget)
               this.scrollTarget = scrollTarget;
           if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
               update.state.selection.main.empty && update.state.selection.main.assoc &&
               !update.state.facet(nativeSelectionHidden))
               this.mustEnforceCursorAssoc = true;
       }
       measure(view) {
           let dom = view.contentDOM, style = window.getComputedStyle(dom);
           let oracle = this.heightOracle;
           let whiteSpace = style.whiteSpace;
           this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
           let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
           let domRect = dom.getBoundingClientRect();
           let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
           this.contentDOMHeight = domRect.height;
           this.mustMeasureContent = false;
           let result = 0, bias = 0;
           if (domRect.width && domRect.height) {
               let scaleX = domRect.width / dom.offsetWidth;
               let scaleY = domRect.height / dom.offsetHeight;
               if (scaleX > 0.995 && scaleX < 1.005)
                   scaleX = 1;
               if (scaleY > 0.995 && scaleY < 1.005)
                   scaleY = 1;
               if (this.scaleX != scaleX || this.scaleY != scaleY) {
                   this.scaleX = scaleX;
                   this.scaleY = scaleY;
                   result |= 8 /* UpdateFlag.Geometry */;
                   refresh = measureContent = true;
               }
           }
           // Vertical padding
           let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
           let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
           if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
               this.paddingTop = paddingTop;
               this.paddingBottom = paddingBottom;
               result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
           }
           if (this.editorWidth != view.scrollDOM.clientWidth) {
               if (oracle.lineWrapping)
                   measureContent = true;
               this.editorWidth = view.scrollDOM.clientWidth;
               result |= 8 /* UpdateFlag.Geometry */;
           }
           let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
           if (this.scrollTop != scrollTop) {
               this.scrollAnchorHeight = -1;
               this.scrollTop = scrollTop;
           }
           this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
           // Pixel viewport
           let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
           let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
           this.pixelViewport = pixelViewport;
           let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
           if (inView != this.inView) {
               this.inView = inView;
               if (inView)
                   measureContent = true;
           }
           if (!this.inView && !this.scrollTarget)
               return 0;
           let contentWidth = domRect.width;
           if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
               this.contentDOMWidth = domRect.width;
               this.editorHeight = view.scrollDOM.clientHeight;
               result |= 8 /* UpdateFlag.Geometry */;
           }
           if (measureContent) {
               let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
               if (oracle.mustRefreshForHeights(lineHeights))
                   refresh = true;
               if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                   let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                   refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
                   if (refresh) {
                       view.docView.minWidth = 0;
                       result |= 8 /* UpdateFlag.Geometry */;
                   }
               }
               if (dTop > 0 && dBottom > 0)
                   bias = Math.max(dTop, dBottom);
               else if (dTop < 0 && dBottom < 0)
                   bias = Math.min(dTop, dBottom);
               oracle.heightChanged = false;
               for (let vp of this.viewports) {
                   let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                   this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
               }
               if (oracle.heightChanged)
                   result |= 2 /* UpdateFlag.Height */;
           }
           let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
               this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                   this.scrollTarget.range.head > this.viewport.to);
           if (viewportChange)
               this.viewport = this.getViewport(bias, this.scrollTarget);
           this.updateForViewport();
           if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
               this.updateViewportLines();
           if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
               this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
           result |= this.computeVisibleRanges();
           if (this.mustEnforceCursorAssoc) {
               this.mustEnforceCursorAssoc = false;
               // This is done in the read stage, because moving the selection
               // to a line end is going to trigger a layout anyway, so it
               // can't be a pure write. It should be rare that it does any
               // writing.
               view.docView.enforceCursorAssoc();
           }
           return result;
       }
       get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
       get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
       getViewport(bias, scrollTarget) {
           // This will divide VP.Margin between the top and the
           // bottom, depending on the bias (the change in viewport position
           // since the last update). It'll hold a number between 0 and 1
           let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
           let map = this.heightMap, oracle = this.heightOracle;
           let { visibleTop, visibleBottom } = this;
           let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType$1.ByHeight, oracle, 0, 0).to);
           // If scrollTarget is given, make sure the viewport includes that position
           if (scrollTarget) {
               let { head } = scrollTarget.range;
               if (head < viewport.from || head > viewport.to) {
                   let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                   let block = map.lineAt(head, QueryType$1.ByPos, oracle, 0, 0), topPos;
                   if (scrollTarget.y == "center")
                       topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                   else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                       topPos = block.top;
                   else
                       topPos = block.bottom - viewHeight;
                   viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType$1.ByHeight, oracle, 0, 0).to);
               }
           }
           return viewport;
       }
       mapViewport(viewport, changes) {
           let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
           return new Viewport(this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0).to);
       }
       // Checks if a given viewport covers the visible part of the
       // document and not too much beyond that.
       viewportIsAppropriate({ from, to }, bias = 0) {
           if (!this.inView)
               return true;
           let { top } = this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0);
           let { bottom } = this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0);
           let { visibleTop, visibleBottom } = this;
           return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
               (to == this.state.doc.length ||
                   bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
               (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
       }
       mapLineGaps(gaps, changes) {
           if (!gaps.length || changes.empty)
               return gaps;
           let mapped = [];
           for (let gap of gaps)
               if (!changes.touchesRange(gap.from, gap.to))
                   mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
           return mapped;
       }
       // Computes positions in the viewport where the start or end of a
       // line should be hidden, trying to reuse existing line gaps when
       // appropriate to avoid unneccesary redraws.
       // Uses crude character-counting for the positioning and sizing,
       // since actual DOM coordinates aren't always available and
       // predictable. Relies on generous margins (see LG.Margin) to hide
       // the artifacts this might produce from the user.
       ensureLineGaps(current, mayMeasure) {
           let wrapping = this.heightOracle.lineWrapping;
           let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
           // The non-wrapping logic won't work at all in predominantly right-to-left text.
           if (this.defaultTextDirection != Direction.LTR && !wrapping)
               return [];
           let gaps = [];
           let addGap = (from, to, line, structure) => {
               if (to - from < halfMargin)
                   return;
               let sel = this.state.selection.main, avoid = [sel.from];
               if (!sel.empty)
                   avoid.push(sel.to);
               for (let pos of avoid) {
                   if (pos > from && pos < to) {
                       addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                       addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                       return;
                   }
               }
               let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                   Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                   !avoid.some(pos => gap.from < pos && gap.to > pos));
               if (!gap) {
                   // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                   if (to < line.to && mayMeasure && wrapping &&
                       mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                       let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
                       if (lineStart > from)
                           to = lineStart;
                   }
                   gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
               }
               gaps.push(gap);
           };
           for (let line of this.viewportLines) {
               if (line.length < doubleMargin)
                   continue;
               let structure = lineStructure(line.from, line.to, this.stateDeco);
               if (structure.total < doubleMargin)
                   continue;
               let target = this.scrollTarget ? this.scrollTarget.range.head : null;
               let viewFrom, viewTo;
               if (wrapping) {
                   let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                   let top, bot;
                   if (target != null) {
                       let targetFrac = findFraction(structure, target);
                       let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                       top = targetFrac - spaceFrac;
                       bot = targetFrac + spaceFrac;
                   }
                   else {
                       top = (this.visibleTop - line.top - marginHeight) / line.height;
                       bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                   }
                   viewFrom = findPosition(structure, top);
                   viewTo = findPosition(structure, bot);
               }
               else {
                   let totalWidth = structure.total * this.heightOracle.charWidth;
                   let marginWidth = margin * this.heightOracle.charWidth;
                   let left, right;
                   if (target != null) {
                       let targetFrac = findFraction(structure, target);
                       let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
                       left = targetFrac - spaceFrac;
                       right = targetFrac + spaceFrac;
                   }
                   else {
                       left = (this.pixelViewport.left - marginWidth) / totalWidth;
                       right = (this.pixelViewport.right + marginWidth) / totalWidth;
                   }
                   viewFrom = findPosition(structure, left);
                   viewTo = findPosition(structure, right);
               }
               if (viewFrom > line.from)
                   addGap(line.from, viewFrom, line, structure);
               if (viewTo < line.to)
                   addGap(viewTo, line.to, line, structure);
           }
           return gaps;
       }
       gapSize(line, from, to, structure) {
           let fraction = findFraction(structure, to) - findFraction(structure, from);
           if (this.heightOracle.lineWrapping) {
               return line.height * fraction;
           }
           else {
               return structure.total * this.heightOracle.charWidth * fraction;
           }
       }
       updateLineGaps(gaps) {
           if (!LineGap.same(gaps, this.lineGaps)) {
               this.lineGaps = gaps;
               this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
           }
       }
       computeVisibleRanges() {
           let deco = this.stateDeco;
           if (this.lineGaps.length)
               deco = deco.concat(this.lineGapDeco);
           let ranges = [];
           RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
               span(from, to) { ranges.push({ from, to }); },
               point() { }
           }, 20);
           let changed = ranges.length != this.visibleRanges.length ||
               this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
           this.visibleRanges = ranges;
           return changed ? 4 /* UpdateFlag.Viewport */ : 0;
       }
       lineBlockAt(pos) {
           return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
               scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.heightOracle, 0, 0), this.scaler);
       }
       lineBlockAtHeight(height) {
           return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.heightOracle, 0, 0), this.scaler);
       }
       scrollAnchorAt(scrollTop) {
           let block = this.lineBlockAtHeight(scrollTop + 8);
           return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
       }
       elementAtHeight(height) {
           return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
       }
       get docHeight() {
           return this.scaler.toDOM(this.heightMap.height);
       }
       get contentHeight() {
           return this.docHeight + this.paddingTop + this.paddingBottom;
       }
   }
   class Viewport {
       constructor(from, to) {
           this.from = from;
           this.to = to;
       }
   }
   function lineStructure(from, to, stateDeco) {
       let ranges = [], pos = from, total = 0;
       RangeSet.spans(stateDeco, from, to, {
           span() { },
           point(from, to) {
               if (from > pos) {
                   ranges.push({ from: pos, to: from });
                   total += from - pos;
               }
               pos = to;
           }
       }, 20); // We're only interested in collapsed ranges of a significant size
       if (pos < to) {
           ranges.push({ from: pos, to });
           total += to - pos;
       }
       return { total, ranges };
   }
   function findPosition({ total, ranges }, ratio) {
       if (ratio <= 0)
           return ranges[0].from;
       if (ratio >= 1)
           return ranges[ranges.length - 1].to;
       let dist = Math.floor(total * ratio);
       for (let i = 0;; i++) {
           let { from, to } = ranges[i], size = to - from;
           if (dist <= size)
               return from + dist;
           dist -= size;
       }
   }
   function findFraction(structure, pos) {
       let counted = 0;
       for (let { from, to } of structure.ranges) {
           if (pos <= to) {
               counted += pos - from;
               break;
           }
           counted += to - from;
       }
       return counted / structure.total;
   }
   function find(array, f) {
       for (let val of array)
           if (f(val))
               return val;
       return undefined;
   }
   // Don't scale when the document height is within the range of what
   // the DOM can handle.
   const IdScaler = {
       toDOM(n) { return n; },
       fromDOM(n) { return n; },
       scale: 1
   };
   // When the height is too big (> VP.MaxDOMHeight), scale down the
   // regions outside the viewports so that the total height is
   // VP.MaxDOMHeight.
   class BigScaler {
       constructor(oracle, heightMap, viewports) {
           let vpHeight = 0, base = 0, domBase = 0;
           this.viewports = viewports.map(({ from, to }) => {
               let top = heightMap.lineAt(from, QueryType$1.ByPos, oracle, 0, 0).top;
               let bottom = heightMap.lineAt(to, QueryType$1.ByPos, oracle, 0, 0).bottom;
               vpHeight += bottom - top;
               return { from, to, top, bottom, domTop: 0, domBottom: 0 };
           });
           this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
           for (let obj of this.viewports) {
               obj.domTop = domBase + (obj.top - base) * this.scale;
               domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
               base = obj.bottom;
           }
       }
       toDOM(n) {
           for (let i = 0, base = 0, domBase = 0;; i++) {
               let vp = i < this.viewports.length ? this.viewports[i] : null;
               if (!vp || n < vp.top)
                   return domBase + (n - base) * this.scale;
               if (n <= vp.bottom)
                   return vp.domTop + (n - vp.top);
               base = vp.bottom;
               domBase = vp.domBottom;
           }
       }
       fromDOM(n) {
           for (let i = 0, base = 0, domBase = 0;; i++) {
               let vp = i < this.viewports.length ? this.viewports[i] : null;
               if (!vp || n < vp.domTop)
                   return base + (n - domBase) / this.scale;
               if (n <= vp.domBottom)
                   return vp.top + (n - vp.domTop);
               base = vp.bottom;
               domBase = vp.domBottom;
           }
       }
   }
   function scaleBlock(block, scaler) {
       if (scaler.scale == 1)
           return block;
       let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
       return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
   }

   const theme = /*@__PURE__*/Facet.define({ combine: strs => strs.join(" ") });
   const darkTheme = /*@__PURE__*/Facet.define({ combine: values => values.indexOf(true) > -1 });
   const baseThemeID = /*@__PURE__*/StyleModule.newName(), baseLightID = /*@__PURE__*/StyleModule.newName(), baseDarkID = /*@__PURE__*/StyleModule.newName();
   const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
   function buildTheme(main, spec, scopes) {
       return new StyleModule(spec, {
           finish(sel) {
               return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                   if (m == "&")
                       return main;
                   if (!scopes || !scopes[m])
                       throw new RangeError(`Unsupported selector: ${m}`);
                   return scopes[m];
               }) : main + " " + sel;
           }
       });
   }
   const baseTheme$1$3 = /*@__PURE__*/buildTheme("." + baseThemeID, {
       "&": {
           position: "relative !important",
           boxSizing: "border-box",
           "&.cm-focused": {
               // Provide a simple default outline to make sure a focused
               // editor is visually distinct. Can't leave the default behavior
               // because that will apply to the content element, which is
               // inside the scrollable container and doesn't include the
               // gutters. We also can't use an 'auto' outline, since those
               // are, for some reason, drawn behind the element content, which
               // will cause things like the active line background to cover
               // the outline (#297).
               outline: "1px dotted #212121"
           },
           display: "flex !important",
           flexDirection: "column"
       },
       ".cm-scroller": {
           display: "flex !important",
           alignItems: "flex-start !important",
           fontFamily: "monospace",
           lineHeight: 1.4,
           height: "100%",
           overflowX: "auto",
           position: "relative",
           zIndex: 0
       },
       ".cm-content": {
           margin: 0,
           flexGrow: 2,
           flexShrink: 0,
           display: "block",
           whiteSpace: "pre",
           wordWrap: "normal",
           boxSizing: "border-box",
           padding: "4px 0",
           outline: "none",
           "&[contenteditable=true]": {
               WebkitUserModify: "read-write-plaintext-only",
           }
       },
       ".cm-lineWrapping": {
           whiteSpace_fallback: "pre-wrap",
           whiteSpace: "break-spaces",
           wordBreak: "break-word",
           overflowWrap: "anywhere",
           flexShrink: 1
       },
       "&light .cm-content": { caretColor: "black" },
       "&dark .cm-content": { caretColor: "white" },
       ".cm-line": {
           display: "block",
           padding: "0 2px 0 6px"
       },
       ".cm-layer": {
           position: "absolute",
           left: 0,
           top: 0,
           contain: "size style",
           "& > *": {
               position: "absolute"
           }
       },
       "&light .cm-selectionBackground": {
           background: "#d9d9d9"
       },
       "&dark .cm-selectionBackground": {
           background: "#222"
       },
       "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
           background: "#d7d4f0"
       },
       "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
           background: "#233"
       },
       ".cm-cursorLayer": {
           pointerEvents: "none"
       },
       "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
           animation: "steps(1) cm-blink 1.2s infinite"
       },
       // Two animations defined so that we can switch between them to
       // restart the animation without forcing another style
       // recomputation.
       "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
       "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
       ".cm-cursor, .cm-dropCursor": {
           borderLeft: "1.2px solid black",
           marginLeft: "-0.6px",
           pointerEvents: "none",
       },
       ".cm-cursor": {
           display: "none"
       },
       "&dark .cm-cursor": {
           borderLeftColor: "#444"
       },
       ".cm-dropCursor": {
           position: "absolute"
       },
       "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
           display: "block"
       },
       "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
       "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
       "&light .cm-specialChar": { color: "red" },
       "&dark .cm-specialChar": { color: "#f78" },
       ".cm-gutters": {
           flexShrink: 0,
           display: "flex",
           height: "100%",
           boxSizing: "border-box",
           insetInlineStart: 0,
           zIndex: 200
       },
       "&light .cm-gutters": {
           backgroundColor: "#f5f5f5",
           color: "#6c6c6c",
           borderRight: "1px solid #ddd"
       },
       "&dark .cm-gutters": {
           backgroundColor: "#333338",
           color: "#ccc"
       },
       ".cm-gutter": {
           display: "flex !important",
           flexDirection: "column",
           flexShrink: 0,
           boxSizing: "border-box",
           minHeight: "100%",
           overflow: "hidden"
       },
       ".cm-gutterElement": {
           boxSizing: "border-box"
       },
       ".cm-lineNumbers .cm-gutterElement": {
           padding: "0 3px 0 5px",
           minWidth: "20px",
           textAlign: "right",
           whiteSpace: "nowrap"
       },
       "&light .cm-activeLineGutter": {
           backgroundColor: "#e2f2ff"
       },
       "&dark .cm-activeLineGutter": {
           backgroundColor: "#222227"
       },
       ".cm-panels": {
           boxSizing: "border-box",
           position: "sticky",
           left: 0,
           right: 0
       },
       "&light .cm-panels": {
           backgroundColor: "#f5f5f5",
           color: "black"
       },
       "&light .cm-panels-top": {
           borderBottom: "1px solid #ddd"
       },
       "&light .cm-panels-bottom": {
           borderTop: "1px solid #ddd"
       },
       "&dark .cm-panels": {
           backgroundColor: "#333338",
           color: "white"
       },
       ".cm-tab": {
           display: "inline-block",
           overflow: "hidden",
           verticalAlign: "bottom"
       },
       ".cm-widgetBuffer": {
           verticalAlign: "text-top",
           height: "1em",
           width: 0,
           display: "inline"
       },
       ".cm-placeholder": {
           color: "#888",
           display: "inline-block",
           verticalAlign: "top",
       },
       ".cm-highlightSpace:before": {
           content: "attr(data-display)",
           position: "absolute",
           pointerEvents: "none",
           color: "#888"
       },
       ".cm-highlightTab": {
           backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
           backgroundSize: "auto 100%",
           backgroundPosition: "right 90%",
           backgroundRepeat: "no-repeat"
       },
       ".cm-trailingSpace": {
           backgroundColor: "#ff332255"
       },
       ".cm-button": {
           verticalAlign: "middle",
           color: "inherit",
           fontSize: "70%",
           padding: ".2em 1em",
           borderRadius: "1px"
       },
       "&light .cm-button": {
           backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
           border: "1px solid #888",
           "&:active": {
               backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
           }
       },
       "&dark .cm-button": {
           backgroundImage: "linear-gradient(#393939, #111)",
           border: "1px solid #888",
           "&:active": {
               backgroundImage: "linear-gradient(#111, #333)"
           }
       },
       ".cm-textfield": {
           verticalAlign: "middle",
           color: "inherit",
           fontSize: "70%",
           border: "1px solid silver",
           padding: ".2em .5em"
       },
       "&light .cm-textfield": {
           backgroundColor: "white"
       },
       "&dark .cm-textfield": {
           border: "1px solid #555",
           backgroundColor: "inherit"
       }
   }, lightDarkIDs);

   class DOMChange {
       constructor(view, start, end, typeOver) {
           this.typeOver = typeOver;
           this.bounds = null;
           this.text = "";
           let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
           if (view.state.readOnly && start > -1) {
               // Ignore changes when the editor is read-only
               this.newSel = null;
           }
           else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
               let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
               let reader = new DOMReader(selPoints, view.state);
               reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
               this.text = reader.text;
               this.newSel = selectionFromPoints(selPoints, this.bounds.from);
           }
           else {
               let domSel = view.observer.selectionRange;
               let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                   !contains(view.contentDOM, domSel.focusNode)
                   ? view.state.selection.main.head
                   : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
               let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                   !contains(view.contentDOM, domSel.anchorNode)
                   ? view.state.selection.main.anchor
                   : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
               this.newSel = EditorSelection.single(anchor, head);
           }
       }
   }
   function applyDOMChange(view, domChange) {
       let change;
       let { newSel } = domChange, sel = view.state.selection.main;
       let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
       if (domChange.bounds) {
           let { from, to } = domChange.bounds;
           let preferredPos = sel.from, preferredSide = null;
           // Prefer anchoring to end when Backspace is pressed (or, on
           // Android, when something was deleted)
           if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
               preferredPos = sel.to;
               preferredSide = "end";
           }
           let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
           if (diff) {
               // Chrome inserts two newlines when pressing shift-enter at the
               // end of a line. DomChange drops one of those.
               if (browser.chrome && lastKey == 13 &&
                   diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                   diff.toB--;
               change = { from: from + diff.from, to: from + diff.toA,
                   insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
           }
       }
       else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
           newSel = null;
       }
       if (!change && !newSel)
           return false;
       if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
           // Heuristic to notice typing over a selected character
           change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
       }
       else if (change && change.from >= sel.from && change.to <= sel.to &&
           (change.from != sel.from || change.to != sel.to) &&
           (sel.to - sel.from) - (change.to - change.from) <= 4) {
           // If the change is inside the selection and covers most of it,
           // assume it is a selection replace (with identical characters at
           // the start/end not included in the diff)
           change = {
               from: sel.from, to: sel.to,
               insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
           };
       }
       else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
           /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
           // Detect insert-period-on-double-space Mac and Android behavior,
           // and transform it into a regular space insert.
           if (newSel && change.insert.length == 2)
               newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
           change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
       }
       else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
           change.insert.toString() == "\n " && view.lineWrapping) {
           // In Chrome, if you insert a space at the start of a wrapped
           // line, it will actually insert a newline and a space, causing a
           // bogus new line to be created in CodeMirror (#968)
           if (newSel)
               newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
           change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
       }
       if (change) {
           if (browser.ios && view.inputState.flushIOSKey(view))
               return true;
           // Android browsers don't fire reasonable key events for enter,
           // backspace, or delete. So this detects changes that look like
           // they're caused by those keys, and reinterprets them as key
           // events. (Some of these keys are also handled by beforeinput
           // events and the pendingAndroidKey mechanism, but that's not
           // reliable in all situations.)
           if (browser.android &&
               ((change.from == sel.from && change.to == sel.to &&
                   change.insert.length == 1 && change.insert.lines == 2 &&
                   dispatchKey(view.contentDOM, "Enter", 13)) ||
                   ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                       lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                       dispatchKey(view.contentDOM, "Backspace", 8)) ||
                   (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                       dispatchKey(view.contentDOM, "Delete", 46))))
               return true;
           let text = change.insert.toString();
           if (view.inputState.composing >= 0)
               view.inputState.composing++;
           let defaultTr;
           let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
           if (!view.state.facet(inputHandler$1).some(h => h(view, change.from, change.to, text, defaultInsert)))
               view.dispatch(defaultInsert());
           return true;
       }
       else if (newSel && !newSel.main.eq(sel)) {
           let scrollIntoView = false, userEvent = "select";
           if (view.inputState.lastSelectionTime > Date.now() - 50) {
               if (view.inputState.lastSelectionOrigin == "select")
                   scrollIntoView = true;
               userEvent = view.inputState.lastSelectionOrigin;
           }
           view.dispatch({ selection: newSel, scrollIntoView, userEvent });
           return true;
       }
       else {
           return false;
       }
   }
   function applyDefaultInsert(view, change, newSel) {
       let tr, startState = view.state, sel = startState.selection.main;
       if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
           (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
           view.inputState.composing < 0) {
           let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
           let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
           tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
       }
       else {
           let changes = startState.changes(change);
           let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
           // Try to apply a composition change to all cursors
           if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
               change.to <= sel.to && change.to >= sel.to - 10) {
               let replaced = view.state.sliceDoc(change.from, change.to);
               let composition = findCompositionNode(view, change.insert.length - (change.to - change.from)) ||
                   view.state.doc.lineAt(sel.head);
               let offset = sel.to - change.to, size = sel.to - sel.from;
               tr = startState.changeByRange(range => {
                   if (range.from == sel.from && range.to == sel.to)
                       return { changes, range: mainSel || range.map(changes) };
                   let to = range.to - offset, from = to - replaced.length;
                   if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                       // Unfortunately, there's no way to make multiple
                       // changes in the same node work without aborting
                       // composition, so cursors in the composition range are
                       // ignored.
                       composition && range.to >= composition.from && range.from <= composition.to)
                       return { range };
                   let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                   return {
                       changes: rangeChanges,
                       range: !mainSel ? range.map(rangeChanges) :
                           EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                   };
               });
           }
           else {
               tr = {
                   changes,
                   selection: mainSel && startState.selection.replaceRange(mainSel)
               };
           }
       }
       let userEvent = "input.type";
       if (view.composing ||
           view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
           view.inputState.compositionPendingChange = false;
           userEvent += ".compose";
           if (view.inputState.compositionFirstChange) {
               userEvent += ".start";
               view.inputState.compositionFirstChange = false;
           }
       }
       return startState.update(tr, { userEvent, scrollIntoView: true });
   }
   function findDiff(a, b, preferredPos, preferredSide) {
       let minLen = Math.min(a.length, b.length);
       let from = 0;
       while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
           from++;
       if (from == minLen && a.length == b.length)
           return null;
       let toA = a.length, toB = b.length;
       while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
           toA--;
           toB--;
       }
       if (preferredSide == "end") {
           let adjust = Math.max(0, from - Math.min(toA, toB));
           preferredPos -= toA + adjust - from;
       }
       if (toA < from && a.length < b.length) {
           let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
           from -= move;
           toB = from + (toB - toA);
           toA = from;
       }
       else if (toB < from) {
           let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
           from -= move;
           toA = from + (toA - toB);
           toB = from;
       }
       return { from, toA, toB };
   }
   function selectionPoints(view) {
       let result = [];
       if (view.root.activeElement != view.contentDOM)
           return result;
       let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
       if (anchorNode) {
           result.push(new DOMPoint(anchorNode, anchorOffset));
           if (focusNode != anchorNode || focusOffset != anchorOffset)
               result.push(new DOMPoint(focusNode, focusOffset));
       }
       return result;
   }
   function selectionFromPoints(points, base) {
       if (points.length == 0)
           return null;
       let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
       return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;
   }

   const observeOptions = {
       childList: true,
       characterData: true,
       subtree: true,
       attributes: true,
       characterDataOldValue: true
   };
   // IE11 has very broken mutation observers, so we also listen to
   // DOMCharacterDataModified there
   const useCharData = browser.ie && browser.ie_version <= 11;
   class DOMObserver {
       constructor(view) {
           this.view = view;
           this.active = false;
           // The known selection. Kept in our own object, as opposed to just
           // directly accessing the selection because:
           //  - Safari doesn't report the right selection in shadow DOM
           //  - Reading from the selection forces a DOM layout
           //  - This way, we can ignore selectionchange events if we have
           //    already seen the 'new' selection
           this.selectionRange = new DOMSelectionState;
           // Set when a selection change is detected, cleared on flush
           this.selectionChanged = false;
           this.delayedFlush = -1;
           this.resizeTimeout = -1;
           this.queue = [];
           this.delayedAndroidKey = null;
           this.flushingAndroidKey = -1;
           this.lastChange = 0;
           this.scrollTargets = [];
           this.intersection = null;
           this.resizeScroll = null;
           this.resizeContent = null;
           this.intersecting = false;
           this.gapIntersection = null;
           this.gaps = [];
           // Timeout for scheduling check of the parents that need scroll handlers
           this.parentCheck = -1;
           this.dom = view.contentDOM;
           this.observer = new MutationObserver(mutations => {
               for (let mut of mutations)
                   this.queue.push(mut);
               // IE11 will sometimes (on typing over a selection or
               // backspacing out a single character text node) call the
               // observer callback before actually updating the DOM.
               //
               // Unrelatedly, iOS Safari will, when ending a composition,
               // sometimes first clear it, deliver the mutations, and then
               // reinsert the finished text. CodeMirror's handling of the
               // deletion will prevent the reinsertion from happening,
               // breaking composition.
               if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                   mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                       m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                   this.flushSoon();
               else
                   this.flush();
           });
           if (useCharData)
               this.onCharData = (event) => {
                   this.queue.push({ target: event.target,
                       type: "characterData",
                       oldValue: event.prevValue });
                   this.flushSoon();
               };
           this.onSelectionChange = this.onSelectionChange.bind(this);
           this.onResize = this.onResize.bind(this);
           this.onPrint = this.onPrint.bind(this);
           this.onScroll = this.onScroll.bind(this);
           if (typeof ResizeObserver == "function") {
               this.resizeScroll = new ResizeObserver(() => {
                   var _a;
                   if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                       this.onResize();
               });
               this.resizeScroll.observe(view.scrollDOM);
               this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
               this.resizeContent.observe(view.contentDOM);
           }
           this.addWindowListeners(this.win = view.win);
           this.start();
           if (typeof IntersectionObserver == "function") {
               this.intersection = new IntersectionObserver(entries => {
                   if (this.parentCheck < 0)
                       this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                   if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                       this.intersecting = !this.intersecting;
                       if (this.intersecting != this.view.inView)
                           this.onScrollChanged(document.createEvent("Event"));
                   }
               }, { threshold: [0, .001] });
               this.intersection.observe(this.dom);
               this.gapIntersection = new IntersectionObserver(entries => {
                   if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                       this.onScrollChanged(document.createEvent("Event"));
               }, {});
           }
           this.listenForScroll();
           this.readSelectionRange();
       }
       onScrollChanged(e) {
           this.view.inputState.runScrollHandlers(this.view, e);
           if (this.intersecting)
               this.view.measure();
       }
       onScroll(e) {
           if (this.intersecting)
               this.flush(false);
           this.onScrollChanged(e);
       }
       onResize() {
           if (this.resizeTimeout < 0)
               this.resizeTimeout = setTimeout(() => {
                   this.resizeTimeout = -1;
                   this.view.requestMeasure();
               }, 50);
       }
       onPrint() {
           this.view.viewState.printing = true;
           this.view.measure();
           setTimeout(() => {
               this.view.viewState.printing = false;
               this.view.requestMeasure();
           }, 500);
       }
       updateGaps(gaps) {
           if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
               this.gapIntersection.disconnect();
               for (let gap of gaps)
                   this.gapIntersection.observe(gap);
               this.gaps = gaps;
           }
       }
       onSelectionChange(event) {
           let wasChanged = this.selectionChanged;
           if (!this.readSelectionRange() || this.delayedAndroidKey)
               return;
           let { view } = this, sel = this.selectionRange;
           if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
               return;
           let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
           if (context && context.ignoreEvent(event)) {
               if (!wasChanged)
                   this.selectionChanged = false;
               return;
           }
           // Deletions on IE11 fire their events in the wrong order, giving
           // us a selection change event before the DOM changes are
           // reported.
           // Chrome Android has a similar issue when backspacing out a
           // selection (#645).
           if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
               // (Selection.isCollapsed isn't reliable on IE)
               sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
               this.flushSoon();
           else
               this.flush(false);
       }
       readSelectionRange() {
           let { view } = this;
           // The Selection object is broken in shadow roots in Safari. See
           // https://github.com/codemirror/dev/issues/414
           let range = browser.safari && view.root.nodeType == 11 &&
               deepActiveElement(this.dom.ownerDocument) == this.dom &&
               safariSelectionRangeHack(this.view) || getSelection(view.root);
           if (!range || this.selectionRange.eq(range))
               return false;
           let local = hasSelection(this.dom, range);
           // Detect the situation where the browser has, on focus, moved the
           // selection to the start of the content element. Reset it to the
           // position from the editor state.
           if (local && !this.selectionChanged &&
               view.inputState.lastFocusTime > Date.now() - 200 &&
               view.inputState.lastTouchTime < Date.now() - 300 &&
               atElementStart(this.dom, range)) {
               this.view.inputState.lastFocusTime = 0;
               view.docView.updateSelection();
               return false;
           }
           this.selectionRange.setRange(range);
           if (local)
               this.selectionChanged = true;
           return true;
       }
       setSelectionRange(anchor, head) {
           this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
           this.selectionChanged = false;
       }
       clearSelectionRange() {
           this.selectionRange.set(null, 0, null, 0);
       }
       listenForScroll() {
           this.parentCheck = -1;
           let i = 0, changed = null;
           for (let dom = this.dom; dom;) {
               if (dom.nodeType == 1) {
                   if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                       i++;
                   else if (!changed)
                       changed = this.scrollTargets.slice(0, i);
                   if (changed)
                       changed.push(dom);
                   dom = dom.assignedSlot || dom.parentNode;
               }
               else if (dom.nodeType == 11) { // Shadow root
                   dom = dom.host;
               }
               else {
                   break;
               }
           }
           if (i < this.scrollTargets.length && !changed)
               changed = this.scrollTargets.slice(0, i);
           if (changed) {
               for (let dom of this.scrollTargets)
                   dom.removeEventListener("scroll", this.onScroll);
               for (let dom of this.scrollTargets = changed)
                   dom.addEventListener("scroll", this.onScroll);
           }
       }
       ignore(f) {
           if (!this.active)
               return f();
           try {
               this.stop();
               return f();
           }
           finally {
               this.start();
               this.clear();
           }
       }
       start() {
           if (this.active)
               return;
           this.observer.observe(this.dom, observeOptions);
           if (useCharData)
               this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
           this.active = true;
       }
       stop() {
           if (!this.active)
               return;
           this.active = false;
           this.observer.disconnect();
           if (useCharData)
               this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
       }
       // Throw away any pending changes
       clear() {
           this.processRecords();
           this.queue.length = 0;
           this.selectionChanged = false;
       }
       // Chrome Android, especially in combination with GBoard, not only
       // doesn't reliably fire regular key events, but also often
       // surrounds the effect of enter or backspace with a bunch of
       // composition events that, when interrupted, cause text duplication
       // or other kinds of corruption. This hack makes the editor back off
       // from handling DOM changes for a moment when such a key is
       // detected (via beforeinput or keydown), and then tries to flush
       // them or, if that has no effect, dispatches the given key.
       delayAndroidKey(key, keyCode) {
           var _a;
           if (!this.delayedAndroidKey) {
               let flush = () => {
                   let key = this.delayedAndroidKey;
                   if (key) {
                       this.clearDelayedAndroidKey();
                       this.view.inputState.lastKeyCode = key.keyCode;
                       this.view.inputState.lastKeyTime = Date.now();
                       let flushed = this.flush();
                       if (!flushed && key.force)
                           dispatchKey(this.dom, key.key, key.keyCode);
                   }
               };
               this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
           }
           // Since backspace beforeinput is sometimes signalled spuriously,
           // Enter always takes precedence.
           if (!this.delayedAndroidKey || key == "Enter")
               this.delayedAndroidKey = {
                   key, keyCode,
                   // Only run the key handler when no changes are detected if
                   // this isn't coming right after another change, in which case
                   // it is probably part of a weird chain of updates, and should
                   // be ignored if it returns the DOM to its previous state.
                   force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
               };
       }
       clearDelayedAndroidKey() {
           this.win.cancelAnimationFrame(this.flushingAndroidKey);
           this.delayedAndroidKey = null;
           this.flushingAndroidKey = -1;
       }
       flushSoon() {
           if (this.delayedFlush < 0)
               this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
       }
       forceFlush() {
           if (this.delayedFlush >= 0) {
               this.view.win.cancelAnimationFrame(this.delayedFlush);
               this.delayedFlush = -1;
           }
           this.flush();
       }
       pendingRecords() {
           for (let mut of this.observer.takeRecords())
               this.queue.push(mut);
           return this.queue;
       }
       processRecords() {
           let records = this.pendingRecords();
           if (records.length)
               this.queue = [];
           let from = -1, to = -1, typeOver = false;
           for (let record of records) {
               let range = this.readMutation(record);
               if (!range)
                   continue;
               if (range.typeOver)
                   typeOver = true;
               if (from == -1) {
                   ({ from, to } = range);
               }
               else {
                   from = Math.min(range.from, from);
                   to = Math.max(range.to, to);
               }
           }
           return { from, to, typeOver };
       }
       readChange() {
           let { from, to, typeOver } = this.processRecords();
           let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
           if (from < 0 && !newSel)
               return null;
           if (from > -1)
               this.lastChange = Date.now();
           this.view.inputState.lastFocusTime = 0;
           this.selectionChanged = false;
           return new DOMChange(this.view, from, to, typeOver);
       }
       // Apply pending changes, if any
       flush(readSelection = true) {
           // Completely hold off flushing when pending keys are set—the code
           // managing those will make sure processRecords is called and the
           // view is resynchronized after
           if (this.delayedFlush >= 0 || this.delayedAndroidKey)
               return false;
           if (readSelection)
               this.readSelectionRange();
           let domChange = this.readChange();
           if (!domChange)
               return false;
           let startState = this.view.state;
           let handled = applyDOMChange(this.view, domChange);
           // The view wasn't updated
           if (this.view.state == startState)
               this.view.update([]);
           return handled;
       }
       readMutation(rec) {
           let cView = this.view.docView.nearest(rec.target);
           if (!cView || cView.ignoreMutation(rec))
               return null;
           cView.markDirty(rec.type == "attributes");
           if (rec.type == "attributes")
               cView.flags |= 4 /* ViewFlag.AttrsDirty */;
           if (rec.type == "childList") {
               let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
               let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
               return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                   to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
           }
           else if (rec.type == "characterData") {
               return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
           }
           else {
               return null;
           }
       }
       setWindow(win) {
           if (win != this.win) {
               this.removeWindowListeners(this.win);
               this.win = win;
               this.addWindowListeners(this.win);
           }
       }
       addWindowListeners(win) {
           win.addEventListener("resize", this.onResize);
           win.addEventListener("beforeprint", this.onPrint);
           win.addEventListener("scroll", this.onScroll);
           win.document.addEventListener("selectionchange", this.onSelectionChange);
       }
       removeWindowListeners(win) {
           win.removeEventListener("scroll", this.onScroll);
           win.removeEventListener("resize", this.onResize);
           win.removeEventListener("beforeprint", this.onPrint);
           win.document.removeEventListener("selectionchange", this.onSelectionChange);
       }
       destroy() {
           var _a, _b, _c, _d;
           this.stop();
           (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
           (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
           (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
           (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
           for (let dom of this.scrollTargets)
               dom.removeEventListener("scroll", this.onScroll);
           this.removeWindowListeners(this.win);
           clearTimeout(this.parentCheck);
           clearTimeout(this.resizeTimeout);
           this.win.cancelAnimationFrame(this.delayedFlush);
           this.win.cancelAnimationFrame(this.flushingAndroidKey);
       }
   }
   function findChild(cView, dom, dir) {
       while (dom) {
           let curView = ContentView.get(dom);
           if (curView && curView.parent == cView)
               return curView;
           let parent = dom.parentNode;
           dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
       }
       return null;
   }
   // Used to work around a Safari Selection/shadow DOM bug (#414)
   function safariSelectionRangeHack(view) {
       let found = null;
       // Because Safari (at least in 2018-2021) doesn't provide regular
       // access to the selection inside a shadowroot, we have to perform a
       // ridiculous hack to get at it—using `execCommand` to trigger a
       // `beforeInput` event so that we can read the target range from the
       // event.
       function read(event) {
           event.preventDefault();
           event.stopImmediatePropagation();
           found = event.getTargetRanges()[0];
       }
       view.contentDOM.addEventListener("beforeinput", read, true);
       view.dom.ownerDocument.execCommand("indent");
       view.contentDOM.removeEventListener("beforeinput", read, true);
       if (!found)
           return null;
       let anchorNode = found.startContainer, anchorOffset = found.startOffset;
       let focusNode = found.endContainer, focusOffset = found.endOffset;
       let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
       // Since such a range doesn't distinguish between anchor and head,
       // use a heuristic that flips it around if its end matches the
       // current anchor.
       if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
           [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
       return { anchorNode, anchorOffset, focusNode, focusOffset };
   }

   // The editor's update state machine looks something like this:
   //
   //     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
   //                                         ↑      ↓
   //                                         Updating (measure)
   //
   // The difference between 'Idle' and 'Idle (unchecked)' lies in
   // whether a layout check has been scheduled. A regular update through
   // the `update` method updates the DOM in a write-only fashion, and
   // relies on a check (scheduled with `requestAnimationFrame`) to make
   // sure everything is where it should be and the viewport covers the
   // visible code. That check continues to measure and then optionally
   // update until it reaches a coherent state.
   /**
   An editor view represents the editor's user interface. It holds
   the editable DOM surface, and possibly other elements such as the
   line number gutter. It handles events and dispatches state
   transactions for editing actions.
   */
   class EditorView {
       /**
       The current editor state.
       */
       get state() { return this.viewState.state; }
       /**
       To be able to display large documents without consuming too much
       memory or overloading the browser, CodeMirror only draws the
       code that is visible (plus a margin around it) to the DOM. This
       property tells you the extent of the current drawn viewport, in
       document positions.
       */
       get viewport() { return this.viewState.viewport; }
       /**
       When there are, for example, large collapsed ranges in the
       viewport, its size can be a lot bigger than the actual visible
       content. Thus, if you are doing something like styling the
       content in the viewport, it is preferable to only do so for
       these ranges, which are the subset of the viewport that is
       actually drawn.
       */
       get visibleRanges() { return this.viewState.visibleRanges; }
       /**
       Returns false when the editor is entirely scrolled out of view
       or otherwise hidden.
       */
       get inView() { return this.viewState.inView; }
       /**
       Indicates whether the user is currently composing text via
       [IME](https://en.wikipedia.org/wiki/Input_method), and at least
       one change has been made in the current composition.
       */
       get composing() { return this.inputState.composing > 0; }
       /**
       Indicates whether the user is currently in composing state. Note
       that on some platforms, like Android, this will be the case a
       lot, since just putting the cursor on a word starts a
       composition there.
       */
       get compositionStarted() { return this.inputState.composing >= 0; }
       /**
       The document or shadow root that the view lives in.
       */
       get root() { return this._root; }
       /**
       @internal
       */
       get win() { return this.dom.ownerDocument.defaultView || window; }
       /**
       Construct a new view. You'll want to either provide a `parent`
       option, or put `view.dom` into your document after creating a
       view, so that the user can see the editor.
       */
       constructor(config = {}) {
           this.plugins = [];
           this.pluginMap = new Map;
           this.editorAttrs = {};
           this.contentAttrs = {};
           this.bidiCache = [];
           this.destroyed = false;
           /**
           @internal
           */
           this.updateState = 2 /* UpdateState.Updating */;
           /**
           @internal
           */
           this.measureScheduled = -1;
           /**
           @internal
           */
           this.measureRequests = [];
           this.contentDOM = document.createElement("div");
           this.scrollDOM = document.createElement("div");
           this.scrollDOM.tabIndex = -1;
           this.scrollDOM.className = "cm-scroller";
           this.scrollDOM.appendChild(this.contentDOM);
           this.announceDOM = document.createElement("div");
           this.announceDOM.style.cssText = "position: fixed; top: -10000px";
           this.announceDOM.setAttribute("aria-live", "polite");
           this.dom = document.createElement("div");
           this.dom.appendChild(this.announceDOM);
           this.dom.appendChild(this.scrollDOM);
           let { dispatch } = config;
           this.dispatchTransactions = config.dispatchTransactions ||
               (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
               ((trs) => this.update(trs));
           this.dispatch = this.dispatch.bind(this);
           this._root = (config.root || getRoot(config.parent) || document);
           this.viewState = new ViewState(config.state || EditorState.create(config));
           this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
           for (let plugin of this.plugins)
               plugin.update(this);
           this.observer = new DOMObserver(this);
           this.inputState = new InputState(this);
           this.inputState.ensureHandlers(this, this.plugins);
           this.docView = new DocView(this);
           this.mountStyles();
           this.updateAttrs();
           this.updateState = 0 /* UpdateState.Idle */;
           this.requestMeasure();
           if (config.parent)
               config.parent.appendChild(this.dom);
       }
       dispatch(...input) {
           let trs = input.length == 1 && input[0] instanceof Transaction ? input
               : input.length == 1 && Array.isArray(input[0]) ? input[0]
                   : [this.state.update(...input)];
           this.dispatchTransactions(trs, this);
       }
       /**
       Update the view for the given array of transactions. This will
       update the visible document and selection to match the state
       produced by the transactions, and notify view plugins of the
       change. You should usually call
       [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
       as a primitive.
       */
       update(transactions) {
           if (this.updateState != 0 /* UpdateState.Idle */)
               throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
           let redrawn = false, attrsChanged = false, update;
           let state = this.state;
           for (let tr of transactions) {
               if (tr.startState != state)
                   throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
               state = tr.state;
           }
           if (this.destroyed) {
               this.viewState.state = state;
               return;
           }
           let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
           if (transactions.some(tr => tr.annotation(isFocusChange))) {
               this.inputState.notifiedFocused = focus;
               // If a focus-change transaction is being dispatched, set this update flag.
               focusFlag = 1 /* UpdateFlag.Focus */;
           }
           else if (focus != this.inputState.notifiedFocused) {
               this.inputState.notifiedFocused = focus;
               // Schedule a separate focus transaction if necessary, otherwise
               // add a flag to this update
               dispatchFocus = focusChangeTransaction(state, focus);
               if (!dispatchFocus)
                   focusFlag = 1 /* UpdateFlag.Focus */;
           }
           // If there was a pending DOM change, eagerly read it and try to
           // apply it after the given transactions.
           let pendingKey = this.observer.delayedAndroidKey, domChange = null;
           if (pendingKey) {
               this.observer.clearDelayedAndroidKey();
               domChange = this.observer.readChange();
               // Only try to apply DOM changes if the transactions didn't
               // change the doc or selection.
               if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                   domChange = null;
           }
           else {
               this.observer.clear();
           }
           // When the phrases change, redraw the editor
           if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
               return this.setState(state);
           update = ViewUpdate.create(this, state, transactions);
           update.flags |= focusFlag;
           let scrollTarget = this.viewState.scrollTarget;
           try {
               this.updateState = 2 /* UpdateState.Updating */;
               for (let tr of transactions) {
                   if (scrollTarget)
                       scrollTarget = scrollTarget.map(tr.changes);
                   if (tr.scrollIntoView) {
                       let { main } = tr.state.selection;
                       scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                   }
                   for (let e of tr.effects)
                       if (e.is(scrollIntoView$1))
                           scrollTarget = e.value;
               }
               this.viewState.update(update, scrollTarget);
               this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
               if (!update.empty) {
                   this.updatePlugins(update);
                   this.inputState.update(update);
               }
               redrawn = this.docView.update(update);
               if (this.state.facet(styleModule) != this.styleModules)
                   this.mountStyles();
               attrsChanged = this.updateAttrs();
               this.showAnnouncements(transactions);
               this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
           }
           finally {
               this.updateState = 0 /* UpdateState.Idle */;
           }
           if (update.startState.facet(theme) != update.state.facet(theme))
               this.viewState.mustMeasureContent = true;
           if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
               this.requestMeasure();
           if (!update.empty)
               for (let listener of this.state.facet(updateListener))
                   listener(update);
           if (dispatchFocus || domChange)
               Promise.resolve().then(() => {
                   if (dispatchFocus && this.state == dispatchFocus.startState)
                       this.dispatch(dispatchFocus);
                   if (domChange) {
                       if (!applyDOMChange(this, domChange) && pendingKey.force)
                           dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                   }
               });
       }
       /**
       Reset the view to the given state. (This will cause the entire
       document to be redrawn and all view plugins to be reinitialized,
       so you should probably only use it when the new state isn't
       derived from the old state. Otherwise, use
       [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
       */
       setState(newState) {
           if (this.updateState != 0 /* UpdateState.Idle */)
               throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
           if (this.destroyed) {
               this.viewState.state = newState;
               return;
           }
           this.updateState = 2 /* UpdateState.Updating */;
           let hadFocus = this.hasFocus;
           try {
               for (let plugin of this.plugins)
                   plugin.destroy(this);
               this.viewState = new ViewState(newState);
               this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
               this.pluginMap.clear();
               for (let plugin of this.plugins)
                   plugin.update(this);
               this.docView = new DocView(this);
               this.inputState.ensureHandlers(this, this.plugins);
               this.mountStyles();
               this.updateAttrs();
               this.bidiCache = [];
           }
           finally {
               this.updateState = 0 /* UpdateState.Idle */;
           }
           if (hadFocus)
               this.focus();
           this.requestMeasure();
       }
       updatePlugins(update) {
           let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
           if (prevSpecs != specs) {
               let newPlugins = [];
               for (let spec of specs) {
                   let found = prevSpecs.indexOf(spec);
                   if (found < 0) {
                       newPlugins.push(new PluginInstance(spec));
                   }
                   else {
                       let plugin = this.plugins[found];
                       plugin.mustUpdate = update;
                       newPlugins.push(plugin);
                   }
               }
               for (let plugin of this.plugins)
                   if (plugin.mustUpdate != update)
                       plugin.destroy(this);
               this.plugins = newPlugins;
               this.pluginMap.clear();
               this.inputState.ensureHandlers(this, this.plugins);
           }
           else {
               for (let p of this.plugins)
                   p.mustUpdate = update;
           }
           for (let i = 0; i < this.plugins.length; i++)
               this.plugins[i].update(this);
       }
       /**
       @internal
       */
       measure(flush = true) {
           if (this.destroyed)
               return;
           if (this.measureScheduled > -1)
               this.win.cancelAnimationFrame(this.measureScheduled);
           if (this.observer.delayedAndroidKey) {
               this.measureScheduled = -1;
               this.requestMeasure();
               return;
           }
           this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
           if (flush)
               this.observer.forceFlush();
           let updated = null;
           let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
           let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
           if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
               scrollAnchorHeight = -1;
           this.viewState.scrollAnchorHeight = -1;
           try {
               for (let i = 0;; i++) {
                   if (scrollAnchorHeight < 0) {
                       if (isScrolledToBottom(sDOM)) {
                           scrollAnchorPos = -1;
                           scrollAnchorHeight = this.viewState.heightMap.height;
                       }
                       else {
                           let block = this.viewState.scrollAnchorAt(scrollTop);
                           scrollAnchorPos = block.from;
                           scrollAnchorHeight = block.top;
                       }
                   }
                   this.updateState = 1 /* UpdateState.Measuring */;
                   let changed = this.viewState.measure(this);
                   if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                       break;
                   if (i > 5) {
                       console.warn(this.measureRequests.length
                           ? "Measure loop restarted more than 5 times"
                           : "Viewport failed to stabilize");
                       break;
                   }
                   let measuring = [];
                   // Only run measure requests in this cycle when the viewport didn't change
                   if (!(changed & 4 /* UpdateFlag.Viewport */))
                       [this.measureRequests, measuring] = [measuring, this.measureRequests];
                   let measured = measuring.map(m => {
                       try {
                           return m.read(this);
                       }
                       catch (e) {
                           logException(this.state, e);
                           return BadMeasure;
                       }
                   });
                   let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                   update.flags |= changed;
                   if (!updated)
                       updated = update;
                   else
                       updated.flags |= changed;
                   this.updateState = 2 /* UpdateState.Updating */;
                   if (!update.empty) {
                       this.updatePlugins(update);
                       this.inputState.update(update);
                       this.updateAttrs();
                       redrawn = this.docView.update(update);
                   }
                   for (let i = 0; i < measuring.length; i++)
                       if (measured[i] != BadMeasure) {
                           try {
                               let m = measuring[i];
                               if (m.write)
                                   m.write(measured[i], this);
                           }
                           catch (e) {
                               logException(this.state, e);
                           }
                       }
                   if (redrawn)
                       this.docView.updateSelection(true);
                   if (!update.viewportChanged && this.measureRequests.length == 0) {
                       if (this.viewState.editorHeight) {
                           if (this.viewState.scrollTarget) {
                               this.docView.scrollIntoView(this.viewState.scrollTarget);
                               this.viewState.scrollTarget = null;
                               continue;
                           }
                           else {
                               let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                   this.viewState.lineBlockAt(scrollAnchorPos).top;
                               let diff = newAnchorHeight - scrollAnchorHeight;
                               if (diff > 1 || diff < -1) {
                                   scrollTop = scrollTop + diff;
                                   sDOM.scrollTop = scrollTop / this.scaleY;
                                   scrollAnchorHeight = -1;
                                   continue;
                               }
                           }
                       }
                       break;
                   }
               }
           }
           finally {
               this.updateState = 0 /* UpdateState.Idle */;
               this.measureScheduled = -1;
           }
           if (updated && !updated.empty)
               for (let listener of this.state.facet(updateListener))
                   listener(updated);
       }
       /**
       Get the CSS classes for the currently active editor themes.
       */
       get themeClasses() {
           return baseThemeID + " " +
               (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
               this.state.facet(theme);
       }
       updateAttrs() {
           let editorAttrs = attrsFromFacet(this, editorAttributes, {
               class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
           });
           let contentAttrs = {
               spellcheck: "false",
               autocorrect: "off",
               autocapitalize: "off",
               translate: "no",
               contenteditable: !this.state.facet(editable) ? "false" : "true",
               class: "cm-content",
               style: `${browser.tabSize}: ${this.state.tabSize}`,
               role: "textbox",
               "aria-multiline": "true"
           };
           if (this.state.readOnly)
               contentAttrs["aria-readonly"] = "true";
           attrsFromFacet(this, contentAttributes, contentAttrs);
           let changed = this.observer.ignore(() => {
               let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
               let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
               return changedContent || changedEditor;
           });
           this.editorAttrs = editorAttrs;
           this.contentAttrs = contentAttrs;
           return changed;
       }
       showAnnouncements(trs) {
           let first = true;
           for (let tr of trs)
               for (let effect of tr.effects)
                   if (effect.is(EditorView.announce)) {
                       if (first)
                           this.announceDOM.textContent = "";
                       first = false;
                       let div = this.announceDOM.appendChild(document.createElement("div"));
                       div.textContent = effect.value;
                   }
       }
       mountStyles() {
           this.styleModules = this.state.facet(styleModule);
           let nonce = this.state.facet(EditorView.cspNonce);
           StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse(), nonce ? { nonce } : undefined);
       }
       readMeasured() {
           if (this.updateState == 2 /* UpdateState.Updating */)
               throw new Error("Reading the editor layout isn't allowed during an update");
           if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
               this.measure(false);
       }
       /**
       Schedule a layout measurement, optionally providing callbacks to
       do custom DOM measuring followed by a DOM write phase. Using
       this is preferable reading DOM layout directly from, for
       example, an event handler, because it'll make sure measuring and
       drawing done by other components is synchronized, avoiding
       unnecessary DOM layout computations.
       */
       requestMeasure(request) {
           if (this.measureScheduled < 0)
               this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
           if (request) {
               if (this.measureRequests.indexOf(request) > -1)
                   return;
               if (request.key != null)
                   for (let i = 0; i < this.measureRequests.length; i++) {
                       if (this.measureRequests[i].key === request.key) {
                           this.measureRequests[i] = request;
                           return;
                       }
                   }
               this.measureRequests.push(request);
           }
       }
       /**
       Get the value of a specific plugin, if present. Note that
       plugins that crash can be dropped from a view, so even when you
       know you registered a given plugin, it is recommended to check
       the return value of this method.
       */
       plugin(plugin) {
           let known = this.pluginMap.get(plugin);
           if (known === undefined || known && known.spec != plugin)
               this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
           return known && known.update(this).value;
       }
       /**
       The top position of the document, in screen coordinates. This
       may be negative when the editor is scrolled down. Points
       directly to the top of the first line, not above the padding.
       */
       get documentTop() {
           return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
       }
       /**
       Reports the padding above and below the document.
       */
       get documentPadding() {
           return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
       }
       /**
       If the editor is transformed with CSS, this provides the scale
       along the X axis. Otherwise, it will just be 1. Note that
       transforms other than translation and scaling are not supported.
       */
       get scaleX() { return this.viewState.scaleX; }
       /**
       Provide the CSS transformed scale along the Y axis.
       */
       get scaleY() { return this.viewState.scaleY; }
       /**
       Find the text line or block widget at the given vertical
       position (which is interpreted as relative to the [top of the
       document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
       */
       elementAtHeight(height) {
           this.readMeasured();
           return this.viewState.elementAtHeight(height);
       }
       /**
       Find the line block (see
       [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
       height, again interpreted relative to the [top of the
       document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
       */
       lineBlockAtHeight(height) {
           this.readMeasured();
           return this.viewState.lineBlockAtHeight(height);
       }
       /**
       Get the extent and vertical position of all [line
       blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
       are relative to the [top of the
       document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
       */
       get viewportLineBlocks() {
           return this.viewState.viewportLines;
       }
       /**
       Find the line block around the given document position. A line
       block is a range delimited on both sides by either a
       non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
       start/end of the document. It will usually just hold a line of
       text, but may be broken into multiple textblocks by block
       widgets.
       */
       lineBlockAt(pos) {
           return this.viewState.lineBlockAt(pos);
       }
       /**
       The editor's total content height.
       */
       get contentHeight() {
           return this.viewState.contentHeight;
       }
       /**
       Move a cursor position by [grapheme
       cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
       the motion is away from the line start, or towards it. In
       bidirectional text, the line is traversed in visual order, using
       the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
       When the start position was the last one on the line, the
       returned position will be across the line break. If there is no
       further line, the original position is returned.
       
       By default, this method moves over a single cluster. The
       optional `by` argument can be used to move across more. It will
       be called with the first cluster as argument, and should return
       a predicate that determines, for each subsequent cluster,
       whether it should also be moved over.
       */
       moveByChar(start, forward, by) {
           return skipAtoms(this, start, moveByChar(this, start, forward, by));
       }
       /**
       Move a cursor position across the next group of either
       [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
       non-whitespace characters.
       */
       moveByGroup(start, forward) {
           return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
       }
       /**
       Move to the next line boundary in the given direction. If
       `includeWrap` is true, line wrapping is on, and there is a
       further wrap point on the current line, the wrap point will be
       returned. Otherwise this function will return the start or end
       of the line.
       */
       moveToLineBoundary(start, forward, includeWrap = true) {
           return moveToLineBoundary(this, start, forward, includeWrap);
       }
       /**
       Move a cursor position vertically. When `distance` isn't given,
       it defaults to moving to the next line (including wrapped
       lines). Otherwise, `distance` should provide a positive distance
       in pixels.
       
       When `start` has a
       [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
       motion will use that as a target horizontal position. Otherwise,
       the cursor's own horizontal position is used. The returned
       cursor will have its goal column set to whichever column was
       used.
       */
       moveVertically(start, forward, distance) {
           return skipAtoms(this, start, moveVertically(this, start, forward, distance));
       }
       /**
       Find the DOM parent node and offset (child offset if `node` is
       an element, character offset when it is a text node) at the
       given document position.
       
       Note that for positions that aren't currently in
       `visibleRanges`, the resulting DOM position isn't necessarily
       meaningful (it may just point before or after a placeholder
       element).
       */
       domAtPos(pos) {
           return this.docView.domAtPos(pos);
       }
       /**
       Find the document position at the given DOM node. Can be useful
       for associating positions with DOM events. Will raise an error
       when `node` isn't part of the editor content.
       */
       posAtDOM(node, offset = 0) {
           return this.docView.posFromDOM(node, offset);
       }
       posAtCoords(coords, precise = true) {
           this.readMeasured();
           return posAtCoords(this, coords, precise);
       }
       /**
       Get the screen coordinates at the given document position.
       `side` determines whether the coordinates are based on the
       element before (-1) or after (1) the position (if no element is
       available on the given side, the method will transparently use
       another strategy to get reasonable coordinates).
       */
       coordsAtPos(pos, side = 1) {
           this.readMeasured();
           let rect = this.docView.coordsAt(pos, side);
           if (!rect || rect.left == rect.right)
               return rect;
           let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
           let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
           return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
       }
       /**
       Return the rectangle around a given character. If `pos` does not
       point in front of a character that is in the viewport and
       rendered (i.e. not replaced, not a line break), this will return
       null. For space characters that are a line wrap point, this will
       return the position before the line break.
       */
       coordsForChar(pos) {
           this.readMeasured();
           return this.docView.coordsForChar(pos);
       }
       /**
       The default width of a character in the editor. May not
       accurately reflect the width of all characters (given variable
       width fonts or styling of invididual ranges).
       */
       get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
       /**
       The default height of a line in the editor. May not be accurate
       for all lines.
       */
       get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
       /**
       The text direction
       ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
       CSS property) of the editor's content element.
       */
       get textDirection() { return this.viewState.defaultTextDirection; }
       /**
       Find the text direction of the block at the given position, as
       assigned by CSS. If
       [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
       isn't enabled, or the given position is outside of the viewport,
       this will always return the same as
       [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
       this may trigger a DOM layout.
       */
       textDirectionAt(pos) {
           let perLine = this.state.facet(perLineTextDirection);
           if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
               return this.textDirection;
           this.readMeasured();
           return this.docView.textDirectionAt(pos);
       }
       /**
       Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
       (as determined by the
       [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
       CSS property of its content element).
       */
       get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
       /**
       Returns the bidirectional text structure of the given line
       (which should be in the current document) as an array of span
       objects. The order of these spans matches the [text
       direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
       left-to-right, the leftmost spans come first, otherwise the
       rightmost spans come first.
       */
       bidiSpans(line) {
           if (line.length > MaxBidiLine)
               return trivialOrder(line.length);
           let dir = this.textDirectionAt(line.from), isolates;
           for (let entry of this.bidiCache) {
               if (entry.from == line.from && entry.dir == dir &&
                   (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))
                   return entry.order;
           }
           if (!isolates)
               isolates = getIsolatedRanges(this, line.from, line.to);
           let order = computeOrder(line.text, dir, isolates);
           this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
           return order;
       }
       /**
       Check whether the editor has focus.
       */
       get hasFocus() {
           var _a;
           // Safari return false for hasFocus when the context menu is open
           // or closing, which leads us to ignore selection changes from the
           // context menu because it looks like the editor isn't focused.
           // This kludges around that.
           return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
               this.root.activeElement == this.contentDOM;
       }
       /**
       Put focus on the editor.
       */
       focus() {
           this.observer.ignore(() => {
               focusPreventScroll(this.contentDOM);
               this.docView.updateSelection();
           });
       }
       /**
       Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
       necessary when moving the editor's existing DOM to a new window or shadow root.
       */
       setRoot(root) {
           if (this._root != root) {
               this._root = root;
               this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
               this.mountStyles();
           }
       }
       /**
       Clean up this editor view, removing its element from the
       document, unregistering event handlers, and notifying
       plugins. The view instance can no longer be used after
       calling this.
       */
       destroy() {
           for (let plugin of this.plugins)
               plugin.destroy(this);
           this.plugins = [];
           this.inputState.destroy();
           this.dom.remove();
           this.observer.destroy();
           if (this.measureScheduled > -1)
               this.win.cancelAnimationFrame(this.measureScheduled);
           this.destroyed = true;
       }
       /**
       Returns an effect that can be
       [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
       cause it to scroll the given position or range into view.
       */
       static scrollIntoView(pos, options = {}) {
           return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
       }
       /**
       Returns an extension that can be used to add DOM event handlers.
       The value should be an object mapping event names to handler
       functions. For any given event, such functions are ordered by
       extension precedence, and the first handler to return true will
       be assumed to have handled that event, and no other handlers or
       built-in behavior will be activated for it. These are registered
       on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
       for `scroll` handlers, which will be called any time the
       editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
       its parent nodes is scrolled.
       */
       static domEventHandlers(handlers) {
           return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
       }
       /**
       Create a theme extension. The first argument can be a
       [`style-mod`](https://github.com/marijnh/style-mod#documentation)
       style spec providing the styles for the theme. These will be
       prefixed with a generated class for the style.
       
       Because the selectors will be prefixed with a scope class, rule
       that directly match the editor's [wrapper
       element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
       added—need to be explicitly differentiated by adding an `&` to
       the selector for that element—for example
       `&.cm-focused`.
       
       When `dark` is set to true, the theme will be marked as dark,
       which will cause the `&dark` rules from [base
       themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
       `&light` when a light theme is active).
       */
       static theme(spec, options) {
           let prefix = StyleModule.newName();
           let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
           if (options && options.dark)
               result.push(darkTheme.of(true));
           return result;
       }
       /**
       Create an extension that adds styles to the base theme. Like
       with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
       place of the editor wrapper element when directly targeting
       that. You can also use `&dark` or `&light` instead to only
       target editors with a dark or light theme.
       */
       static baseTheme(spec) {
           return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
       }
       /**
       Retrieve an editor view instance from the view's DOM
       representation.
       */
       static findFromDOM(dom) {
           var _a;
           let content = dom.querySelector(".cm-content");
           let cView = content && ContentView.get(content) || ContentView.get(dom);
           return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
       }
   }
   /**
   Facet to add a [style
   module](https://github.com/marijnh/style-mod#documentation) to
   an editor view. The view will ensure that the module is
   mounted in its [document
   root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
   */
   EditorView.styleModule = styleModule;
   /**
   An input handler can override the way changes to the editable
   DOM content are handled. Handlers are passed the document
   positions between which the change was found, and the new
   content. When one returns true, no further input handlers are
   called and the default behavior is prevented.

   The `insert` argument can be used to get the default transaction
   that would be applied for this input. This can be useful when
   dispatching the custom behavior as a separate transaction.
   */
   EditorView.inputHandler = inputHandler$1;
   /**
   This facet can be used to provide functions that create effects
   to be dispatched when the editor's focus state changes.
   */
   EditorView.focusChangeEffect = focusChangeEffect;
   /**
   By default, the editor assumes all its content has the same
   [text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
   value to make it read the text direction of every (rendered)
   line separately.
   */
   EditorView.perLineTextDirection = perLineTextDirection;
   /**
   Allows you to provide a function that should be called when the
   library catches an exception from an extension (mostly from view
   plugins, but may be used by other extensions to route exceptions
   from user-code-provided callbacks). This is mostly useful for
   debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
   */
   EditorView.exceptionSink = exceptionSink;
   /**
   A facet that can be used to register a function to be called
   every time the view updates.
   */
   EditorView.updateListener = updateListener;
   /**
   Facet that controls whether the editor content DOM is editable.
   When its highest-precedence value is `false`, the element will
   not have its `contenteditable` attribute set. (Note that this
   doesn't affect API calls that change the editor content, even
   when those are bound to keys or buttons. See the
   [`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
   */
   EditorView.editable = editable;
   /**
   Allows you to influence the way mouse selection happens. The
   functions in this facet will be called for a `mousedown` event
   on the editor, and can return an object that overrides the way a
   selection is computed from that mouse click or drag.
   */
   EditorView.mouseSelectionStyle = mouseSelectionStyle;
   /**
   Facet used to configure whether a given selection drag event
   should move or copy the selection. The given predicate will be
   called with the `mousedown` event, and can return `true` when
   the drag should move the content.
   */
   EditorView.dragMovesSelection = dragMovesSelection$1;
   /**
   Facet used to configure whether a given selecting click adds a
   new range to the existing selection or replaces it entirely. The
   default behavior is to check `event.metaKey` on macOS, and
   `event.ctrlKey` elsewhere.
   */
   EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
   /**
   A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
   are shown in the view. Decorations can be provided in two
   ways—directly, or via a function that takes an editor view.

   Only decoration sets provided directly are allowed to influence
   the editor's vertical layout structure. The ones provided as
   functions are called _after_ the new viewport has been computed,
   and thus **must not** introduce block widgets or replacing
   decorations that cover line breaks.

   If you want decorated ranges to behave like atomic units for
   cursor motion and deletion purposes, also provide the range set
   containing the decorations to
   [`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
   */
   EditorView.decorations = decorations;
   /**
   Used to provide ranges that should be treated as atoms as far as
   cursor motion is concerned. This causes methods like
   [`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
   [`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
   commands built on top of them) to skip across such regions when
   a selection endpoint would enter them. This does _not_ prevent
   direct programmatic [selection
   updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
   regions.
   */
   EditorView.atomicRanges = atomicRanges;
   /**
   When range decorations add a `unicode-bidi: isolate` style, they
   should also include a
   [`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
   in their decoration spec, and be exposed through this facet, so
   that the editor can compute the proper text order. (Other values
   for `unicode-bidi`, except of course `normal`, are not
   supported.)
   */
   EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
   /**
   Facet that allows extensions to provide additional scroll
   margins (space around the sides of the scrolling element that
   should be considered invisible). This can be useful when the
   plugin introduces elements that cover part of that element (for
   example a horizontally fixed gutter).
   */
   EditorView.scrollMargins = scrollMargins;
   /**
   This facet records whether a dark theme is active. The extension
   returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
   includes an instance of this when the `dark` option is set to
   true.
   */
   EditorView.darkTheme = darkTheme;
   /**
   Provides a Content Security Policy nonce to use when creating
   the style sheets for the editor. Holds the empty string when no
   nonce has been provided.
   */
   EditorView.cspNonce = /*@__PURE__*/Facet.define({ combine: values => values.length ? values[0] : "" });
   /**
   Facet that provides additional DOM attributes for the editor's
   editable DOM element.
   */
   EditorView.contentAttributes = contentAttributes;
   /**
   Facet that provides DOM attributes for the editor's outer
   element.
   */
   EditorView.editorAttributes = editorAttributes;
   /**
   An extension that enables line wrapping in the editor (by
   setting CSS `white-space` to `pre-wrap` in the content).
   */
   EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
   /**
   State effect used to include screen reader announcements in a
   transaction. These will be added to the DOM in a visually hidden
   element with `aria-live="polite"` set, and should be used to
   describe effects that are visually obvious but may not be
   noticed by screen reader users (such as moving to the next
   search match).
   */
   EditorView.announce = /*@__PURE__*/StateEffect.define();
   // Maximum line length for which we compute accurate bidi info
   const MaxBidiLine = 4096;
   const BadMeasure = {};
   class CachedOrder {
       constructor(from, to, dir, isolates, fresh, order) {
           this.from = from;
           this.to = to;
           this.dir = dir;
           this.isolates = isolates;
           this.fresh = fresh;
           this.order = order;
       }
       static update(cache, changes) {
           if (changes.empty && !cache.some(c => c.fresh))
               return cache;
           let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
           for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
               let entry = cache[i];
               if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                   result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
           }
           return result;
       }
   }
   function attrsFromFacet(view, facet, base) {
       for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
           let source = sources[i], value = typeof source == "function" ? source(view) : source;
           if (value)
               combineAttrs(value, base);
       }
       return base;
   }

   const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
   function normalizeKeyName(name, platform) {
       const parts = name.split(/-(?!$)/);
       let result = parts[parts.length - 1];
       if (result == "Space")
           result = " ";
       let alt, ctrl, shift, meta;
       for (let i = 0; i < parts.length - 1; ++i) {
           const mod = parts[i];
           if (/^(cmd|meta|m)$/i.test(mod))
               meta = true;
           else if (/^a(lt)?$/i.test(mod))
               alt = true;
           else if (/^(c|ctrl|control)$/i.test(mod))
               ctrl = true;
           else if (/^s(hift)?$/i.test(mod))
               shift = true;
           else if (/^mod$/i.test(mod)) {
               if (platform == "mac")
                   meta = true;
               else
                   ctrl = true;
           }
           else
               throw new Error("Unrecognized modifier name: " + mod);
       }
       if (alt)
           result = "Alt-" + result;
       if (ctrl)
           result = "Ctrl-" + result;
       if (meta)
           result = "Meta-" + result;
       if (shift)
           result = "Shift-" + result;
       return result;
   }
   function modifiers(name, event, shift) {
       if (event.altKey)
           name = "Alt-" + name;
       if (event.ctrlKey)
           name = "Ctrl-" + name;
       if (event.metaKey)
           name = "Meta-" + name;
       if (shift !== false && event.shiftKey)
           name = "Shift-" + name;
       return name;
   }
   const handleKeyEvents = /*@__PURE__*/Prec.default(/*@__PURE__*/EditorView.domEventHandlers({
       keydown(event, view) {
           return runHandlers(getKeymap(view.state), event, view, "editor");
       }
   }));
   /**
   Facet used for registering keymaps.

   You can add multiple keymaps to an editor. Their priorities
   determine their precedence (the ones specified early or with high
   priority get checked first). When a handler has returned `true`
   for a given key, no further handlers are called.
   */
   const keymap = /*@__PURE__*/Facet.define({ enables: handleKeyEvents });
   const Keymaps = /*@__PURE__*/new WeakMap();
   // This is hidden behind an indirection, rather than directly computed
   // by the facet, to keep internal types out of the facet's type.
   function getKeymap(state) {
       let bindings = state.facet(keymap);
       let map = Keymaps.get(bindings);
       if (!map)
           Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
       return map;
   }
   /**
   Run the key handlers registered for a given scope. The event
   object should be a `"keydown"` event. Returns true if any of the
   handlers handled it.
   */
   function runScopeHandlers(view, event, scope) {
       return runHandlers(getKeymap(view.state), event, view, scope);
   }
   let storedPrefix = null;
   const PrefixTimeout = 4000;
   function buildKeymap(bindings, platform = currentPlatform) {
       let bound = Object.create(null);
       let isPrefix = Object.create(null);
       let checkPrefix = (name, is) => {
           let current = isPrefix[name];
           if (current == null)
               isPrefix[name] = is;
           else if (current != is)
               throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
       };
       let add = (scope, key, command, preventDefault, stopPropagation) => {
           var _a, _b;
           let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
           let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
           for (let i = 1; i < parts.length; i++) {
               let prefix = parts.slice(0, i).join(" ");
               checkPrefix(prefix, true);
               if (!scopeObj[prefix])
                   scopeObj[prefix] = {
                       preventDefault: true,
                       stopPropagation: false,
                       run: [(view) => {
                               let ourObj = storedPrefix = { view, prefix, scope };
                               setTimeout(() => { if (storedPrefix == ourObj)
                                   storedPrefix = null; }, PrefixTimeout);
                               return true;
                           }]
                   };
           }
           let full = parts.join(" ");
           checkPrefix(full, false);
           let binding = scopeObj[full] || (scopeObj[full] = {
               preventDefault: false,
               stopPropagation: false,
               run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
           });
           if (command)
               binding.run.push(command);
           if (preventDefault)
               binding.preventDefault = true;
           if (stopPropagation)
               binding.stopPropagation = true;
       };
       for (let b of bindings) {
           let scopes = b.scope ? b.scope.split(" ") : ["editor"];
           if (b.any)
               for (let scope of scopes) {
                   let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                   if (!scopeObj._any)
                       scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                   for (let key in scopeObj)
                       scopeObj[key].run.push(b.any);
               }
           let name = b[platform] || b.key;
           if (!name)
               continue;
           for (let scope of scopes) {
               add(scope, name, b.run, b.preventDefault, b.stopPropagation);
               if (b.shift)
                   add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
           }
       }
       return bound;
   }
   function runHandlers(map, event, view, scope) {
       let name = keyName(event);
       let charCode = codePointAt(name, 0), isChar = codePointSize(charCode) == name.length && name != " ";
       let prefix = "", handled = false, prevented = false, stopPropagation = false;
       if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
           prefix = storedPrefix.prefix + " ";
           if (modifierCodes.indexOf(event.keyCode) < 0) {
               prevented = true;
               storedPrefix = null;
           }
       }
       let ran = new Set;
       let runFor = (binding) => {
           if (binding) {
               for (let cmd of binding.run)
                   if (!ran.has(cmd)) {
                       ran.add(cmd);
                       if (cmd(view, event)) {
                           if (binding.stopPropagation)
                               stopPropagation = true;
                           return true;
                       }
                   }
               if (binding.preventDefault) {
                   if (binding.stopPropagation)
                       stopPropagation = true;
                   prevented = true;
               }
           }
           return false;
       };
       let scopeObj = map[scope], baseName, shiftName;
       if (scopeObj) {
           if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
               handled = true;
           }
           else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
               // Ctrl-Alt may be used for AltGr on Windows
               !(browser.windows && event.ctrlKey && event.altKey) &&
               (baseName = base[event.keyCode]) && baseName != name) {
               if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                   handled = true;
               }
               else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName &&
                   runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                   handled = true;
               }
           }
           else if (isChar && event.shiftKey &&
               runFor(scopeObj[prefix + modifiers(name, event, true)])) {
               handled = true;
           }
           if (!handled && runFor(scopeObj._any))
               handled = true;
       }
       if (prevented)
           handled = true;
       if (handled && stopPropagation)
           event.stopPropagation();
       return handled;
   }

   /**
   Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
   a rectangle at a given set of coordinates.
   */
   class RectangleMarker {
       /**
       Create a marker with the given class and dimensions. If `width`
       is null, the DOM element will get no width style.
       */
       constructor(className, left, top, width, height) {
           this.className = className;
           this.left = left;
           this.top = top;
           this.width = width;
           this.height = height;
       }
       draw() {
           let elt = document.createElement("div");
           elt.className = this.className;
           this.adjust(elt);
           return elt;
       }
       update(elt, prev) {
           if (prev.className != this.className)
               return false;
           this.adjust(elt);
           return true;
       }
       adjust(elt) {
           elt.style.left = this.left + "px";
           elt.style.top = this.top + "px";
           if (this.width != null)
               elt.style.width = this.width + "px";
           elt.style.height = this.height + "px";
       }
       eq(p) {
           return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
               this.className == p.className;
       }
       /**
       Create a set of rectangles for the given selection range,
       assigning them theclass`className`. Will create a single
       rectangle for empty ranges, and a set of selection-style
       rectangles covering the range's content (in a bidi-aware
       way) for non-empty ones.
       */
       static forRange(view, className, range) {
           if (range.empty) {
               let pos = view.coordsAtPos(range.head, range.assoc || 1);
               if (!pos)
                   return [];
               let base = getBase(view);
               return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
           }
           else {
               return rectanglesForRange(view, className, range);
           }
       }
   }
   function getBase(view) {
       let rect = view.scrollDOM.getBoundingClientRect();
       let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
       return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
   }
   function wrappedLine(view, pos, inside) {
       let range = EditorSelection.cursor(pos);
       return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
           to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),
           type: BlockType.Text };
   }
   function rectanglesForRange(view, className, range) {
       if (range.to <= view.viewport.from || range.from >= view.viewport.to)
           return [];
       let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
       let ltr = view.textDirection == Direction.LTR;
       let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
       let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
       let leftSide = contentRect.left +
           (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
       let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
       let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
       let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
       let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
       if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
           visualStart = wrappedLine(view, from, visualStart);
       if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
           visualEnd = wrappedLine(view, to, visualEnd);
       if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
           return pieces(drawForLine(range.from, range.to, visualStart));
       }
       else {
           let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
           let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
           let between = [];
           if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
               startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
               between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
           else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
               top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
           return pieces(top).concat(between).concat(pieces(bottom));
       }
       function piece(left, top, right, bottom) {
           return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);
       }
       function pieces({ top, bottom, horizontal }) {
           let pieces = [];
           for (let i = 0; i < horizontal.length; i += 2)
               pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
           return pieces;
       }
       // Gets passed from/to in line-local positions
       function drawForLine(from, to, line) {
           let top = 1e9, bottom = -1e9, horizontal = [];
           function addSpan(from, fromOpen, to, toOpen, dir) {
               // Passing 2/-2 is a kludge to force the view to return
               // coordinates on the proper side of block widgets, since
               // normalizing the side there, though appropriate for most
               // coordsAtPos queries, would break selection drawing.
               let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
               let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
               if (!fromCoords || !toCoords)
                   return;
               top = Math.min(fromCoords.top, toCoords.top, top);
               bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
               if (dir == Direction.LTR)
                   horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
               else
                   horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
           }
           let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
           // Split the range by visible range and document line
           for (let r of view.visibleRanges)
               if (r.to > start && r.from < end) {
                   for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                       let docLine = view.state.doc.lineAt(pos);
                       for (let span of view.bidiSpans(docLine)) {
                           let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                           if (spanFrom >= endPos)
                               break;
                           if (spanTo > pos)
                               addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                       }
                       pos = docLine.to + 1;
                       if (pos >= endPos)
                           break;
                   }
               }
           if (horizontal.length == 0)
               addSpan(start, from == null, end, to == null, view.textDirection);
           return { top, bottom, horizontal };
       }
       function drawForWidget(block, top) {
           let y = contentRect.top + (top ? block.top : block.bottom);
           return { top: y, bottom: y, horizontal: [] };
       }
   }
   function sameMarker(a, b) {
       return a.constructor == b.constructor && a.eq(b);
   }
   class LayerView {
       constructor(view, layer) {
           this.view = view;
           this.layer = layer;
           this.drawn = [];
           this.scaleX = 1;
           this.scaleY = 1;
           this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
           this.dom = view.scrollDOM.appendChild(document.createElement("div"));
           this.dom.classList.add("cm-layer");
           if (layer.above)
               this.dom.classList.add("cm-layer-above");
           if (layer.class)
               this.dom.classList.add(layer.class);
           this.scale();
           this.dom.setAttribute("aria-hidden", "true");
           this.setOrder(view.state);
           view.requestMeasure(this.measureReq);
           if (layer.mount)
               layer.mount(this.dom, view);
       }
       update(update) {
           if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
               this.setOrder(update.state);
           if (this.layer.update(update, this.dom) || update.geometryChanged) {
               this.scale();
               update.view.requestMeasure(this.measureReq);
           }
       }
       setOrder(state) {
           let pos = 0, order = state.facet(layerOrder);
           while (pos < order.length && order[pos] != this.layer)
               pos++;
           this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
       }
       measure() {
           return this.layer.markers(this.view);
       }
       scale() {
           let { scaleX, scaleY } = this.view;
           if (scaleX != this.scaleX || scaleY != this.scaleY) {
               this.scaleX = scaleX;
               this.scaleY = scaleY;
               this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
           }
       }
       draw(markers) {
           if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
               let old = this.dom.firstChild, oldI = 0;
               for (let marker of markers) {
                   if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                       marker.update(old, this.drawn[oldI])) {
                       old = old.nextSibling;
                       oldI++;
                   }
                   else {
                       this.dom.insertBefore(marker.draw(), old);
                   }
               }
               while (old) {
                   let next = old.nextSibling;
                   old.remove();
                   old = next;
               }
               this.drawn = markers;
           }
       }
       destroy() {
           if (this.layer.destroy)
               this.layer.destroy(this.dom, this.view);
           this.dom.remove();
       }
   }
   const layerOrder = /*@__PURE__*/Facet.define();
   /**
   Define a layer.
   */
   function layer(config) {
       return [
           ViewPlugin.define(v => new LayerView(v, config)),
           layerOrder.of(config)
       ];
   }

   const CanHidePrimary = !browser.ios; // FIXME test IE
   const selectionConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           return combineConfig(configs, {
               cursorBlinkRate: 1200,
               drawRangeCursor: true
           }, {
               cursorBlinkRate: (a, b) => Math.min(a, b),
               drawRangeCursor: (a, b) => a || b
           });
       }
   });
   /**
   Returns an extension that hides the browser's native selection and
   cursor, replacing the selection with a background behind the text
   (with the `cm-selectionBackground` class), and the
   cursors with elements overlaid over the code (using
   `cm-cursor-primary` and `cm-cursor-secondary`).

   This allows the editor to display secondary selection ranges, and
   tends to produce a type of selection more in line with that users
   expect in a text editor (the native selection styling will often
   leave gaps between lines and won't fill the horizontal space after
   a line when the selection continues past it).

   It does have a performance cost, in that it requires an extra DOM
   layout cycle for many updates (the selection is drawn based on DOM
   layout information that's only available after laying out the
   content).
   */
   function drawSelection(config = {}) {
       return [
           selectionConfig.of(config),
           cursorLayer,
           selectionLayer,
           hideNativeSelection,
           nativeSelectionHidden.of(true)
       ];
   }
   function configChanged(update) {
       return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
   }
   const cursorLayer = /*@__PURE__*/layer({
       above: true,
       markers(view) {
           let { state } = view, conf = state.facet(selectionConfig);
           let cursors = [];
           for (let r of state.selection.ranges) {
               let prim = r == state.selection.main;
               if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                   let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                   let cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                   for (let piece of RectangleMarker.forRange(view, className, cursor))
                       cursors.push(piece);
               }
           }
           return cursors;
       },
       update(update, dom) {
           if (update.transactions.some(tr => tr.selection))
               dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
           let confChange = configChanged(update);
           if (confChange)
               setBlinkRate(update.state, dom);
           return update.docChanged || update.selectionSet || confChange;
       },
       mount(dom, view) {
           setBlinkRate(view.state, dom);
       },
       class: "cm-cursorLayer"
   });
   function setBlinkRate(state, dom) {
       dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
   }
   const selectionLayer = /*@__PURE__*/layer({
       above: false,
       markers(view) {
           return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
               .reduce((a, b) => a.concat(b));
       },
       update(update, dom) {
           return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
       },
       class: "cm-selectionLayer"
   });
   const themeSpec = {
       ".cm-line": {
           "& ::selection": { backgroundColor: "transparent !important" },
           "&::selection": { backgroundColor: "transparent !important" }
       }
   };
   if (CanHidePrimary)
       themeSpec[".cm-line"].caretColor = "transparent !important";
   const hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));

   const setDropCursorPos = /*@__PURE__*/StateEffect.define({
       map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
   });
   const dropCursorPos = /*@__PURE__*/StateField.define({
       create() { return null; },
       update(pos, tr) {
           if (pos != null)
               pos = tr.changes.mapPos(pos);
           return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
       }
   });
   const drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.view = view;
           this.cursor = null;
           this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
       }
       update(update) {
           var _a;
           let cursorPos = update.state.field(dropCursorPos);
           if (cursorPos == null) {
               if (this.cursor != null) {
                   (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                   this.cursor = null;
               }
           }
           else {
               if (!this.cursor) {
                   this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                   this.cursor.className = "cm-dropCursor";
               }
               if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                   this.view.requestMeasure(this.measureReq);
           }
       }
       readPos() {
           let { view } = this;
           let pos = view.state.field(dropCursorPos);
           let rect = pos != null && view.coordsAtPos(pos);
           if (!rect)
               return null;
           let outer = view.scrollDOM.getBoundingClientRect();
           return {
               left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
               top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
               height: rect.bottom - rect.top
           };
       }
       drawCursor(pos) {
           if (this.cursor) {
               let { scaleX, scaleY } = this.view;
               if (pos) {
                   this.cursor.style.left = pos.left / scaleX + "px";
                   this.cursor.style.top = pos.top / scaleY + "px";
                   this.cursor.style.height = pos.height / scaleY + "px";
               }
               else {
                   this.cursor.style.left = "-100000px";
               }
           }
       }
       destroy() {
           if (this.cursor)
               this.cursor.remove();
       }
       setDropPos(pos) {
           if (this.view.state.field(dropCursorPos) != pos)
               this.view.dispatch({ effects: setDropCursorPos.of(pos) });
       }
   }, {
       eventHandlers: {
           dragover(event) {
               this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
           },
           dragleave(event) {
               if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                   this.setDropPos(null);
           },
           dragend() {
               this.setDropPos(null);
           },
           drop() {
               this.setDropPos(null);
           }
       }
   });
   /**
   Draws a cursor at the current drop position when something is
   dragged over the editor.
   */
   function dropCursor() {
       return [dropCursorPos, drawDropCursor];
   }

   function iterMatches(doc, re, from, to, f) {
       re.lastIndex = 0;
       for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
           if (!cursor.lineBreak)
               while (m = re.exec(cursor.value))
                   f(pos + m.index, m);
       }
   }
   function matchRanges(view, maxLength) {
       let visible = view.visibleRanges;
       if (visible.length == 1 && visible[0].from == view.viewport.from &&
           visible[0].to == view.viewport.to)
           return visible;
       let result = [];
       for (let { from, to } of visible) {
           from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
           to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
           if (result.length && result[result.length - 1].to >= from)
               result[result.length - 1].to = to;
           else
               result.push({ from, to });
       }
       return result;
   }
   /**
   Helper class used to make it easier to maintain decorations on
   visible code that matches a given regular expression. To be used
   in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
   represent a matching configuration.
   */
   class MatchDecorator {
       /**
       Create a decorator.
       */
       constructor(config) {
           const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
           if (!regexp.global)
               throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
           this.regexp = regexp;
           if (decorate) {
               this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
           }
           else if (typeof decoration == "function") {
               this.addMatch = (match, view, from, add) => {
                   let deco = decoration(match, view, from);
                   if (deco)
                       add(from, from + match[0].length, deco);
               };
           }
           else if (decoration) {
               this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
           }
           else {
               throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
           }
           this.boundary = boundary;
           this.maxLength = maxLength;
       }
       /**
       Compute the full set of decorations for matches in the given
       view's viewport. You'll want to call this when initializing your
       plugin.
       */
       createDeco(view) {
           let build = new RangeSetBuilder(), add = build.add.bind(build);
           for (let { from, to } of matchRanges(view, this.maxLength))
               iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
           return build.finish();
       }
       /**
       Update a set of decorations for a view update. `deco` _must_ be
       the set of decorations produced by _this_ `MatchDecorator` for
       the view state before the update.
       */
       updateDeco(update, deco) {
           let changeFrom = 1e9, changeTo = -1;
           if (update.docChanged)
               update.changes.iterChanges((_f, _t, from, to) => {
                   if (to > update.view.viewport.from && from < update.view.viewport.to) {
                       changeFrom = Math.min(from, changeFrom);
                       changeTo = Math.max(to, changeTo);
                   }
               });
           if (update.viewportChanged || changeTo - changeFrom > 1000)
               return this.createDeco(update.view);
           if (changeTo > -1)
               return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
           return deco;
       }
       updateRange(view, deco, updateFrom, updateTo) {
           for (let r of view.visibleRanges) {
               let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
               if (to > from) {
                   let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                   let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                   if (this.boundary) {
                       for (; from > fromLine.from; from--)
                           if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                               start = from;
                               break;
                           }
                       for (; to < toLine.to; to++)
                           if (this.boundary.test(toLine.text[to - toLine.from])) {
                               end = to;
                               break;
                           }
                   }
                   let ranges = [], m;
                   let add = (from, to, deco) => ranges.push(deco.range(from, to));
                   if (fromLine == toLine) {
                       this.regexp.lastIndex = start - fromLine.from;
                       while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                           this.addMatch(m, view, m.index + fromLine.from, add);
                   }
                   else {
                       iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                   }
                   deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
               }
           }
           return deco;
       }
   }

   const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
   const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
   const Names = {
       0: "null",
       7: "bell",
       8: "backspace",
       10: "newline",
       11: "vertical tab",
       13: "carriage return",
       27: "escape",
       8203: "zero width space",
       8204: "zero width non-joiner",
       8205: "zero width joiner",
       8206: "left-to-right mark",
       8207: "right-to-left mark",
       8232: "line separator",
       8237: "left-to-right override",
       8238: "right-to-left override",
       8294: "left-to-right isolate",
       8295: "right-to-left isolate",
       8297: "pop directional isolate",
       8233: "paragraph separator",
       65279: "zero width no-break space",
       65532: "object replacement"
   };
   let _supportsTabSize = null;
   function supportsTabSize() {
       var _a;
       if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
           let styles = document.body.style;
           _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
       }
       return _supportsTabSize || false;
   }
   const specialCharConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           let config = combineConfig(configs, {
               render: null,
               specialChars: Specials,
               addSpecialChars: null
           });
           if (config.replaceTabs = !supportsTabSize())
               config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
           if (config.addSpecialChars)
               config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
           return config;
       }
   });
   /**
   Returns an extension that installs highlighting of special
   characters.
   */
   function highlightSpecialChars(
   /**
   Configuration options.
   */
   config = {}) {
       return [specialCharConfig.of(config), specialCharPlugin()];
   }
   let _plugin = null;
   function specialCharPlugin() {
       return _plugin || (_plugin = ViewPlugin.fromClass(class {
           constructor(view) {
               this.view = view;
               this.decorations = Decoration.none;
               this.decorationCache = Object.create(null);
               this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
               this.decorations = this.decorator.createDeco(view);
           }
           makeDecorator(conf) {
               return new MatchDecorator({
                   regexp: conf.specialChars,
                   decoration: (m, view, pos) => {
                       let { doc } = view.state;
                       let code = codePointAt(m[0], 0);
                       if (code == 9) {
                           let line = doc.lineAt(pos);
                           let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
                           return Decoration.replace({
                               widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                           });
                       }
                       return this.decorationCache[code] ||
                           (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                   },
                   boundary: conf.replaceTabs ? undefined : /[^]/
               });
           }
           update(update) {
               let conf = update.state.facet(specialCharConfig);
               if (update.startState.facet(specialCharConfig) != conf) {
                   this.decorator = this.makeDecorator(conf);
                   this.decorations = this.decorator.createDeco(update.view);
               }
               else {
                   this.decorations = this.decorator.updateDeco(update, this.decorations);
               }
           }
       }, {
           decorations: v => v.decorations
       }));
   }
   const DefaultPlaceholder = "\u2022";
   // Assigns placeholder characters from the Control Pictures block to
   // ASCII control characters
   function placeholder$1(code) {
       if (code >= 32)
           return DefaultPlaceholder;
       if (code == 10)
           return "\u2424";
       return String.fromCharCode(9216 + code);
   }
   class SpecialCharWidget extends WidgetType {
       constructor(options, code) {
           super();
           this.options = options;
           this.code = code;
       }
       eq(other) { return other.code == this.code; }
       toDOM(view) {
           let ph = placeholder$1(this.code);
           let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
           let custom = this.options.render && this.options.render(this.code, desc, ph);
           if (custom)
               return custom;
           let span = document.createElement("span");
           span.textContent = ph;
           span.title = desc;
           span.setAttribute("aria-label", desc);
           span.className = "cm-specialChar";
           return span;
       }
       ignoreEvent() { return false; }
   }
   class TabWidget extends WidgetType {
       constructor(width) {
           super();
           this.width = width;
       }
       eq(other) { return other.width == this.width; }
       toDOM() {
           let span = document.createElement("span");
           span.textContent = "\t";
           span.className = "cm-tab";
           span.style.width = this.width + "px";
           return span;
       }
       ignoreEvent() { return false; }
   }

   /**
   Mark lines that have a cursor on them with the `"cm-activeLine"`
   DOM class.
   */
   function highlightActiveLine() {
       return activeLineHighlighter;
   }
   const lineDeco = /*@__PURE__*/Decoration.line({ class: "cm-activeLine" });
   const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.decorations = this.getDeco(view);
       }
       update(update) {
           if (update.docChanged || update.selectionSet)
               this.decorations = this.getDeco(update.view);
       }
       getDeco(view) {
           let lastLineStart = -1, deco = [];
           for (let r of view.state.selection.ranges) {
               let line = view.lineBlockAt(r.head);
               if (line.from > lastLineStart) {
                   deco.push(lineDeco.range(line.from));
                   lastLineStart = line.from;
               }
           }
           return Decoration.set(deco);
       }
   }, {
       decorations: v => v.decorations
   });

   // Don't compute precise column positions for line offsets above this
   // (since it could get expensive). Assume offset==column for them.
   const MaxOff = 2000;
   function rectangleFor(state, a, b) {
       let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
       let ranges = [];
       if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
           let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
           for (let i = startLine; i <= endLine; i++) {
               let line = state.doc.line(i);
               if (line.length <= endOff)
                   ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
           }
       }
       else {
           let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
           for (let i = startLine; i <= endLine; i++) {
               let line = state.doc.line(i);
               let start = findColumn(line.text, startCol, state.tabSize, true);
               if (start < 0) {
                   ranges.push(EditorSelection.cursor(line.to));
               }
               else {
                   let end = findColumn(line.text, endCol, state.tabSize);
                   ranges.push(EditorSelection.range(line.from + start, line.from + end));
               }
           }
       }
       return ranges;
   }
   function absoluteColumn(view, x) {
       let ref = view.coordsAtPos(view.viewport.from);
       return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
   }
   function getPos(view, event) {
       let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
       let line = view.state.doc.lineAt(offset), off = offset - line.from;
       let col = off > MaxOff ? -1
           : off == line.length ? absoluteColumn(view, event.clientX)
               : countColumn(line.text, view.state.tabSize, offset - line.from);
       return { line: line.number, col, off };
   }
   function rectangleSelectionStyle(view, event) {
       let start = getPos(view, event), startSel = view.state.selection;
       if (!start)
           return null;
       return {
           update(update) {
               if (update.docChanged) {
                   let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                   let newLine = update.state.doc.lineAt(newStart);
                   start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                   startSel = startSel.map(update.changes);
               }
           },
           get(event, _extend, multiple) {
               let cur = getPos(view, event);
               if (!cur)
                   return startSel;
               let ranges = rectangleFor(view.state, start, cur);
               if (!ranges.length)
                   return startSel;
               if (multiple)
                   return EditorSelection.create(ranges.concat(startSel.ranges));
               else
                   return EditorSelection.create(ranges);
           }
       };
   }
   /**
   Create an extension that enables rectangular selections. By
   default, it will react to left mouse drag with the Alt key held
   down. When such a selection occurs, the text within the rectangle
   that was dragged over will be selected, as one selection
   [range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
   */
   function rectangularSelection(options) {
       let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
       return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
   }
   const keys = {
       Alt: [18, e => !!e.altKey],
       Control: [17, e => !!e.ctrlKey],
       Shift: [16, e => !!e.shiftKey],
       Meta: [91, e => !!e.metaKey]
   };
   const showCrosshair = { style: "cursor: crosshair" };
   /**
   Returns an extension that turns the pointer cursor into a
   crosshair when a given modifier key, defaulting to Alt, is held
   down. Can serve as a visual hint that rectangular selection is
   going to happen when paired with
   [`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
   */
   function crosshairCursor(options = {}) {
       let [code, getter] = keys[options.key || "Alt"];
       let plugin = ViewPlugin.fromClass(class {
           constructor(view) {
               this.view = view;
               this.isDown = false;
           }
           set(isDown) {
               if (this.isDown != isDown) {
                   this.isDown = isDown;
                   this.view.update([]);
               }
           }
       }, {
           eventHandlers: {
               keydown(e) {
                   this.set(e.keyCode == code || getter(e));
               },
               keyup(e) {
                   if (e.keyCode == code || !getter(e))
                       this.set(false);
               },
               mousemove(e) {
                   this.set(getter(e));
               }
           }
       });
       return [
           plugin,
           EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
       ];
   }

   const Outside = "-10000px";
   class TooltipViewManager {
       constructor(view, facet, createTooltipView) {
           this.facet = facet;
           this.createTooltipView = createTooltipView;
           this.input = view.state.facet(facet);
           this.tooltips = this.input.filter(t => t);
           this.tooltipViews = this.tooltips.map(createTooltipView);
       }
       update(update) {
           var _a;
           let input = update.state.facet(this.facet);
           let tooltips = input.filter(x => x);
           if (input === this.input) {
               for (let t of this.tooltipViews)
                   if (t.update)
                       t.update(update);
               return false;
           }
           let tooltipViews = [];
           for (let i = 0; i < tooltips.length; i++) {
               let tip = tooltips[i], known = -1;
               if (!tip)
                   continue;
               for (let i = 0; i < this.tooltips.length; i++) {
                   let other = this.tooltips[i];
                   if (other && other.create == tip.create)
                       known = i;
               }
               if (known < 0) {
                   tooltipViews[i] = this.createTooltipView(tip);
               }
               else {
                   let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                   if (tooltipView.update)
                       tooltipView.update(update);
               }
           }
           for (let t of this.tooltipViews)
               if (tooltipViews.indexOf(t) < 0) {
                   t.dom.remove();
                   (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
               }
           this.input = input;
           this.tooltips = tooltips;
           this.tooltipViews = tooltipViews;
           return true;
       }
   }
   function windowSpace(view) {
       let { win } = view;
       return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
   }
   const tooltipConfig = /*@__PURE__*/Facet.define({
       combine: values => {
           var _a, _b, _c;
           return ({
               position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
               parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
               tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
           });
       }
   });
   const knownHeight = /*@__PURE__*/new WeakMap();
   const tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.view = view;
           this.inView = true;
           this.madeAbsolute = false;
           this.lastTransaction = 0;
           this.measureTimeout = -1;
           let config = view.state.facet(tooltipConfig);
           this.position = config.position;
           this.parent = config.parent;
           this.classes = view.themeClasses;
           this.createContainer();
           this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
           this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));
           this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
               if (Date.now() > this.lastTransaction - 50 &&
                   entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                   this.measureSoon();
           }, { threshold: [1] }) : null;
           this.observeIntersection();
           view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
           this.maybeMeasure();
       }
       createContainer() {
           if (this.parent) {
               this.container = document.createElement("div");
               this.container.style.position = "relative";
               this.container.className = this.view.themeClasses;
               this.parent.appendChild(this.container);
           }
           else {
               this.container = this.view.dom;
           }
       }
       observeIntersection() {
           if (this.intersectionObserver) {
               this.intersectionObserver.disconnect();
               for (let tooltip of this.manager.tooltipViews)
                   this.intersectionObserver.observe(tooltip.dom);
           }
       }
       measureSoon() {
           if (this.measureTimeout < 0)
               this.measureTimeout = setTimeout(() => {
                   this.measureTimeout = -1;
                   this.maybeMeasure();
               }, 50);
       }
       update(update) {
           if (update.transactions.length)
               this.lastTransaction = Date.now();
           let updated = this.manager.update(update);
           if (updated)
               this.observeIntersection();
           let shouldMeasure = updated || update.geometryChanged;
           let newConfig = update.state.facet(tooltipConfig);
           if (newConfig.position != this.position && !this.madeAbsolute) {
               this.position = newConfig.position;
               for (let t of this.manager.tooltipViews)
                   t.dom.style.position = this.position;
               shouldMeasure = true;
           }
           if (newConfig.parent != this.parent) {
               if (this.parent)
                   this.container.remove();
               this.parent = newConfig.parent;
               this.createContainer();
               for (let t of this.manager.tooltipViews)
                   this.container.appendChild(t.dom);
               shouldMeasure = true;
           }
           else if (this.parent && this.view.themeClasses != this.classes) {
               this.classes = this.container.className = this.view.themeClasses;
           }
           if (shouldMeasure)
               this.maybeMeasure();
       }
       createTooltip(tooltip) {
           let tooltipView = tooltip.create(this.view);
           tooltipView.dom.classList.add("cm-tooltip");
           if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
               let arrow = document.createElement("div");
               arrow.className = "cm-tooltip-arrow";
               tooltipView.dom.appendChild(arrow);
           }
           tooltipView.dom.style.position = this.position;
           tooltipView.dom.style.top = Outside;
           this.container.appendChild(tooltipView.dom);
           if (tooltipView.mount)
               tooltipView.mount(this.view);
           return tooltipView;
       }
       destroy() {
           var _a, _b;
           this.view.win.removeEventListener("resize", this.measureSoon);
           for (let tooltipView of this.manager.tooltipViews) {
               tooltipView.dom.remove();
               (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
           }
           (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
           clearTimeout(this.measureTimeout);
       }
       readMeasure() {
           let editor = this.view.dom.getBoundingClientRect();
           let scaleX = 1, scaleY = 1, makeAbsolute = false;
           if (this.position == "fixed") {
               let views = this.manager.tooltipViews;
               // When the dialog's offset parent isn't the body, we are
               // probably in a transformed container, and should use absolute
               // positioning instead, since fixed positioning inside a
               // transform works in a very broken way.
               makeAbsolute = views.length > 0 && views[0].dom.offsetParent != this.container.ownerDocument.body;
           }
           if (makeAbsolute || this.position == "absolute") {
               if (this.parent) {
                   let rect = this.parent.getBoundingClientRect();
                   if (rect.width && rect.height) {
                       scaleX = rect.width / this.parent.offsetWidth;
                       scaleY = rect.height / this.parent.offsetHeight;
                   }
               }
               else {
                   ({ scaleX, scaleY } = this.view.viewState);
               }
           }
           return {
               editor,
               parent: this.parent ? this.container.getBoundingClientRect() : editor,
               pos: this.manager.tooltips.map((t, i) => {
                   let tv = this.manager.tooltipViews[i];
                   return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
               }),
               size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
               space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
               scaleX, scaleY, makeAbsolute
           };
       }
       writeMeasure(measured) {
           var _a;
           if (measured.makeAbsolute) {
               this.madeAbsolute = true;
               this.position = "absolute";
               for (let t of this.manager.tooltipViews)
                   t.dom.style.position = "absolute";
           }
           let { editor, space, scaleX, scaleY } = measured;
           let others = [];
           for (let i = 0; i < this.manager.tooltips.length; i++) {
               let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
               let pos = measured.pos[i], size = measured.size[i];
               // Hide tooltips that are outside of the editor.
               if (!pos || pos.bottom <= Math.max(editor.top, space.top) ||
                   pos.top >= Math.min(editor.bottom, space.bottom) ||
                   pos.right < Math.max(editor.left, space.left) - .1 ||
                   pos.left > Math.min(editor.right, space.right) + .1) {
                   dom.style.top = Outside;
                   continue;
               }
               let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
               let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
               let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
               let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
               let left = size.width > space.right - space.left ? (ltr ? space.left : space.right - size.width)
                   : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width)
                       : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);
               let above = !!tooltip.above;
               if (!tooltip.strictSide && (above
                   ? pos.top - (size.bottom - size.top) - offset.y < space.top
                   : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) &&
                   above == (space.bottom - pos.bottom > pos.top - space.top))
                   above = !above;
               let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
               if (spaceVert < height && tView.resize !== false) {
                   if (spaceVert < this.view.defaultLineHeight) {
                       dom.style.top = Outside;
                       continue;
                   }
                   knownHeight.set(tView, height);
                   dom.style.height = (height = spaceVert) / scaleY + "px";
               }
               else if (dom.style.height) {
                   dom.style.height = "";
               }
               let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
               let right = left + width;
               if (tView.overlap !== true)
                   for (let r of others)
                       if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                           top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
               if (this.position == "absolute") {
                   dom.style.top = (top - measured.parent.top) / scaleY + "px";
                   dom.style.left = (left - measured.parent.left) / scaleX + "px";
               }
               else {
                   dom.style.top = top / scaleY + "px";
                   dom.style.left = left / scaleX + "px";
               }
               if (arrow) {
                   let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
                   arrow.style.left = arrowLeft / scaleX + "px";
               }
               if (tView.overlap !== true)
                   others.push({ left, top, right, bottom: top + height });
               dom.classList.toggle("cm-tooltip-above", above);
               dom.classList.toggle("cm-tooltip-below", !above);
               if (tView.positioned)
                   tView.positioned(measured.space);
           }
       }
       maybeMeasure() {
           if (this.manager.tooltips.length) {
               if (this.view.inView)
                   this.view.requestMeasure(this.measureReq);
               if (this.inView != this.view.inView) {
                   this.inView = this.view.inView;
                   if (!this.inView)
                       for (let tv of this.manager.tooltipViews)
                           tv.dom.style.top = Outside;
               }
           }
       }
   }, {
       eventHandlers: {
           scroll() { this.maybeMeasure(); }
       }
   });
   const baseTheme$4 = /*@__PURE__*/EditorView.baseTheme({
       ".cm-tooltip": {
           zIndex: 100,
           boxSizing: "border-box"
       },
       "&light .cm-tooltip": {
           border: "1px solid #bbb",
           backgroundColor: "#f5f5f5"
       },
       "&light .cm-tooltip-section:not(:first-child)": {
           borderTop: "1px solid #bbb",
       },
       "&dark .cm-tooltip": {
           backgroundColor: "#333338",
           color: "white"
       },
       ".cm-tooltip-arrow": {
           height: `${7 /* Arrow.Size */}px`,
           width: `${7 /* Arrow.Size */ * 2}px`,
           position: "absolute",
           zIndex: -1,
           overflow: "hidden",
           "&:before, &:after": {
               content: "''",
               position: "absolute",
               width: 0,
               height: 0,
               borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
               borderRight: `${7 /* Arrow.Size */}px solid transparent`,
           },
           ".cm-tooltip-above &": {
               bottom: `-${7 /* Arrow.Size */}px`,
               "&:before": {
                   borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
               },
               "&:after": {
                   borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                   bottom: "1px"
               }
           },
           ".cm-tooltip-below &": {
               top: `-${7 /* Arrow.Size */}px`,
               "&:before": {
                   borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
               },
               "&:after": {
                   borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                   top: "1px"
               }
           },
       },
       "&dark .cm-tooltip .cm-tooltip-arrow": {
           "&:before": {
               borderTopColor: "#333338",
               borderBottomColor: "#333338"
           },
           "&:after": {
               borderTopColor: "transparent",
               borderBottomColor: "transparent"
           }
       }
   });
   const noOffset = { x: 0, y: 0 };
   /**
   Facet to which an extension can add a value to show a tooltip.
   */
   const showTooltip = /*@__PURE__*/Facet.define({
       enables: [tooltipPlugin, baseTheme$4]
   });
   const showHoverTooltip = /*@__PURE__*/Facet.define();
   class HoverTooltipHost {
       // Needs to be static so that host tooltip instances always match
       static create(view) {
           return new HoverTooltipHost(view);
       }
       constructor(view) {
           this.view = view;
           this.mounted = false;
           this.dom = document.createElement("div");
           this.dom.classList.add("cm-tooltip-hover");
           this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));
       }
       createHostedView(tooltip) {
           let hostedView = tooltip.create(this.view);
           hostedView.dom.classList.add("cm-tooltip-section");
           this.dom.appendChild(hostedView.dom);
           if (this.mounted && hostedView.mount)
               hostedView.mount(this.view);
           return hostedView;
       }
       mount(view) {
           for (let hostedView of this.manager.tooltipViews) {
               if (hostedView.mount)
                   hostedView.mount(view);
           }
           this.mounted = true;
       }
       positioned(space) {
           for (let hostedView of this.manager.tooltipViews) {
               if (hostedView.positioned)
                   hostedView.positioned(space);
           }
       }
       update(update) {
           this.manager.update(update);
       }
       destroy() {
           var _a;
           for (let t of this.manager.tooltipViews)
               (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
       }
   }
   const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
       let tooltips = state.facet(showHoverTooltip).filter(t => t);
       if (tooltips.length === 0)
           return null;
       return {
           pos: Math.min(...tooltips.map(t => t.pos)),
           end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),
           create: HoverTooltipHost.create,
           above: tooltips[0].above,
           arrow: tooltips.some(t => t.arrow),
       };
   });
   class HoverPlugin {
       constructor(view, source, field, setHover, hoverTime) {
           this.view = view;
           this.source = source;
           this.field = field;
           this.setHover = setHover;
           this.hoverTime = hoverTime;
           this.hoverTimeout = -1;
           this.restartTimeout = -1;
           this.pending = null;
           this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
           this.checkHover = this.checkHover.bind(this);
           view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
           view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
       }
       update() {
           if (this.pending) {
               this.pending = null;
               clearTimeout(this.restartTimeout);
               this.restartTimeout = setTimeout(() => this.startHover(), 20);
           }
       }
       get active() {
           return this.view.state.field(this.field);
       }
       checkHover() {
           this.hoverTimeout = -1;
           if (this.active)
               return;
           let hovered = Date.now() - this.lastMove.time;
           if (hovered < this.hoverTime)
               this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
           else
               this.startHover();
       }
       startHover() {
           clearTimeout(this.restartTimeout);
           let { view, lastMove } = this;
           let desc = view.docView.nearest(lastMove.target);
           if (!desc)
               return;
           let pos, side = 1;
           if (desc instanceof WidgetView) {
               pos = desc.posAtStart;
           }
           else {
               pos = view.posAtCoords(lastMove);
               if (pos == null)
                   return;
               let posCoords = view.coordsAtPos(pos);
               if (!posCoords ||
                   lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                   lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                   lastMove.x > posCoords.right + view.defaultCharacterWidth)
                   return;
               let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
               let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
               side = (lastMove.x < posCoords.left ? -rtl : rtl);
           }
           let open = this.source(view, pos, side);
           if (open === null || open === void 0 ? void 0 : open.then) {
               let pending = this.pending = { pos };
               open.then(result => {
                   if (this.pending == pending) {
                       this.pending = null;
                       if (result)
                           view.dispatch({ effects: this.setHover.of(result) });
                   }
               }, e => logException(view.state, e, "hover tooltip"));
           }
           else if (open) {
               view.dispatch({ effects: this.setHover.of(open) });
           }
       }
       mousemove(event) {
           var _a;
           this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
           if (this.hoverTimeout < 0)
               this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
           let tooltip = this.active;
           if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
               let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
               if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                   : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                   this.view.dispatch({ effects: this.setHover.of(null) });
                   this.pending = null;
               }
           }
       }
       mouseleave(e) {
           clearTimeout(this.hoverTimeout);
           this.hoverTimeout = -1;
           if (this.active && !isInTooltip(e.relatedTarget))
               this.view.dispatch({ effects: this.setHover.of(null) });
       }
       destroy() {
           clearTimeout(this.hoverTimeout);
           this.view.dom.removeEventListener("mouseleave", this.mouseleave);
           this.view.dom.removeEventListener("mousemove", this.mousemove);
       }
   }
   function isInTooltip(elt) {
       for (let cur = elt; cur; cur = cur.parentNode)
           if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
               return true;
       return false;
   }
   function isOverRange(view, from, to, x, y, margin) {
       let rect = view.scrollDOM.getBoundingClientRect();
       let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
       if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
           return false;
       let pos = view.posAtCoords({ x, y }, false);
       return pos >= from && pos <= to;
   }
   /**
   Set up a hover tooltip, which shows up when the pointer hovers
   over ranges of text. The callback is called when the mouse hovers
   over the document text. It should, if there is a tooltip
   associated with position `pos`, return the tooltip description
   (either directly or in a promise). The `side` argument indicates
   on which side of the position the pointer is—it will be -1 if the
   pointer is before the position, 1 if after the position.

   Note that all hover tooltips are hosted within a single tooltip
   container element. This allows multiple tooltips over the same
   range to be "merged" together without overlapping.
   */
   function hoverTooltip(source, options = {}) {
       let setHover = StateEffect.define();
       let hoverState = StateField.define({
           create() { return null; },
           update(value, tr) {
               if (value && (options.hideOnChange && (tr.docChanged || tr.selection) ||
                   options.hideOn && options.hideOn(tr, value)))
                   return null;
               if (value && tr.docChanged) {
                   let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                   if (newPos == null)
                       return null;
                   let copy = Object.assign(Object.create(null), value);
                   copy.pos = newPos;
                   if (value.end != null)
                       copy.end = tr.changes.mapPos(value.end);
                   value = copy;
               }
               for (let effect of tr.effects) {
                   if (effect.is(setHover))
                       value = effect.value;
                   if (effect.is(closeHoverTooltipEffect))
                       value = null;
               }
               return value;
           },
           provide: f => showHoverTooltip.from(f)
       });
       return [
           hoverState,
           ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
           showHoverTooltipHost
       ];
   }
   /**
   Get the active tooltip view for a given tooltip, if available.
   */
   function getTooltip(view, tooltip) {
       let plugin = view.plugin(tooltipPlugin);
       if (!plugin)
           return null;
       let found = plugin.manager.tooltips.indexOf(tooltip);
       return found < 0 ? null : plugin.manager.tooltipViews[found];
   }
   const closeHoverTooltipEffect = /*@__PURE__*/StateEffect.define();

   const panelConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           let topContainer, bottomContainer;
           for (let c of configs) {
               topContainer = topContainer || c.topContainer;
               bottomContainer = bottomContainer || c.bottomContainer;
           }
           return { topContainer, bottomContainer };
       }
   });
   /**
   Get the active panel created by the given constructor, if any.
   This can be useful when you need access to your panels' DOM
   structure.
   */
   function getPanel(view, panel) {
       let plugin = view.plugin(panelPlugin);
       let index = plugin ? plugin.specs.indexOf(panel) : -1;
       return index > -1 ? plugin.panels[index] : null;
   }
   const panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.input = view.state.facet(showPanel);
           this.specs = this.input.filter(s => s);
           this.panels = this.specs.map(spec => spec(view));
           let conf = view.state.facet(panelConfig);
           this.top = new PanelGroup(view, true, conf.topContainer);
           this.bottom = new PanelGroup(view, false, conf.bottomContainer);
           this.top.sync(this.panels.filter(p => p.top));
           this.bottom.sync(this.panels.filter(p => !p.top));
           for (let p of this.panels) {
               p.dom.classList.add("cm-panel");
               if (p.mount)
                   p.mount();
           }
       }
       update(update) {
           let conf = update.state.facet(panelConfig);
           if (this.top.container != conf.topContainer) {
               this.top.sync([]);
               this.top = new PanelGroup(update.view, true, conf.topContainer);
           }
           if (this.bottom.container != conf.bottomContainer) {
               this.bottom.sync([]);
               this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
           }
           this.top.syncClasses();
           this.bottom.syncClasses();
           let input = update.state.facet(showPanel);
           if (input != this.input) {
               let specs = input.filter(x => x);
               let panels = [], top = [], bottom = [], mount = [];
               for (let spec of specs) {
                   let known = this.specs.indexOf(spec), panel;
                   if (known < 0) {
                       panel = spec(update.view);
                       mount.push(panel);
                   }
                   else {
                       panel = this.panels[known];
                       if (panel.update)
                           panel.update(update);
                   }
                   panels.push(panel);
                   (panel.top ? top : bottom).push(panel);
               }
               this.specs = specs;
               this.panels = panels;
               this.top.sync(top);
               this.bottom.sync(bottom);
               for (let p of mount) {
                   p.dom.classList.add("cm-panel");
                   if (p.mount)
                       p.mount();
               }
           }
           else {
               for (let p of this.panels)
                   if (p.update)
                       p.update(update);
           }
       }
       destroy() {
           this.top.sync([]);
           this.bottom.sync([]);
       }
   }, {
       provide: plugin => EditorView.scrollMargins.of(view => {
           let value = view.plugin(plugin);
           return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
       })
   });
   class PanelGroup {
       constructor(view, top, container) {
           this.view = view;
           this.top = top;
           this.container = container;
           this.dom = undefined;
           this.classes = "";
           this.panels = [];
           this.syncClasses();
       }
       sync(panels) {
           for (let p of this.panels)
               if (p.destroy && panels.indexOf(p) < 0)
                   p.destroy();
           this.panels = panels;
           this.syncDOM();
       }
       syncDOM() {
           if (this.panels.length == 0) {
               if (this.dom) {
                   this.dom.remove();
                   this.dom = undefined;
               }
               return;
           }
           if (!this.dom) {
               this.dom = document.createElement("div");
               this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
               this.dom.style[this.top ? "top" : "bottom"] = "0";
               let parent = this.container || this.view.dom;
               parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
           }
           let curDOM = this.dom.firstChild;
           for (let panel of this.panels) {
               if (panel.dom.parentNode == this.dom) {
                   while (curDOM != panel.dom)
                       curDOM = rm(curDOM);
                   curDOM = curDOM.nextSibling;
               }
               else {
                   this.dom.insertBefore(panel.dom, curDOM);
               }
           }
           while (curDOM)
               curDOM = rm(curDOM);
       }
       scrollMargin() {
           return !this.dom || this.container ? 0
               : Math.max(0, this.top ?
                   this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                   Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
       }
       syncClasses() {
           if (!this.container || this.classes == this.view.themeClasses)
               return;
           for (let cls of this.classes.split(" "))
               if (cls)
                   this.container.classList.remove(cls);
           for (let cls of (this.classes = this.view.themeClasses).split(" "))
               if (cls)
                   this.container.classList.add(cls);
       }
   }
   function rm(node) {
       let next = node.nextSibling;
       node.remove();
       return next;
   }
   /**
   Opening a panel is done by providing a constructor function for
   the panel through this facet. (The panel is closed again when its
   constructor is no longer provided.) Values of `null` are ignored.
   */
   const showPanel = /*@__PURE__*/Facet.define({
       enables: panelPlugin
   });

   /**
   A gutter marker represents a bit of information attached to a line
   in a specific gutter. Your own custom markers have to extend this
   class.
   */
   class GutterMarker extends RangeValue {
       /**
       @internal
       */
       compare(other) {
           return this == other || this.constructor == other.constructor && this.eq(other);
       }
       /**
       Compare this marker to another marker of the same type.
       */
       eq(other) { return false; }
       /**
       Called if the marker has a `toDOM` method and its representation
       was removed from a gutter.
       */
       destroy(dom) { }
   }
   GutterMarker.prototype.elementClass = "";
   GutterMarker.prototype.toDOM = undefined;
   GutterMarker.prototype.mapMode = MapMode.TrackBefore;
   GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
   GutterMarker.prototype.point = true;
   /**
   Facet used to add a class to all gutter elements for a given line.
   Markers given to this facet should _only_ define an
   [`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
   [`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
   in all gutters for the line).
   */
   const gutterLineClass = /*@__PURE__*/Facet.define();
   const defaults$1 = {
       class: "",
       renderEmptyElements: false,
       elementStyle: "",
       markers: () => RangeSet.empty,
       lineMarker: () => null,
       widgetMarker: () => null,
       lineMarkerChange: null,
       initialSpacer: null,
       updateSpacer: null,
       domEventHandlers: {}
   };
   const activeGutters = /*@__PURE__*/Facet.define();
   /**
   Define an editor gutter. The order in which the gutters appear is
   determined by their extension priority.
   */
   function gutter(config) {
       return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults$1), config))];
   }
   const unfixGutters = /*@__PURE__*/Facet.define({
       combine: values => values.some(x => x)
   });
   /**
   The gutter-drawing plugin is automatically enabled when you add a
   gutter, but you can use this function to explicitly configure it.

   Unless `fixed` is explicitly set to `false`, the gutters are
   fixed, meaning they don't scroll along with the content
   horizontally (except on Internet Explorer, which doesn't support
   CSS [`position:
   sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
   */
   function gutters(config) {
       let result = [
           gutterView,
       ];
       if (config && config.fixed === false)
           result.push(unfixGutters.of(true));
       return result;
   }
   const gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.view = view;
           this.prevViewport = view.viewport;
           this.dom = document.createElement("div");
           this.dom.className = "cm-gutters";
           this.dom.setAttribute("aria-hidden", "true");
           this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
           this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
           for (let gutter of this.gutters)
               this.dom.appendChild(gutter.dom);
           this.fixed = !view.state.facet(unfixGutters);
           if (this.fixed) {
               // FIXME IE11 fallback, which doesn't support position: sticky,
               // by using position: relative + event handlers that realign the
               // gutter (or just force fixed=false on IE11?)
               this.dom.style.position = "sticky";
           }
           this.syncGutters(false);
           view.scrollDOM.insertBefore(this.dom, view.contentDOM);
       }
       update(update) {
           if (this.updateGutters(update)) {
               // Detach during sync when the viewport changed significantly
               // (such as during scrolling), since for large updates that is
               // faster.
               let vpA = this.prevViewport, vpB = update.view.viewport;
               let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
               this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
           }
           if (update.geometryChanged)
               this.dom.style.minHeight = this.view.contentHeight + "px";
           if (this.view.state.facet(unfixGutters) != !this.fixed) {
               this.fixed = !this.fixed;
               this.dom.style.position = this.fixed ? "sticky" : "";
           }
           this.prevViewport = update.view.viewport;
       }
       syncGutters(detach) {
           let after = this.dom.nextSibling;
           if (detach)
               this.dom.remove();
           let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
           let classSet = [];
           let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
           for (let line of this.view.viewportLineBlocks) {
               if (classSet.length)
                   classSet = [];
               if (Array.isArray(line.type)) {
                   let first = true;
                   for (let b of line.type) {
                       if (b.type == BlockType.Text && first) {
                           advanceCursor(lineClasses, classSet, b.from);
                           for (let cx of contexts)
                               cx.line(this.view, b, classSet);
                           first = false;
                       }
                       else if (b.widget) {
                           for (let cx of contexts)
                               cx.widget(this.view, b);
                       }
                   }
               }
               else if (line.type == BlockType.Text) {
                   advanceCursor(lineClasses, classSet, line.from);
                   for (let cx of contexts)
                       cx.line(this.view, line, classSet);
               }
           }
           for (let cx of contexts)
               cx.finish();
           if (detach)
               this.view.scrollDOM.insertBefore(this.dom, after);
       }
       updateGutters(update) {
           let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
           let change = update.docChanged || update.heightChanged || update.viewportChanged ||
               !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
           if (prev == cur) {
               for (let gutter of this.gutters)
                   if (gutter.update(update))
                       change = true;
           }
           else {
               change = true;
               let gutters = [];
               for (let conf of cur) {
                   let known = prev.indexOf(conf);
                   if (known < 0) {
                       gutters.push(new SingleGutterView(this.view, conf));
                   }
                   else {
                       this.gutters[known].update(update);
                       gutters.push(this.gutters[known]);
                   }
               }
               for (let g of this.gutters) {
                   g.dom.remove();
                   if (gutters.indexOf(g) < 0)
                       g.destroy();
               }
               for (let g of gutters)
                   this.dom.appendChild(g.dom);
               this.gutters = gutters;
           }
           return change;
       }
       destroy() {
           for (let view of this.gutters)
               view.destroy();
           this.dom.remove();
       }
   }, {
       provide: plugin => EditorView.scrollMargins.of(view => {
           let value = view.plugin(plugin);
           if (!value || value.gutters.length == 0 || !value.fixed)
               return null;
           return view.textDirection == Direction.LTR
               ? { left: value.dom.offsetWidth * view.scaleX }
               : { right: value.dom.offsetWidth * view.scaleX };
       })
   });
   function asArray(val) { return (Array.isArray(val) ? val : [val]); }
   function advanceCursor(cursor, collect, pos) {
       while (cursor.value && cursor.from <= pos) {
           if (cursor.from == pos)
               collect.push(cursor.value);
           cursor.next();
       }
   }
   class UpdateContext {
       constructor(gutter, viewport, height) {
           this.gutter = gutter;
           this.height = height;
           this.i = 0;
           this.cursor = RangeSet.iter(gutter.markers, viewport.from);
       }
       addElement(view, block, markers) {
           let { gutter } = this, above = block.top - this.height;
           if (this.i == gutter.elements.length) {
               let newElt = new GutterElement(view, block.height, above, markers);
               gutter.elements.push(newElt);
               gutter.dom.appendChild(newElt.dom);
           }
           else {
               gutter.elements[this.i].update(view, block.height, above, markers);
           }
           this.height = block.bottom;
           this.i++;
       }
       line(view, line, extraMarkers) {
           let localMarkers = [];
           advanceCursor(this.cursor, localMarkers, line.from);
           if (extraMarkers.length)
               localMarkers = localMarkers.concat(extraMarkers);
           let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
           if (forLine)
               localMarkers.unshift(forLine);
           let gutter = this.gutter;
           if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
               return;
           this.addElement(view, line, localMarkers);
       }
       widget(view, block) {
           let marker = this.gutter.config.widgetMarker(view, block.widget, block);
           if (marker)
               this.addElement(view, block, [marker]);
       }
       finish() {
           let gutter = this.gutter;
           while (gutter.elements.length > this.i) {
               let last = gutter.elements.pop();
               gutter.dom.removeChild(last.dom);
               last.destroy();
           }
       }
   }
   class SingleGutterView {
       constructor(view, config) {
           this.view = view;
           this.config = config;
           this.elements = [];
           this.spacer = null;
           this.dom = document.createElement("div");
           this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
           for (let prop in config.domEventHandlers) {
               this.dom.addEventListener(prop, (event) => {
                   let target = event.target, y;
                   if (target != this.dom && this.dom.contains(target)) {
                       while (target.parentNode != this.dom)
                           target = target.parentNode;
                       let rect = target.getBoundingClientRect();
                       y = (rect.top + rect.bottom) / 2;
                   }
                   else {
                       y = event.clientY;
                   }
                   let line = view.lineBlockAtHeight(y - view.documentTop);
                   if (config.domEventHandlers[prop](view, line, event))
                       event.preventDefault();
               });
           }
           this.markers = asArray(config.markers(view));
           if (config.initialSpacer) {
               this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
               this.dom.appendChild(this.spacer.dom);
               this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
           }
       }
       update(update) {
           let prevMarkers = this.markers;
           this.markers = asArray(this.config.markers(update.view));
           if (this.spacer && this.config.updateSpacer) {
               let updated = this.config.updateSpacer(this.spacer.markers[0], update);
               if (updated != this.spacer.markers[0])
                   this.spacer.update(update.view, 0, 0, [updated]);
           }
           let vp = update.view.viewport;
           return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
               (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
       }
       destroy() {
           for (let elt of this.elements)
               elt.destroy();
       }
   }
   class GutterElement {
       constructor(view, height, above, markers) {
           this.height = -1;
           this.above = 0;
           this.markers = [];
           this.dom = document.createElement("div");
           this.dom.className = "cm-gutterElement";
           this.update(view, height, above, markers);
       }
       update(view, height, above, markers) {
           if (this.height != height) {
               this.height = height;
               this.dom.style.height = height / view.scaleY + "px";
           }
           if (this.above != above)
               this.dom.style.marginTop = (this.above = above) ? above / view.scaleY + "px" : "";
           if (!sameMarkers(this.markers, markers))
               this.setMarkers(view, markers);
       }
       setMarkers(view, markers) {
           let cls = "cm-gutterElement", domPos = this.dom.firstChild;
           for (let iNew = 0, iOld = 0;;) {
               let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
               if (marker) {
                   let c = marker.elementClass;
                   if (c)
                       cls += " " + c;
                   for (let i = iOld; i < this.markers.length; i++)
                       if (this.markers[i].compare(marker)) {
                           skipTo = i;
                           matched = true;
                           break;
                       }
               }
               else {
                   skipTo = this.markers.length;
               }
               while (iOld < skipTo) {
                   let next = this.markers[iOld++];
                   if (next.toDOM) {
                       next.destroy(domPos);
                       let after = domPos.nextSibling;
                       domPos.remove();
                       domPos = after;
                   }
               }
               if (!marker)
                   break;
               if (marker.toDOM) {
                   if (matched)
                       domPos = domPos.nextSibling;
                   else
                       this.dom.insertBefore(marker.toDOM(view), domPos);
               }
               if (matched)
                   iOld++;
           }
           this.dom.className = cls;
           this.markers = markers;
       }
       destroy() {
           this.setMarkers(null, []); // First argument not used unless creating markers
       }
   }
   function sameMarkers(a, b) {
       if (a.length != b.length)
           return false;
       for (let i = 0; i < a.length; i++)
           if (!a[i].compare(b[i]))
               return false;
       return true;
   }
   /**
   Facet used to provide markers to the line number gutter.
   */
   const lineNumberMarkers = /*@__PURE__*/Facet.define();
   const lineNumberConfig = /*@__PURE__*/Facet.define({
       combine(values) {
           return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
               domEventHandlers(a, b) {
                   let result = Object.assign({}, a);
                   for (let event in b) {
                       let exists = result[event], add = b[event];
                       result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                   }
                   return result;
               }
           });
       }
   });
   class NumberMarker extends GutterMarker {
       constructor(number) {
           super();
           this.number = number;
       }
       eq(other) { return this.number == other.number; }
       toDOM() { return document.createTextNode(this.number); }
   }
   function formatNumber(view, number) {
       return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
   }
   const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
       class: "cm-lineNumbers",
       renderEmptyElements: false,
       markers(view) { return view.state.facet(lineNumberMarkers); },
       lineMarker(view, line, others) {
           if (others.some(m => m.toDOM))
               return null;
           return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
       },
       widgetMarker: () => null,
       lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
       initialSpacer(view) {
           return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
       },
       updateSpacer(spacer, update) {
           let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
           return max == spacer.number ? spacer : new NumberMarker(max);
       },
       domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
   }));
   /**
   Create a line number gutter extension.
   */
   function lineNumbers(config = {}) {
       return [
           lineNumberConfig.of(config),
           gutters(),
           lineNumberGutter
       ];
   }
   function maxLineNumber(lines) {
       let last = 9;
       while (last < lines)
           last = last * 10 + 9;
       return last;
   }
   const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
       constructor() {
           super(...arguments);
           this.elementClass = "cm-activeLineGutter";
       }
   };
   const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute(["selection"], state => {
       let marks = [], last = -1;
       for (let range of state.selection.ranges) {
           let linePos = state.doc.lineAt(range.head).from;
           if (linePos > last) {
               last = linePos;
               marks.push(activeLineGutterMarker.range(linePos));
           }
       }
       return RangeSet.of(marks);
   });
   /**
   Returns an extension that adds a `cm-activeLineGutter` class to
   all gutter elements on the [active
   line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
   */
   function highlightActiveLineGutter() {
       return activeLineGutterHighlighter;
   }

   // FIXME profile adding a per-Tree TreeNode cache, validating it by
   // parent pointer
   /**
   The default maximum length of a `TreeBuffer` node.
   */
   const DefaultBufferLength = 1024;
   let nextPropID = 0;
   let Range$1 = class Range {
       constructor(from, to) {
           this.from = from;
           this.to = to;
       }
   };
   /**
   Each [node type](#common.NodeType) or [individual tree](#common.Tree)
   can have metadata associated with it in props. Instances of this
   class represent prop names.
   */
   class NodeProp {
       /**
       Create a new node prop type.
       */
       constructor(config = {}) {
           this.id = nextPropID++;
           this.perNode = !!config.perNode;
           this.deserialize = config.deserialize || (() => {
               throw new Error("This node type doesn't define a deserialize function");
           });
       }
       /**
       This is meant to be used with
       [`NodeSet.extend`](#common.NodeSet.extend) or
       [`LRParser.configure`](#lr.ParserConfig.props) to compute
       prop values for each node type in the set. Takes a [match
       object](#common.NodeType^match) or function that returns undefined
       if the node type doesn't get this prop, and the prop's value if
       it does.
       */
       add(match) {
           if (this.perNode)
               throw new RangeError("Can't add per-node props to node types");
           if (typeof match != "function")
               match = NodeType.match(match);
           return (type) => {
               let result = match(type);
               return result === undefined ? null : [this, result];
           };
       }
   }
   /**
   Prop that is used to describe matching delimiters. For opening
   delimiters, this holds an array of node names (written as a
   space-separated string when declaring this prop in a grammar)
   for the node types of closing delimiters that match it.
   */
   NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
   /**
   The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
   attached to closing delimiters, holding an array of node names
   of types of matching opening delimiters.
   */
   NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
   /**
   Used to assign node types to groups (for example, all node
   types that represent an expression could be tagged with an
   `"Expression"` group).
   */
   NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
   /**
   The hash of the [context](#lr.ContextTracker.constructor)
   that the node was parsed in, if any. Used to limit reuse of
   contextual nodes.
   */
   NodeProp.contextHash = new NodeProp({ perNode: true });
   /**
   The distance beyond the end of the node that the tokenizer
   looked ahead for any of the tokens inside the node. (The LR
   parser only stores this when it is larger than 25, for
   efficiency reasons.)
   */
   NodeProp.lookAhead = new NodeProp({ perNode: true });
   /**
   This per-node prop is used to replace a given node, or part of a
   node, with another tree. This is useful to include trees from
   different languages in mixed-language parsers.
   */
   NodeProp.mounted = new NodeProp({ perNode: true });
   const noProps = Object.create(null);
   /**
   Each node in a syntax tree has a node type associated with it.
   */
   class NodeType {
       /**
       @internal
       */
       constructor(
       /**
       The name of the node type. Not necessarily unique, but if the
       grammar was written properly, different node types with the
       same name within a node set should play the same semantic
       role.
       */
       name, 
       /**
       @internal
       */
       props, 
       /**
       The id of this node in its set. Corresponds to the term ids
       used in the parser.
       */
       id, 
       /**
       @internal
       */
       flags = 0) {
           this.name = name;
           this.props = props;
           this.id = id;
           this.flags = flags;
       }
       /**
       Define a node type.
       */
       static define(spec) {
           let props = spec.props && spec.props.length ? Object.create(null) : noProps;
           let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |
               (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);
           let type = new NodeType(spec.name || "", props, spec.id, flags);
           if (spec.props)
               for (let src of spec.props) {
                   if (!Array.isArray(src))
                       src = src(type);
                   if (src) {
                       if (src[0].perNode)
                           throw new RangeError("Can't store a per-node prop on a node type");
                       props[src[0].id] = src[1];
                   }
               }
           return type;
       }
       /**
       Retrieves a node prop for this type. Will return `undefined` if
       the prop isn't present on this node.
       */
       prop(prop) { return this.props[prop.id]; }
       /**
       True when this is the top node of a grammar.
       */
       get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }
       /**
       True when this node is produced by a skip rule.
       */
       get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }
       /**
       Indicates whether this is an error node.
       */
       get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }
       /**
       When true, this node type doesn't correspond to a user-declared
       named node, for example because it is used to cache repetition.
       */
       get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }
       /**
       Returns true when this node's name or one of its
       [groups](#common.NodeProp^group) matches the given string.
       */
       is(name) {
           if (typeof name == 'string') {
               if (this.name == name)
                   return true;
               let group = this.prop(NodeProp.group);
               return group ? group.indexOf(name) > -1 : false;
           }
           return this.id == name;
       }
       /**
       Create a function from node types to arbitrary values by
       specifying an object whose property names are node or
       [group](#common.NodeProp^group) names. Often useful with
       [`NodeProp.add`](#common.NodeProp.add). You can put multiple
       names, separated by spaces, in a single property name to map
       multiple node names to a single value.
       */
       static match(map) {
           let direct = Object.create(null);
           for (let prop in map)
               for (let name of prop.split(" "))
                   direct[name] = map[prop];
           return (node) => {
               for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                   let found = direct[i < 0 ? node.name : groups[i]];
                   if (found)
                       return found;
               }
           };
       }
   }
   /**
   An empty dummy node type to use when no actual type is available.
   */
   NodeType.none = new NodeType("", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);
   /**
   A node set holds a collection of node types. It is used to
   compactly represent trees by storing their type ids, rather than a
   full pointer to the type object, in a numeric array. Each parser
   [has](#lr.LRParser.nodeSet) a node set, and [tree
   buffers](#common.TreeBuffer) can only store collections of nodes
   from the same set. A set can have a maximum of 2**16 (65536) node
   types in it, so that the ids fit into 16-bit typed array slots.
   */
   class NodeSet {
       /**
       Create a set with the given types. The `id` property of each
       type should correspond to its position within the array.
       */
       constructor(
       /**
       The node types in this set, by id.
       */
       types) {
           this.types = types;
           for (let i = 0; i < types.length; i++)
               if (types[i].id != i)
                   throw new RangeError("Node type ids should correspond to array positions when creating a node set");
       }
       /**
       Create a copy of this set with some node properties added. The
       arguments to this method can be created with
       [`NodeProp.add`](#common.NodeProp.add).
       */
       extend(...props) {
           let newTypes = [];
           for (let type of this.types) {
               let newProps = null;
               for (let source of props) {
                   let add = source(type);
                   if (add) {
                       if (!newProps)
                           newProps = Object.assign({}, type.props);
                       newProps[add[0].id] = add[1];
                   }
               }
               newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
           }
           return new NodeSet(newTypes);
       }
   }
   const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
   /**
   Options that control iteration. Can be combined with the `|`
   operator to enable multiple ones.
   */
   var IterMode;
   (function (IterMode) {
       /**
       When enabled, iteration will only visit [`Tree`](#common.Tree)
       objects, not nodes packed into
       [`TreeBuffer`](#common.TreeBuffer)s.
       */
       IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
       /**
       Enable this to make iteration include anonymous nodes (such as
       the nodes that wrap repeated grammar constructs into a balanced
       tree).
       */
       IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
       /**
       By default, regular [mounted](#common.NodeProp^mounted) nodes
       replace their base node in iteration. Enable this to ignore them
       instead.
       */
       IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
       /**
       This option only applies in
       [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
       library to not enter mounted overlays if one covers the given
       position.
       */
       IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
   })(IterMode || (IterMode = {}));
   /**
   A piece of syntax tree. There are two ways to approach these
   trees: the way they are actually stored in memory, and the
   convenient way.

   Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
   objects. By packing detail information into `TreeBuffer` leaf
   nodes, the representation is made a lot more memory-efficient.

   However, when you want to actually work with tree nodes, this
   representation is very awkward, so most client code will want to
   use the [`TreeCursor`](#common.TreeCursor) or
   [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
   a view on some part of this data structure, and can be used to
   move around to adjacent nodes.
   */
   class Tree {
       /**
       Construct a new tree. See also [`Tree.build`](#common.Tree^build).
       */
       constructor(
       /**
       The type of the top node.
       */
       type, 
       /**
       This node's child nodes.
       */
       children, 
       /**
       The positions (offsets relative to the start of this tree) of
       the children.
       */
       positions, 
       /**
       The total length of this tree
       */
       length, 
       /**
       Per-node [node props](#common.NodeProp) to associate with this node.
       */
       props) {
           this.type = type;
           this.children = children;
           this.positions = positions;
           this.length = length;
           /**
           @internal
           */
           this.props = null;
           if (props && props.length) {
               this.props = Object.create(null);
               for (let [prop, value] of props)
                   this.props[typeof prop == "number" ? prop : prop.id] = value;
           }
       }
       /**
       @internal
       */
       toString() {
           let mounted = this.prop(NodeProp.mounted);
           if (mounted && !mounted.overlay)
               return mounted.tree.toString();
           let children = "";
           for (let ch of this.children) {
               let str = ch.toString();
               if (str) {
                   if (children)
                       children += ",";
                   children += str;
               }
           }
           return !this.type.name ? children :
               (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                   (children.length ? "(" + children + ")" : "");
       }
       /**
       Get a [tree cursor](#common.TreeCursor) positioned at the top of
       the tree. Mode can be used to [control](#common.IterMode) which
       nodes the cursor visits.
       */
       cursor(mode = 0) {
           return new TreeCursor(this.topNode, mode);
       }
       /**
       Get a [tree cursor](#common.TreeCursor) pointing into this tree
       at the given position and side (see
       [`moveTo`](#common.TreeCursor.moveTo).
       */
       cursorAt(pos, side = 0, mode = 0) {
           let scope = CachedNode.get(this) || this.topNode;
           let cursor = new TreeCursor(scope);
           cursor.moveTo(pos, side);
           CachedNode.set(this, cursor._tree);
           return cursor;
       }
       /**
       Get a [syntax node](#common.SyntaxNode) object for the top of the
       tree.
       */
       get topNode() {
           return new TreeNode(this, 0, 0, null);
       }
       /**
       Get the [syntax node](#common.SyntaxNode) at the given position.
       If `side` is -1, this will move into nodes that end at the
       position. If 1, it'll move into nodes that start at the
       position. With 0, it'll only enter nodes that cover the position
       from both sides.
       
       Note that this will not enter
       [overlays](#common.MountedTree.overlay), and you often want
       [`resolveInner`](#common.Tree.resolveInner) instead.
       */
       resolve(pos, side = 0) {
           let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
           CachedNode.set(this, node);
           return node;
       }
       /**
       Like [`resolve`](#common.Tree.resolve), but will enter
       [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
       pointing into the innermost overlaid tree at the given position
       (with parent links going through all parent structure, including
       the host trees).
       */
       resolveInner(pos, side = 0) {
           let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
           CachedInnerNode.set(this, node);
           return node;
       }
       /**
       Iterate over the tree and its children, calling `enter` for any
       node that touches the `from`/`to` region (if given) before
       running over such a node's children, and `leave` (if given) when
       leaving the node. When `enter` returns `false`, that node will
       not have its children iterated over (or `leave` called).
       */
       iterate(spec) {
           let { enter, leave, from = 0, to = this.length } = spec;
           let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
           for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
               let entered = false;
               if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
                   if (c.firstChild())
                       continue;
                   entered = true;
               }
               for (;;) {
                   if (entered && leave && (anon || !c.type.isAnonymous))
                       leave(c);
                   if (c.nextSibling())
                       break;
                   if (!c.parent())
                       return;
                   entered = true;
               }
           }
       }
       /**
       Get the value of the given [node prop](#common.NodeProp) for this
       node. Works with both per-node and per-type props.
       */
       prop(prop) {
           return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
       }
       /**
       Returns the node's [per-node props](#common.NodeProp.perNode) in a
       format that can be passed to the [`Tree`](#common.Tree)
       constructor.
       */
       get propValues() {
           let result = [];
           if (this.props)
               for (let id in this.props)
                   result.push([+id, this.props[id]]);
           return result;
       }
       /**
       Balance the direct children of this tree, producing a copy of
       which may have children grouped into subtrees with type
       [`NodeType.none`](#common.NodeType^none).
       */
       balance(config = {}) {
           return this.children.length <= 8 /* Balance.BranchFactor */ ? this :
               balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
       }
       /**
       Build a tree from a postfix-ordered buffer of node information,
       or a cursor over such a buffer.
       */
       static build(data) { return buildTree(data); }
   }
   /**
   The empty tree
   */
   Tree.empty = new Tree(NodeType.none, [], [], 0);
   class FlatBufferCursor {
       constructor(buffer, index) {
           this.buffer = buffer;
           this.index = index;
       }
       get id() { return this.buffer[this.index - 4]; }
       get start() { return this.buffer[this.index - 3]; }
       get end() { return this.buffer[this.index - 2]; }
       get size() { return this.buffer[this.index - 1]; }
       get pos() { return this.index; }
       next() { this.index -= 4; }
       fork() { return new FlatBufferCursor(this.buffer, this.index); }
   }
   /**
   Tree buffers contain (type, start, end, endIndex) quads for each
   node. In such a buffer, nodes are stored in prefix order (parents
   before children, with the endIndex of the parent indicating which
   children belong to it).
   */
   class TreeBuffer {
       /**
       Create a tree buffer.
       */
       constructor(
       /**
       The buffer's content.
       */
       buffer, 
       /**
       The total length of the group of nodes in the buffer.
       */
       length, 
       /**
       The node set used in this buffer.
       */
       set) {
           this.buffer = buffer;
           this.length = length;
           this.set = set;
       }
       /**
       @internal
       */
       get type() { return NodeType.none; }
       /**
       @internal
       */
       toString() {
           let result = [];
           for (let index = 0; index < this.buffer.length;) {
               result.push(this.childString(index));
               index = this.buffer[index + 3];
           }
           return result.join(",");
       }
       /**
       @internal
       */
       childString(index) {
           let id = this.buffer[index], endIndex = this.buffer[index + 3];
           let type = this.set.types[id], result = type.name;
           if (/\W/.test(result) && !type.isError)
               result = JSON.stringify(result);
           index += 4;
           if (endIndex == index)
               return result;
           let children = [];
           while (index < endIndex) {
               children.push(this.childString(index));
               index = this.buffer[index + 3];
           }
           return result + "(" + children.join(",") + ")";
       }
       /**
       @internal
       */
       findChild(startIndex, endIndex, dir, pos, side) {
           let { buffer } = this, pick = -1;
           for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
               if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                   pick = i;
                   if (dir > 0)
                       break;
               }
           }
           return pick;
       }
       /**
       @internal
       */
       slice(startI, endI, from) {
           let b = this.buffer;
           let copy = new Uint16Array(endI - startI), len = 0;
           for (let i = startI, j = 0; i < endI;) {
               copy[j++] = b[i++];
               copy[j++] = b[i++] - from;
               let to = copy[j++] = b[i++] - from;
               copy[j++] = b[i++] - startI;
               len = Math.max(len, to);
           }
           return new TreeBuffer(copy, len, this.set);
       }
   }
   function checkSide(side, pos, from, to) {
       switch (side) {
           case -2 /* Side.Before */: return from < pos;
           case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;
           case 0 /* Side.Around */: return from < pos && to > pos;
           case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;
           case 2 /* Side.After */: return to > pos;
           case 4 /* Side.DontCare */: return true;
       }
   }
   function enterUnfinishedNodesBefore(node, pos) {
       let scan = node.childBefore(pos);
       while (scan) {
           let last = scan.lastChild;
           if (!last || last.to != scan.to)
               break;
           if (last.type.isError && last.from == last.to) {
               node = scan;
               scan = last.prevSibling;
           }
           else {
               scan = last;
           }
       }
       return node;
   }
   function resolveNode(node, pos, side, overlays) {
       var _a;
       // Move up to a node that actually holds the position, if possible
       while (node.from == node.to ||
           (side < 1 ? node.from >= pos : node.from > pos) ||
           (side > -1 ? node.to <= pos : node.to < pos)) {
           let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
           if (!parent)
               return node;
           node = parent;
       }
       let mode = overlays ? 0 : IterMode.IgnoreOverlays;
       // Must go up out of overlays when those do not overlap with pos
       if (overlays)
           for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
               if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                   node = parent;
           }
       for (;;) {
           let inner = node.enter(pos, side, mode);
           if (!inner)
               return node;
           node = inner;
       }
   }
   class TreeNode {
       constructor(_tree, from, 
       // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
       index, _parent) {
           this._tree = _tree;
           this.from = from;
           this.index = index;
           this._parent = _parent;
       }
       get type() { return this._tree.type; }
       get name() { return this._tree.type.name; }
       get to() { return this.from + this._tree.length; }
       nextChild(i, dir, pos, side, mode = 0) {
           for (let parent = this;;) {
               for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                   let next = children[i], start = positions[i] + parent.from;
                   if (!checkSide(side, pos, start, start + next.length))
                       continue;
                   if (next instanceof TreeBuffer) {
                       if (mode & IterMode.ExcludeBuffers)
                           continue;
                       let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                       if (index > -1)
                           return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                   }
                   else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                       let mounted;
                       if (!(mode & IterMode.IgnoreMounts) &&
                           next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                           return new TreeNode(mounted.tree, start, i, parent);
                       let inner = new TreeNode(next, start, i, parent);
                       return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                           : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                   }
               }
               if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                   return null;
               if (parent.index >= 0)
                   i = parent.index + dir;
               else
                   i = dir < 0 ? -1 : parent._parent._tree.children.length;
               parent = parent._parent;
               if (!parent)
                   return null;
           }
       }
       get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }
       get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }
       childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }
       childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }
       enter(pos, side, mode = 0) {
           let mounted;
           if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
               let rPos = pos - this.from;
               for (let { from, to } of mounted.overlay) {
                   if ((side > 0 ? from <= rPos : from < rPos) &&
                       (side < 0 ? to >= rPos : to > rPos))
                       return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
               }
           }
           return this.nextChild(0, 1, pos, side, mode);
       }
       nextSignificantParent() {
           let val = this;
           while (val.type.isAnonymous && val._parent)
               val = val._parent;
           return val;
       }
       get parent() {
           return this._parent ? this._parent.nextSignificantParent() : null;
       }
       get nextSibling() {
           return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;
       }
       get prevSibling() {
           return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;
       }
       cursor(mode = 0) { return new TreeCursor(this, mode); }
       get tree() { return this._tree; }
       toTree() { return this._tree; }
       resolve(pos, side = 0) {
           return resolveNode(this, pos, side, false);
       }
       resolveInner(pos, side = 0) {
           return resolveNode(this, pos, side, true);
       }
       enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
       getChild(type, before = null, after = null) {
           let r = getChildren(this, type, before, after);
           return r.length ? r[0] : null;
       }
       getChildren(type, before = null, after = null) {
           return getChildren(this, type, before, after);
       }
       /**
       @internal
       */
       toString() { return this._tree.toString(); }
       get node() { return this; }
       matchContext(context) { return matchNodeContext(this, context); }
   }
   function getChildren(node, type, before, after) {
       let cur = node.cursor(), result = [];
       if (!cur.firstChild())
           return result;
       if (before != null)
           while (!cur.type.is(before))
               if (!cur.nextSibling())
                   return result;
       for (;;) {
           if (after != null && cur.type.is(after))
               return result;
           if (cur.type.is(type))
               result.push(cur.node);
           if (!cur.nextSibling())
               return after == null ? result : [];
       }
   }
   function matchNodeContext(node, context, i = context.length - 1) {
       for (let p = node.parent; i >= 0; p = p.parent) {
           if (!p)
               return false;
           if (!p.type.isAnonymous) {
               if (context[i] && context[i] != p.name)
                   return false;
               i--;
           }
       }
       return true;
   }
   class BufferContext {
       constructor(parent, buffer, index, start) {
           this.parent = parent;
           this.buffer = buffer;
           this.index = index;
           this.start = start;
       }
   }
   class BufferNode {
       get name() { return this.type.name; }
       get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
       get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
       constructor(context, _parent, index) {
           this.context = context;
           this._parent = _parent;
           this.index = index;
           this.type = context.buffer.set.types[context.buffer.buffer[index]];
       }
       child(dir, pos, side) {
           let { buffer } = this.context;
           let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
           return index < 0 ? null : new BufferNode(this.context, this, index);
       }
       get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }
       get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }
       childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }
       childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }
       enter(pos, side, mode = 0) {
           if (mode & IterMode.ExcludeBuffers)
               return null;
           let { buffer } = this.context;
           let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
           return index < 0 ? null : new BufferNode(this.context, this, index);
       }
       get parent() {
           return this._parent || this.context.parent.nextSignificantParent();
       }
       externalSibling(dir) {
           return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);
       }
       get nextSibling() {
           let { buffer } = this.context;
           let after = buffer.buffer[this.index + 3];
           if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
               return new BufferNode(this.context, this._parent, after);
           return this.externalSibling(1);
       }
       get prevSibling() {
           let { buffer } = this.context;
           let parentStart = this._parent ? this._parent.index + 4 : 0;
           if (this.index == parentStart)
               return this.externalSibling(-1);
           return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
       }
       cursor(mode = 0) { return new TreeCursor(this, mode); }
       get tree() { return null; }
       toTree() {
           let children = [], positions = [];
           let { buffer } = this.context;
           let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
           if (endI > startI) {
               let from = buffer.buffer[this.index + 1];
               children.push(buffer.slice(startI, endI, from));
               positions.push(0);
           }
           return new Tree(this.type, children, positions, this.to - this.from);
       }
       resolve(pos, side = 0) {
           return resolveNode(this, pos, side, false);
       }
       resolveInner(pos, side = 0) {
           return resolveNode(this, pos, side, true);
       }
       enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
       /**
       @internal
       */
       toString() { return this.context.buffer.childString(this.index); }
       getChild(type, before = null, after = null) {
           let r = getChildren(this, type, before, after);
           return r.length ? r[0] : null;
       }
       getChildren(type, before = null, after = null) {
           return getChildren(this, type, before, after);
       }
       get node() { return this; }
       matchContext(context) { return matchNodeContext(this, context); }
   }
   /**
   A tree cursor object focuses on a given node in a syntax tree, and
   allows you to move to adjacent nodes.
   */
   class TreeCursor {
       /**
       Shorthand for `.type.name`.
       */
       get name() { return this.type.name; }
       /**
       @internal
       */
       constructor(node, 
       /**
       @internal
       */
       mode = 0) {
           this.mode = mode;
           /**
           @internal
           */
           this.buffer = null;
           this.stack = [];
           /**
           @internal
           */
           this.index = 0;
           this.bufferNode = null;
           if (node instanceof TreeNode) {
               this.yieldNode(node);
           }
           else {
               this._tree = node.context.parent;
               this.buffer = node.context;
               for (let n = node._parent; n; n = n._parent)
                   this.stack.unshift(n.index);
               this.bufferNode = node;
               this.yieldBuf(node.index);
           }
       }
       yieldNode(node) {
           if (!node)
               return false;
           this._tree = node;
           this.type = node.type;
           this.from = node.from;
           this.to = node.to;
           return true;
       }
       yieldBuf(index, type) {
           this.index = index;
           let { start, buffer } = this.buffer;
           this.type = type || buffer.set.types[buffer.buffer[index]];
           this.from = start + buffer.buffer[index + 1];
           this.to = start + buffer.buffer[index + 2];
           return true;
       }
       yield(node) {
           if (!node)
               return false;
           if (node instanceof TreeNode) {
               this.buffer = null;
               return this.yieldNode(node);
           }
           this.buffer = node.context;
           return this.yieldBuf(node.index, node.type);
       }
       /**
       @internal
       */
       toString() {
           return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
       }
       /**
       @internal
       */
       enterChild(dir, pos, side) {
           if (!this.buffer)
               return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
           let { buffer } = this.buffer;
           let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
           if (index < 0)
               return false;
           this.stack.push(this.index);
           return this.yieldBuf(index);
       }
       /**
       Move the cursor to this node's first child. When this returns
       false, the node has no child, and the cursor has not been moved.
       */
       firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }
       /**
       Move the cursor to this node's last child.
       */
       lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }
       /**
       Move the cursor to the first child that ends after `pos`.
       */
       childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }
       /**
       Move to the last child that starts before `pos`.
       */
       childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }
       /**
       Move the cursor to the child around `pos`. If side is -1 the
       child may end at that position, when 1 it may start there. This
       will also enter [overlaid](#common.MountedTree.overlay)
       [mounted](#common.NodeProp^mounted) trees unless `overlays` is
       set to false.
       */
       enter(pos, side, mode = this.mode) {
           if (!this.buffer)
               return this.yield(this._tree.enter(pos, side, mode));
           return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
       }
       /**
       Move to the node's parent node, if this isn't the top node.
       */
       parent() {
           if (!this.buffer)
               return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
           if (this.stack.length)
               return this.yieldBuf(this.stack.pop());
           let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
           this.buffer = null;
           return this.yieldNode(parent);
       }
       /**
       @internal
       */
       sibling(dir) {
           if (!this.buffer)
               return !this._tree._parent ? false
                   : this.yield(this._tree.index < 0 ? null
                       : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));
           let { buffer } = this.buffer, d = this.stack.length - 1;
           if (dir < 0) {
               let parentStart = d < 0 ? 0 : this.stack[d] + 4;
               if (this.index != parentStart)
                   return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
           }
           else {
               let after = buffer.buffer[this.index + 3];
               if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                   return this.yieldBuf(after);
           }
           return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;
       }
       /**
       Move to this node's next sibling, if any.
       */
       nextSibling() { return this.sibling(1); }
       /**
       Move to this node's previous sibling, if any.
       */
       prevSibling() { return this.sibling(-1); }
       atLastNode(dir) {
           let index, parent, { buffer } = this;
           if (buffer) {
               if (dir > 0) {
                   if (this.index < buffer.buffer.buffer.length)
                       return false;
               }
               else {
                   for (let i = 0; i < this.index; i++)
                       if (buffer.buffer.buffer[i + 3] < this.index)
                           return false;
               }
               ({ index, parent } = buffer);
           }
           else {
               ({ index, _parent: parent } = this._tree);
           }
           for (; parent; { index, _parent: parent } = parent) {
               if (index > -1)
                   for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                       let child = parent._tree.children[i];
                       if ((this.mode & IterMode.IncludeAnonymous) ||
                           child instanceof TreeBuffer ||
                           !child.type.isAnonymous ||
                           hasChild(child))
                           return false;
                   }
           }
           return true;
       }
       move(dir, enter) {
           if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))
               return true;
           for (;;) {
               if (this.sibling(dir))
                   return true;
               if (this.atLastNode(dir) || !this.parent())
                   return false;
           }
       }
       /**
       Move to the next node in a
       [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
       traversal, going from a node to its first child or, if the
       current node is empty or `enter` is false, its next sibling or
       the next sibling of the first parent node that has one.
       */
       next(enter = true) { return this.move(1, enter); }
       /**
       Move to the next node in a last-to-first pre-order traveral. A
       node is followed by its last child or, if it has none, its
       previous sibling or the previous sibling of the first parent
       node that has one.
       */
       prev(enter = true) { return this.move(-1, enter); }
       /**
       Move the cursor to the innermost node that covers `pos`. If
       `side` is -1, it will enter nodes that end at `pos`. If it is 1,
       it will enter nodes that start at `pos`.
       */
       moveTo(pos, side = 0) {
           // Move up to a node that actually holds the position, if possible
           while (this.from == this.to ||
               (side < 1 ? this.from >= pos : this.from > pos) ||
               (side > -1 ? this.to <= pos : this.to < pos))
               if (!this.parent())
                   break;
           // Then scan down into child nodes as far as possible
           while (this.enterChild(1, pos, side)) { }
           return this;
       }
       /**
       Get a [syntax node](#common.SyntaxNode) at the cursor's current
       position.
       */
       get node() {
           if (!this.buffer)
               return this._tree;
           let cache = this.bufferNode, result = null, depth = 0;
           if (cache && cache.context == this.buffer) {
               scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                   for (let c = cache; c; c = c._parent)
                       if (c.index == index) {
                           if (index == this.index)
                               return c;
                           result = c;
                           depth = d + 1;
                           break scan;
                       }
                   index = this.stack[--d];
               }
           }
           for (let i = depth; i < this.stack.length; i++)
               result = new BufferNode(this.buffer, result, this.stack[i]);
           return this.bufferNode = new BufferNode(this.buffer, result, this.index);
       }
       /**
       Get the [tree](#common.Tree) that represents the current node, if
       any. Will return null when the node is in a [tree
       buffer](#common.TreeBuffer).
       */
       get tree() {
           return this.buffer ? null : this._tree._tree;
       }
       /**
       Iterate over the current node and all its descendants, calling
       `enter` when entering a node and `leave`, if given, when leaving
       one. When `enter` returns `false`, any children of that node are
       skipped, and `leave` isn't called for it.
       */
       iterate(enter, leave) {
           for (let depth = 0;;) {
               let mustLeave = false;
               if (this.type.isAnonymous || enter(this) !== false) {
                   if (this.firstChild()) {
                       depth++;
                       continue;
                   }
                   if (!this.type.isAnonymous)
                       mustLeave = true;
               }
               for (;;) {
                   if (mustLeave && leave)
                       leave(this);
                   mustLeave = this.type.isAnonymous;
                   if (this.nextSibling())
                       break;
                   if (!depth)
                       return;
                   this.parent();
                   depth--;
                   mustLeave = true;
               }
           }
       }
       /**
       Test whether the current node matches a given context—a sequence
       of direct parent node names. Empty strings in the context array
       are treated as wildcards.
       */
       matchContext(context) {
           if (!this.buffer)
               return matchNodeContext(this.node, context);
           let { buffer } = this.buffer, { types } = buffer.set;
           for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
               if (d < 0)
                   return matchNodeContext(this.node, context, i);
               let type = types[buffer.buffer[this.stack[d]]];
               if (!type.isAnonymous) {
                   if (context[i] && context[i] != type.name)
                       return false;
                   i--;
               }
           }
           return true;
       }
   }
   function hasChild(tree) {
       return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
   }
   function buildTree(data) {
       var _a;
       let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
       let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
       let types = nodeSet.types;
       let contextHash = 0, lookAhead = 0;
       function takeNode(parentStart, minPos, children, positions, inRepeat) {
           let { id, start, end, size } = cursor;
           let lookAheadAtStart = lookAhead;
           while (size < 0) {
               cursor.next();
               if (size == -1 /* SpecialRecord.Reuse */) {
                   let node = reused[id];
                   children.push(node);
                   positions.push(start - parentStart);
                   return;
               }
               else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change
                   contextHash = id;
                   return;
               }
               else if (size == -4 /* SpecialRecord.LookAhead */) {
                   lookAhead = id;
                   return;
               }
               else {
                   throw new RangeError(`Unrecognized record size: ${size}`);
               }
           }
           let type = types[id], node, buffer;
           let startPos = start - parentStart;
           if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
               // Small enough for a buffer, and no reused nodes inside
               let data = new Uint16Array(buffer.size - buffer.skip);
               let endPos = cursor.pos - buffer.size, index = data.length;
               while (cursor.pos > endPos)
                   index = copyToBuffer(buffer.start, data, index);
               node = new TreeBuffer(data, end - buffer.start, nodeSet);
               startPos = buffer.start - parentStart;
           }
           else { // Make it a node
               let endPos = cursor.pos - size;
               cursor.next();
               let localChildren = [], localPositions = [];
               let localInRepeat = id >= minRepeatType ? id : -1;
               let lastGroup = 0, lastEnd = end;
               while (cursor.pos > endPos) {
                   if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                       if (cursor.end <= lastEnd - maxBufferLength) {
                           makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                           lastGroup = localChildren.length;
                           lastEnd = cursor.end;
                       }
                       cursor.next();
                   }
                   else {
                       takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                   }
               }
               if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                   makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
               localChildren.reverse();
               localPositions.reverse();
               if (localInRepeat > -1 && lastGroup > 0) {
                   let make = makeBalanced(type);
                   node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
               }
               else {
                   node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
               }
           }
           children.push(node);
           positions.push(startPos);
       }
       function makeBalanced(type) {
           return (children, positions, length) => {
               let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
               if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                   if (!lastI && last.type == type && last.length == length)
                       return last;
                   if (lookAheadProp = last.prop(NodeProp.lookAhead))
                       lookAhead = positions[lastI] + last.length + lookAheadProp;
               }
               return makeTree(type, children, positions, length, lookAhead);
           };
       }
       function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
           let localChildren = [], localPositions = [];
           while (children.length > i) {
               localChildren.push(children.pop());
               localPositions.push(positions.pop() + base - from);
           }
           children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
           positions.push(from - base);
       }
       function makeTree(type, children, positions, length, lookAhead = 0, props) {
           if (contextHash) {
               let pair = [NodeProp.contextHash, contextHash];
               props = props ? [pair].concat(props) : [pair];
           }
           if (lookAhead > 25) {
               let pair = [NodeProp.lookAhead, lookAhead];
               props = props ? [pair].concat(props) : [pair];
           }
           return new Tree(type, children, positions, length, props);
       }
       function findBufferSize(maxSize, inRepeat) {
           // Scan through the buffer to find previous siblings that fit
           // together in a TreeBuffer, and don't contain any reused nodes
           // (which can't be stored in a buffer).
           // If `inRepeat` is > -1, ignore node boundaries of that type for
           // nesting, but make sure the end falls either at the start
           // (`maxSize`) or before such a node.
           let fork = cursor.fork();
           let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
           let result = { size: 0, start: 0, skip: 0 };
           scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
               let nodeSize = fork.size;
               // Pretend nested repeat nodes of the same type don't exist
               if (fork.id == inRepeat && nodeSize >= 0) {
                   // Except that we store the current state as a valid return
                   // value.
                   result.size = size;
                   result.start = start;
                   result.skip = skip;
                   skip += 4;
                   size += 4;
                   fork.next();
                   continue;
               }
               let startPos = fork.pos - nodeSize;
               if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                   break;
               let localSkipped = fork.id >= minRepeatType ? 4 : 0;
               let nodeStart = fork.start;
               fork.next();
               while (fork.pos > startPos) {
                   if (fork.size < 0) {
                       if (fork.size == -3 /* SpecialRecord.ContextChange */)
                           localSkipped += 4;
                       else
                           break scan;
                   }
                   else if (fork.id >= minRepeatType) {
                       localSkipped += 4;
                   }
                   fork.next();
               }
               start = nodeStart;
               size += nodeSize;
               skip += localSkipped;
           }
           if (inRepeat < 0 || size == maxSize) {
               result.size = size;
               result.start = start;
               result.skip = skip;
           }
           return result.size > 4 ? result : undefined;
       }
       function copyToBuffer(bufferStart, buffer, index) {
           let { id, start, end, size } = cursor;
           cursor.next();
           if (size >= 0 && id < minRepeatType) {
               let startIndex = index;
               if (size > 4) {
                   let endPos = cursor.pos - (size - 4);
                   while (cursor.pos > endPos)
                       index = copyToBuffer(bufferStart, buffer, index);
               }
               buffer[--index] = startIndex;
               buffer[--index] = end - bufferStart;
               buffer[--index] = start - bufferStart;
               buffer[--index] = id;
           }
           else if (size == -3 /* SpecialRecord.ContextChange */) {
               contextHash = id;
           }
           else if (size == -4 /* SpecialRecord.LookAhead */) {
               lookAhead = id;
           }
           return index;
       }
       let children = [], positions = [];
       while (cursor.pos > 0)
           takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
       let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
       return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
   }
   const nodeSizeCache = new WeakMap;
   function nodeSize(balanceType, node) {
       if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
           return 1;
       let size = nodeSizeCache.get(node);
       if (size == null) {
           size = 1;
           for (let child of node.children) {
               if (child.type != balanceType || !(child instanceof Tree)) {
                   size = 1;
                   break;
               }
               size += nodeSize(balanceType, child);
           }
           nodeSizeCache.set(node, size);
       }
       return size;
   }
   function balanceRange(
   // The type the balanced tree's inner nodes.
   balanceType, 
   // The direct children and their positions
   children, positions, 
   // The index range in children/positions to use
   from, to, 
   // The start position of the nodes, relative to their parent.
   start, 
   // Length of the outer node
   length, 
   // Function to build the top node of the balanced tree
   mkTop, 
   // Function to build internal nodes for the balanced tree
   mkTree) {
       let total = 0;
       for (let i = from; i < to; i++)
           total += nodeSize(balanceType, children[i]);
       let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);
       let localChildren = [], localPositions = [];
       function divide(children, positions, from, to, offset) {
           for (let i = from; i < to;) {
               let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
               i++;
               for (; i < to; i++) {
                   let nextSize = nodeSize(balanceType, children[i]);
                   if (groupSize + nextSize >= maxChild)
                       break;
                   groupSize += nextSize;
               }
               if (i == groupFrom + 1) {
                   if (groupSize > maxChild) {
                       let only = children[groupFrom]; // Only trees can have a size > 1
                       divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                       continue;
                   }
                   localChildren.push(children[groupFrom]);
               }
               else {
                   let length = positions[i - 1] + children[i - 1].length - groupStart;
                   localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
               }
               localPositions.push(groupStart + offset - start);
           }
       }
       divide(children, positions, from, to, 0);
       return (mkTop || mkTree)(localChildren, localPositions, length);
   }

   /**
   Tree fragments are used during [incremental
   parsing](#common.Parser.startParse) to track parts of old trees
   that can be reused in a new parse. An array of fragments is used
   to track regions of an old tree whose nodes might be reused in new
   parses. Use the static
   [`applyChanges`](#common.TreeFragment^applyChanges) method to
   update fragments for document changes.
   */
   class TreeFragment {
       /**
       Construct a tree fragment. You'll usually want to use
       [`addTree`](#common.TreeFragment^addTree) and
       [`applyChanges`](#common.TreeFragment^applyChanges) instead of
       calling this directly.
       */
       constructor(
       /**
       The start of the unchanged range pointed to by this fragment.
       This refers to an offset in the _updated_ document (as opposed
       to the original tree).
       */
       from, 
       /**
       The end of the unchanged range.
       */
       to, 
       /**
       The tree that this fragment is based on.
       */
       tree, 
       /**
       The offset between the fragment's tree and the document that
       this fragment can be used against. Add this when going from
       document to tree positions, subtract it to go from tree to
       document positions.
       */
       offset, openStart = false, openEnd = false) {
           this.from = from;
           this.to = to;
           this.tree = tree;
           this.offset = offset;
           this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);
       }
       /**
       Whether the start of the fragment represents the start of a
       parse, or the end of a change. (In the second case, it may not
       be safe to reuse some nodes at the start, depending on the
       parsing algorithm.)
       */
       get openStart() { return (this.open & 1 /* Open.Start */) > 0; }
       /**
       Whether the end of the fragment represents the end of a
       full-document parse, or the start of a change.
       */
       get openEnd() { return (this.open & 2 /* Open.End */) > 0; }
       /**
       Create a set of fragments from a freshly parsed tree, or update
       an existing set of fragments by replacing the ones that overlap
       with a tree with content from the new tree. When `partial` is
       true, the parse is treated as incomplete, and the resulting
       fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
       true.
       */
       static addTree(tree, fragments = [], partial = false) {
           let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
           for (let f of fragments)
               if (f.to > tree.length)
                   result.push(f);
           return result;
       }
       /**
       Apply a set of edits to an array of fragments, removing or
       splitting fragments as necessary to remove edited ranges, and
       adjusting offsets for fragments that moved.
       */
       static applyChanges(fragments, changes, minGap = 128) {
           if (!changes.length)
               return fragments;
           let result = [];
           let fI = 1, nextF = fragments.length ? fragments[0] : null;
           for (let cI = 0, pos = 0, off = 0;; cI++) {
               let nextC = cI < changes.length ? changes[cI] : null;
               let nextPos = nextC ? nextC.fromA : 1e9;
               if (nextPos - pos >= minGap)
                   while (nextF && nextF.from < nextPos) {
                       let cut = nextF;
                       if (pos >= cut.from || nextPos <= cut.to || off) {
                           let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                           cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                       }
                       if (cut)
                           result.push(cut);
                       if (nextF.to > nextPos)
                           break;
                       nextF = fI < fragments.length ? fragments[fI++] : null;
                   }
               if (!nextC)
                   break;
               pos = nextC.toA;
               off = nextC.toA - nextC.toB;
           }
           return result;
       }
   }
   /**
   A superclass that parsers should extend.
   */
   let Parser$1 = class Parser {
       /**
       Start a parse, returning a [partial parse](#common.PartialParse)
       object. [`fragments`](#common.TreeFragment) can be passed in to
       make the parse incremental.
       
       By default, the entire input is parsed. You can pass `ranges`,
       which should be a sorted array of non-empty, non-overlapping
       ranges, to parse only those ranges. The tree returned in that
       case will start at `ranges[0].from`.
       */
       startParse(input, fragments, ranges) {
           if (typeof input == "string")
               input = new StringInput(input);
           ranges = !ranges ? [new Range$1(0, input.length)] : ranges.length ? ranges.map(r => new Range$1(r.from, r.to)) : [new Range$1(0, 0)];
           return this.createParse(input, fragments || [], ranges);
       }
       /**
       Run a full parse, returning the resulting tree.
       */
       parse(input, fragments, ranges) {
           let parse = this.startParse(input, fragments, ranges);
           for (;;) {
               let done = parse.advance();
               if (done)
                   return done;
           }
       }
   };
   class StringInput {
       constructor(string) {
           this.string = string;
       }
       get length() { return this.string.length; }
       chunk(from) { return this.string.slice(from); }
       get lineChunks() { return false; }
       read(from, to) { return this.string.slice(from, to); }
   }
   new NodeProp({ perNode: true });

   let nextTagID = 0;
   /**
   Highlighting tags are markers that denote a highlighting category.
   They are [associated](#highlight.styleTags) with parts of a syntax
   tree by a language mode, and then mapped to an actual CSS style by
   a [highlighter](#highlight.Highlighter).

   Because syntax tree node types and highlight styles have to be
   able to talk the same language, CodeMirror uses a mostly _closed_
   [vocabulary](#highlight.tags) of syntax tags (as opposed to
   traditional open string-based systems, which make it hard for
   highlighting themes to cover all the tokens produced by the
   various languages).

   It _is_ possible to [define](#highlight.Tag^define) your own
   highlighting tags for system-internal use (where you control both
   the language package and the highlighter), but such tags will not
   be picked up by regular highlighters (though you can derive them
   from standard tags to allow highlighters to fall back to those).
   */
   class Tag {
       /**
       @internal
       */
       constructor(
       /**
       The set of this tag and all its parent tags, starting with
       this one itself and sorted in order of decreasing specificity.
       */
       set, 
       /**
       The base unmodified tag that this one is based on, if it's
       modified @internal
       */
       base, 
       /**
       The modifiers applied to this.base @internal
       */
       modified) {
           this.set = set;
           this.base = base;
           this.modified = modified;
           /**
           @internal
           */
           this.id = nextTagID++;
       }
       /**
       Define a new tag. If `parent` is given, the tag is treated as a
       sub-tag of that parent, and
       [highlighters](#highlight.tagHighlighter) that don't mention
       this tag will try to fall back to the parent tag (or grandparent
       tag, etc).
       */
       static define(parent) {
           if (parent === null || parent === void 0 ? void 0 : parent.base)
               throw new Error("Can not derive from a modified tag");
           let tag = new Tag([], null, []);
           tag.set.push(tag);
           if (parent)
               for (let t of parent.set)
                   tag.set.push(t);
           return tag;
       }
       /**
       Define a tag _modifier_, which is a function that, given a tag,
       will return a tag that is a subtag of the original. Applying the
       same modifier to a twice tag will return the same value (`m1(t1)
       == m1(t1)`) and applying multiple modifiers will, regardless or
       order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
       
       When multiple modifiers are applied to a given base tag, each
       smaller set of modifiers is registered as a parent, so that for
       example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
       `m1(m3(t1)`, and so on.
       */
       static defineModifier() {
           let mod = new Modifier;
           return (tag) => {
               if (tag.modified.indexOf(mod) > -1)
                   return tag;
               return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
           };
       }
   }
   let nextModifierID = 0;
   class Modifier {
       constructor() {
           this.instances = [];
           this.id = nextModifierID++;
       }
       static get(base, mods) {
           if (!mods.length)
               return base;
           let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
           if (exists)
               return exists;
           let set = [], tag = new Tag(set, base, mods);
           for (let m of mods)
               m.instances.push(tag);
           let configs = powerSet(mods);
           for (let parent of base.set)
               if (!parent.modified.length)
                   for (let config of configs)
                       set.push(Modifier.get(parent, config));
           return tag;
       }
   }
   function sameArray(a, b) {
       return a.length == b.length && a.every((x, i) => x == b[i]);
   }
   function powerSet(array) {
       let sets = [[]];
       for (let i = 0; i < array.length; i++) {
           for (let j = 0, e = sets.length; j < e; j++) {
               sets.push(sets[j].concat(array[i]));
           }
       }
       return sets.sort((a, b) => b.length - a.length);
   }
   /**
   This function is used to add a set of tags to a language syntax
   via [`NodeSet.extend`](#common.NodeSet.extend) or
   [`LRParser.configure`](#lr.LRParser.configure).

   The argument object maps node selectors to [highlighting
   tags](#highlight.Tag) or arrays of tags.

   Node selectors may hold one or more (space-separated) node paths.
   Such a path can be a [node name](#common.NodeType.name), or
   multiple node names (or `*` wildcards) separated by slash
   characters, as in `"Block/Declaration/VariableName"`. Such a path
   matches the final node but only if its direct parent nodes are the
   other nodes mentioned. A `*` in such a path matches any parent,
   but only a single level—wildcards that match multiple parents
   aren't supported, both for efficiency reasons and because Lezer
   trees make it rather hard to reason about what they would match.)

   A path can be ended with `/...` to indicate that the tag assigned
   to the node should also apply to all child nodes, even if they
   match their own style (by default, only the innermost style is
   used).

   When a path ends in `!`, as in `Attribute!`, no further matching
   happens for the node's child nodes, and the entire node gets the
   given style.

   In this notation, node names that contain `/`, `!`, `*`, or `...`
   must be quoted as JSON strings.

   For example:

   ```javascript
   parser.withProps(
     styleTags({
       // Style Number and BigNumber nodes
       "Number BigNumber": tags.number,
       // Style Escape nodes whose parent is String
       "String/Escape": tags.escape,
       // Style anything inside Attributes nodes
       "Attributes!": tags.meta,
       // Add a style to all content inside Italic nodes
       "Italic/...": tags.emphasis,
       // Style InvalidString nodes as both `string` and `invalid`
       "InvalidString": [tags.string, tags.invalid],
       // Style the node named "/" as punctuation
       '"/"': tags.punctuation
     })
   )
   ```
   */
   function styleTags(spec) {
       let byName = Object.create(null);
       for (let prop in spec) {
           let tags = spec[prop];
           if (!Array.isArray(tags))
               tags = [tags];
           for (let part of prop.split(" "))
               if (part) {
                   let pieces = [], mode = 2 /* Normal */, rest = part;
                   for (let pos = 0;;) {
                       if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                           mode = 1 /* Inherit */;
                           break;
                       }
                       let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                       if (!m)
                           throw new RangeError("Invalid path: " + part);
                       pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                       pos += m[0].length;
                       if (pos == part.length)
                           break;
                       let next = part[pos++];
                       if (pos == part.length && next == "!") {
                           mode = 0 /* Opaque */;
                           break;
                       }
                       if (next != "/")
                           throw new RangeError("Invalid path: " + part);
                       rest = part.slice(pos);
                   }
                   let last = pieces.length - 1, inner = pieces[last];
                   if (!inner)
                       throw new RangeError("Invalid path: " + part);
                   let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                   byName[inner] = rule.sort(byName[inner]);
               }
       }
       return ruleNodeProp.add(byName);
   }
   const ruleNodeProp = new NodeProp();
   class Rule {
       constructor(tags, mode, context, next) {
           this.tags = tags;
           this.mode = mode;
           this.context = context;
           this.next = next;
       }
       get opaque() { return this.mode == 0 /* Opaque */; }
       get inherit() { return this.mode == 1 /* Inherit */; }
       sort(other) {
           if (!other || other.depth < this.depth) {
               this.next = other;
               return this;
           }
           other.next = this.sort(other.next);
           return other;
       }
       get depth() { return this.context ? this.context.length : 0; }
   }
   Rule.empty = new Rule([], 2 /* Normal */, null);
   /**
   Define a [highlighter](#highlight.Highlighter) from an array of
   tag/class pairs. Classes associated with more specific tags will
   take precedence.
   */
   function tagHighlighter(tags, options) {
       let map = Object.create(null);
       for (let style of tags) {
           if (!Array.isArray(style.tag))
               map[style.tag.id] = style.class;
           else
               for (let tag of style.tag)
                   map[tag.id] = style.class;
       }
       let { scope, all = null } = options || {};
       return {
           style: (tags) => {
               let cls = all;
               for (let tag of tags) {
                   for (let sub of tag.set) {
                       let tagClass = map[sub.id];
                       if (tagClass) {
                           cls = cls ? cls + " " + tagClass : tagClass;
                           break;
                       }
                   }
               }
               return cls;
           },
           scope
       };
   }
   function highlightTags(highlighters, tags) {
       let result = null;
       for (let highlighter of highlighters) {
           let value = highlighter.style(tags);
           if (value)
               result = result ? result + " " + value : value;
       }
       return result;
   }
   /**
   Highlight the given [tree](#common.Tree) with the given
   [highlighter](#highlight.Highlighter).
   */
   function highlightTree(tree, highlighter, 
   /**
   Assign styling to a region of the text. Will be called, in order
   of position, for any ranges where more than zero classes apply.
   `classes` is a space separated string of CSS classes.
   */
   putStyle, 
   /**
   The start of the range to highlight.
   */
   from = 0, 
   /**
   The end of the range.
   */
   to = tree.length) {
       let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
       builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
       builder.flush(to);
   }
   class HighlightBuilder {
       constructor(at, highlighters, span) {
           this.at = at;
           this.highlighters = highlighters;
           this.span = span;
           this.class = "";
       }
       startSpan(at, cls) {
           if (cls != this.class) {
               this.flush(at);
               if (at > this.at)
                   this.at = at;
               this.class = cls;
           }
       }
       flush(to) {
           if (to > this.at && this.class)
               this.span(this.at, to, this.class);
       }
       highlightRange(cursor, from, to, inheritedClass, highlighters) {
           let { type, from: start, to: end } = cursor;
           if (start >= to || end <= from)
               return;
           if (type.isTop)
               highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
           let cls = inheritedClass;
           let rule = getStyleTags(cursor) || Rule.empty;
           let tagCls = highlightTags(highlighters, rule.tags);
           if (tagCls) {
               if (cls)
                   cls += " ";
               cls += tagCls;
               if (rule.mode == 1 /* Inherit */)
                   inheritedClass += (inheritedClass ? " " : "") + tagCls;
           }
           this.startSpan(Math.max(from, start), cls);
           if (rule.opaque)
               return;
           let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
           if (mounted && mounted.overlay) {
               let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
               let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
               let hasChild = cursor.firstChild();
               for (let i = 0, pos = start;; i++) {
                   let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                   let nextPos = next ? next.from + start : end;
                   let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                   if (rangeFrom < rangeTo && hasChild) {
                       while (cursor.from < rangeTo) {
                           this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                           this.startSpan(Math.min(rangeTo, cursor.to), cls);
                           if (cursor.to >= nextPos || !cursor.nextSibling())
                               break;
                       }
                   }
                   if (!next || nextPos > to)
                       break;
                   pos = next.to + start;
                   if (pos > from) {
                       this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
                       this.startSpan(Math.min(to, pos), cls);
                   }
               }
               if (hasChild)
                   cursor.parent();
           }
           else if (cursor.firstChild()) {
               if (mounted)
                   inheritedClass = "";
               do {
                   if (cursor.to <= from)
                       continue;
                   if (cursor.from >= to)
                       break;
                   this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                   this.startSpan(Math.min(to, cursor.to), cls);
               } while (cursor.nextSibling());
               cursor.parent();
           }
       }
   }
   /**
   Match a syntax node's [highlight rules](#highlight.styleTags). If
   there's a match, return its set of tags, and whether it is
   opaque (uses a `!`) or applies to all child nodes (`/...`).
   */
   function getStyleTags(node) {
       let rule = node.type.prop(ruleNodeProp);
       while (rule && rule.context && !node.matchContext(rule.context))
           rule = rule.next;
       return rule || null;
   }
   const t = Tag.define;
   const comment = t(), name$4P = t(), typeName = t(name$4P), propertyName = t(name$4P), literal = t(), string$1 = t(literal), number$1 = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
   /**
   The default set of highlighting [tags](#highlight.Tag).

   This collection is heavily biased towards programming languages,
   and necessarily incomplete. A full ontology of syntactic
   constructs would fill a stack of books, and be impractical to
   write themes for. So try to make do with this set. If all else
   fails, [open an
   issue](https://github.com/codemirror/codemirror.next) to propose a
   new tag, or [define](#highlight.Tag^define) a local custom tag for
   your use case.

   Note that it is not obligatory to always attach the most specific
   tag possible to an element—if your grammar can't easily
   distinguish a certain type of element (such as a local variable),
   it is okay to style it as its more general variant (a variable).

   For tags that extend some parent tag, the documentation links to
   the parent.
   */
   const tags = {
       /**
       A comment.
       */
       comment,
       /**
       A line [comment](#highlight.tags.comment).
       */
       lineComment: t(comment),
       /**
       A block [comment](#highlight.tags.comment).
       */
       blockComment: t(comment),
       /**
       A documentation [comment](#highlight.tags.comment).
       */
       docComment: t(comment),
       /**
       Any kind of identifier.
       */
       name: name$4P,
       /**
       The [name](#highlight.tags.name) of a variable.
       */
       variableName: t(name$4P),
       /**
       A type [name](#highlight.tags.name).
       */
       typeName: typeName,
       /**
       A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
       */
       tagName: t(typeName),
       /**
       A property or field [name](#highlight.tags.name).
       */
       propertyName: propertyName,
       /**
       An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
       */
       attributeName: t(propertyName),
       /**
       The [name](#highlight.tags.name) of a class.
       */
       className: t(name$4P),
       /**
       A label [name](#highlight.tags.name).
       */
       labelName: t(name$4P),
       /**
       A namespace [name](#highlight.tags.name).
       */
       namespace: t(name$4P),
       /**
       The [name](#highlight.tags.name) of a macro.
       */
       macroName: t(name$4P),
       /**
       A literal value.
       */
       literal,
       /**
       A string [literal](#highlight.tags.literal).
       */
       string: string$1,
       /**
       A documentation [string](#highlight.tags.string).
       */
       docString: t(string$1),
       /**
       A character literal (subtag of [string](#highlight.tags.string)).
       */
       character: t(string$1),
       /**
       An attribute value (subtag of [string](#highlight.tags.string)).
       */
       attributeValue: t(string$1),
       /**
       A number [literal](#highlight.tags.literal).
       */
       number: number$1,
       /**
       An integer [number](#highlight.tags.number) literal.
       */
       integer: t(number$1),
       /**
       A floating-point [number](#highlight.tags.number) literal.
       */
       float: t(number$1),
       /**
       A boolean [literal](#highlight.tags.literal).
       */
       bool: t(literal),
       /**
       Regular expression [literal](#highlight.tags.literal).
       */
       regexp: t(literal),
       /**
       An escape [literal](#highlight.tags.literal), for example a
       backslash escape in a string.
       */
       escape: t(literal),
       /**
       A color [literal](#highlight.tags.literal).
       */
       color: t(literal),
       /**
       A URL [literal](#highlight.tags.literal).
       */
       url: t(literal),
       /**
       A language keyword.
       */
       keyword,
       /**
       The [keyword](#highlight.tags.keyword) for the self or this
       object.
       */
       self: t(keyword),
       /**
       The [keyword](#highlight.tags.keyword) for null.
       */
       null: t(keyword),
       /**
       A [keyword](#highlight.tags.keyword) denoting some atomic value.
       */
       atom: t(keyword),
       /**
       A [keyword](#highlight.tags.keyword) that represents a unit.
       */
       unit: t(keyword),
       /**
       A modifier [keyword](#highlight.tags.keyword).
       */
       modifier: t(keyword),
       /**
       A [keyword](#highlight.tags.keyword) that acts as an operator.
       */
       operatorKeyword: t(keyword),
       /**
       A control-flow related [keyword](#highlight.tags.keyword).
       */
       controlKeyword: t(keyword),
       /**
       A [keyword](#highlight.tags.keyword) that defines something.
       */
       definitionKeyword: t(keyword),
       /**
       A [keyword](#highlight.tags.keyword) related to defining or
       interfacing with modules.
       */
       moduleKeyword: t(keyword),
       /**
       An operator.
       */
       operator,
       /**
       An [operator](#highlight.tags.operator) that dereferences something.
       */
       derefOperator: t(operator),
       /**
       Arithmetic-related [operator](#highlight.tags.operator).
       */
       arithmeticOperator: t(operator),
       /**
       Logical [operator](#highlight.tags.operator).
       */
       logicOperator: t(operator),
       /**
       Bit [operator](#highlight.tags.operator).
       */
       bitwiseOperator: t(operator),
       /**
       Comparison [operator](#highlight.tags.operator).
       */
       compareOperator: t(operator),
       /**
       [Operator](#highlight.tags.operator) that updates its operand.
       */
       updateOperator: t(operator),
       /**
       [Operator](#highlight.tags.operator) that defines something.
       */
       definitionOperator: t(operator),
       /**
       Type-related [operator](#highlight.tags.operator).
       */
       typeOperator: t(operator),
       /**
       Control-flow [operator](#highlight.tags.operator).
       */
       controlOperator: t(operator),
       /**
       Program or markup punctuation.
       */
       punctuation,
       /**
       [Punctuation](#highlight.tags.punctuation) that separates
       things.
       */
       separator: t(punctuation),
       /**
       Bracket-style [punctuation](#highlight.tags.punctuation).
       */
       bracket,
       /**
       Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
       tokens).
       */
       angleBracket: t(bracket),
       /**
       Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
       tokens).
       */
       squareBracket: t(bracket),
       /**
       Parentheses (usually `(` and `)` tokens). Subtag of
       [bracket](#highlight.tags.bracket).
       */
       paren: t(bracket),
       /**
       Braces (usually `{` and `}` tokens). Subtag of
       [bracket](#highlight.tags.bracket).
       */
       brace: t(bracket),
       /**
       Content, for example plain text in XML or markup documents.
       */
       content,
       /**
       [Content](#highlight.tags.content) that represents a heading.
       */
       heading,
       /**
       A level 1 [heading](#highlight.tags.heading).
       */
       heading1: t(heading),
       /**
       A level 2 [heading](#highlight.tags.heading).
       */
       heading2: t(heading),
       /**
       A level 3 [heading](#highlight.tags.heading).
       */
       heading3: t(heading),
       /**
       A level 4 [heading](#highlight.tags.heading).
       */
       heading4: t(heading),
       /**
       A level 5 [heading](#highlight.tags.heading).
       */
       heading5: t(heading),
       /**
       A level 6 [heading](#highlight.tags.heading).
       */
       heading6: t(heading),
       /**
       A prose separator (such as a horizontal rule).
       */
       contentSeparator: t(content),
       /**
       [Content](#highlight.tags.content) that represents a list.
       */
       list: t(content),
       /**
       [Content](#highlight.tags.content) that represents a quote.
       */
       quote: t(content),
       /**
       [Content](#highlight.tags.content) that is emphasized.
       */
       emphasis: t(content),
       /**
       [Content](#highlight.tags.content) that is styled strong.
       */
       strong: t(content),
       /**
       [Content](#highlight.tags.content) that is part of a link.
       */
       link: t(content),
       /**
       [Content](#highlight.tags.content) that is styled as code or
       monospace.
       */
       monospace: t(content),
       /**
       [Content](#highlight.tags.content) that has a strike-through
       style.
       */
       strikethrough: t(content),
       /**
       Inserted text in a change-tracking format.
       */
       inserted: t(),
       /**
       Deleted text.
       */
       deleted: t(),
       /**
       Changed text.
       */
       changed: t(),
       /**
       An invalid or unsyntactic element.
       */
       invalid: t(),
       /**
       Metadata or meta-instruction.
       */
       meta,
       /**
       [Metadata](#highlight.tags.meta) that applies to the entire
       document.
       */
       documentMeta: t(meta),
       /**
       [Metadata](#highlight.tags.meta) that annotates or adds
       attributes to a given syntactic element.
       */
       annotation: t(meta),
       /**
       Processing instruction or preprocessor directive. Subtag of
       [meta](#highlight.tags.meta).
       */
       processingInstruction: t(meta),
       /**
       [Modifier](#highlight.Tag^defineModifier) that indicates that a
       given element is being defined. Expected to be used with the
       various [name](#highlight.tags.name) tags.
       */
       definition: Tag.defineModifier(),
       /**
       [Modifier](#highlight.Tag^defineModifier) that indicates that
       something is constant. Mostly expected to be used with
       [variable names](#highlight.tags.variableName).
       */
       constant: Tag.defineModifier(),
       /**
       [Modifier](#highlight.Tag^defineModifier) used to indicate that
       a [variable](#highlight.tags.variableName) or [property
       name](#highlight.tags.propertyName) is being called or defined
       as a function.
       */
       function: Tag.defineModifier(),
       /**
       [Modifier](#highlight.Tag^defineModifier) that can be applied to
       [names](#highlight.tags.name) to indicate that they belong to
       the language's standard environment.
       */
       standard: Tag.defineModifier(),
       /**
       [Modifier](#highlight.Tag^defineModifier) that indicates a given
       [names](#highlight.tags.name) is local to some scope.
       */
       local: Tag.defineModifier(),
       /**
       A generic variant [modifier](#highlight.Tag^defineModifier) that
       can be used to tag language-specific alternative variants of
       some common tag. It is recommended for themes to define special
       forms of at least the [string](#highlight.tags.string) and
       [variable name](#highlight.tags.variableName) tags, since those
       come up a lot.
       */
       special: Tag.defineModifier()
   };
   /**
   This is a highlighter that adds stable, predictable classes to
   tokens, for styling with external CSS.

   The following tags are mapped to their name prefixed with `"tok-"`
   (for example `"tok-comment"`):

   * [`link`](#highlight.tags.link)
   * [`heading`](#highlight.tags.heading)
   * [`emphasis`](#highlight.tags.emphasis)
   * [`strong`](#highlight.tags.strong)
   * [`keyword`](#highlight.tags.keyword)
   * [`atom`](#highlight.tags.atom)
   * [`bool`](#highlight.tags.bool)
   * [`url`](#highlight.tags.url)
   * [`labelName`](#highlight.tags.labelName)
   * [`inserted`](#highlight.tags.inserted)
   * [`deleted`](#highlight.tags.deleted)
   * [`literal`](#highlight.tags.literal)
   * [`string`](#highlight.tags.string)
   * [`number`](#highlight.tags.number)
   * [`variableName`](#highlight.tags.variableName)
   * [`typeName`](#highlight.tags.typeName)
   * [`namespace`](#highlight.tags.namespace)
   * [`className`](#highlight.tags.className)
   * [`macroName`](#highlight.tags.macroName)
   * [`propertyName`](#highlight.tags.propertyName)
   * [`operator`](#highlight.tags.operator)
   * [`comment`](#highlight.tags.comment)
   * [`meta`](#highlight.tags.meta)
   * [`punctuation`](#highlight.tags.punctuation)
   * [`invalid`](#highlight.tags.invalid)

   In addition, these mappings are provided:

   * [`regexp`](#highlight.tags.regexp),
     [`escape`](#highlight.tags.escape), and
     [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
     are mapped to `"tok-string2"`
   * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
     to `"tok-variableName2"`
   * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
     to `"tok-variableName tok-local"`
   * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
     to `"tok-variableName tok-definition"`
   * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
     to `"tok-propertyName tok-definition"`
   */
   tagHighlighter([
       { tag: tags.link, class: "tok-link" },
       { tag: tags.heading, class: "tok-heading" },
       { tag: tags.emphasis, class: "tok-emphasis" },
       { tag: tags.strong, class: "tok-strong" },
       { tag: tags.keyword, class: "tok-keyword" },
       { tag: tags.atom, class: "tok-atom" },
       { tag: tags.bool, class: "tok-bool" },
       { tag: tags.url, class: "tok-url" },
       { tag: tags.labelName, class: "tok-labelName" },
       { tag: tags.inserted, class: "tok-inserted" },
       { tag: tags.deleted, class: "tok-deleted" },
       { tag: tags.literal, class: "tok-literal" },
       { tag: tags.string, class: "tok-string" },
       { tag: tags.number, class: "tok-number" },
       { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
       { tag: tags.variableName, class: "tok-variableName" },
       { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
       { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
       { tag: tags.special(tags.variableName), class: "tok-variableName2" },
       { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
       { tag: tags.typeName, class: "tok-typeName" },
       { tag: tags.namespace, class: "tok-namespace" },
       { tag: tags.className, class: "tok-className" },
       { tag: tags.macroName, class: "tok-macroName" },
       { tag: tags.propertyName, class: "tok-propertyName" },
       { tag: tags.operator, class: "tok-operator" },
       { tag: tags.comment, class: "tok-comment" },
       { tag: tags.meta, class: "tok-meta" },
       { tag: tags.invalid, class: "tok-invalid" },
       { tag: tags.punctuation, class: "tok-punctuation" }
   ]);

   var _a$1;
   /**
   Node prop stored in a parser's top syntax node to provide the
   facet that stores language-specific data for that language.
   */
   const languageDataProp = /*@__PURE__*/new NodeProp();
   /**
   Helper function to define a facet (to be added to the top syntax
   node(s) for a language via
   [`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
   used to associate language data with the language. You
   probably only need this when subclassing
   [`Language`](https://codemirror.net/6/docs/ref/#language.Language).
   */
   function defineLanguageFacet(baseData) {
       return Facet.define({
           combine: baseData ? values => values.concat(baseData) : undefined
       });
   }
   /**
   Syntax node prop used to register sublanguages. Should be added to
   the top level node type for the language.
   */
   const sublanguageProp = /*@__PURE__*/new NodeProp();
   /**
   A language object manages parsing and per-language
   [metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
   managed as a [Lezer](https://lezer.codemirror.net) tree. The class
   can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
   subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
   via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
   for stream parsers.
   */
   class Language {
       /**
       Construct a language object. If you need to invoke this
       directly, first define a data facet with
       [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
       configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
       to the language's outer syntax node.
       */
       constructor(
       /**
       The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
       used for this language.
       */
       data, parser, extraExtensions = [], 
       /**
       A language name.
       */
       name = "") {
           this.data = data;
           this.name = name;
           // Kludge to define EditorState.tree as a debugging helper,
           // without the EditorState package actually knowing about
           // languages and lezer trees.
           if (!EditorState.prototype.hasOwnProperty("tree"))
               Object.defineProperty(EditorState.prototype, "tree", { get() { return syntaxTree(this); } });
           this.parser = parser;
           this.extension = [
               language.of(this),
               EditorState.languageData.of((state, pos, side) => {
                   let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);
                   if (!data)
                       return [];
                   let base = state.facet(data), sub = top.type.prop(sublanguageProp);
                   if (sub) {
                       let innerNode = top.resolve(pos - top.from, side);
                       for (let sublang of sub)
                           if (sublang.test(innerNode, state)) {
                               let data = state.facet(sublang.facet);
                               return sublang.type == "replace" ? data : data.concat(base);
                           }
                   }
                   return base;
               })
           ].concat(extraExtensions);
       }
       /**
       Query whether this language is active at the given position.
       */
       isActiveAt(state, pos, side = -1) {
           return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
       }
       /**
       Find the document regions that were parsed using this language.
       The returned regions will _include_ any nested languages rooted
       in this language, when those exist.
       */
       findRegions(state) {
           let lang = state.facet(language);
           if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
               return [{ from: 0, to: state.doc.length }];
           if (!lang || !lang.allowsNesting)
               return [];
           let result = [];
           let explore = (tree, from) => {
               if (tree.prop(languageDataProp) == this.data) {
                   result.push({ from, to: from + tree.length });
                   return;
               }
               let mount = tree.prop(NodeProp.mounted);
               if (mount) {
                   if (mount.tree.prop(languageDataProp) == this.data) {
                       if (mount.overlay)
                           for (let r of mount.overlay)
                               result.push({ from: r.from + from, to: r.to + from });
                       else
                           result.push({ from: from, to: from + tree.length });
                       return;
                   }
                   else if (mount.overlay) {
                       let size = result.length;
                       explore(mount.tree, mount.overlay[0].from + from);
                       if (result.length > size)
                           return;
                   }
               }
               for (let i = 0; i < tree.children.length; i++) {
                   let ch = tree.children[i];
                   if (ch instanceof Tree)
                       explore(ch, tree.positions[i] + from);
               }
           };
           explore(syntaxTree(state), 0);
           return result;
       }
       /**
       Indicates whether this language allows nested languages. The
       default implementation returns true.
       */
       get allowsNesting() { return true; }
   }
   /**
   @internal
   */
   Language.setState = /*@__PURE__*/StateEffect.define();
   function topNodeAt(state, pos, side) {
       let topLang = state.facet(language), tree = syntaxTree(state).topNode;
       if (!topLang || topLang.allowsNesting) {
           for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
               if (node.type.isTop)
                   tree = node;
       }
       return tree;
   }
   /**
   A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
   [LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
   parsers.
   */
   class LRLanguage extends Language {
       constructor(data, parser, name) {
           super(data, parser, [], name);
           this.parser = parser;
       }
       /**
       Define a language from a parser.
       */
       static define(spec) {
           let data = defineLanguageFacet(spec.languageData);
           return new LRLanguage(data, spec.parser.configure({
               props: [languageDataProp.add(type => type.isTop ? data : undefined)]
           }), spec.name);
       }
       /**
       Create a new instance of this language with a reconfigured
       version of its parser and optionally a new name.
       */
       configure(options, name) {
           return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
       }
       get allowsNesting() { return this.parser.hasWrappers(); }
   }
   /**
   Get the syntax tree for a state, which is the current (possibly
   incomplete) parse tree of the active
   [language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
   language available.
   */
   function syntaxTree(state) {
       let field = state.field(Language.state, false);
       return field ? field.tree : Tree.empty;
   }
   /**
   Lezer-style
   [`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
   object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
   */
   class DocInput {
       /**
       Create an input object for the given document.
       */
       constructor(doc) {
           this.doc = doc;
           this.cursorPos = 0;
           this.string = "";
           this.cursor = doc.iter();
       }
       get length() { return this.doc.length; }
       syncTo(pos) {
           this.string = this.cursor.next(pos - this.cursorPos).value;
           this.cursorPos = pos + this.string.length;
           return this.cursorPos - this.string.length;
       }
       chunk(pos) {
           this.syncTo(pos);
           return this.string;
       }
       get lineChunks() { return true; }
       read(from, to) {
           let stringStart = this.cursorPos - this.string.length;
           if (from < stringStart || to >= this.cursorPos)
               return this.doc.sliceString(from, to);
           else
               return this.string.slice(from - stringStart, to - stringStart);
       }
   }
   let currentContext = null;
   /**
   A parse context provided to parsers working on the editor content.
   */
   class ParseContext {
       constructor(parser, 
       /**
       The current editor state.
       */
       state, 
       /**
       Tree fragments that can be reused by incremental re-parses.
       */
       fragments = [], 
       /**
       @internal
       */
       tree, 
       /**
       @internal
       */
       treeLen, 
       /**
       The current editor viewport (or some overapproximation
       thereof). Intended to be used for opportunistically avoiding
       work (in which case
       [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
       should be called to make sure the parser is restarted when the
       skipped region becomes visible).
       */
       viewport, 
       /**
       @internal
       */
       skipped, 
       /**
       This is where skipping parsers can register a promise that,
       when resolved, will schedule a new parse. It is cleared when
       the parse worker picks up the promise. @internal
       */
       scheduleOn) {
           this.parser = parser;
           this.state = state;
           this.fragments = fragments;
           this.tree = tree;
           this.treeLen = treeLen;
           this.viewport = viewport;
           this.skipped = skipped;
           this.scheduleOn = scheduleOn;
           this.parse = null;
           /**
           @internal
           */
           this.tempSkipped = [];
       }
       /**
       @internal
       */
       static create(parser, state, viewport) {
           return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
       }
       startParse() {
           return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
       }
       /**
       @internal
       */
       work(until, upto) {
           if (upto != null && upto >= this.state.doc.length)
               upto = undefined;
           if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
               this.takeTree();
               return true;
           }
           return this.withContext(() => {
               var _a;
               if (typeof until == "number") {
                   let endTime = Date.now() + until;
                   until = () => Date.now() > endTime;
               }
               if (!this.parse)
                   this.parse = this.startParse();
               if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                   upto < this.state.doc.length)
                   this.parse.stopAt(upto);
               for (;;) {
                   let done = this.parse.advance();
                   if (done) {
                       this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                       this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                       this.tree = done;
                       this.parse = null;
                       if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                           this.parse = this.startParse();
                       else
                           return true;
                   }
                   if (until())
                       return false;
               }
           });
       }
       /**
       @internal
       */
       takeTree() {
           let pos, tree;
           if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
               if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                   this.parse.stopAt(pos);
               this.withContext(() => { while (!(tree = this.parse.advance())) { } });
               this.treeLen = pos;
               this.tree = tree;
               this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
               this.parse = null;
           }
       }
       withContext(f) {
           let prev = currentContext;
           currentContext = this;
           try {
               return f();
           }
           finally {
               currentContext = prev;
           }
       }
       withoutTempSkipped(fragments) {
           for (let r; r = this.tempSkipped.pop();)
               fragments = cutFragments(fragments, r.from, r.to);
           return fragments;
       }
       /**
       @internal
       */
       changes(changes, newState) {
           let { fragments, tree, treeLen, viewport, skipped } = this;
           this.takeTree();
           if (!changes.empty) {
               let ranges = [];
               changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
               fragments = TreeFragment.applyChanges(fragments, ranges);
               tree = Tree.empty;
               treeLen = 0;
               viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
               if (this.skipped.length) {
                   skipped = [];
                   for (let r of this.skipped) {
                       let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                       if (from < to)
                           skipped.push({ from, to });
                   }
               }
           }
           return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
       }
       /**
       @internal
       */
       updateViewport(viewport) {
           if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
               return false;
           this.viewport = viewport;
           let startLen = this.skipped.length;
           for (let i = 0; i < this.skipped.length; i++) {
               let { from, to } = this.skipped[i];
               if (from < viewport.to && to > viewport.from) {
                   this.fragments = cutFragments(this.fragments, from, to);
                   this.skipped.splice(i--, 1);
               }
           }
           if (this.skipped.length >= startLen)
               return false;
           this.reset();
           return true;
       }
       /**
       @internal
       */
       reset() {
           if (this.parse) {
               this.takeTree();
               this.parse = null;
           }
       }
       /**
       Notify the parse scheduler that the given region was skipped
       because it wasn't in view, and the parse should be restarted
       when it comes into view.
       */
       skipUntilInView(from, to) {
           this.skipped.push({ from, to });
       }
       /**
       Returns a parser intended to be used as placeholder when
       asynchronously loading a nested parser. It'll skip its input and
       mark it as not-really-parsed, so that the next update will parse
       it again.
       
       When `until` is given, a reparse will be scheduled when that
       promise resolves.
       */
       static getSkippingParser(until) {
           return new class extends Parser$1 {
               createParse(input, fragments, ranges) {
                   let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                   let parser = {
                       parsedPos: from,
                       advance() {
                           let cx = currentContext;
                           if (cx) {
                               for (let r of ranges)
                                   cx.tempSkipped.push(r);
                               if (until)
                                   cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                           }
                           this.parsedPos = to;
                           return new Tree(NodeType.none, [], [], to - from);
                       },
                       stoppedAt: null,
                       stopAt() { }
                   };
                   return parser;
               }
           };
       }
       /**
       @internal
       */
       isDone(upto) {
           upto = Math.min(upto, this.state.doc.length);
           let frags = this.fragments;
           return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
       }
       /**
       Get the context for the current parse, or `null` if no editor
       parse is in progress.
       */
       static get() { return currentContext; }
   }
   function cutFragments(fragments, from, to) {
       return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
   }
   class LanguageState {
       constructor(
       // A mutable parse state that is used to preserve work done during
       // the lifetime of a state when moving to the next state.
       context) {
           this.context = context;
           this.tree = context.tree;
       }
       apply(tr) {
           if (!tr.docChanged && this.tree == this.context.tree)
               return this;
           let newCx = this.context.changes(tr.changes, tr.state);
           // If the previous parse wasn't done, go forward only up to its
           // end position or the end of the viewport, to avoid slowing down
           // state updates with parse work beyond the viewport.
           let upto = this.context.treeLen == tr.startState.doc.length ? undefined
               : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
           if (!newCx.work(20 /* Apply */, upto))
               newCx.takeTree();
           return new LanguageState(newCx);
       }
       static init(state) {
           let vpTo = Math.min(3000 /* InitViewport */, state.doc.length);
           let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
           if (!parseState.work(20 /* Apply */, vpTo))
               parseState.takeTree();
           return new LanguageState(parseState);
       }
   }
   Language.state = /*@__PURE__*/StateField.define({
       create: LanguageState.init,
       update(value, tr) {
           for (let e of tr.effects)
               if (e.is(Language.setState))
                   return e.value;
           if (tr.startState.facet(language) != tr.state.facet(language))
               return LanguageState.init(tr.state);
           return value.apply(tr);
       }
   });
   let requestIdle = (callback) => {
       let timeout = setTimeout(() => callback(), 500 /* MaxPause */);
       return () => clearTimeout(timeout);
   };
   if (typeof requestIdleCallback != "undefined")
       requestIdle = (callback) => {
           let idle = -1, timeout = setTimeout(() => {
               idle = requestIdleCallback(callback, { timeout: 500 /* MaxPause */ - 100 /* MinPause */ });
           }, 100 /* MinPause */);
           return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
       };
   const isInputPending = typeof navigator != "undefined" && ((_a$1 = navigator.scheduling) === null || _a$1 === void 0 ? void 0 : _a$1.isInputPending)
       ? () => navigator.scheduling.isInputPending() : null;
   const parseWorker = /*@__PURE__*/ViewPlugin.fromClass(class ParseWorker {
       constructor(view) {
           this.view = view;
           this.working = null;
           this.workScheduled = 0;
           // End of the current time chunk
           this.chunkEnd = -1;
           // Milliseconds of budget left for this chunk
           this.chunkBudget = -1;
           this.work = this.work.bind(this);
           this.scheduleWork();
       }
       update(update) {
           let cx = this.view.state.field(Language.state).context;
           if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
               this.scheduleWork();
           if (update.docChanged) {
               if (this.view.hasFocus)
                   this.chunkBudget += 50 /* ChangeBonus */;
               this.scheduleWork();
           }
           this.checkAsyncSchedule(cx);
       }
       scheduleWork() {
           if (this.working)
               return;
           let { state } = this.view, field = state.field(Language.state);
           if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
               this.working = requestIdle(this.work);
       }
       work(deadline) {
           this.working = null;
           let now = Date.now();
           if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
               this.chunkEnd = now + 30000 /* ChunkTime */;
               this.chunkBudget = 3000 /* ChunkBudget */;
           }
           if (this.chunkBudget <= 0)
               return; // No more budget
           let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
           if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* MaxParseAhead */))
               return;
           let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Slice */, deadline && !isInputPending ? Math.max(25 /* MinSlice */, deadline.timeRemaining() - 5) : 1e9);
           let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
           let done = field.context.work(() => {
               return isInputPending && isInputPending() || Date.now() > endTime;
           }, vpTo + (viewportFirst ? 0 : 100000 /* MaxParseAhead */));
           this.chunkBudget -= Date.now() - now;
           if (done || this.chunkBudget <= 0) {
               field.context.takeTree();
               this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
           }
           if (this.chunkBudget > 0 && !(done && !viewportFirst))
               this.scheduleWork();
           this.checkAsyncSchedule(field.context);
       }
       checkAsyncSchedule(cx) {
           if (cx.scheduleOn) {
               this.workScheduled++;
               cx.scheduleOn
                   .then(() => this.scheduleWork())
                   .catch(err => logException(this.view.state, err))
                   .then(() => this.workScheduled--);
               cx.scheduleOn = null;
           }
       }
       destroy() {
           if (this.working)
               this.working();
       }
       isWorking() {
           return !!(this.working || this.workScheduled > 0);
       }
   }, {
       eventHandlers: { focus() { this.scheduleWork(); } }
   });
   /**
   The facet used to associate a language with an editor state. Used
   by `Language` object's `extension` property (so you don't need to
   manually wrap your languages in this). Can be used to access the
   current language on a state.
   */
   const language = /*@__PURE__*/Facet.define({
       combine(languages) { return languages.length ? languages[0] : null; },
       enables: language => [
           Language.state,
           parseWorker,
           EditorView.contentAttributes.compute([language], state => {
               let lang = state.facet(language);
               return lang && lang.name ? { "data-language": lang.name } : {};
           })
       ]
   });
   /**
   This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
   optional set of supporting extensions. Language packages are
   encouraged to export a function that optionally takes a
   configuration object and returns a `LanguageSupport` instance, as
   the main way for client code to use the package.
   */
   class LanguageSupport {
       /**
       Create a language support object.
       */
       constructor(
       /**
       The language object.
       */
       language, 
       /**
       An optional set of supporting extensions. When nesting a
       language in another language, the outer language is encouraged
       to include the supporting extensions for its inner languages
       in its own set of support extensions.
       */
       support = []) {
           this.language = language;
           this.support = support;
           this.extension = [language, support];
       }
   }

   /**
   Facet that defines a way to provide a function that computes the
   appropriate indentation depth, as a column number (see
   [`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
   line. A return value of `null` indicates no indentation can be
   determined, and the line should inherit the indentation of the one
   above it. A return value of `undefined` defers to the next indent
   service.
   */
   const indentService = /*@__PURE__*/Facet.define();
   /**
   Facet for overriding the unit by which indentation happens. Should
   be a string consisting either entirely of the same whitespace
   character. When not set, this defaults to 2 spaces.
   */
   const indentUnit = /*@__PURE__*/Facet.define({
       combine: values => {
           if (!values.length)
               return "  ";
           let unit = values[0];
           if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))
               throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
           return unit;
       }
   });
   /**
   Return the _column width_ of an indent unit in the state.
   Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
   facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
   contains tabs.
   */
   function getIndentUnit(state) {
       let unit = state.facet(indentUnit);
       return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
   }
   /**
   Create an indentation string that covers columns 0 to `cols`.
   Will use tabs for as much of the columns as possible when the
   [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
   tabs.
   */
   function indentString(state, cols) {
       let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
       if (ch == "\t") {
           while (cols >= ts) {
               result += "\t";
               cols -= ts;
           }
           ch = " ";
       }
       for (let i = 0; i < cols; i++)
           result += ch;
       return result;
   }
   /**
   Get the indentation, as a column number, at the given position.
   Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
   that are registered, and if none of those return an indentation,
   this will check the syntax tree for the [indent node
   prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
   number when an indentation could be determined, and null
   otherwise.
   */
   function getIndentation(context, pos) {
       if (context instanceof EditorState)
           context = new IndentContext(context);
       for (let service of context.state.facet(indentService)) {
           let result = service(context, pos);
           if (result !== undefined)
               return result;
       }
       let tree = syntaxTree(context.state);
       return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
   }
   /**
   Indentation contexts are used when calling [indentation
   services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
   useful in indentation logic, and can selectively override the
   indentation reported for some lines.
   */
   class IndentContext {
       /**
       Create an indent context.
       */
       constructor(
       /**
       The editor state.
       */
       state, 
       /**
       @internal
       */
       options = {}) {
           this.state = state;
           this.options = options;
           this.unit = getIndentUnit(state);
       }
       /**
       Get a description of the line at the given position, taking
       [simulated line
       breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
       into account. If there is such a break at `pos`, the `bias`
       argument determines whether the part of the line line before or
       after the break is used.
       */
       lineAt(pos, bias = 1) {
           let line = this.state.doc.lineAt(pos);
           let { simulateBreak, simulateDoubleBreak } = this.options;
           if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
               if (simulateDoubleBreak && simulateBreak == pos)
                   return { text: "", from: pos };
               else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                   return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
               else
                   return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
           }
           return line;
       }
       /**
       Get the text directly after `pos`, either the entire line
       or the next 100 characters, whichever is shorter.
       */
       textAfterPos(pos, bias = 1) {
           if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
               return "";
           let { text, from } = this.lineAt(pos, bias);
           return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
       }
       /**
       Find the column for the given position.
       */
       column(pos, bias = 1) {
           let { text, from } = this.lineAt(pos, bias);
           let result = this.countColumn(text, pos - from);
           let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
           if (override > -1)
               result += override - this.countColumn(text, text.search(/\S|$/));
           return result;
       }
       /**
       Find the column position (taking tabs into account) of the given
       position in the given string.
       */
       countColumn(line, pos = line.length) {
           return countColumn(line, this.state.tabSize, pos);
       }
       /**
       Find the indentation column of the line at the given point.
       */
       lineIndent(pos, bias = 1) {
           let { text, from } = this.lineAt(pos, bias);
           let override = this.options.overrideIndentation;
           if (override) {
               let overriden = override(from);
               if (overriden > -1)
                   return overriden;
           }
           return this.countColumn(text, text.search(/\S|$/));
       }
       /**
       Returns the [simulated line
       break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
       for this context, if any.
       */
       get simulatedBreak() {
           return this.options.simulateBreak || null;
       }
   }
   /**
   A syntax tree node prop used to associate indentation strategies
   with node types. Such a strategy is a function from an indentation
   context to a column number (see also
   [`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
   indicates that no definitive indentation can be determined.
   */
   const indentNodeProp = /*@__PURE__*/new NodeProp();
   // Compute the indentation for a given position from the syntax tree.
   function syntaxIndentation(cx, ast, pos) {
       return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
   }
   function ignoreClosed(cx) {
       return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
   }
   function indentStrategy(tree) {
       let strategy = tree.type.prop(indentNodeProp);
       if (strategy)
           return strategy;
       let first = tree.firstChild, close;
       if (first && (close = first.type.prop(NodeProp.closedBy))) {
           let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
           return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
       }
       return tree.parent == null ? topIndent : null;
   }
   function indentFrom(node, pos, base) {
       for (; node; node = node.parent) {
           let strategy = indentStrategy(node);
           if (strategy)
               return strategy(TreeIndentContext.create(base, pos, node));
       }
       return null;
   }
   function topIndent() { return 0; }
   /**
   Objects of this type provide context information and helper
   methods to indentation functions registered on syntax nodes.
   */
   class TreeIndentContext extends IndentContext {
       constructor(base, 
       /**
       The position at which indentation is being computed.
       */
       pos, 
       /**
       The syntax tree node to which the indentation strategy
       applies.
       */
       node) {
           super(base.state, base.options);
           this.base = base;
           this.pos = pos;
           this.node = node;
       }
       /**
       @internal
       */
       static create(base, pos, node) {
           return new TreeIndentContext(base, pos, node);
       }
       /**
       Get the text directly after `this.pos`, either the entire line
       or the next 100 characters, whichever is shorter.
       */
       get textAfter() {
           return this.textAfterPos(this.pos);
       }
       /**
       Get the indentation at the reference line for `this.node`, which
       is the line on which it starts, unless there is a node that is
       _not_ a parent of this node covering the start of that line. If
       so, the line at the start of that node is tried, again skipping
       on if it is covered by another such node.
       */
       get baseIndent() {
           return this.baseIndentFor(this.node);
       }
       /**
       Get the indentation for the reference line of the given node
       (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
       */
       baseIndentFor(node) {
           let line = this.state.doc.lineAt(node.from);
           // Skip line starts that are covered by a sibling (or cousin, etc)
           for (;;) {
               let atBreak = node.resolve(line.from);
               while (atBreak.parent && atBreak.parent.from == atBreak.from)
                   atBreak = atBreak.parent;
               if (isParent(atBreak, node))
                   break;
               line = this.state.doc.lineAt(atBreak.from);
           }
           return this.lineIndent(line.from);
       }
       /**
       Continue looking for indentations in the node's parent nodes,
       and return the result of that.
       */
       continue() {
           let parent = this.node.parent;
           return parent ? indentFrom(parent, this.pos, this.base) : 0;
       }
   }
   function isParent(parent, of) {
       for (let cur = of; cur; cur = cur.parent)
           if (parent == cur)
               return true;
       return false;
   }
   // Check whether a delimited node is aligned (meaning there are
   // non-skipped nodes on the same line as the opening delimiter). And
   // if so, return the opening token.
   function bracketedAligned(context) {
       let tree = context.node;
       let openToken = tree.childAfter(tree.from), last = tree.lastChild;
       if (!openToken)
           return null;
       let sim = context.options.simulateBreak;
       let openLine = context.state.doc.lineAt(openToken.from);
       let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
       for (let pos = openToken.to;;) {
           let next = tree.childAfter(pos);
           if (!next || next == last)
               return null;
           if (!next.type.isSkipped)
               return next.from < lineEnd ? openToken : null;
           pos = next.to;
       }
   }
   function delimitedStrategy(context, align, units, closing, closedAt) {
       let after = context.textAfter, space = after.match(/^\s*/)[0].length;
       let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
       let aligned = align ? bracketedAligned(context) : null;
       if (aligned)
           return closed ? context.column(aligned.from) : context.column(aligned.to);
       return context.baseIndent + (closed ? 0 : context.unit * units);
   }
   const DontIndentBeyond = 200;
   /**
   Enables reindentation on input. When a language defines an
   `indentOnInput` field in its [language
   data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
   expression, the line at the cursor will be reindented whenever new
   text is typed and the input from the start of the line up to the
   cursor matches that regexp.

   To avoid unneccesary reindents, it is recommended to start the
   regexp with `^` (usually followed by `\s*`), and end it with `$`.
   For example, `/^\s*\}$/` will reindent when a closing brace is
   added at the start of a line.
   */
   function indentOnInput() {
       return EditorState.transactionFilter.of(tr => {
           if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
               return tr;
           let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
           if (!rules.length)
               return tr;
           let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
           if (head > line.from + DontIndentBeyond)
               return tr;
           let lineStart = doc.sliceString(line.from, head);
           if (!rules.some(r => r.test(lineStart)))
               return tr;
           let { state } = tr, last = -1, changes = [];
           for (let { head } of state.selection.ranges) {
               let line = state.doc.lineAt(head);
               if (line.from == last)
                   continue;
               last = line.from;
               let indent = getIndentation(state, line.from);
               if (indent == null)
                   continue;
               let cur = /^\s*/.exec(line.text)[0];
               let norm = indentString(state, indent);
               if (cur != norm)
                   changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
           }
           return changes.length ? [tr, { changes, sequential: true }] : tr;
       });
   }

   /**
   A facet that registers a code folding service. When called with
   the extent of a line, such a function should return a foldable
   range that starts on that line (but continues beyond it), if one
   can be found.
   */
   const foldService = /*@__PURE__*/Facet.define();
   /**
   This node prop is used to associate folding information with
   syntax node types. Given a syntax node, it should check whether
   that tree is foldable and return the range that can be collapsed
   when it is.
   */
   const foldNodeProp = /*@__PURE__*/new NodeProp();
   function syntaxFolding(state, start, end) {
       let tree = syntaxTree(state);
       if (tree.length < end)
           return null;
       let inner = tree.resolveInner(end, 1);
       let found = null;
       for (let cur = inner; cur; cur = cur.parent) {
           if (cur.to <= end || cur.from > end)
               continue;
           if (found && cur.from < start)
               break;
           let prop = cur.type.prop(foldNodeProp);
           if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
               let value = prop(cur, state);
               if (value && value.from <= end && value.from >= start && value.to > end)
                   found = value;
           }
       }
       return found;
   }
   function isUnfinished(node) {
       let ch = node.lastChild;
       return ch && ch.to == node.to && ch.type.isError;
   }
   /**
   Check whether the given line is foldable. First asks any fold
   services registered through
   [`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
   a result, tries to query the [fold node
   prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
   of the line.
   */
   function foldable(state, lineStart, lineEnd) {
       for (let service of state.facet(foldService)) {
           let result = service(state, lineStart, lineEnd);
           if (result)
               return result;
       }
       return syntaxFolding(state, lineStart, lineEnd);
   }
   function mapRange(range, mapping) {
       let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
       return from >= to ? undefined : { from, to };
   }
   /**
   State effect that can be attached to a transaction to fold the
   given range. (You probably only need this in exceptional
   circumstances—usually you'll just want to let
   [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
   gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
   */
   const foldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });
   /**
   State effect that unfolds the given range (if it was folded).
   */
   const unfoldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });
   function selectedLines(view) {
       let lines = [];
       for (let { head } of view.state.selection.ranges) {
           if (lines.some(l => l.from <= head && l.to >= head))
               continue;
           lines.push(view.lineBlockAt(head));
       }
       return lines;
   }
   /**
   The state field that stores the folded ranges (as a [decoration
   set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
   [`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
   [`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
   state.
   */
   const foldState = /*@__PURE__*/StateField.define({
       create() {
           return Decoration.none;
       },
       update(folded, tr) {
           folded = folded.map(tr.changes);
           for (let e of tr.effects) {
               if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
                   let { preparePlaceholder } = tr.state.facet(foldConfig);
                   let widget = !preparePlaceholder ? foldWidget :
                       Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
                   folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
               }
               else if (e.is(unfoldEffect)) {
                   folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                       filterFrom: e.value.from, filterTo: e.value.to });
               }
           }
           // Clear folded ranges that cover the selection head
           if (tr.selection) {
               let onSelection = false, { head } = tr.selection.main;
               folded.between(head, head, (a, b) => { if (a < head && b > head)
                   onSelection = true; });
               if (onSelection)
                   folded = folded.update({
                       filterFrom: head,
                       filterTo: head,
                       filter: (a, b) => b <= head || a >= head
                   });
           }
           return folded;
       },
       provide: f => EditorView.decorations.from(f),
       toJSON(folded, state) {
           let ranges = [];
           folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
           return ranges;
       },
       fromJSON(value) {
           if (!Array.isArray(value) || value.length % 2)
               throw new RangeError("Invalid JSON for fold state");
           let ranges = [];
           for (let i = 0; i < value.length;) {
               let from = value[i++], to = value[i++];
               if (typeof from != "number" || typeof to != "number")
                   throw new RangeError("Invalid JSON for fold state");
               ranges.push(foldWidget.range(from, to));
           }
           return Decoration.set(ranges, true);
       }
   });
   function findFold(state, from, to) {
       var _a;
       let found = null;
       (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
           if (!found || found.from > from)
               found = { from, to };
       });
       return found;
   }
   function foldExists(folded, from, to) {
       let found = false;
       folded.between(from, from, (a, b) => { if (a == from && b == to)
           found = true; });
       return found;
   }
   function maybeEnable(state, other) {
       return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
   }
   /**
   Fold the lines that are selected, if possible.
   */
   const foldCode = view => {
       for (let line of selectedLines(view)) {
           let range = foldable(view.state, line.from, line.to);
           if (range) {
               view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
               return true;
           }
       }
       return false;
   };
   /**
   Unfold folded ranges on selected lines.
   */
   const unfoldCode = view => {
       if (!view.state.field(foldState, false))
           return false;
       let effects = [];
       for (let line of selectedLines(view)) {
           let folded = findFold(view.state, line.from, line.to);
           if (folded)
               effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
       }
       if (effects.length)
           view.dispatch({ effects });
       return effects.length > 0;
   };
   function announceFold(view, range, fold = true) {
       let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
       return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
   }
   /**
   Fold all top-level foldable ranges. Note that, in most cases,
   folding information will depend on the [syntax
   tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
   reliably when the document hasn't been fully parsed (either
   because the editor state was only just initialized, or because the
   document is so big that the parser decided not to parse it
   entirely).
   */
   const foldAll = view => {
       let { state } = view, effects = [];
       for (let pos = 0; pos < state.doc.length;) {
           let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
           if (range)
               effects.push(foldEffect.of(range));
           pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
       }
       if (effects.length)
           view.dispatch({ effects: maybeEnable(view.state, effects) });
       return !!effects.length;
   };
   /**
   Unfold all folded code.
   */
   const unfoldAll = view => {
       let field = view.state.field(foldState, false);
       if (!field || !field.size)
           return false;
       let effects = [];
       field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
       view.dispatch({ effects });
       return true;
   };
   /**
   Default fold-related key bindings.

    - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
    - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
    - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
    - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
   */
   const foldKeymap = [
       { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
       { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
       { key: "Ctrl-Alt-[", run: foldAll },
       { key: "Ctrl-Alt-]", run: unfoldAll }
   ];
   const defaultConfig = {
       placeholderDOM: null,
       preparePlaceholder: null,
       placeholderText: "…"
   };
   const foldConfig = /*@__PURE__*/Facet.define({
       combine(values) { return combineConfig(values, defaultConfig); }
   });
   /**
   Create an extension that configures code folding.
   */
   function codeFolding(config) {
       let result = [foldState, baseTheme$1$2];
       if (config)
           result.push(foldConfig.of(config));
       return result;
   }
   function widgetToDOM(view, prepared) {
       let { state } = view, conf = state.facet(foldConfig);
       let onclick = (event) => {
           let line = view.lineBlockAt(view.posAtDOM(event.target));
           let folded = findFold(view.state, line.from, line.to);
           if (folded)
               view.dispatch({ effects: unfoldEffect.of(folded) });
           event.preventDefault();
       };
       if (conf.placeholderDOM)
           return conf.placeholderDOM(view, onclick, prepared);
       let element = document.createElement("span");
       element.textContent = conf.placeholderText;
       element.setAttribute("aria-label", state.phrase("folded code"));
       element.title = state.phrase("unfold");
       element.className = "cm-foldPlaceholder";
       element.onclick = onclick;
       return element;
   }
   const foldWidget = /*@__PURE__*/Decoration.replace({ widget: /*@__PURE__*/new class extends WidgetType {
           toDOM(view) { return widgetToDOM(view, null); }
       } });
   class PreparedFoldWidget extends WidgetType {
       constructor(value) {
           super();
           this.value = value;
       }
       eq(other) { return this.value == other.value; }
       toDOM(view) { return widgetToDOM(view, this.value); }
   }
   const foldGutterDefaults = {
       openText: "⌄",
       closedText: "›",
       markerDOM: null,
       domEventHandlers: {},
       foldingChanged: () => false
   };
   class FoldMarker extends GutterMarker {
       constructor(config, open) {
           super();
           this.config = config;
           this.open = open;
       }
       eq(other) { return this.config == other.config && this.open == other.open; }
       toDOM(view) {
           if (this.config.markerDOM)
               return this.config.markerDOM(this.open);
           let span = document.createElement("span");
           span.textContent = this.open ? this.config.openText : this.config.closedText;
           span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
           return span;
       }
   }
   /**
   Create an extension that registers a fold gutter, which shows a
   fold status indicator before foldable lines (which can be clicked
   to fold or unfold the line).
   */
   function foldGutter(config = {}) {
       let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
       let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
       let markers = ViewPlugin.fromClass(class {
           constructor(view) {
               this.from = view.viewport.from;
               this.markers = this.buildMarkers(view);
           }
           update(update) {
               if (update.docChanged || update.viewportChanged ||
                   update.startState.facet(language) != update.state.facet(language) ||
                   update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                   syntaxTree(update.startState) != syntaxTree(update.state) ||
                   fullConfig.foldingChanged(update))
                   this.markers = this.buildMarkers(update.view);
           }
           buildMarkers(view) {
               let builder = new RangeSetBuilder();
               for (let line of view.viewportLineBlocks) {
                   let mark = findFold(view.state, line.from, line.to) ? canUnfold
                       : foldable(view.state, line.from, line.to) ? canFold : null;
                   if (mark)
                       builder.add(line.from, line.from, mark);
               }
               return builder.finish();
           }
       });
       let { domEventHandlers } = fullConfig;
       return [
           markers,
           gutter({
               class: "cm-foldGutter",
               markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty; },
               initialSpacer() {
                   return new FoldMarker(fullConfig, false);
               },
               domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                       if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                           return true;
                       let folded = findFold(view.state, line.from, line.to);
                       if (folded) {
                           view.dispatch({ effects: unfoldEffect.of(folded) });
                           return true;
                       }
                       let range = foldable(view.state, line.from, line.to);
                       if (range) {
                           view.dispatch({ effects: foldEffect.of(range) });
                           return true;
                       }
                       return false;
                   } })
           }),
           codeFolding()
       ];
   }
   const baseTheme$1$2 = /*@__PURE__*/EditorView.baseTheme({
       ".cm-foldPlaceholder": {
           backgroundColor: "#eee",
           border: "1px solid #ddd",
           color: "#888",
           borderRadius: ".2em",
           margin: "0 1px",
           padding: "0 1px",
           cursor: "pointer"
       },
       ".cm-foldGutter span": {
           padding: "0 1px",
           cursor: "pointer"
       }
   });

   /**
   A highlight style associates CSS styles with higlighting
   [tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
   */
   class HighlightStyle {
       constructor(
       /**
       The tag styles used to create this highlight style.
       */
       specs, options) {
           this.specs = specs;
           let modSpec;
           function def(spec) {
               let cls = StyleModule.newName();
               (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
               return cls;
           }
           const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
           const scopeOpt = options.scope;
           this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
               : scopeOpt ? (type) => type == scopeOpt : undefined;
           this.style = tagHighlighter(specs.map(style => ({
               tag: style.tag,
               class: style.class || def(Object.assign({}, style, { tag: null }))
           })), {
               all,
           }).style;
           this.module = modSpec ? new StyleModule(modSpec) : null;
           this.themeType = options.themeType;
       }
       /**
       Create a highlighter style that associates the given styles to
       the given tags. The specs must be objects that hold a style tag
       or array of tags in their `tag` property, and either a single
       `class` property providing a static CSS class (for highlighter
       that rely on external styling), or a
       [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
       set of CSS properties (which define the styling for those tags).
       
       The CSS rules created for a highlighter will be emitted in the
       order of the spec's properties. That means that for elements that
       have multiple tags associated with them, styles defined further
       down in the list will have a higher CSS precedence than styles
       defined earlier.
       */
       static define(specs, options) {
           return new HighlightStyle(specs, options || {});
       }
   }
   const highlighterFacet = /*@__PURE__*/Facet.define();
   const fallbackHighlighter = /*@__PURE__*/Facet.define({
       combine(values) { return values.length ? [values[0]] : null; }
   });
   function getHighlighters(state) {
       let main = state.facet(highlighterFacet);
       return main.length ? main : state.facet(fallbackHighlighter);
   }
   /**
   Wrap a highlighter in an editor extension that uses it to apply
   syntax highlighting to the editor content.

   When multiple (non-fallback) styles are provided, the styling
   applied is the union of the classes they emit.
   */
   function syntaxHighlighting(highlighter, options) {
       let ext = [treeHighlighter], themeType;
       if (highlighter instanceof HighlightStyle) {
           if (highlighter.module)
               ext.push(EditorView.styleModule.of(highlighter.module));
           themeType = highlighter.themeType;
       }
       if (options === null || options === void 0 ? void 0 : options.fallback)
           ext.push(fallbackHighlighter.of(highlighter));
       else if (themeType)
           ext.push(highlighterFacet.computeN([EditorView.darkTheme], state => {
               return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
           }));
       else
           ext.push(highlighterFacet.of(highlighter));
       return ext;
   }
   class TreeHighlighter {
       constructor(view) {
           this.markCache = Object.create(null);
           this.tree = syntaxTree(view.state);
           this.decorations = this.buildDeco(view, getHighlighters(view.state));
       }
       update(update) {
           let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
           let styleChange = highlighters != getHighlighters(update.startState);
           if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
               this.decorations = this.decorations.map(update.changes);
           }
           else if (tree != this.tree || update.viewportChanged || styleChange) {
               this.tree = tree;
               this.decorations = this.buildDeco(update.view, highlighters);
           }
       }
       buildDeco(view, highlighters) {
           if (!highlighters || !this.tree.length)
               return Decoration.none;
           let builder = new RangeSetBuilder();
           for (let { from, to } of view.visibleRanges) {
               highlightTree(this.tree, highlighters, (from, to, style) => {
                   builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
               }, from, to);
           }
           return builder.finish();
       }
   }
   const treeHighlighter = /*@__PURE__*/Prec.high(/*@__PURE__*/ViewPlugin.fromClass(TreeHighlighter, {
       decorations: v => v.decorations
   }));
   /**
   A default highlight style (works well with light themes).
   */
   const defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([
       { tag: tags.meta,
           color: "#404740" },
       { tag: tags.link,
           textDecoration: "underline" },
       { tag: tags.heading,
           textDecoration: "underline",
           fontWeight: "bold" },
       { tag: tags.emphasis,
           fontStyle: "italic" },
       { tag: tags.strong,
           fontWeight: "bold" },
       { tag: tags.strikethrough,
           textDecoration: "line-through" },
       { tag: tags.keyword,
           color: "#708" },
       { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
           color: "#219" },
       { tag: [tags.literal, tags.inserted],
           color: "#164" },
       { tag: [tags.string, tags.deleted],
           color: "#a11" },
       { tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],
           color: "#e40" },
       { tag: /*@__PURE__*/tags.definition(tags.variableName),
           color: "#00f" },
       { tag: /*@__PURE__*/tags.local(tags.variableName),
           color: "#30a" },
       { tag: [tags.typeName, tags.namespace],
           color: "#085" },
       { tag: tags.className,
           color: "#167" },
       { tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],
           color: "#256" },
       { tag: /*@__PURE__*/tags.definition(tags.propertyName),
           color: "#00c" },
       { tag: tags.comment,
           color: "#940" },
       { tag: tags.invalid,
           color: "#f00" }
   ]);

   const baseTheme$3 = /*@__PURE__*/EditorView.baseTheme({
       "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
       "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
   });
   const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
   const bracketMatchingConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           return combineConfig(configs, {
               afterCursor: true,
               brackets: DefaultBrackets,
               maxScanDistance: DefaultScanDist,
               renderMatch: defaultRenderMatch
           });
       }
   });
   const matchingMark = /*@__PURE__*/Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /*@__PURE__*/Decoration.mark({ class: "cm-nonmatchingBracket" });
   function defaultRenderMatch(match) {
       let decorations = [];
       let mark = match.matched ? matchingMark : nonmatchingMark;
       decorations.push(mark.range(match.start.from, match.start.to));
       if (match.end)
           decorations.push(mark.range(match.end.from, match.end.to));
       return decorations;
   }
   const bracketMatchingState = /*@__PURE__*/StateField.define({
       create() { return Decoration.none; },
       update(deco, tr) {
           if (!tr.docChanged && !tr.selection)
               return deco;
           let decorations = [];
           let config = tr.state.facet(bracketMatchingConfig);
           for (let range of tr.state.selection.ranges) {
               if (!range.empty)
                   continue;
               let match = matchBrackets(tr.state, range.head, -1, config)
                   || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                   || (config.afterCursor &&
                       (matchBrackets(tr.state, range.head, 1, config) ||
                           (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
               if (match)
                   decorations = decorations.concat(config.renderMatch(match, tr.state));
           }
           return Decoration.set(decorations, true);
       },
       provide: f => EditorView.decorations.from(f)
   });
   const bracketMatchingUnique = [
       bracketMatchingState,
       baseTheme$3
   ];
   /**
   Create an extension that enables bracket matching. Whenever the
   cursor is next to a bracket, that bracket and the one it matches
   are highlighted. Or, when no matching bracket is found, another
   highlighting style is used to indicate this.
   */
   function bracketMatching(config = {}) {
       return [bracketMatchingConfig.of(config), bracketMatchingUnique];
   }
   /**
   When larger syntax nodes, such as HTML tags, are marked as
   opening/closing, it can be a bit messy to treat the whole node as
   a matchable bracket. This node prop allows you to define, for such
   a node, a ‘handle’—the part of the node that is highlighted, and
   that the cursor must be on to activate highlighting in the first
   place.
   */
   const bracketMatchingHandle = /*@__PURE__*/new NodeProp();
   function matchingNodes(node, dir, brackets) {
       let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
       if (byProp)
           return byProp;
       if (node.name.length == 1) {
           let index = brackets.indexOf(node.name);
           if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
               return [brackets[index + dir]];
       }
       return null;
   }
   function findHandle(node) {
       let hasHandle = node.type.prop(bracketMatchingHandle);
       return hasHandle ? hasHandle(node.node) : node;
   }
   /**
   Find the matching bracket for the token at `pos`, scanning
   direction `dir`. Only the `brackets` and `maxScanDistance`
   properties are used from `config`, if given. Returns null if no
   bracket was found at `pos`, or a match result otherwise.
   */
   function matchBrackets(state, pos, dir, config = {}) {
       let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
       let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
       for (let cur = node; cur; cur = cur.parent) {
           let matches = matchingNodes(cur.type, dir, brackets);
           if (matches && cur.from < cur.to) {
               let handle = findHandle(cur);
               if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                   return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
           }
       }
       return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
   }
   function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
       let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
       let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
       if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
           do {
               if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                   if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                       let endHandle = findHandle(cursor);
                       return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };
                   }
                   else if (matchingNodes(cursor.type, dir, brackets)) {
                       depth++;
                   }
                   else if (matchingNodes(cursor.type, -dir, brackets)) {
                       if (depth == 0) {
                           let endHandle = findHandle(cursor);
                           return {
                               start: firstToken,
                               end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,
                               matched: false
                           };
                       }
                       depth--;
                   }
               }
           } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
       return { start: firstToken, matched: false };
   }
   function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
       let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
       let bracket = brackets.indexOf(startCh);
       if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
           return null;
       let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
       let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
       for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
           let text = iter.value;
           if (dir < 0)
               distance += text.length;
           let basePos = pos + distance * dir;
           for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
               let found = brackets.indexOf(text[pos]);
               if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                   continue;
               if ((found % 2 == 0) == (dir > 0)) {
                   depth++;
               }
               else if (depth == 1) { // Closing
                   return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
               }
               else {
                   depth--;
               }
           }
           if (dir > 0)
               distance += text.length;
       }
       return iter.done ? { start: startToken, matched: false } : null;
   }
   const noTokens = /*@__PURE__*/Object.create(null);
   const typeArray = [NodeType.none];
   const warned = [];
   const defaultTable = /*@__PURE__*/Object.create(null);
   for (let [legacyName, name] of [
       ["variable", "variableName"],
       ["variable-2", "variableName.special"],
       ["string-2", "string.special"],
       ["def", "variableName.definition"],
       ["tag", "tagName"],
       ["attribute", "attributeName"],
       ["type", "typeName"],
       ["builtin", "variableName.standard"],
       ["qualifier", "modifier"],
       ["error", "invalid"],
       ["header", "heading"],
       ["property", "propertyName"]
   ])
       defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);
   function warnForPart(part, msg) {
       if (warned.indexOf(part) > -1)
           return;
       warned.push(part);
       console.warn(msg);
   }
   function createTokenType(extra, tagStr) {
       let tag = null;
       for (let part of tagStr.split(".")) {
           let value = (extra[part] || tags[part]);
           if (!value) {
               warnForPart(part, `Unknown highlighting tag ${part}`);
           }
           else if (typeof value == "function") {
               if (!tag)
                   warnForPart(part, `Modifier ${part} used at start of tag`);
               else
                   tag = value(tag);
           }
           else {
               if (tag)
                   warnForPart(part, `Tag ${part} used as modifier`);
               else
                   tag = value;
           }
       }
       if (!tag)
           return 0;
       let name = tagStr.replace(/ /g, "_"), type = NodeType.define({
           id: typeArray.length,
           name,
           props: [styleTags({ [name]: tag })]
       });
       typeArray.push(type);
       return type.id;
   }

   /**
   Comment or uncomment the current selection. Will use line comments
   if available, otherwise falling back to block comments.
   */
   const toggleComment = target => {
       let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
       return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
   };
   function command(f, option) {
       return ({ state, dispatch }) => {
           if (state.readOnly)
               return false;
           let tr = f(option, state);
           if (!tr)
               return false;
           dispatch(state.update(tr));
           return true;
       };
   }
   /**
   Comment or uncomment the current selection using line comments.
   The line comment syntax is taken from the
   [`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
   data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
   */
   const toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);
   /**
   Comment or uncomment the current selection using block comments.
   The block comment syntax is taken from the
   [`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
   data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
   */
   const toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);
   /**
   Comment or uncomment the lines around the current selection using
   block comments.
   */
   const toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);
   function getConfig(state, pos) {
       let data = state.languageDataAt("commentTokens", pos);
       return data.length ? data[0] : {};
   }
   const SearchMargin = 50;
   /**
   Determines if the given range is block-commented in the given
   state.
   */
   function findBlockComment(state, { open, close }, from, to) {
       let textBefore = state.sliceDoc(from - SearchMargin, from);
       let textAfter = state.sliceDoc(to, to + SearchMargin);
       let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
       let beforeOff = textBefore.length - spaceBefore;
       if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
           textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
           return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
               close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
       }
       let startText, endText;
       if (to - from <= 2 * SearchMargin) {
           startText = endText = state.sliceDoc(from, to);
       }
       else {
           startText = state.sliceDoc(from, from + SearchMargin);
           endText = state.sliceDoc(to - SearchMargin, to);
       }
       let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
       let endOff = endText.length - endSpace - close.length;
       if (startText.slice(startSpace, startSpace + open.length) == open &&
           endText.slice(endOff, endOff + close.length) == close) {
           return { open: { pos: from + startSpace + open.length,
                   margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
               close: { pos: to - endSpace - close.length,
                   margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
       }
       return null;
   }
   function selectedLineRanges(state) {
       let ranges = [];
       for (let r of state.selection.ranges) {
           let fromLine = state.doc.lineAt(r.from);
           let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
           let last = ranges.length - 1;
           if (last >= 0 && ranges[last].to > fromLine.from)
               ranges[last].to = toLine.to;
           else
               ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
       }
       return ranges;
   }
   // Performs toggle, comment and uncomment of block comments in
   // languages that support them.
   function changeBlockComment(option, state, ranges = state.selection.ranges) {
       let tokens = ranges.map(r => getConfig(state, r.from).block);
       if (!tokens.every(c => c))
           return null;
       let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
       if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {
           return { changes: state.changes(ranges.map((range, i) => {
                   if (comments[i])
                       return [];
                   return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
               })) };
       }
       else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {
           let changes = [];
           for (let i = 0, comment; i < comments.length; i++)
               if (comment = comments[i]) {
                   let token = tokens[i], { open, close } = comment;
                   changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
               }
           return { changes };
       }
       return null;
   }
   // Performs toggle, comment and uncomment of line comments.
   function changeLineComment(option, state, ranges = state.selection.ranges) {
       let lines = [];
       let prevLine = -1;
       for (let { from, to } of ranges) {
           let startI = lines.length, minIndent = 1e9;
           let token = getConfig(state, from).line;
           if (!token)
               continue;
           for (let pos = from; pos <= to;) {
               let line = state.doc.lineAt(pos);
               if (line.from > prevLine && (from == to || to > line.from)) {
                   prevLine = line.from;
                   let indent = /^\s*/.exec(line.text)[0].length;
                   let empty = indent == line.length;
                   let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                   if (indent < line.text.length && indent < minIndent)
                       minIndent = indent;
                   lines.push({ line, comment, token, indent, empty, single: false });
               }
               pos = line.to + 1;
           }
           if (minIndent < 1e9)
               for (let i = startI; i < lines.length; i++)
                   if (lines[i].indent < lines[i].line.text.length)
                       lines[i].indent = minIndent;
           if (lines.length == startI + 1)
               lines[startI].single = true;
       }
       if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
           let changes = [];
           for (let { line, token, indent, empty, single } of lines)
               if (single || !empty)
                   changes.push({ from: line.from + indent, insert: token + " " });
           let changeSet = state.changes(changes);
           return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
       }
       else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {
           let changes = [];
           for (let { line, comment, token } of lines)
               if (comment >= 0) {
                   let from = line.from + comment, to = from + token.length;
                   if (line.text[to - line.from] == " ")
                       to++;
                   changes.push({ from, to });
               }
           return { changes };
       }
       return null;
   }

   const fromHistory = /*@__PURE__*/Annotation.define();
   /**
   Transaction annotation that will prevent that transaction from
   being combined with other transactions in the undo history. Given
   `"before"`, it'll prevent merging with previous transactions. With
   `"after"`, subsequent transactions won't be combined with this
   one. With `"full"`, the transaction is isolated on both sides.
   */
   const isolateHistory = /*@__PURE__*/Annotation.define();
   /**
   This facet provides a way to register functions that, given a
   transaction, provide a set of effects that the history should
   store when inverting the transaction. This can be used to
   integrate some kinds of effects in the history, so that they can
   be undone (and redone again).
   */
   const invertedEffects = /*@__PURE__*/Facet.define();
   const historyConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           return combineConfig(configs, {
               minDepth: 100,
               newGroupDelay: 500,
               joinToEvent: (_t, isAdjacent) => isAdjacent,
           }, {
               minDepth: Math.max,
               newGroupDelay: Math.min,
               joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
           });
       }
   });
   function changeEnd(changes) {
       let end = 0;
       changes.iterChangedRanges((_, to) => end = to);
       return end;
   }
   const historyField_ = /*@__PURE__*/StateField.define({
       create() {
           return HistoryState.empty;
       },
       update(state, tr) {
           let config = tr.state.facet(historyConfig);
           let fromHist = tr.annotation(fromHistory);
           if (fromHist) {
               let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : undefined;
               let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
               let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;
               if (item)
                   other = updateBranch(other, other.length, config.minDepth, item);
               else
                   other = addSelection(other, tr.startState.selection);
               return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);
           }
           let isolate = tr.annotation(isolateHistory);
           if (isolate == "full" || isolate == "before")
               state = state.isolate();
           if (tr.annotation(Transaction.addToHistory) === false)
               return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
           let event = HistEvent.fromTransaction(tr);
           let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
           if (event)
               state = state.addChanges(event, time, userEvent, config, tr);
           else if (tr.selection)
               state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
           if (isolate == "full" || isolate == "after")
               state = state.isolate();
           return state;
       },
       toJSON(value) {
           return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
       },
       fromJSON(json) {
           return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
       }
   });
   /**
   Create a history extension with the given configuration.
   */
   function history(config = {}) {
       return [
           historyField_,
           historyConfig.of(config),
           EditorView.domEventHandlers({
               beforeinput(e, view) {
                   let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                   if (!command)
                       return false;
                   e.preventDefault();
                   return command(view);
               }
           })
       ];
   }
   function cmd(side, selection) {
       return function ({ state, dispatch }) {
           if (!selection && state.readOnly)
               return false;
           let historyState = state.field(historyField_, false);
           if (!historyState)
               return false;
           let tr = historyState.pop(side, state, selection);
           if (!tr)
               return false;
           dispatch(tr);
           return true;
       };
   }
   /**
   Undo a single group of history events. Returns false if no group
   was available.
   */
   const undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);
   /**
   Redo a group of history events. Returns false if no group was
   available.
   */
   const redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);
   /**
   Undo a change or selection change.
   */
   const undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);
   /**
   Redo a change or selection change.
   */
   const redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);
   // History events store groups of changes or effects that need to be
   // undone/redone together.
   class HistEvent {
       constructor(
       // The changes in this event. Normal events hold at least one
       // change or effect. But it may be necessary to store selection
       // events before the first change, in which case a special type of
       // instance is created which doesn't hold any changes, with
       // changes == startSelection == undefined
       changes, 
       // The effects associated with this event
       effects, 
       // Accumulated mapping (from addToHistory==false) that should be
       // applied to events below this one.
       mapped, 
       // The selection before this event
       startSelection, 
       // Stores selection changes after this event, to be used for
       // selection undo/redo.
       selectionsAfter) {
           this.changes = changes;
           this.effects = effects;
           this.mapped = mapped;
           this.startSelection = startSelection;
           this.selectionsAfter = selectionsAfter;
       }
       setSelAfter(after) {
           return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
       }
       toJSON() {
           var _a, _b, _c;
           return {
               changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
               mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
               startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
               selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
           };
       }
       static fromJSON(json) {
           return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
       }
       // This does not check `addToHistory` and such, it assumes the
       // transaction needs to be converted to an item. Returns null when
       // there are no changes or effects in the transaction.
       static fromTransaction(tr, selection) {
           let effects = none$1;
           for (let invert of tr.startState.facet(invertedEffects)) {
               let result = invert(tr);
               if (result.length)
                   effects = effects.concat(result);
           }
           if (!effects.length && tr.changes.empty)
               return null;
           return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none$1);
       }
       static selection(selections) {
           return new HistEvent(undefined, none$1, undefined, undefined, selections);
       }
   }
   function updateBranch(branch, to, maxLen, newEvent) {
       let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
       let newBranch = branch.slice(start, to);
       newBranch.push(newEvent);
       return newBranch;
   }
   function isAdjacent(a, b) {
       let ranges = [], isAdjacent = false;
       a.iterChangedRanges((f, t) => ranges.push(f, t));
       b.iterChangedRanges((_f, _t, f, t) => {
           for (let i = 0; i < ranges.length;) {
               let from = ranges[i++], to = ranges[i++];
               if (t >= from && f <= to)
                   isAdjacent = true;
           }
       });
       return isAdjacent;
   }
   function eqSelectionShape(a, b) {
       return a.ranges.length == b.ranges.length &&
           a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
   }
   function conc(a, b) {
       return !a.length ? b : !b.length ? a : a.concat(b);
   }
   const none$1 = [];
   const MaxSelectionsPerEvent = 200;
   function addSelection(branch, selection) {
       if (!branch.length) {
           return [HistEvent.selection([selection])];
       }
       else {
           let lastEvent = branch[branch.length - 1];
           let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
           if (sels.length && sels[sels.length - 1].eq(selection))
               return branch;
           sels.push(selection);
           return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
       }
   }
   // Assumes the top item has one or more selectionAfter values
   function popSelection(branch) {
       let last = branch[branch.length - 1];
       let newBranch = branch.slice();
       newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
       return newBranch;
   }
   // Add a mapping to the top event in the given branch. If this maps
   // away all the changes and effects in that item, drop it and
   // propagate the mapping to the next item.
   function addMappingToBranch(branch, mapping) {
       if (!branch.length)
           return branch;
       let length = branch.length, selections = none$1;
       while (length) {
           let event = mapEvent(branch[length - 1], mapping, selections);
           if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping
               let result = branch.slice(0, length);
               result[length - 1] = event;
               return result;
           }
           else { // Drop this event, since there's no changes or effects left
               mapping = event.mapped;
               length--;
               selections = event.selectionsAfter;
           }
       }
       return selections.length ? [HistEvent.selection(selections)] : none$1;
   }
   function mapEvent(event, mapping, extraSelections) {
       let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none$1, extraSelections);
       // Change-less events don't store mappings (they are always the last event in a branch)
       if (!event.changes)
           return HistEvent.selection(selections);
       let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
       let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
       return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
   }
   const joinableUserEvent = /^(input\.type|delete)($|\.)/;
   class HistoryState {
       constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
           this.done = done;
           this.undone = undone;
           this.prevTime = prevTime;
           this.prevUserEvent = prevUserEvent;
       }
       isolate() {
           return this.prevTime ? new HistoryState(this.done, this.undone) : this;
       }
       addChanges(event, time, userEvent, config, tr) {
           let done = this.done, lastEvent = done[done.length - 1];
           if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&
               (!userEvent || joinableUserEvent.test(userEvent)) &&
               ((!lastEvent.selectionsAfter.length &&
                   time - this.prevTime < config.newGroupDelay &&
                   config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||
                   // For compose (but not compose.start) events, always join with previous event
                   userEvent == "input.type.compose")) {
               done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$1));
           }
           else {
               done = updateBranch(done, done.length, config.minDepth, event);
           }
           return new HistoryState(done, none$1, time, userEvent);
       }
       addSelection(selection, time, userEvent, newGroupDelay) {
           let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$1;
           if (last.length > 0 &&
               time - this.prevTime < newGroupDelay &&
               userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) &&
               eqSelectionShape(last[last.length - 1], selection))
               return this;
           return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
       }
       addMapping(mapping) {
           return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
       }
       pop(side, state, selection) {
           let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;
           if (branch.length == 0)
               return null;
           let event = branch[branch.length - 1];
           if (selection && event.selectionsAfter.length) {
               return state.update({
                   selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                   annotations: fromHistory.of({ side, rest: popSelection(branch) }),
                   userEvent: side == 0 /* BranchName.Done */ ? "select.undo" : "select.redo",
                   scrollIntoView: true
               });
           }
           else if (!event.changes) {
               return null;
           }
           else {
               let rest = branch.length == 1 ? none$1 : branch.slice(0, branch.length - 1);
               if (event.mapped)
                   rest = addMappingToBranch(rest, event.mapped);
               return state.update({
                   changes: event.changes,
                   selection: event.startSelection,
                   effects: event.effects,
                   annotations: fromHistory.of({ side, rest }),
                   filter: false,
                   userEvent: side == 0 /* BranchName.Done */ ? "undo" : "redo",
                   scrollIntoView: true
               });
           }
       }
   }
   HistoryState.empty = /*@__PURE__*/new HistoryState(none$1, none$1);
   /**
   Default key bindings for the undo history.

   - Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
   - Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
   - Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
   - Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
   */
   const historyKeymap = [
       { key: "Mod-z", run: undo, preventDefault: true },
       { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
       { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
       { key: "Mod-u", run: undoSelection, preventDefault: true },
       { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
   ];

   function updateSel(sel, by) {
       return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
   }
   function setSel(state, selection) {
       return state.update({ selection, scrollIntoView: true, userEvent: "select" });
   }
   function moveSel({ state, dispatch }, how) {
       let selection = updateSel(state.selection, how);
       if (selection.eq(state.selection))
           return false;
       dispatch(setSel(state, selection));
       return true;
   }
   function rangeEnd(range, forward) {
       return EditorSelection.cursor(forward ? range.to : range.from);
   }
   function cursorByChar(view, forward) {
       return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
   }
   function ltrAtCursor(view) {
       return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
   }
   /**
   Move the selection one character to the left (which is backward in
   left-to-right text, forward in right-to-left text).
   */
   const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
   /**
   Move the selection one character to the right.
   */
   const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
   function cursorByGroup(view, forward) {
       return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
   }
   /**
   Move the selection to the left across one group of word or
   non-word (but also non-space) characters.
   */
   const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
   /**
   Move the selection one group to the right.
   */
   const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
   function interestingNode(state, node, bracketProp) {
       if (node.type.prop(bracketProp))
           return true;
       let len = node.to - node.from;
       return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
   }
   function moveBySyntax(state, start, forward) {
       let pos = syntaxTree(state).resolveInner(start.head);
       let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
       // Scan forward through child nodes to see if there's an interesting
       // node ahead.
       for (let at = start.head;;) {
           let next = forward ? pos.childAfter(at) : pos.childBefore(at);
           if (!next)
               break;
           if (interestingNode(state, next, bracketProp))
               pos = next;
           else
               at = forward ? next.to : next.from;
       }
       let bracket = pos.type.prop(bracketProp), match, newPos;
       if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
           newPos = forward ? match.end.to : match.end.from;
       else
           newPos = forward ? pos.to : pos.from;
       return EditorSelection.cursor(newPos, forward ? -1 : 1);
   }
   /**
   Move the cursor over the next syntactic element to the left.
   */
   const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
   /**
   Move the cursor over the next syntactic element to the right.
   */
   const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
   function cursorByLine(view, forward) {
       return moveSel(view, range => {
           if (!range.empty)
               return rangeEnd(range, forward);
           let moved = view.moveVertically(range, forward);
           return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
       });
   }
   /**
   Move the selection one line up.
   */
   const cursorLineUp = view => cursorByLine(view, false);
   /**
   Move the selection one line down.
   */
   const cursorLineDown = view => cursorByLine(view, true);
   function pageInfo(view) {
       let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
       let marginTop = 0, marginBottom = 0, height;
       if (selfScroll) {
           for (let source of view.state.facet(EditorView.scrollMargins)) {
               let margins = source(view);
               if (margins === null || margins === void 0 ? void 0 : margins.top)
                   marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
               if (margins === null || margins === void 0 ? void 0 : margins.bottom)
                   marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
           }
           height = view.scrollDOM.clientHeight - marginTop - marginBottom;
       }
       else {
           height = (view.dom.ownerDocument.defaultView || window).innerHeight;
       }
       return { marginTop, marginBottom, selfScroll,
           height: Math.max(view.defaultLineHeight, height - 5) };
   }
   function cursorByPage(view, forward) {
       let page = pageInfo(view);
       let { state } = view, selection = updateSel(state.selection, range => {
           return range.empty ? view.moveVertically(range, forward, page.height)
               : rangeEnd(range, forward);
       });
       if (selection.eq(state.selection))
           return false;
       let effect;
       if (page.selfScroll) {
           let startPos = view.coordsAtPos(state.selection.main.head);
           let scrollRect = view.scrollDOM.getBoundingClientRect();
           let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
           if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
               effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
       }
       view.dispatch(setSel(state, selection), { effects: effect });
       return true;
   }
   /**
   Move the selection one page up.
   */
   const cursorPageUp = view => cursorByPage(view, false);
   /**
   Move the selection one page down.
   */
   const cursorPageDown = view => cursorByPage(view, true);
   function moveByLineBoundary(view, start, forward) {
       let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
       if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
           moved = view.moveToLineBoundary(start, forward, false);
       if (!forward && moved.head == line.from && line.length) {
           let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
           if (space && start.head != line.from + space)
               moved = EditorSelection.cursor(line.from + space);
       }
       return moved;
   }
   /**
   Move the selection to the next line wrap point, or to the end of
   the line if there isn't one left on this line.
   */
   const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
   /**
   Move the selection to previous line wrap point, or failing that to
   the start of the line. If the line is indented, and the cursor
   isn't already at the end of the indentation, this will move to the
   end of the indentation instead of the start of the line.
   */
   const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
   /**
   Move the selection one line wrap point to the left.
   */
   const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
   /**
   Move the selection one line wrap point to the right.
   */
   const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
   /**
   Move the selection to the start of the line.
   */
   const cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
   /**
   Move the selection to the end of the line.
   */
   const cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
   function toMatchingBracket(state, dispatch, extend) {
       let found = false, selection = updateSel(state.selection, range => {
           let matching = matchBrackets(state, range.head, -1)
               || matchBrackets(state, range.head, 1)
               || (range.head > 0 && matchBrackets(state, range.head - 1, 1))
               || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));
           if (!matching || !matching.end)
               return range;
           found = true;
           let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
           return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
       });
       if (!found)
           return false;
       dispatch(setSel(state, selection));
       return true;
   }
   /**
   Move the selection to the bracket matching the one it is currently
   on, if any.
   */
   const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
   function extendSel(view, how) {
       let selection = updateSel(view.state.selection, range => {
           let head = how(range);
           return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
       });
       if (selection.eq(view.state.selection))
           return false;
       view.dispatch(setSel(view.state, selection));
       return true;
   }
   function selectByChar(view, forward) {
       return extendSel(view, range => view.moveByChar(range, forward));
   }
   /**
   Move the selection head one character to the left, while leaving
   the anchor in place.
   */
   const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
   /**
   Move the selection head one character to the right.
   */
   const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
   function selectByGroup(view, forward) {
       return extendSel(view, range => view.moveByGroup(range, forward));
   }
   /**
   Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
   the left.
   */
   const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
   /**
   Move the selection head one group to the right.
   */
   const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
   /**
   Move the selection head over the next syntactic element to the left.
   */
   const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
   /**
   Move the selection head over the next syntactic element to the right.
   */
   const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
   function selectByLine(view, forward) {
       return extendSel(view, range => view.moveVertically(range, forward));
   }
   /**
   Move the selection head one line up.
   */
   const selectLineUp = view => selectByLine(view, false);
   /**
   Move the selection head one line down.
   */
   const selectLineDown = view => selectByLine(view, true);
   function selectByPage(view, forward) {
       return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));
   }
   /**
   Move the selection head one page up.
   */
   const selectPageUp = view => selectByPage(view, false);
   /**
   Move the selection head one page down.
   */
   const selectPageDown = view => selectByPage(view, true);
   /**
   Move the selection head to the next line boundary.
   */
   const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
   /**
   Move the selection head to the previous line boundary.
   */
   const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
   /**
   Move the selection head one line boundary to the left.
   */
   const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
   /**
   Move the selection head one line boundary to the right.
   */
   const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
   /**
   Move the selection head to the start of the line.
   */
   const selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));
   /**
   Move the selection head to the end of the line.
   */
   const selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));
   /**
   Move the selection to the start of the document.
   */
   const cursorDocStart = ({ state, dispatch }) => {
       dispatch(setSel(state, { anchor: 0 }));
       return true;
   };
   /**
   Move the selection to the end of the document.
   */
   const cursorDocEnd = ({ state, dispatch }) => {
       dispatch(setSel(state, { anchor: state.doc.length }));
       return true;
   };
   /**
   Move the selection head to the start of the document.
   */
   const selectDocStart = ({ state, dispatch }) => {
       dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
       return true;
   };
   /**
   Move the selection head to the end of the document.
   */
   const selectDocEnd = ({ state, dispatch }) => {
       dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
       return true;
   };
   /**
   Select the entire document.
   */
   const selectAll = ({ state, dispatch }) => {
       dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
       return true;
   };
   /**
   Expand the selection to cover entire lines.
   */
   const selectLine = ({ state, dispatch }) => {
       let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
       dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
       return true;
   };
   /**
   Select the next syntactic construct that is larger than the
   selection. Note that this will only work insofar as the language
   [provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
   syntax tree.
   */
   const selectParentSyntax = ({ state, dispatch }) => {
       let selection = updateSel(state.selection, range => {
           var _a;
           let context = syntaxTree(state).resolveInner(range.head, 1);
           while (!((context.from < range.from && context.to >= range.to) ||
               (context.to > range.to && context.from <= range.from) ||
               !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
               context = context.parent;
           return EditorSelection.range(context.to, context.from);
       });
       dispatch(setSel(state, selection));
       return true;
   };
   /**
   Simplify the current selection. When multiple ranges are selected,
   reduce it to its main range. Otherwise, if the selection is
   non-empty, convert it to a cursor selection.
   */
   const simplifySelection = ({ state, dispatch }) => {
       let cur = state.selection, selection = null;
       if (cur.ranges.length > 1)
           selection = EditorSelection.create([cur.main]);
       else if (!cur.main.empty)
           selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
       if (!selection)
           return false;
       dispatch(setSel(state, selection));
       return true;
   };
   function deleteBy(target, by) {
       if (target.state.readOnly)
           return false;
       let event = "delete.selection", { state } = target;
       let changes = state.changeByRange(range => {
           let { from, to } = range;
           if (from == to) {
               let towards = by(from);
               if (towards < from) {
                   event = "delete.backward";
                   towards = skipAtomic(target, towards, false);
               }
               else if (towards > from) {
                   event = "delete.forward";
                   towards = skipAtomic(target, towards, true);
               }
               from = Math.min(from, towards);
               to = Math.max(to, towards);
           }
           else {
               from = skipAtomic(target, from, false);
               to = skipAtomic(target, to, true);
           }
           return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };
       });
       if (changes.changes.empty)
           return false;
       target.dispatch(state.update(changes, {
           scrollIntoView: true,
           userEvent: event,
           effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : undefined
       }));
       return true;
   }
   function skipAtomic(target, pos, forward) {
       if (target instanceof EditorView)
           for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target)))
               ranges.between(pos, pos, (from, to) => {
                   if (from < pos && to > pos)
                       pos = forward ? to : from;
               });
       return pos;
   }
   const deleteByChar = (target, forward) => deleteBy(target, pos => {
       let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
       if (!forward && pos > line.from && pos < line.from + 200 &&
           !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
           if (before[before.length - 1] == "\t")
               return pos - 1;
           let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
           for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
               pos--;
           targetPos = pos;
       }
       else {
           targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
           if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
               targetPos += forward ? 1 : -1;
       }
       return targetPos;
   });
   /**
   Delete the selection, or, for cursor selections, the character
   before the cursor.
   */
   const deleteCharBackward = view => deleteByChar(view, false);
   /**
   Delete the selection or the character after the cursor.
   */
   const deleteCharForward = view => deleteByChar(view, true);
   const deleteByGroup = (target, forward) => deleteBy(target, start => {
       let pos = start, { state } = target, line = state.doc.lineAt(pos);
       let categorize = state.charCategorizer(pos);
       for (let cat = null;;) {
           if (pos == (forward ? line.to : line.from)) {
               if (pos == start && line.number != (forward ? state.doc.lines : 1))
                   pos += forward ? 1 : -1;
               break;
           }
           let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
           let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
           let nextCat = categorize(nextChar);
           if (cat != null && nextCat != cat)
               break;
           if (nextChar != " " || pos != start)
               cat = nextCat;
           pos = next;
       }
       return pos;
   });
   /**
   Delete the selection or backward until the end of the next
   [group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
   whitespace when they consist of a single space.
   */
   const deleteGroupBackward = target => deleteByGroup(target, false);
   /**
   Delete the selection or forward until the end of the next group.
   */
   const deleteGroupForward = target => deleteByGroup(target, true);
   /**
   Delete the selection, or, if it is a cursor selection, delete to
   the end of the line. If the cursor is directly at the end of the
   line, delete the line break after it.
   */
   const deleteToLineEnd = view => deleteBy(view, pos => {
       let lineEnd = view.lineBlockAt(pos).to;
       return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
   });
   /**
   Delete the selection, or, if it is a cursor selection, delete to
   the start of the line. If the cursor is directly at the start of the
   line, delete the line break before it.
   */
   const deleteToLineStart = view => deleteBy(view, pos => {
       let lineStart = view.lineBlockAt(pos).from;
       return pos > lineStart ? lineStart : Math.max(0, pos - 1);
   });
   /**
   Replace each selection range with a line break, leaving the cursor
   on the line before the break.
   */
   const splitLine = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       let changes = state.changeByRange(range => {
           return { changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
               range: EditorSelection.cursor(range.from) };
       });
       dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
       return true;
   };
   /**
   Flip the characters before and after the cursor(s).
   */
   const transposeChars = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       let changes = state.changeByRange(range => {
           if (!range.empty || range.from == 0 || range.from == state.doc.length)
               return { range };
           let pos = range.from, line = state.doc.lineAt(pos);
           let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
           let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
           return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
               range: EditorSelection.cursor(to) };
       });
       if (changes.changes.empty)
           return false;
       dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
       return true;
   };
   function selectedLineBlocks(state) {
       let blocks = [], upto = -1;
       for (let range of state.selection.ranges) {
           let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
           if (!range.empty && range.to == endLine.from)
               endLine = state.doc.lineAt(range.to - 1);
           if (upto >= startLine.number) {
               let prev = blocks[blocks.length - 1];
               prev.to = endLine.to;
               prev.ranges.push(range);
           }
           else {
               blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
           }
           upto = endLine.number + 1;
       }
       return blocks;
   }
   function moveLine(state, dispatch, forward) {
       if (state.readOnly)
           return false;
       let changes = [], ranges = [];
       for (let block of selectedLineBlocks(state)) {
           if (forward ? block.to == state.doc.length : block.from == 0)
               continue;
           let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
           let size = nextLine.length + 1;
           if (forward) {
               changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
               for (let r of block.ranges)
                   ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
           }
           else {
               changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
               for (let r of block.ranges)
                   ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
           }
       }
       if (!changes.length)
           return false;
       dispatch(state.update({
           changes,
           scrollIntoView: true,
           selection: EditorSelection.create(ranges, state.selection.mainIndex),
           userEvent: "move.line"
       }));
       return true;
   }
   /**
   Move the selected lines up one line.
   */
   const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
   /**
   Move the selected lines down one line.
   */
   const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
   function copyLine(state, dispatch, forward) {
       if (state.readOnly)
           return false;
       let changes = [];
       for (let block of selectedLineBlocks(state)) {
           if (forward)
               changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
           else
               changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
       }
       dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
       return true;
   }
   /**
   Create a copy of the selected lines. Keep the selection in the top copy.
   */
   const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
   /**
   Create a copy of the selected lines. Keep the selection in the bottom copy.
   */
   const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
   /**
   Delete selected lines.
   */
   const deleteLine = view => {
       if (view.state.readOnly)
           return false;
       let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
           if (from > 0)
               from--;
           else if (to < state.doc.length)
               to++;
           return { from, to };
       }));
       let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
       view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
       return true;
   };
   function isBetweenBrackets(state, pos) {
       if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
           return { from: pos, to: pos };
       let context = syntaxTree(state).resolveInner(pos);
       let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
       if (before && after && before.to <= pos && after.from >= pos &&
           (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&
           state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
           !/\S/.test(state.sliceDoc(before.to, after.from)))
           return { from: before.to, to: after.from };
       return null;
   }
   /**
   Replace the selection with a newline and indent the newly created
   line(s). If the current line consists only of whitespace, this
   will also delete that whitespace. When the cursor is between
   matching brackets, an additional newline will be inserted after
   the cursor.
   */
   const insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);
   /**
   Create a blank, indented line below the current line.
   */
   const insertBlankLine = /*@__PURE__*/newlineAndIndent(true);
   function newlineAndIndent(atEof) {
       return ({ state, dispatch }) => {
           if (state.readOnly)
               return false;
           let changes = state.changeByRange(range => {
               let { from, to } = range, line = state.doc.lineAt(from);
               let explode = !atEof && from == to && isBetweenBrackets(state, from);
               if (atEof)
                   from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
               let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
               let indent = getIndentation(cx, from);
               if (indent == null)
                   indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
               while (to < line.to && /\s/.test(line.text[to - line.from]))
                   to++;
               if (explode)
                   ({ from, to } = explode);
               else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                   from = line.from;
               let insert = ["", indentString(state, indent)];
               if (explode)
                   insert.push(indentString(state, cx.lineIndent(line.from, -1)));
               return { changes: { from, to, insert: Text.of(insert) },
                   range: EditorSelection.cursor(from + 1 + insert[1].length) };
           });
           dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
           return true;
       };
   }
   function changeBySelectedLine(state, f) {
       let atLine = -1;
       return state.changeByRange(range => {
           let changes = [];
           for (let pos = range.from; pos <= range.to;) {
               let line = state.doc.lineAt(pos);
               if (line.number > atLine && (range.empty || range.to > line.from)) {
                   f(line, changes, range);
                   atLine = line.number;
               }
               pos = line.to + 1;
           }
           let changeSet = state.changes(changes);
           return { changes,
               range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
       });
   }
   /**
   Auto-indent the selected lines. This uses the [indentation service
   facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
   information.
   */
   const indentSelection = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       let updated = Object.create(null);
       let context = new IndentContext(state, { overrideIndentation: start => {
               let found = updated[start];
               return found == null ? -1 : found;
           } });
       let changes = changeBySelectedLine(state, (line, changes, range) => {
           let indent = getIndentation(context, line.from);
           if (indent == null)
               return;
           if (!/\S/.test(line.text))
               indent = 0;
           let cur = /^\s*/.exec(line.text)[0];
           let norm = indentString(state, indent);
           if (cur != norm || range.from < line.from + cur.length) {
               updated[line.from] = indent;
               changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
           }
       });
       if (!changes.changes.empty)
           dispatch(state.update(changes, { userEvent: "indent" }));
       return true;
   };
   /**
   Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
   lines.
   */
   const indentMore = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
           changes.push({ from: line.from, insert: state.facet(indentUnit) });
       }), { userEvent: "input.indent" }));
       return true;
   };
   /**
   Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
   selected lines.
   */
   const indentLess = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
           let space = /^\s*/.exec(line.text)[0];
           if (!space)
               return;
           let col = countColumn(space, state.tabSize), keep = 0;
           let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
           while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
               keep++;
           changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
       }), { userEvent: "delete.dedent" }));
       return true;
   };
   /**
   Array of key bindings containing the Emacs-style bindings that are
   available on macOS by default.

    - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
    - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
    - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
    - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
    - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
    - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
    - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
    - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
    - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
    - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
    - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
    - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
    - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
    - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
   */
   const emacsStyleKeymap = [
       { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
       { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
       { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
       { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
       { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
       { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
       { key: "Ctrl-d", run: deleteCharForward },
       { key: "Ctrl-h", run: deleteCharBackward },
       { key: "Ctrl-k", run: deleteToLineEnd },
       { key: "Ctrl-Alt-h", run: deleteGroupBackward },
       { key: "Ctrl-o", run: splitLine },
       { key: "Ctrl-t", run: transposeChars },
       { key: "Ctrl-v", run: cursorPageDown },
   ];
   /**
   An array of key bindings closely sticking to platform-standard or
   widely used bindings. (This includes the bindings from
   [`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
   property changed to `mac`.)

    - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
    - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
    - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
    - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
    - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
    - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
    - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
    - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
    - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
    - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
    - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
    - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
    - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
    - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
    - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
    - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
    - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
    - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
    - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
    - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
    - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
    - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
    - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
    - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
    - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).
    - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).
   */
   const standardKeymap = /*@__PURE__*/[
       { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
       { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
       { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
       { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
       { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
       { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
       { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
       { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
       { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
       { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
       { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
       { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
       { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
       { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
       { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
       { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
       { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
       { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
       { key: "Enter", run: insertNewlineAndIndent },
       { key: "Mod-a", run: selectAll },
       { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
       { key: "Delete", run: deleteCharForward },
       { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
       { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
       { mac: "Mod-Backspace", run: deleteToLineStart },
       { mac: "Mod-Delete", run: deleteToLineEnd }
   ].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
   /**
   The default keymap. Includes all bindings from
   [`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

   - Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
   - Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
   - Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
   - Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
   - Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
   - Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
   - Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
   - Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
   - Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
   - Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
   - Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
   - Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
   - Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
   - Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
   - Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
   - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
   - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
   */
   const defaultKeymap = /*@__PURE__*/[
       { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
       { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
       { key: "Alt-ArrowUp", run: moveLineUp },
       { key: "Shift-Alt-ArrowUp", run: copyLineUp },
       { key: "Alt-ArrowDown", run: moveLineDown },
       { key: "Shift-Alt-ArrowDown", run: copyLineDown },
       { key: "Escape", run: simplifySelection },
       { key: "Mod-Enter", run: insertBlankLine },
       { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
       { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
       { key: "Mod-[", run: indentLess },
       { key: "Mod-]", run: indentMore },
       { key: "Mod-Alt-\\", run: indentSelection },
       { key: "Shift-Mod-k", run: deleteLine },
       { key: "Shift-Mod-\\", run: cursorMatchingBracket },
       { key: "Mod-/", run: toggleComment },
       { key: "Alt-A", run: toggleBlockComment }
   ].concat(standardKeymap);

   function crelt() {
     var elt = arguments[0];
     if (typeof elt == "string") elt = document.createElement(elt);
     var i = 1, next = arguments[1];
     if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
       for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
         var value = next[name];
         if (typeof value == "string") elt.setAttribute(name, value);
         else if (value != null) elt[name] = value;
       }
       i++;
     }
     for (; i < arguments.length; i++) add$2(elt, arguments[i]);
     return elt
   }

   function add$2(elt, child) {
     if (typeof child == "string") {
       elt.appendChild(document.createTextNode(child));
     } else if (child == null) ; else if (child.nodeType != null) {
       elt.appendChild(child);
     } else if (Array.isArray(child)) {
       for (var i = 0; i < child.length; i++) add$2(elt, child[i]);
     } else {
       throw new RangeError("Unsupported child node: " + child)
     }
   }

   const basicNormalize = typeof String.prototype.normalize == "function"
       ? x => x.normalize("NFKD") : x => x;
   /**
   A search cursor provides an iterator over text matches in a
   document.
   */
   class SearchCursor {
       /**
       Create a text cursor. The query is the search string, `from` to
       `to` provides the region to search.
       
       When `normalize` is given, it will be called, on both the query
       string and the content it is matched against, before comparing.
       You can, for example, create a case-insensitive search by
       passing `s => s.toLowerCase()`.
       
       Text is always normalized with
       [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
       (when supported).
       */
       constructor(text, query, from = 0, to = text.length, normalize, test) {
           this.test = test;
           /**
           The current match (only holds a meaningful value after
           [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
           `done` is false).
           */
           this.value = { from: 0, to: 0 };
           /**
           Whether the end of the iterated region has been reached.
           */
           this.done = false;
           this.matches = [];
           this.buffer = "";
           this.bufferPos = 0;
           this.iter = text.iterRange(from, to);
           this.bufferStart = from;
           this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
           this.query = this.normalize(query);
       }
       peek() {
           if (this.bufferPos == this.buffer.length) {
               this.bufferStart += this.buffer.length;
               this.iter.next();
               if (this.iter.done)
                   return -1;
               this.bufferPos = 0;
               this.buffer = this.iter.value;
           }
           return codePointAt(this.buffer, this.bufferPos);
       }
       /**
       Look for the next match. Updates the iterator's
       [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
       [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
       at least once before using the cursor.
       */
       next() {
           while (this.matches.length)
               this.matches.pop();
           return this.nextOverlapping();
       }
       /**
       The `next` method will ignore matches that partially overlap a
       previous match. This method behaves like `next`, but includes
       such matches.
       */
       nextOverlapping() {
           for (;;) {
               let next = this.peek();
               if (next < 0) {
                   this.done = true;
                   return this;
               }
               let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
               this.bufferPos += codePointSize(next);
               let norm = this.normalize(str);
               for (let i = 0, pos = start;; i++) {
                   let code = norm.charCodeAt(i);
                   let match = this.match(code, pos);
                   if (i == norm.length - 1) {
                       if (match) {
                           this.value = match;
                           return this;
                       }
                       break;
                   }
                   if (pos == start && i < str.length && str.charCodeAt(i) == code)
                       pos++;
               }
           }
       }
       match(code, pos) {
           let match = null;
           for (let i = 0; i < this.matches.length; i += 2) {
               let index = this.matches[i], keep = false;
               if (this.query.charCodeAt(index) == code) {
                   if (index == this.query.length - 1) {
                       match = { from: this.matches[i + 1], to: pos + 1 };
                   }
                   else {
                       this.matches[i]++;
                       keep = true;
                   }
               }
               if (!keep) {
                   this.matches.splice(i, 2);
                   i -= 2;
               }
           }
           if (this.query.charCodeAt(0) == code) {
               if (this.query.length == 1)
                   match = { from: pos, to: pos + 1 };
               else
                   this.matches.push(1, pos);
           }
           if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
               match = null;
           return match;
       }
   }
   if (typeof Symbol != "undefined")
       SearchCursor.prototype[Symbol.iterator] = function () { return this; };

   const empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec("") };
   const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
   /**
   This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
   but searches for a regular expression pattern instead of a plain
   string.
   */
   class RegExpCursor {
       /**
       Create a cursor that will search the given range in the given
       document. `query` should be the raw pattern (as you'd pass it to
       `new RegExp`).
       */
       constructor(text, query, options, from = 0, to = text.length) {
           this.text = text;
           this.to = to;
           this.curLine = "";
           /**
           Set to `true` when the cursor has reached the end of the search
           range.
           */
           this.done = false;
           /**
           Will contain an object with the extent of the match and the
           match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
           sucessfully finds a match.
           */
           this.value = empty;
           if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
               return new MultilineRegExpCursor(text, query, options, from, to);
           this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
           this.test = options === null || options === void 0 ? void 0 : options.test;
           this.iter = text.iter();
           let startLine = text.lineAt(from);
           this.curLineStart = startLine.from;
           this.matchPos = toCharEnd(text, from);
           this.getLine(this.curLineStart);
       }
       getLine(skip) {
           this.iter.next(skip);
           if (this.iter.lineBreak) {
               this.curLine = "";
           }
           else {
               this.curLine = this.iter.value;
               if (this.curLineStart + this.curLine.length > this.to)
                   this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
               this.iter.next();
           }
       }
       nextLine() {
           this.curLineStart = this.curLineStart + this.curLine.length + 1;
           if (this.curLineStart > this.to)
               this.curLine = "";
           else
               this.getLine(0);
       }
       /**
       Move to the next match, if there is one.
       */
       next() {
           for (let off = this.matchPos - this.curLineStart;;) {
               this.re.lastIndex = off;
               let match = this.matchPos <= this.to && this.re.exec(this.curLine);
               if (match) {
                   let from = this.curLineStart + match.index, to = from + match[0].length;
                   this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                   if (from == this.curLineStart + this.curLine.length)
                       this.nextLine();
                   if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                       this.value = { from, to, match };
                       return this;
                   }
                   off = this.matchPos - this.curLineStart;
               }
               else if (this.curLineStart + this.curLine.length < this.to) {
                   this.nextLine();
                   off = 0;
               }
               else {
                   this.done = true;
                   return this;
               }
           }
       }
   }
   const flattened = /*@__PURE__*/new WeakMap();
   // Reusable (partially) flattened document strings
   class FlattenedDoc {
       constructor(from, text) {
           this.from = from;
           this.text = text;
       }
       get to() { return this.from + this.text.length; }
       static get(doc, from, to) {
           let cached = flattened.get(doc);
           if (!cached || cached.from >= to || cached.to <= from) {
               let flat = new FlattenedDoc(from, doc.sliceString(from, to));
               flattened.set(doc, flat);
               return flat;
           }
           if (cached.from == from && cached.to == to)
               return cached;
           let { text, from: cachedFrom } = cached;
           if (cachedFrom > from) {
               text = doc.sliceString(from, cachedFrom) + text;
               cachedFrom = from;
           }
           if (cached.to < to)
               text += doc.sliceString(cached.to, to);
           flattened.set(doc, new FlattenedDoc(cachedFrom, text));
           return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
       }
   }
   class MultilineRegExpCursor {
       constructor(text, query, options, from, to) {
           this.text = text;
           this.to = to;
           this.done = false;
           this.value = empty;
           this.matchPos = toCharEnd(text, from);
           this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
           this.test = options === null || options === void 0 ? void 0 : options.test;
           this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));
       }
       chunkEnd(pos) {
           return pos >= this.to ? this.to : this.text.lineAt(pos).to;
       }
       next() {
           for (;;) {
               let off = this.re.lastIndex = this.matchPos - this.flat.from;
               let match = this.re.exec(this.flat.text);
               // Skip empty matches directly after the last match
               if (match && !match[0] && match.index == off) {
                   this.re.lastIndex = off + 1;
                   match = this.re.exec(this.flat.text);
               }
               if (match) {
                   let from = this.flat.from + match.index, to = from + match[0].length;
                   // If a match goes almost to the end of a noncomplete chunk, try
                   // again, since it'll likely be able to match more
                   if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&
                       (!this.test || this.test(from, to, match))) {
                       this.value = { from, to, match };
                       this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                       return this;
                   }
               }
               if (this.flat.to == this.to) {
                   this.done = true;
                   return this;
               }
               // Grow the flattened doc
               this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
           }
       }
   }
   if (typeof Symbol != "undefined") {
       RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
           function () { return this; };
   }
   function validRegExp(source) {
       try {
           new RegExp(source, baseFlags);
           return true;
       }
       catch (_a) {
           return false;
       }
   }
   function toCharEnd(text, pos) {
       if (pos >= text.length)
           return pos;
       let line = text.lineAt(pos), next;
       while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
           pos++;
       return pos;
   }

   function createLineDialog(view) {
       let input = crelt("input", { class: "cm-textfield", name: "line" });
       let dom = crelt("form", {
           class: "cm-gotoLine",
           onkeydown: (event) => {
               if (event.keyCode == 27) { // Escape
                   event.preventDefault();
                   view.dispatch({ effects: dialogEffect.of(false) });
                   view.focus();
               }
               else if (event.keyCode == 13) { // Enter
                   event.preventDefault();
                   go();
               }
           },
           onsubmit: (event) => {
               event.preventDefault();
               go();
           }
       }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
       function go() {
           let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
           if (!match)
               return;
           let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
           let [, sign, ln, cl, percent] = match;
           let col = cl ? +cl.slice(1) : 0;
           let line = ln ? +ln : startLine.number;
           if (ln && percent) {
               let pc = line / 100;
               if (sign)
                   pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state.doc.lines);
               line = Math.round(state.doc.lines * pc);
           }
           else if (ln && sign) {
               line = line * (sign == "-" ? -1 : 1) + startLine.number;
           }
           let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
           let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
           view.dispatch({
               effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],
               selection,
           });
           view.focus();
       }
       return { dom };
   }
   const dialogEffect = /*@__PURE__*/StateEffect.define();
   const dialogField = /*@__PURE__*/StateField.define({
       create() { return true; },
       update(value, tr) {
           for (let e of tr.effects)
               if (e.is(dialogEffect))
                   value = e.value;
           return value;
       },
       provide: f => showPanel.from(f, val => val ? createLineDialog : null)
   });
   /**
   Command that shows a dialog asking the user for a line number, and
   when a valid position is provided, moves the cursor to that line.

   Supports line numbers, relative line offsets prefixed with `+` or
   `-`, document percentages suffixed with `%`, and an optional
   column position by adding `:` and a second number after the line
   number.
   */
   const gotoLine = view => {
       let panel = getPanel(view, createLineDialog);
       if (!panel) {
           let effects = [dialogEffect.of(true)];
           if (view.state.field(dialogField, false) == null)
               effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1$1]));
           view.dispatch({ effects });
           panel = getPanel(view, createLineDialog);
       }
       if (panel)
           panel.dom.querySelector("input").focus();
       return true;
   };
   const baseTheme$1$1 = /*@__PURE__*/EditorView.baseTheme({
       ".cm-panel.cm-gotoLine": {
           padding: "2px 6px 4px",
           "& label": { fontSize: "80%" }
       }
   });

   const defaultHighlightOptions = {
       highlightWordAroundCursor: false,
       minSelectionLength: 1,
       maxMatches: 100,
       wholeWords: false
   };
   const highlightConfig = /*@__PURE__*/Facet.define({
       combine(options) {
           return combineConfig(options, defaultHighlightOptions, {
               highlightWordAroundCursor: (a, b) => a || b,
               minSelectionLength: Math.min,
               maxMatches: Math.min
           });
       }
   });
   /**
   This extension highlights text that matches the selection. It uses
   the `"cm-selectionMatch"` class for the highlighting. When
   `highlightWordAroundCursor` is enabled, the word at the cursor
   itself will be highlighted with `"cm-selectionMatch-main"`.
   */
   function highlightSelectionMatches(options) {
       let ext = [defaultTheme, matchHighlighter];
       if (options)
           ext.push(highlightConfig.of(options));
       return ext;
   }
   const matchDeco = /*@__PURE__*/Decoration.mark({ class: "cm-selectionMatch" });
   const mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
   // Whether the characters directly outside the given positions are non-word characters
   function insideWordBoundaries(check, state, from, to) {
       return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&
           (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
   }
   // Whether the characters directly at the given positions are word characters
   function insideWord(check, state, from, to) {
       return check(state.sliceDoc(from, from + 1)) == CharCategory.Word
           && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
   }
   const matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.decorations = this.getDeco(view);
       }
       update(update) {
           if (update.selectionSet || update.docChanged || update.viewportChanged)
               this.decorations = this.getDeco(update.view);
       }
       getDeco(view) {
           let conf = view.state.facet(highlightConfig);
           let { state } = view, sel = state.selection;
           if (sel.ranges.length > 1)
               return Decoration.none;
           let range = sel.main, query, check = null;
           if (range.empty) {
               if (!conf.highlightWordAroundCursor)
                   return Decoration.none;
               let word = state.wordAt(range.head);
               if (!word)
                   return Decoration.none;
               check = state.charCategorizer(range.head);
               query = state.sliceDoc(word.from, word.to);
           }
           else {
               let len = range.to - range.from;
               if (len < conf.minSelectionLength || len > 200)
                   return Decoration.none;
               if (conf.wholeWords) {
                   query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?
                   check = state.charCategorizer(range.head);
                   if (!(insideWordBoundaries(check, state, range.from, range.to)
                       && insideWord(check, state, range.from, range.to)))
                       return Decoration.none;
               }
               else {
                   query = state.sliceDoc(range.from, range.to).trim();
                   if (!query)
                       return Decoration.none;
               }
           }
           let deco = [];
           for (let part of view.visibleRanges) {
               let cursor = new SearchCursor(state.doc, query, part.from, part.to);
               while (!cursor.next().done) {
                   let { from, to } = cursor.value;
                   if (!check || insideWordBoundaries(check, state, from, to)) {
                       if (range.empty && from <= range.from && to >= range.to)
                           deco.push(mainMatchDeco.range(from, to));
                       else if (from >= range.to || to <= range.from)
                           deco.push(matchDeco.range(from, to));
                       if (deco.length > conf.maxMatches)
                           return Decoration.none;
                   }
               }
           }
           return Decoration.set(deco);
       }
   }, {
       decorations: v => v.decorations
   });
   const defaultTheme = /*@__PURE__*/EditorView.baseTheme({
       ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
       ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
   });
   // Select the words around the cursors.
   const selectWord = ({ state, dispatch }) => {
       let { selection } = state;
       let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
       if (newSel.eq(selection))
           return false;
       dispatch(state.update({ selection: newSel }));
       return true;
   };
   // Find next occurrence of query relative to last cursor. Wrap around
   // the document if there are no more matches.
   function findNextOccurrence(state, query) {
       let { main, ranges } = state.selection;
       let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
       for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
           cursor.next();
           if (cursor.done) {
               if (cycled)
                   return null;
               cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
               cycled = true;
           }
           else {
               if (cycled && ranges.some(r => r.from == cursor.value.from))
                   continue;
               if (fullWord) {
                   let word = state.wordAt(cursor.value.from);
                   if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                       continue;
               }
               return cursor.value;
           }
       }
   }
   /**
   Select next occurrence of the current selection. Expand selection
   to the surrounding word when the selection is empty.
   */
   const selectNextOccurrence = ({ state, dispatch }) => {
       let { ranges } = state.selection;
       if (ranges.some(sel => sel.from === sel.to))
           return selectWord({ state, dispatch });
       let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
       if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))
           return false;
       let range = findNextOccurrence(state, searchedText);
       if (!range)
           return false;
       dispatch(state.update({
           selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
           effects: EditorView.scrollIntoView(range.to)
       }));
       return true;
   };

   const searchConfigFacet = /*@__PURE__*/Facet.define({
       combine(configs) {
           return combineConfig(configs, {
               top: false,
               caseSensitive: false,
               literal: false,
               regexp: false,
               wholeWord: false,
               createPanel: view => new SearchPanel(view),
               scrollToMatch: range => EditorView.scrollIntoView(range)
           });
       }
   });
   /**
   A search query. Part of the editor's search state.
   */
   class SearchQuery {
       /**
       Create a query object.
       */
       constructor(config) {
           this.search = config.search;
           this.caseSensitive = !!config.caseSensitive;
           this.literal = !!config.literal;
           this.regexp = !!config.regexp;
           this.replace = config.replace || "";
           this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
           this.unquoted = this.unquote(this.search);
           this.wholeWord = !!config.wholeWord;
       }
       /**
       @internal
       */
       unquote(text) {
           return this.literal ? text :
               text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
       }
       /**
       Compare this query to another query.
       */
       eq(other) {
           return this.search == other.search && this.replace == other.replace &&
               this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&
               this.wholeWord == other.wholeWord;
       }
       /**
       @internal
       */
       create() {
           return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
       }
       /**
       Get a search cursor for this query, searching through the given
       range in the given state.
       */
       getCursor(state, from = 0, to) {
           let st = state.doc ? state : EditorState.create({ doc: state });
           if (to == null)
               to = st.doc.length;
           return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
       }
   }
   class QueryType {
       constructor(spec) {
           this.spec = spec;
       }
   }
   function stringCursor(spec, state, from, to) {
       return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
   }
   function stringWordTest(doc, categorizer) {
       return (from, to, buf, bufPos) => {
           if (bufPos > from || bufPos + buf.length < to) {
               bufPos = Math.max(0, from - 2);
               buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
           }
           return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||
               categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&
               (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||
                   categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
       };
   }
   class StringQuery extends QueryType {
       constructor(spec) {
           super(spec);
       }
       nextMatch(state, curFrom, curTo) {
           let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
           if (cursor.done)
               cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
           return cursor.done ? null : cursor.value;
       }
       // Searching in reverse is, rather than implementing an inverted search
       // cursor, done by scanning chunk after chunk forward.
       prevMatchInRange(state, from, to) {
           for (let pos = to;;) {
               let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);
               let cursor = stringCursor(this.spec, state, start, pos), range = null;
               while (!cursor.nextOverlapping().done)
                   range = cursor.value;
               if (range)
                   return range;
               if (start == from)
                   return null;
               pos -= 10000 /* FindPrev.ChunkSize */;
           }
       }
       prevMatch(state, curFrom, curTo) {
           return this.prevMatchInRange(state, 0, curFrom) ||
               this.prevMatchInRange(state, curTo, state.doc.length);
       }
       getReplacement(_result) { return this.spec.unquote(this.spec.replace); }
       matchAll(state, limit) {
           let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
           while (!cursor.next().done) {
               if (ranges.length >= limit)
                   return null;
               ranges.push(cursor.value);
           }
           return ranges;
       }
       highlight(state, from, to, add) {
           let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
           while (!cursor.next().done)
               add(cursor.value.from, cursor.value.to);
       }
   }
   function regexpCursor(spec, state, from, to) {
       return new RegExpCursor(state.doc, spec.search, {
           ignoreCase: !spec.caseSensitive,
           test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
       }, from, to);
   }
   function charBefore(str, index) {
       return str.slice(findClusterBreak(str, index, false), index);
   }
   function charAfter(str, index) {
       return str.slice(index, findClusterBreak(str, index));
   }
   function regexpWordTest(categorizer) {
       return (_from, _to, match) => !match[0].length ||
           (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||
               categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&
               (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||
                   categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
   }
   class RegExpQuery extends QueryType {
       nextMatch(state, curFrom, curTo) {
           let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
           if (cursor.done)
               cursor = regexpCursor(this.spec, state, 0, curFrom).next();
           return cursor.done ? null : cursor.value;
       }
       prevMatchInRange(state, from, to) {
           for (let size = 1;; size++) {
               let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);
               let cursor = regexpCursor(this.spec, state, start, to), range = null;
               while (!cursor.next().done)
                   range = cursor.value;
               if (range && (start == from || range.from > start + 10))
                   return range;
               if (start == from)
                   return null;
           }
       }
       prevMatch(state, curFrom, curTo) {
           return this.prevMatchInRange(state, 0, curFrom) ||
               this.prevMatchInRange(state, curTo, state.doc.length);
       }
       getReplacement(result) {
           return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$"
               : i == "&" ? result.match[0]
                   : i != "0" && +i < result.match.length ? result.match[i]
                       : m));
       }
       matchAll(state, limit) {
           let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
           while (!cursor.next().done) {
               if (ranges.length >= limit)
                   return null;
               ranges.push(cursor.value);
           }
           return ranges;
       }
       highlight(state, from, to, add) {
           let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));
           while (!cursor.next().done)
               add(cursor.value.from, cursor.value.to);
       }
   }
   /**
   A state effect that updates the current search query. Note that
   this only has an effect if the search state has been initialized
   (by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
   by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
   once).
   */
   const setSearchQuery = /*@__PURE__*/StateEffect.define();
   const togglePanel$1 = /*@__PURE__*/StateEffect.define();
   const searchState = /*@__PURE__*/StateField.define({
       create(state) {
           return new SearchState(defaultQuery(state).create(), null);
       },
       update(value, tr) {
           for (let effect of tr.effects) {
               if (effect.is(setSearchQuery))
                   value = new SearchState(effect.value.create(), value.panel);
               else if (effect.is(togglePanel$1))
                   value = new SearchState(value.query, effect.value ? createSearchPanel : null);
           }
           return value;
       },
       provide: f => showPanel.from(f, val => val.panel)
   });
   class SearchState {
       constructor(query, panel) {
           this.query = query;
           this.panel = panel;
       }
   }
   const matchMark = /*@__PURE__*/Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
   const searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.view = view;
           this.decorations = this.highlight(view.state.field(searchState));
       }
       update(update) {
           let state = update.state.field(searchState);
           if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
               this.decorations = this.highlight(state);
       }
       highlight({ query, panel }) {
           if (!panel || !query.spec.valid)
               return Decoration.none;
           let { view } = this;
           let builder = new RangeSetBuilder();
           for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
               let { from, to } = ranges[i];
               while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)
                   to = ranges[++i].to;
               query.highlight(view.state, from, to, (from, to) => {
                   let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
                   builder.add(from, to, selected ? selectedMatchMark : matchMark);
               });
           }
           return builder.finish();
       }
   }, {
       decorations: v => v.decorations
   });
   function searchCommand(f) {
       return view => {
           let state = view.state.field(searchState, false);
           return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
       };
   }
   /**
   Open the search panel if it isn't already open, and move the
   selection to the first match after the current main selection.
   Will wrap around to the start of the document when it reaches the
   end.
   */
   const findNext = /*@__PURE__*/searchCommand((view, { query }) => {
       let { to } = view.state.selection.main;
       let next = query.nextMatch(view.state, to, to);
       if (!next)
           return false;
       let selection = EditorSelection.single(next.from, next.to);
       let config = view.state.facet(searchConfigFacet);
       view.dispatch({
           selection,
           effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
           userEvent: "select.search"
       });
       selectSearchInput(view);
       return true;
   });
   /**
   Move the selection to the previous instance of the search query,
   before the current main selection. Will wrap past the start
   of the document to start searching at the end again.
   */
   const findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {
       let { state } = view, { from } = state.selection.main;
       let prev = query.prevMatch(state, from, from);
       if (!prev)
           return false;
       let selection = EditorSelection.single(prev.from, prev.to);
       let config = view.state.facet(searchConfigFacet);
       view.dispatch({
           selection,
           effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
           userEvent: "select.search"
       });
       selectSearchInput(view);
       return true;
   });
   /**
   Select all instances of the search query.
   */
   const selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {
       let ranges = query.matchAll(view.state, 1000);
       if (!ranges || !ranges.length)
           return false;
       view.dispatch({
           selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),
           userEvent: "select.search.matches"
       });
       return true;
   });
   /**
   Select all instances of the currently selected text.
   */
   const selectSelectionMatches = ({ state, dispatch }) => {
       let sel = state.selection;
       if (sel.ranges.length > 1 || sel.main.empty)
           return false;
       let { from, to } = sel.main;
       let ranges = [], main = 0;
       for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
           if (ranges.length > 1000)
               return false;
           if (cur.value.from == from)
               main = ranges.length;
           ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
       }
       dispatch(state.update({
           selection: EditorSelection.create(ranges, main),
           userEvent: "select.search.matches"
       }));
       return true;
   };
   /**
   Replace the current match of the search query.
   */
   const replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {
       let { state } = view, { from, to } = state.selection.main;
       if (state.readOnly)
           return false;
       let next = query.nextMatch(state, from, from);
       if (!next)
           return false;
       let changes = [], selection, replacement;
       let effects = [];
       if (next.from == from && next.to == to) {
           replacement = state.toText(query.getReplacement(next));
           changes.push({ from: next.from, to: next.to, insert: replacement });
           next = query.nextMatch(state, next.from, next.to);
           effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
       }
       if (next) {
           let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
           selection = EditorSelection.single(next.from - off, next.to - off);
           effects.push(announceMatch(view, next));
           effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
       }
       view.dispatch({
           changes, selection, effects,
           userEvent: "input.replace"
       });
       return true;
   });
   /**
   Replace all instances of the search query with the given
   replacement.
   */
   const replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {
       if (view.state.readOnly)
           return false;
       let changes = query.matchAll(view.state, 1e9).map(match => {
           let { from, to } = match;
           return { from, to, insert: query.getReplacement(match) };
       });
       if (!changes.length)
           return false;
       let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
       view.dispatch({
           changes,
           effects: EditorView.announce.of(announceText),
           userEvent: "input.replace.all"
       });
       return true;
   });
   function createSearchPanel(view) {
       return view.state.facet(searchConfigFacet).createPanel(view);
   }
   function defaultQuery(state, fallback) {
       var _a, _b, _c, _d, _e;
       let sel = state.selection.main;
       let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
       if (fallback && !selText)
           return fallback;
       let config = state.facet(searchConfigFacet);
       return new SearchQuery({
           search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
           caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
           literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
           regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
           wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord
       });
   }
   function getSearchInput(view) {
       let panel = getPanel(view, createSearchPanel);
       return panel && panel.dom.querySelector("[main-field]");
   }
   function selectSearchInput(view) {
       let input = getSearchInput(view);
       if (input && input == view.root.activeElement)
           input.select();
   }
   /**
   Make sure the search panel is open and focused.
   */
   const openSearchPanel = view => {
       let state = view.state.field(searchState, false);
       if (state && state.panel) {
           let searchInput = getSearchInput(view);
           if (searchInput && searchInput != view.root.activeElement) {
               let query = defaultQuery(view.state, state.query.spec);
               if (query.valid)
                   view.dispatch({ effects: setSearchQuery.of(query) });
               searchInput.focus();
               searchInput.select();
           }
       }
       else {
           view.dispatch({ effects: [
                   togglePanel$1.of(true),
                   state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
               ] });
       }
       return true;
   };
   /**
   Close the search panel.
   */
   const closeSearchPanel = view => {
       let state = view.state.field(searchState, false);
       if (!state || !state.panel)
           return false;
       let panel = getPanel(view, createSearchPanel);
       if (panel && panel.dom.contains(view.root.activeElement))
           view.focus();
       view.dispatch({ effects: togglePanel$1.of(false) });
       return true;
   };
   /**
   Default search-related key bindings.

    - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
    - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
    - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
    - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
    - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
   */
   const searchKeymap = [
       { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
       { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
       { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
       { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
       { key: "Mod-Shift-l", run: selectSelectionMatches },
       { key: "Alt-g", run: gotoLine },
       { key: "Mod-d", run: selectNextOccurrence, preventDefault: true },
   ];
   class SearchPanel {
       constructor(view) {
           this.view = view;
           let query = this.query = view.state.field(searchState).query.spec;
           this.commit = this.commit.bind(this);
           this.searchField = crelt("input", {
               value: query.search,
               placeholder: phrase(view, "Find"),
               "aria-label": phrase(view, "Find"),
               class: "cm-textfield",
               name: "search",
               form: "",
               "main-field": "true",
               onchange: this.commit,
               onkeyup: this.commit
           });
           this.replaceField = crelt("input", {
               value: query.replace,
               placeholder: phrase(view, "Replace"),
               "aria-label": phrase(view, "Replace"),
               class: "cm-textfield",
               name: "replace",
               form: "",
               onchange: this.commit,
               onkeyup: this.commit
           });
           this.caseField = crelt("input", {
               type: "checkbox",
               name: "case",
               form: "",
               checked: query.caseSensitive,
               onchange: this.commit
           });
           this.reField = crelt("input", {
               type: "checkbox",
               name: "re",
               form: "",
               checked: query.regexp,
               onchange: this.commit
           });
           this.wordField = crelt("input", {
               type: "checkbox",
               name: "word",
               form: "",
               checked: query.wholeWord,
               onchange: this.commit
           });
           function button(name, onclick, content) {
               return crelt("button", { class: "cm-button", name, onclick, type: "button" }, content);
           }
           this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
               this.searchField,
               button("next", () => findNext(view), [phrase(view, "next")]),
               button("prev", () => findPrevious(view), [phrase(view, "previous")]),
               button("select", () => selectMatches(view), [phrase(view, "all")]),
               crelt("label", null, [this.caseField, phrase(view, "match case")]),
               crelt("label", null, [this.reField, phrase(view, "regexp")]),
               crelt("label", null, [this.wordField, phrase(view, "by word")]),
               ...view.state.readOnly ? [] : [
                   crelt("br"),
                   this.replaceField,
                   button("replace", () => replaceNext(view), [phrase(view, "replace")]),
                   button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
               ],
               crelt("button", {
                   name: "close",
                   onclick: () => closeSearchPanel(view),
                   "aria-label": phrase(view, "close"),
                   type: "button"
               }, ["×"])
           ]);
       }
       commit() {
           let query = new SearchQuery({
               search: this.searchField.value,
               caseSensitive: this.caseField.checked,
               regexp: this.reField.checked,
               wholeWord: this.wordField.checked,
               replace: this.replaceField.value,
           });
           if (!query.eq(this.query)) {
               this.query = query;
               this.view.dispatch({ effects: setSearchQuery.of(query) });
           }
       }
       keydown(e) {
           if (runScopeHandlers(this.view, e, "search-panel")) {
               e.preventDefault();
           }
           else if (e.keyCode == 13 && e.target == this.searchField) {
               e.preventDefault();
               (e.shiftKey ? findPrevious : findNext)(this.view);
           }
           else if (e.keyCode == 13 && e.target == this.replaceField) {
               e.preventDefault();
               replaceNext(this.view);
           }
       }
       update(update) {
           for (let tr of update.transactions)
               for (let effect of tr.effects) {
                   if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                       this.setQuery(effect.value);
               }
       }
       setQuery(query) {
           this.query = query;
           this.searchField.value = query.search;
           this.replaceField.value = query.replace;
           this.caseField.checked = query.caseSensitive;
           this.reField.checked = query.regexp;
           this.wordField.checked = query.wholeWord;
       }
       mount() {
           this.searchField.select();
       }
       get pos() { return 80; }
       get top() { return this.view.state.facet(searchConfigFacet).top; }
   }
   function phrase(view, phrase) { return view.state.phrase(phrase); }
   const AnnounceMargin = 30;
   const Break = /[\s\.,:;?!]/;
   function announceMatch(view, { from, to }) {
       let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
       let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
       let text = view.state.sliceDoc(start, end);
       if (start != line.from) {
           for (let i = 0; i < AnnounceMargin; i++)
               if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                   text = text.slice(i);
                   break;
               }
       }
       if (end != lineEnd) {
           for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
               if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                   text = text.slice(0, i);
                   break;
               }
       }
       return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
   }
   const baseTheme$2 = /*@__PURE__*/EditorView.baseTheme({
       ".cm-panel.cm-search": {
           padding: "2px 6px 4px",
           position: "relative",
           "& [name=close]": {
               position: "absolute",
               top: "0",
               right: "4px",
               backgroundColor: "inherit",
               border: "none",
               font: "inherit",
               padding: 0,
               margin: 0
           },
           "& input, & button, & label": {
               margin: ".2em .6em .2em 0"
           },
           "& input[type=checkbox]": {
               marginRight: ".2em"
           },
           "& label": {
               fontSize: "80%",
               whiteSpace: "pre"
           }
       },
       "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
       "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
       "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
       "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
   });
   const searchExtensions = [
       searchState,
       /*@__PURE__*/Prec.low(searchHighlighter),
       baseTheme$2
   ];

   /**
   An instance of this is passed to completion source functions.
   */
   class CompletionContext {
       /**
       Create a new completion context. (Mostly useful for testing
       completion sources—in the editor, the extension will create
       these for you.)
       */
       constructor(
       /**
       The editor state that the completion happens in.
       */
       state, 
       /**
       The position at which the completion is happening.
       */
       pos, 
       /**
       Indicates whether completion was activated explicitly, or
       implicitly by typing. The usual way to respond to this is to
       only return completions when either there is part of a
       completable entity before the cursor, or `explicit` is true.
       */
       explicit) {
           this.state = state;
           this.pos = pos;
           this.explicit = explicit;
           /**
           @internal
           */
           this.abortListeners = [];
       }
       /**
       Get the extent, content, and (if there is a token) type of the
       token before `this.pos`.
       */
       tokenBefore(types) {
           let token = syntaxTree(this.state).resolveInner(this.pos, -1);
           while (token && types.indexOf(token.name) < 0)
               token = token.parent;
           return token ? { from: token.from, to: this.pos,
               text: this.state.sliceDoc(token.from, this.pos),
               type: token.type } : null;
       }
       /**
       Get the match of the given expression directly before the
       cursor.
       */
       matchBefore(expr) {
           let line = this.state.doc.lineAt(this.pos);
           let start = Math.max(line.from, this.pos - 250);
           let str = line.text.slice(start - line.from, this.pos - line.from);
           let found = str.search(ensureAnchor(expr, false));
           return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
       }
       /**
       Yields true when the query has been aborted. Can be useful in
       asynchronous queries to avoid doing work that will be ignored.
       */
       get aborted() { return this.abortListeners == null; }
       /**
       Allows you to register abort handlers, which will be called when
       the query is
       [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
       */
       addEventListener(type, listener) {
           if (type == "abort" && this.abortListeners)
               this.abortListeners.push(listener);
       }
   }
   function toSet(chars) {
       let flat = Object.keys(chars).join("");
       let words = /\w/.test(flat);
       if (words)
           flat = flat.replace(/\w/g, "");
       return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
   }
   function prefixMatch(options) {
       let first = Object.create(null), rest = Object.create(null);
       for (let { label } of options) {
           first[label[0]] = true;
           for (let i = 1; i < label.length; i++)
               rest[label[i]] = true;
       }
       let source = toSet(first) + toSet(rest) + "*$";
       return [new RegExp("^" + source), new RegExp(source)];
   }
   /**
   Given a a fixed array of options, return an autocompleter that
   completes them.
   */
   function completeFromList(list) {
       let options = list.map(o => typeof o == "string" ? { label: o } : o);
       let [validFor, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
       return (context) => {
           let token = context.matchBefore(match);
           return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
       };
   }
   class Option {
       constructor(completion, source, match, score) {
           this.completion = completion;
           this.source = source;
           this.match = match;
           this.score = score;
       }
   }
   function cur(state) { return state.selection.main.from; }
   // Make sure the given regexp has a $ at its end and, if `start` is
   // true, a ^ at its start.
   function ensureAnchor(expr, start) {
       var _a;
       let { source } = expr;
       let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
       if (!addStart && !addEnd)
           return expr;
       return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? "i" : ""));
   }
   /**
   This annotation is added to transactions that are produced by
   picking a completion.
   */
   const pickedCompletion = /*@__PURE__*/Annotation.define();
   /**
   Helper function that returns a transaction spec which inserts a
   completion's text in the main selection range, and any other
   selection range that has the same text in front of it.
   */
   function insertCompletionText$1(state, text, from, to) {
       let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
       return Object.assign(Object.assign({}, state.changeByRange(range => {
           if (range != main && from != to &&
               state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
               return { range };
           return {
               changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: text },
               range: EditorSelection.cursor(range.from + fromOff + text.length)
           };
       })), { userEvent: "input.complete" });
   }
   const SourceCache = /*@__PURE__*/new WeakMap();
   function asSource(source) {
       if (!Array.isArray(source))
           return source;
       let known = SourceCache.get(source);
       if (!known)
           SourceCache.set(source, known = completeFromList(source));
       return known;
   }
   const startCompletionEffect = /*@__PURE__*/StateEffect.define();
   const closeCompletionEffect = /*@__PURE__*/StateEffect.define();

   // A pattern matcher for fuzzy completion matching. Create an instance
   // once for a pattern, and then use that to match any number of
   // completions.
   class FuzzyMatcher {
       constructor(pattern) {
           this.pattern = pattern;
           this.chars = [];
           this.folded = [];
           // Buffers reused by calls to `match` to track matched character
           // positions.
           this.any = [];
           this.precise = [];
           this.byWord = [];
           this.score = 0;
           this.matched = [];
           for (let p = 0; p < pattern.length;) {
               let char = codePointAt(pattern, p), size = codePointSize(char);
               this.chars.push(char);
               let part = pattern.slice(p, p + size), upper = part.toUpperCase();
               this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
               p += size;
           }
           this.astral = pattern.length != this.chars.length;
       }
       ret(score, matched) {
           this.score = score;
           this.matched = matched;
           return true;
       }
       // Matches a given word (completion) against the pattern (input).
       // Will return a boolean indicating whether there was a match and,
       // on success, set `this.score` to the score, `this.matched` to an
       // array of `from, to` pairs indicating the matched parts of `word`.
       //
       // The score is a number that is more negative the worse the match
       // is. See `Penalty` above.
       match(word) {
           if (this.pattern.length == 0)
               return this.ret(-100 /* NotFull */, []);
           if (word.length < this.pattern.length)
               return false;
           let { chars, folded, any, precise, byWord } = this;
           // For single-character queries, only match when they occur right
           // at the start
           if (chars.length == 1) {
               let first = codePointAt(word, 0), firstSize = codePointSize(first);
               let score = firstSize == word.length ? 0 : -100 /* NotFull */;
               if (first == chars[0]) ;
               else if (first == folded[0])
                   score += -200 /* CaseFold */;
               else
                   return false;
               return this.ret(score, [0, firstSize]);
           }
           let direct = word.indexOf(this.pattern);
           if (direct == 0)
               return this.ret(word.length == this.pattern.length ? 0 : -100 /* NotFull */, [0, this.pattern.length]);
           let len = chars.length, anyTo = 0;
           if (direct < 0) {
               for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                   let next = codePointAt(word, i);
                   if (next == chars[anyTo] || next == folded[anyTo])
                       any[anyTo++] = i;
                   i += codePointSize(next);
               }
               // No match, exit immediately
               if (anyTo < len)
                   return false;
           }
           // This tracks the extent of the precise (non-folded, not
           // necessarily adjacent) match
           let preciseTo = 0;
           // Tracks whether there is a match that hits only characters that
           // appear to be starting words. `byWordFolded` is set to true when
           // a case folded character is encountered in such a match
           let byWordTo = 0, byWordFolded = false;
           // If we've found a partial adjacent match, these track its state
           let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
           let hasLower = /[a-z]/.test(word), wordAdjacent = true;
           // Go over the option's text, scanning for the various kinds of matches
           for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {
               let next = codePointAt(word, i);
               if (direct < 0) {
                   if (preciseTo < len && next == chars[preciseTo])
                       precise[preciseTo++] = i;
                   if (adjacentTo < len) {
                       if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                           if (adjacentTo == 0)
                               adjacentStart = i;
                           adjacentEnd = i + 1;
                           adjacentTo++;
                       }
                       else {
                           adjacentTo = 0;
                       }
                   }
               }
               let ch, type = next < 0xff
                   ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)
                   : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);
               if (!i || type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) {
                   if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))
                       byWord[byWordTo++] = i;
                   else if (byWord.length)
                       wordAdjacent = false;
               }
               prevType = type;
               i += codePointSize(next);
           }
           if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
               return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);
           if (adjacentTo == len && adjacentStart == 0)
               return this.ret(-200 /* CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* NotFull */), [0, adjacentEnd]);
           if (direct > -1)
               return this.ret(-700 /* NotStart */ - word.length, [direct, direct + this.pattern.length]);
           if (adjacentTo == len)
               return this.ret(-200 /* CaseFold */ + -700 /* NotStart */ - word.length, [adjacentStart, adjacentEnd]);
           if (byWordTo == len)
               return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */ +
                   (wordAdjacent ? 0 : -1100 /* Gap */), byWord, word);
           return chars.length == 2 ? false
               : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);
       }
       result(score, positions, word) {
           let result = [], i = 0;
           for (let pos of positions) {
               let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
               if (i && result[i - 1] == pos)
                   result[i - 1] = to;
               else {
                   result[i++] = pos;
                   result[i++] = to;
               }
           }
           return this.ret(score - word.length, result);
       }
   }

   const completionConfig = /*@__PURE__*/Facet.define({
       combine(configs) {
           return combineConfig(configs, {
               activateOnTyping: true,
               selectOnOpen: true,
               override: null,
               closeOnBlur: true,
               maxRenderedOptions: 100,
               defaultKeymap: true,
               tooltipClass: () => "",
               optionClass: () => "",
               aboveCursor: false,
               icons: true,
               addToOptions: [],
               positionInfo: defaultPositionInfo,
               compareCompletions: (a, b) => a.label.localeCompare(b.label),
               interactionDelay: 75
           }, {
               defaultKeymap: (a, b) => a && b,
               closeOnBlur: (a, b) => a && b,
               icons: (a, b) => a && b,
               tooltipClass: (a, b) => c => joinClass(a(c), b(c)),
               optionClass: (a, b) => c => joinClass(a(c), b(c)),
               addToOptions: (a, b) => a.concat(b)
           });
       }
   });
   function joinClass(a, b) {
       return a ? b ? a + " " + b : a : b;
   }
   function defaultPositionInfo(view, list, option, info, space) {
       let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
       let side = "top", offset, maxWidth;
       let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
       let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
       if (left && spaceLeft < Math.min(infoWidth, spaceRight))
           left = false;
       else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
           left = true;
       if (infoWidth <= (left ? spaceLeft : spaceRight)) {
           offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
           maxWidth = Math.min(400 /* Width */, left ? spaceLeft : spaceRight);
       }
       else {
           narrow = true;
           maxWidth = Math.min(400 /* Width */, (rtl ? list.right : space.right - list.left) - 30 /* Margin */);
           let spaceBelow = space.bottom - list.bottom;
           if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion
               offset = option.bottom - list.top;
           }
           else { // Above it
               side = "bottom";
               offset = list.bottom - option.top;
           }
       }
       return {
           style: `${side}: ${offset}px; max-width: ${maxWidth}px`,
           class: "cm-completionInfo-" + (narrow ? (rtl ? "left-narrow" : "right-narrow") : left ? "left" : "right")
       };
   }

   function optionContent(config) {
       let content = config.addToOptions.slice();
       if (config.icons)
           content.push({
               render(completion) {
                   let icon = document.createElement("div");
                   icon.classList.add("cm-completionIcon");
                   if (completion.type)
                       icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
                   icon.setAttribute("aria-hidden", "true");
                   return icon;
               },
               position: 20
           });
       content.push({
           render(completion, _s, match) {
               let labelElt = document.createElement("span");
               labelElt.className = "cm-completionLabel";
               let label = completion.displayLabel || completion.label, off = 0;
               for (let j = 0; j < match.length;) {
                   let from = match[j++], to = match[j++];
                   if (from > off)
                       labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                   let span = labelElt.appendChild(document.createElement("span"));
                   span.appendChild(document.createTextNode(label.slice(from, to)));
                   span.className = "cm-completionMatchedText";
                   off = to;
               }
               if (off < label.length)
                   labelElt.appendChild(document.createTextNode(label.slice(off)));
               return labelElt;
           },
           position: 50
       }, {
           render(completion) {
               if (!completion.detail)
                   return null;
               let detailElt = document.createElement("span");
               detailElt.className = "cm-completionDetail";
               detailElt.textContent = completion.detail;
               return detailElt;
           },
           position: 80
       });
       return content.sort((a, b) => a.position - b.position).map(a => a.render);
   }
   function rangeAroundSelected(total, selected, max) {
       if (total <= max)
           return { from: 0, to: total };
       if (selected < 0)
           selected = 0;
       if (selected <= (total >> 1)) {
           let off = Math.floor(selected / max);
           return { from: off * max, to: (off + 1) * max };
       }
       let off = Math.floor((total - selected) / max);
       return { from: total - (off + 1) * max, to: total - off * max };
   }
   class CompletionTooltip {
       constructor(view, stateField, applyCompletion) {
           this.view = view;
           this.stateField = stateField;
           this.applyCompletion = applyCompletion;
           this.info = null;
           this.infoDestroy = null;
           this.placeInfoReq = {
               read: () => this.measureInfo(),
               write: (pos) => this.placeInfo(pos),
               key: this
           };
           this.space = null;
           this.currentClass = "";
           let cState = view.state.field(stateField);
           let { options, selected } = cState.open;
           let config = view.state.facet(completionConfig);
           this.optionContent = optionContent(config);
           this.optionClass = config.optionClass;
           this.tooltipClass = config.tooltipClass;
           this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
           this.dom = document.createElement("div");
           this.dom.className = "cm-tooltip-autocomplete";
           this.updateTooltipClass(view.state);
           this.dom.addEventListener("mousedown", (e) => {
               for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                   if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                       this.applyCompletion(view, options[+match[1]]);
                       e.preventDefault();
                       return;
                   }
               }
           });
           this.dom.addEventListener("focusout", (e) => {
               let state = view.state.field(this.stateField, false);
               if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&
                   e.relatedTarget != view.contentDOM)
                   view.dispatch({ effects: closeCompletionEffect.of(null) });
           });
           this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
           this.list.addEventListener("scroll", () => {
               if (this.info)
                   this.view.requestMeasure(this.placeInfoReq);
           });
       }
       mount() { this.updateSel(); }
       update(update) {
           var _a, _b, _c;
           let cState = update.state.field(this.stateField);
           let prevState = update.startState.field(this.stateField);
           this.updateTooltipClass(update.state);
           if (cState != prevState) {
               this.updateSel();
               if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
                   this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
           }
       }
       updateTooltipClass(state) {
           let cls = this.tooltipClass(state);
           if (cls != this.currentClass) {
               for (let c of this.currentClass.split(" "))
                   if (c)
                       this.dom.classList.remove(c);
               for (let c of cls.split(" "))
                   if (c)
                       this.dom.classList.add(c);
               this.currentClass = cls;
           }
       }
       positioned(space) {
           this.space = space;
           if (this.info)
               this.view.requestMeasure(this.placeInfoReq);
       }
       updateSel() {
           let cState = this.view.state.field(this.stateField), open = cState.open;
           if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
               this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
               this.list.remove();
               this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
               this.list.addEventListener("scroll", () => {
                   if (this.info)
                       this.view.requestMeasure(this.placeInfoReq);
               });
           }
           if (this.updateSelectedOption(open.selected)) {
               this.destroyInfo();
               let { completion } = open.options[open.selected];
               let { info } = completion;
               if (!info)
                   return;
               let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
               if (!infoResult)
                   return;
               if ("then" in infoResult) {
                   infoResult.then(obj => {
                       if (obj && this.view.state.field(this.stateField, false) == cState)
                           this.addInfoPane(obj, completion);
                   }).catch(e => logException(this.view.state, e, "completion info"));
               }
               else {
                   this.addInfoPane(infoResult, completion);
               }
           }
       }
       addInfoPane(content, completion) {
           this.destroyInfo();
           let wrap = this.info = document.createElement("div");
           wrap.className = "cm-tooltip cm-completionInfo";
           if (content.nodeType != null) {
               wrap.appendChild(content);
               this.infoDestroy = null;
           }
           else {
               let { dom, destroy } = content;
               wrap.appendChild(dom);
               this.infoDestroy = destroy || null;
           }
           this.dom.appendChild(wrap);
           this.view.requestMeasure(this.placeInfoReq);
       }
       updateSelectedOption(selected) {
           let set = null;
           for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
               if (opt.nodeName != "LI" || !opt.id) {
                   i--; // A section header
               }
               else if (i == selected) {
                   if (!opt.hasAttribute("aria-selected")) {
                       opt.setAttribute("aria-selected", "true");
                       set = opt;
                   }
               }
               else {
                   if (opt.hasAttribute("aria-selected"))
                       opt.removeAttribute("aria-selected");
               }
           }
           if (set)
               scrollIntoView(this.list, set);
           return set;
       }
       measureInfo() {
           let sel = this.dom.querySelector("[aria-selected]");
           if (!sel || !this.info)
               return null;
           let listRect = this.dom.getBoundingClientRect();
           let infoRect = this.info.getBoundingClientRect();
           let selRect = sel.getBoundingClientRect();
           let space = this.space;
           if (!space) {
               let win = this.dom.ownerDocument.defaultView || window;
               space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
           }
           if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||
               selRect.bottom < Math.max(space.top, listRect.top) + 10)
               return null;
           return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space);
       }
       placeInfo(pos) {
           if (this.info) {
               if (pos) {
                   if (pos.style)
                       this.info.style.cssText = pos.style;
                   this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
               }
               else {
                   this.info.style.cssText = "top: -1e6px";
               }
           }
       }
       createListBox(options, id, range) {
           const ul = document.createElement("ul");
           ul.id = id;
           ul.setAttribute("role", "listbox");
           ul.setAttribute("aria-expanded", "true");
           ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
           let curSection = null;
           for (let i = range.from; i < range.to; i++) {
               let { completion, match } = options[i], { section } = completion;
               if (section) {
                   let name = typeof section == "string" ? section : section.name;
                   if (name != curSection && (i > range.from || range.from == 0)) {
                       curSection = name;
                       if (typeof section != "string" && section.header) {
                           ul.appendChild(section.header(section));
                       }
                       else {
                           let header = ul.appendChild(document.createElement("completion-section"));
                           header.textContent = name;
                       }
                   }
               }
               const li = ul.appendChild(document.createElement("li"));
               li.id = id + "-" + i;
               li.setAttribute("role", "option");
               let cls = this.optionClass(completion);
               if (cls)
                   li.className = cls;
               for (let source of this.optionContent) {
                   let node = source(completion, this.view.state, match);
                   if (node)
                       li.appendChild(node);
               }
           }
           if (range.from)
               ul.classList.add("cm-completionListIncompleteTop");
           if (range.to < options.length)
               ul.classList.add("cm-completionListIncompleteBottom");
           return ul;
       }
       destroyInfo() {
           if (this.info) {
               if (this.infoDestroy)
                   this.infoDestroy();
               this.info.remove();
               this.info = null;
           }
       }
       destroy() {
           this.destroyInfo();
       }
   }
   // We allocate a new function instance every time the completion
   // changes to force redrawing/repositioning of the tooltip
   function completionTooltip(stateField, applyCompletion) {
       return (view) => new CompletionTooltip(view, stateField, applyCompletion);
   }
   function scrollIntoView(container, element) {
       let parent = container.getBoundingClientRect();
       let self = element.getBoundingClientRect();
       if (self.top < parent.top)
           container.scrollTop -= parent.top - self.top;
       else if (self.bottom > parent.bottom)
           container.scrollTop += self.bottom - parent.bottom;
   }

   // Used to pick a preferred option when two options with the same
   // label occur in the result.
   function score(option) {
       return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +
           (option.type ? 1 : 0);
   }
   function sortOptions(active, state) {
       let options = [];
       let sections = null;
       let addOption = (option) => {
           options.push(option);
           let { section } = option.completion;
           if (section) {
               if (!sections)
                   sections = [];
               let name = typeof section == "string" ? section : section.name;
               if (!sections.some(s => s.name == name))
                   sections.push(typeof section == "string" ? { name } : section);
           }
       };
       for (let a of active)
           if (a.hasResult()) {
               let getMatch = a.result.getMatch;
               if (a.result.filter === false) {
                   for (let option of a.result.options) {
                       addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
                   }
               }
               else {
                   let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));
                   for (let option of a.result.options)
                       if (matcher.match(option.label)) {
                           let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];
                           addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));
                       }
               }
           }
       if (sections) {
           let sectionOrder = Object.create(null), pos = 0;
           let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };
           for (let s of sections.sort(cmp)) {
               pos -= 1e5;
               sectionOrder[s.name] = pos;
           }
           for (let option of options) {
               let { section } = option.completion;
               if (section)
                   option.score += sectionOrder[typeof section == "string" ? section : section.name];
           }
       }
       let result = [], prev = null;
       let compare = state.facet(completionConfig).compareCompletions;
       for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {
           let cur = opt.completion;
           if (!prev || prev.label != cur.label || prev.detail != cur.detail ||
               (prev.type != null && cur.type != null && prev.type != cur.type) ||
               prev.apply != cur.apply || prev.boost != cur.boost)
               result.push(opt);
           else if (score(opt.completion) > score(prev))
               result[result.length - 1] = opt;
           prev = opt.completion;
       }
       return result;
   }
   class CompletionDialog {
       constructor(options, attrs, tooltip, timestamp, selected, disabled) {
           this.options = options;
           this.attrs = attrs;
           this.tooltip = tooltip;
           this.timestamp = timestamp;
           this.selected = selected;
           this.disabled = disabled;
       }
       setSelected(selected, id) {
           return selected == this.selected || selected >= this.options.length ? this
               : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
       }
       static build(active, state, id, prev, conf) {
           let options = sortOptions(active, state);
           if (!options.length) {
               return prev && active.some(a => a.state == 1 /* Pending */) ?
                   new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
           }
           let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
           if (prev && prev.selected != selected && prev.selected != -1) {
               let selectedValue = prev.options[prev.selected].completion;
               for (let i = 0; i < options.length; i++)
                   if (options[i].completion == selectedValue) {
                       selected = i;
                       break;
                   }
           }
           return new CompletionDialog(options, makeAttrs(id, selected), {
               pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
               create: completionTooltip(completionState, applyCompletion),
               above: conf.aboveCursor,
           }, prev ? prev.timestamp : Date.now(), selected, false);
       }
       map(changes) {
           return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
       }
   }
   class CompletionState {
       constructor(active, id, open) {
           this.active = active;
           this.id = id;
           this.open = open;
       }
       static start() {
           return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
       }
       update(tr) {
           let { state } = tr, conf = state.facet(completionConfig);
           let sources = conf.override ||
               state.languageDataAt("autocomplete", cur(state)).map(asSource);
           let active = sources.map(source => {
               let value = this.active.find(s => s.source == source) ||
                   new ActiveSource(source, this.active.some(a => a.state != 0 /* Inactive */) ? 1 /* Pending */ : 0 /* Inactive */);
               return value.update(tr, conf);
           });
           if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
               active = this.active;
           let open = this.open;
           if (open && tr.docChanged)
               open = open.map(tr.changes);
           if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
               !sameResults(active, this.active))
               open = CompletionDialog.build(active, state, this.id, open, conf);
           else if (open && open.disabled && !active.some(a => a.state == 1 /* Pending */))
               open = null;
           if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))
               active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */) : a);
           for (let effect of tr.effects)
               if (effect.is(setSelectedEffect))
                   open = open && open.setSelected(effect.value, this.id);
           return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
       }
       get tooltip() { return this.open ? this.open.tooltip : null; }
       get attrs() { return this.open ? this.open.attrs : baseAttrs; }
   }
   function sameResults(a, b) {
       if (a == b)
           return true;
       for (let iA = 0, iB = 0;;) {
           while (iA < a.length && !a[iA].hasResult)
               iA++;
           while (iB < b.length && !b[iB].hasResult)
               iB++;
           let endA = iA == a.length, endB = iB == b.length;
           if (endA || endB)
               return endA == endB;
           if (a[iA++].result != b[iB++].result)
               return false;
       }
   }
   const baseAttrs = {
       "aria-autocomplete": "list"
   };
   function makeAttrs(id, selected) {
       let result = {
           "aria-autocomplete": "list",
           "aria-haspopup": "listbox",
           "aria-controls": id
       };
       if (selected > -1)
           result["aria-activedescendant"] = id + "-" + selected;
       return result;
   }
   const none = [];
   function getUserEvent(tr) {
       return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
   }
   class ActiveSource {
       constructor(source, state, explicitPos = -1) {
           this.source = source;
           this.state = state;
           this.explicitPos = explicitPos;
       }
       hasResult() { return false; }
       update(tr, conf) {
           let event = getUserEvent(tr), value = this;
           if (event)
               value = value.handleUserEvent(tr, event, conf);
           else if (tr.docChanged)
               value = value.handleChange(tr);
           else if (tr.selection && value.state != 0 /* Inactive */)
               value = new ActiveSource(value.source, 0 /* Inactive */);
           for (let effect of tr.effects) {
               if (effect.is(startCompletionEffect))
                   value = new ActiveSource(value.source, 1 /* Pending */, effect.value ? cur(tr.state) : -1);
               else if (effect.is(closeCompletionEffect))
                   value = new ActiveSource(value.source, 0 /* Inactive */);
               else if (effect.is(setActiveEffect))
                   for (let active of effect.value)
                       if (active.source == value.source)
                           value = active;
           }
           return value;
       }
       handleUserEvent(tr, type, conf) {
           return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* Pending */);
       }
       handleChange(tr) {
           return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);
       }
       map(changes) {
           return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
       }
   }
   class ActiveResult extends ActiveSource {
       constructor(source, explicitPos, result, from, to) {
           super(source, 2 /* Result */, explicitPos);
           this.result = result;
           this.from = from;
           this.to = to;
       }
       hasResult() { return true; }
       handleUserEvent(tr, type, conf) {
           var _a;
           let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
           let pos = cur(tr.state);
           if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||
               pos > to ||
               type == "delete" && cur(tr.startState) == this.from)
               return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */);
           let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
           if (checkValid(this.result.validFor, tr.state, from, to))
               return new ActiveResult(this.source, explicitPos, this.result, from, to);
           if (this.result.update &&
               (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
               return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));
           return new ActiveSource(this.source, 1 /* Pending */, explicitPos);
       }
       handleChange(tr) {
           return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);
       }
       map(mapping) {
           return mapping.empty ? this :
               new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
       }
   }
   function checkValid(validFor, state, from, to) {
       if (!validFor)
           return false;
       let text = state.sliceDoc(from, to);
       return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
   }
   const setActiveEffect = /*@__PURE__*/StateEffect.define({
       map(sources, mapping) { return sources.map(s => s.map(mapping)); }
   });
   const setSelectedEffect = /*@__PURE__*/StateEffect.define();
   const completionState = /*@__PURE__*/StateField.define({
       create() { return CompletionState.start(); },
       update(value, tr) { return value.update(tr); },
       provide: f => [
           showTooltip.from(f, val => val.tooltip),
           EditorView.contentAttributes.from(f, state => state.attrs)
       ]
   });
   function applyCompletion(view, option) {
       const apply = option.completion.apply || option.completion.label;
       let result = view.state.field(completionState).active.find(a => a.source == option.source);
       if (!(result instanceof ActiveResult))
           return false;
       if (typeof apply == "string")
           view.dispatch(Object.assign(Object.assign({}, insertCompletionText$1(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
       else
           apply(view, option.completion, result.from, result.to);
       return true;
   }

   /**
   Returns a command that moves the completion selection forward or
   backward by the given amount.
   */
   function moveCompletionSelection(forward, by = "option") {
       return (view) => {
           let cState = view.state.field(completionState, false);
           if (!cState || !cState.open || cState.open.disabled ||
               Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
               return false;
           let step = 1, tooltip;
           if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
               step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /
                   tooltip.dom.querySelector("li").offsetHeight) - 1);
           let { length } = cState.open.options;
           let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
           if (selected < 0)
               selected = by == "page" ? 0 : length - 1;
           else if (selected >= length)
               selected = by == "page" ? length - 1 : 0;
           view.dispatch({ effects: setSelectedEffect.of(selected) });
           return true;
       };
   }
   /**
   Accept the current completion.
   */
   const acceptCompletion = (view) => {
       let cState = view.state.field(completionState, false);
       if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||
           Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
           return false;
       return applyCompletion(view, cState.open.options[cState.open.selected]);
   };
   /**
   Explicitly start autocompletion.
   */
   const startCompletion = (view) => {
       let cState = view.state.field(completionState, false);
       if (!cState)
           return false;
       view.dispatch({ effects: startCompletionEffect.of(true) });
       return true;
   };
   /**
   Close the currently active completion.
   */
   const closeCompletion = (view) => {
       let cState = view.state.field(completionState, false);
       if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))
           return false;
       view.dispatch({ effects: closeCompletionEffect.of(null) });
       return true;
   };
   class RunningQuery {
       constructor(active, context) {
           this.active = active;
           this.context = context;
           this.time = Date.now();
           this.updates = [];
           // Note that 'undefined' means 'not done yet', whereas 'null' means
           // 'query returned null'.
           this.done = undefined;
       }
   }
   const DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;
   const completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
       constructor(view) {
           this.view = view;
           this.debounceUpdate = -1;
           this.running = [];
           this.debounceAccept = -1;
           this.composing = 0 /* None */;
           for (let active of view.state.field(completionState).active)
               if (active.state == 1 /* Pending */)
                   this.startQuery(active);
       }
       update(update) {
           let cState = update.state.field(completionState);
           if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
               return;
           let doesReset = update.transactions.some(tr => {
               return (tr.selection || tr.docChanged) && !getUserEvent(tr);
           });
           for (let i = 0; i < this.running.length; i++) {
               let query = this.running[i];
               if (doesReset ||
                   query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
                   for (let handler of query.context.abortListeners) {
                       try {
                           handler();
                       }
                       catch (e) {
                           logException(this.view.state, e);
                       }
                   }
                   query.context.abortListeners = null;
                   this.running.splice(i--, 1);
               }
               else {
                   query.updates.push(...update.transactions);
               }
           }
           if (this.debounceUpdate > -1)
               clearTimeout(this.debounceUpdate);
           this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.active.source == a.source))
               ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
           if (this.composing != 0 /* None */)
               for (let tr of update.transactions) {
                   if (getUserEvent(tr) == "input")
                       this.composing = 2 /* Changed */;
                   else if (this.composing == 2 /* Changed */ && tr.selection)
                       this.composing = 3 /* ChangedAndMoved */;
               }
       }
       startUpdate() {
           this.debounceUpdate = -1;
           let { state } = this.view, cState = state.field(completionState);
           for (let active of cState.active) {
               if (active.state == 1 /* Pending */ && !this.running.some(r => r.active.source == active.source))
                   this.startQuery(active);
           }
       }
       startQuery(active) {
           let { state } = this.view, pos = cur(state);
           let context = new CompletionContext(state, pos, active.explicitPos == pos);
           let pending = new RunningQuery(active, context);
           this.running.push(pending);
           Promise.resolve(active.source(context)).then(result => {
               if (!pending.context.aborted) {
                   pending.done = result || null;
                   this.scheduleAccept();
               }
           }, err => {
               this.view.dispatch({ effects: closeCompletionEffect.of(null) });
               logException(this.view.state, err);
           });
       }
       scheduleAccept() {
           if (this.running.every(q => q.done !== undefined))
               this.accept();
           else if (this.debounceAccept < 0)
               this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
       }
       // For each finished query in this.running, try to create a result
       // or, if appropriate, restart the query.
       accept() {
           var _a;
           if (this.debounceAccept > -1)
               clearTimeout(this.debounceAccept);
           this.debounceAccept = -1;
           let updated = [];
           let conf = this.view.state.facet(completionConfig);
           for (let i = 0; i < this.running.length; i++) {
               let query = this.running[i];
               if (query.done === undefined)
                   continue;
               this.running.splice(i--, 1);
               if (query.done) {
                   let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));
                   // Replay the transactions that happened since the start of
                   // the request and see if that preserves the result
                   for (let tr of query.updates)
                       active = active.update(tr, conf);
                   if (active.hasResult()) {
                       updated.push(active);
                       continue;
                   }
               }
               let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);
               if (current && current.state == 1 /* Pending */) {
                   if (query.done == null) {
                       // Explicitly failed. Should clear the pending status if it
                       // hasn't been re-set in the meantime.
                       let active = new ActiveSource(query.active.source, 0 /* Inactive */);
                       for (let tr of query.updates)
                           active = active.update(tr, conf);
                       if (active.state != 1 /* Pending */)
                           updated.push(active);
                   }
                   else {
                       // Cleared by subsequent transactions. Restart.
                       this.startQuery(current);
                   }
               }
           }
           if (updated.length)
               this.view.dispatch({ effects: setActiveEffect.of(updated) });
       }
   }, {
       eventHandlers: {
           blur(event) {
               let state = this.view.state.field(completionState, false);
               if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
                   let dialog = state.open && getTooltip(this.view, state.open.tooltip);
                   if (!dialog || !dialog.dom.contains(event.relatedTarget))
                       this.view.dispatch({ effects: closeCompletionEffect.of(null) });
               }
           },
           compositionstart() {
               this.composing = 1 /* Started */;
           },
           compositionend() {
               if (this.composing == 3 /* ChangedAndMoved */) {
                   // Safari fires compositionend events synchronously, possibly
                   // from inside an update, so dispatch asynchronously to avoid reentrancy
                   setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
               }
               this.composing = 0 /* None */;
           }
       }
   });

   const baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({
       ".cm-tooltip.cm-tooltip-autocomplete": {
           "& > ul": {
               fontFamily: "monospace",
               whiteSpace: "nowrap",
               overflow: "hidden auto",
               maxWidth_fallback: "700px",
               maxWidth: "min(700px, 95vw)",
               minWidth: "250px",
               maxHeight: "10em",
               height: "100%",
               listStyle: "none",
               margin: 0,
               padding: 0,
               "& > li, & > completion-section": {
                   padding: "1px 3px",
                   lineHeight: 1.2
               },
               "& > li": {
                   overflowX: "hidden",
                   textOverflow: "ellipsis",
                   cursor: "pointer"
               },
               "& > completion-section": {
                   display: "list-item",
                   borderBottom: "1px solid silver",
                   paddingLeft: "0.5em",
                   opacity: 0.7
               }
           }
       },
       "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
           background: "#17c",
           color: "white",
       },
       "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
           background: "#777",
       },
       "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
           background: "#347",
           color: "white",
       },
       "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
           background: "#444",
       },
       ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
           content: '"···"',
           opacity: 0.5,
           display: "block",
           textAlign: "center"
       },
       ".cm-tooltip.cm-completionInfo": {
           position: "absolute",
           padding: "3px 9px",
           width: "max-content",
           maxWidth: `${400 /* Width */}px`,
           boxSizing: "border-box"
       },
       ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
       ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
       ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30 /* Margin */}px` },
       ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30 /* Margin */}px` },
       "&light .cm-snippetField": { backgroundColor: "#00000022" },
       "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
       ".cm-snippetFieldPosition": {
           verticalAlign: "text-top",
           width: 0,
           height: "1.15em",
           display: "inline-block",
           margin: "0 -0.7px -.7em",
           borderLeft: "1.4px dotted #888"
       },
       ".cm-completionMatchedText": {
           textDecoration: "underline"
       },
       ".cm-completionDetail": {
           marginLeft: "0.5em",
           fontStyle: "italic"
       },
       ".cm-completionIcon": {
           fontSize: "90%",
           width: ".8em",
           display: "inline-block",
           textAlign: "center",
           paddingRight: ".6em",
           opacity: "0.6",
           boxSizing: "content-box"
       },
       ".cm-completionIcon-function, .cm-completionIcon-method": {
           "&:after": { content: "'ƒ'" }
       },
       ".cm-completionIcon-class": {
           "&:after": { content: "'○'" }
       },
       ".cm-completionIcon-interface": {
           "&:after": { content: "'◌'" }
       },
       ".cm-completionIcon-variable": {
           "&:after": { content: "'𝑥'" }
       },
       ".cm-completionIcon-constant": {
           "&:after": { content: "'𝐶'" }
       },
       ".cm-completionIcon-type": {
           "&:after": { content: "'𝑡'" }
       },
       ".cm-completionIcon-enum": {
           "&:after": { content: "'∪'" }
       },
       ".cm-completionIcon-property": {
           "&:after": { content: "'□'" }
       },
       ".cm-completionIcon-keyword": {
           "&:after": { content: "'🔑\uFE0E'" } // Disable emoji rendering
       },
       ".cm-completionIcon-namespace": {
           "&:after": { content: "'▢'" }
       },
       ".cm-completionIcon-text": {
           "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
       }
   });

   const defaults = {
       brackets: ["(", "[", "{", "'", '"'],
       before: ")]}:;>",
       stringPrefixes: []
   };
   const closeBracketEffect = /*@__PURE__*/StateEffect.define({
       map(value, mapping) {
           let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
           return mapped == null ? undefined : mapped;
       }
   });
   const closedBracket = /*@__PURE__*/new class extends RangeValue {
   };
   closedBracket.startSide = 1;
   closedBracket.endSide = -1;
   const bracketState = /*@__PURE__*/StateField.define({
       create() { return RangeSet.empty; },
       update(value, tr) {
           if (tr.selection) {
               let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
               let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
               if (lineStart != tr.changes.mapPos(prevLineStart, -1))
                   value = RangeSet.empty;
           }
           value = value.map(tr.changes);
           for (let effect of tr.effects)
               if (effect.is(closeBracketEffect))
                   value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
           return value;
       }
   });
   /**
   Extension to enable bracket-closing behavior. When a closeable
   bracket is typed, its closing bracket is immediately inserted
   after the cursor. When closing a bracket directly in front of a
   closing bracket inserted by the extension, the cursor moves over
   that bracket.
   */
   function closeBrackets() {
       return [inputHandler, bracketState];
   }
   const definedClosing = "()[]{}<>";
   function closing(ch) {
       for (let i = 0; i < definedClosing.length; i += 2)
           if (definedClosing.charCodeAt(i) == ch)
               return definedClosing.charAt(i + 1);
       return fromCodePoint(ch < 128 ? ch : ch + 1);
   }
   function config$2(state, pos) {
       return state.languageDataAt("closeBrackets", pos)[0] || defaults;
   }
   const android = typeof navigator == "object" && /*@__PURE__*//Android\b/.test(navigator.userAgent);
   const inputHandler = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, insert) => {
       if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
           return false;
       let sel = view.state.selection.main;
       if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||
           from != sel.from || to != sel.to)
           return false;
       let tr = insertBracket(view.state, insert);
       if (!tr)
           return false;
       view.dispatch(tr);
       return true;
   });
   /**
   Command that implements deleting a pair of matching brackets when
   the cursor is between them.
   */
   const deleteBracketPair = ({ state, dispatch }) => {
       if (state.readOnly)
           return false;
       let conf = config$2(state, state.selection.main.head);
       let tokens = conf.brackets || defaults.brackets;
       let dont = null, changes = state.changeByRange(range => {
           if (range.empty) {
               let before = prevChar(state.doc, range.head);
               for (let token of tokens) {
                   if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
                       return { changes: { from: range.head - token.length, to: range.head + token.length },
                           range: EditorSelection.cursor(range.head - token.length) };
               }
           }
           return { range: dont = range };
       });
       if (!dont)
           dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
       return !dont;
   };
   /**
   Close-brackets related key bindings. Binds Backspace to
   [`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).
   */
   const closeBracketsKeymap = [
       { key: "Backspace", run: deleteBracketPair }
   ];
   /**
   Implements the extension's behavior on text insertion. If the
   given string counts as a bracket in the language around the
   selection, and replacing the selection with it requires custom
   behavior (inserting a closing version or skipping past a
   previously-closed bracket), this function returns a transaction
   representing that custom behavior. (You only need this if you want
   to programmatically insert brackets—the
   [`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will
   take care of running this for user input.)
   */
   function insertBracket(state, bracket) {
       let conf = config$2(state, state.selection.main.head);
       let tokens = conf.brackets || defaults.brackets;
       for (let tok of tokens) {
           let closed = closing(codePointAt(tok, 0));
           if (bracket == tok)
               return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)
                   : handleOpen(state, tok, closed, conf.before || defaults.before);
           if (bracket == closed && closedBracketAt(state, state.selection.main.from))
               return handleClose(state, tok, closed);
       }
       return null;
   }
   function closedBracketAt(state, pos) {
       let found = false;
       state.field(bracketState).between(0, state.doc.length, from => {
           if (from == pos)
               found = true;
       });
       return found;
   }
   function nextChar(doc, pos) {
       let next = doc.sliceString(pos, pos + 2);
       return next.slice(0, codePointSize(codePointAt(next, 0)));
   }
   function prevChar(doc, pos) {
       let prev = doc.sliceString(pos - 2, pos);
       return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
   }
   function handleOpen(state, open, close, closeBefore) {
       let dont = null, changes = state.changeByRange(range => {
           if (!range.empty)
               return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
                   effects: closeBracketEffect.of(range.to + open.length),
                   range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };
           let next = nextChar(state.doc, range.head);
           if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
               return { changes: { insert: open + close, from: range.head },
                   effects: closeBracketEffect.of(range.head + open.length),
                   range: EditorSelection.cursor(range.head + open.length) };
           return { range: dont = range };
       });
       return dont ? null : state.update(changes, {
           scrollIntoView: true,
           userEvent: "input.type"
       });
   }
   function handleClose(state, _open, close) {
       let dont = null, changes = state.changeByRange(range => {
           if (range.empty && nextChar(state.doc, range.head) == close)
               return { changes: { from: range.head, to: range.head + close.length, insert: close },
                   range: EditorSelection.cursor(range.head + close.length) };
           return dont = { range };
       });
       return dont ? null : state.update(changes, {
           scrollIntoView: true,
           userEvent: "input.type"
       });
   }
   // Handles cases where the open and close token are the same, and
   // possibly triple quotes (as in `"""abc"""`-style quoting).
   function handleSame(state, token, allowTriple, config) {
       let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;
       let dont = null, changes = state.changeByRange(range => {
           if (!range.empty)
               return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
                   effects: closeBracketEffect.of(range.to + token.length),
                   range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };
           let pos = range.head, next = nextChar(state.doc, pos), start;
           if (next == token) {
               if (nodeStart(state, pos)) {
                   return { changes: { insert: token + token, from: pos },
                       effects: closeBracketEffect.of(pos + token.length),
                       range: EditorSelection.cursor(pos + token.length) };
               }
               else if (closedBracketAt(state, pos)) {
                   let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                   let content = isTriple ? token + token + token : token;
                   return { changes: { from: pos, to: pos + content.length, insert: content },
                       range: EditorSelection.cursor(pos + content.length) };
               }
           }
           else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&
               (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&
               nodeStart(state, start)) {
               return { changes: { insert: token + token + token + token, from: pos },
                   effects: closeBracketEffect.of(pos + token.length),
                   range: EditorSelection.cursor(pos + token.length) };
           }
           else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
               if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
                   return { changes: { insert: token + token, from: pos },
                       effects: closeBracketEffect.of(pos + token.length),
                       range: EditorSelection.cursor(pos + token.length) };
           }
           return { range: dont = range };
       });
       return dont ? null : state.update(changes, {
           scrollIntoView: true,
           userEvent: "input.type"
       });
   }
   function nodeStart(state, pos) {
       let tree = syntaxTree(state).resolveInner(pos + 1);
       return tree.parent && tree.from == pos;
   }
   function probablyInString(state, pos, quoteToken, prefixes) {
       let node = syntaxTree(state).resolveInner(pos, -1);
       let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
       for (let i = 0; i < 5; i++) {
           let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
           let quotePos = start.indexOf(quoteToken);
           if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
               let first = node.firstChild;
               while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
                   if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                       return false;
                   first = first.firstChild;
               }
               return true;
           }
           let parent = node.to == pos && node.parent;
           if (!parent)
               break;
           node = parent;
       }
       return false;
   }
   function canStartStringAt(state, pos, prefixes) {
       let charCat = state.charCategorizer(pos);
       if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
           return pos;
       for (let prefix of prefixes) {
           let start = pos - prefix.length;
           if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
               return start;
       }
       return -1;
   }

   /**
   Returns an extension that enables autocompletion.
   */
   function autocompletion(config = {}) {
       return [
           completionState,
           completionConfig.of(config),
           completionPlugin,
           completionKeymapExt,
           baseTheme$1
       ];
   }
   /**
   Basic keybindings for autocompletion.

    - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
    - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
    - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
    - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
    - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
    - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
    - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
   */
   const completionKeymap = [
       { key: "Ctrl-Space", run: startCompletion },
       { key: "Escape", run: closeCompletion },
       { key: "ArrowDown", run: /*@__PURE__*/moveCompletionSelection(true) },
       { key: "ArrowUp", run: /*@__PURE__*/moveCompletionSelection(false) },
       { key: "PageDown", run: /*@__PURE__*/moveCompletionSelection(true, "page") },
       { key: "PageUp", run: /*@__PURE__*/moveCompletionSelection(false, "page") },
       { key: "Enter", run: acceptCompletion }
   ];
   const completionKeymapExt = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

   class SelectedDiagnostic {
       constructor(from, to, diagnostic) {
           this.from = from;
           this.to = to;
           this.diagnostic = diagnostic;
       }
   }
   class LintState {
       constructor(diagnostics, panel, selected) {
           this.diagnostics = diagnostics;
           this.panel = panel;
           this.selected = selected;
       }
       static init(diagnostics, panel, state) {
           // Filter the list of diagnostics for which to create markers
           let markedDiagnostics = diagnostics;
           let diagnosticFilter = state.facet(lintConfig).markerFilter;
           if (diagnosticFilter)
               markedDiagnostics = diagnosticFilter(markedDiagnostics);
           let ranges = Decoration.set(markedDiagnostics.map((d) => {
               // For zero-length ranges or ranges covering only a line break, create a widget
               return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)
                   ? Decoration.widget({
                       widget: new DiagnosticWidget(d),
                       diagnostic: d
                   }).range(d.from)
                   : Decoration.mark({
                       attributes: { class: "cm-lintRange cm-lintRange-" + d.severity + (d.markClass ? " " + d.markClass : "") },
                       diagnostic: d
                   }).range(d.from, d.to);
           }), true);
           return new LintState(ranges, panel, findDiagnostic(ranges));
       }
   }
   function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
       let found = null;
       diagnostics.between(after, 1e9, (from, to, { spec }) => {
           if (diagnostic && spec.diagnostic != diagnostic)
               return;
           found = new SelectedDiagnostic(from, to, spec.diagnostic);
           return false;
       });
       return found;
   }
   function hideTooltip(tr, tooltip) {
       let line = tr.startState.doc.lineAt(tooltip.pos);
       return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));
   }
   function maybeEnableLint(state, effects) {
       return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
   }
   /**
   The state effect that updates the set of active diagnostics. Can
   be useful when writing an extension that needs to track these.
   */
   const setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();
   const togglePanel = /*@__PURE__*/StateEffect.define();
   const movePanelSelection = /*@__PURE__*/StateEffect.define();
   const lintState = /*@__PURE__*/StateField.define({
       create() {
           return new LintState(Decoration.none, null, null);
       },
       update(value, tr) {
           if (tr.docChanged) {
               let mapped = value.diagnostics.map(tr.changes), selected = null;
               if (value.selected) {
                   let selPos = tr.changes.mapPos(value.selected.from, 1);
                   selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
               }
               value = new LintState(mapped, value.panel, selected);
           }
           for (let effect of tr.effects) {
               if (effect.is(setDiagnosticsEffect)) {
                   value = LintState.init(effect.value, value.panel, tr.state);
               }
               else if (effect.is(togglePanel)) {
                   value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
               }
               else if (effect.is(movePanelSelection)) {
                   value = new LintState(value.diagnostics, value.panel, effect.value);
               }
           }
           return value;
       },
       provide: f => [showPanel.from(f, val => val.panel),
           EditorView.decorations.from(f, s => s.diagnostics)]
   });
   const activeMark = /*@__PURE__*/Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
   function lintTooltip(view, pos, side) {
       let { diagnostics } = view.state.field(lintState);
       let found = [], stackStart = 2e8, stackEnd = 0;
       diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
           if (pos >= from && pos <= to &&
               (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
               found.push(spec.diagnostic);
               stackStart = Math.min(from, stackStart);
               stackEnd = Math.max(to, stackEnd);
           }
       });
       let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
       if (diagnosticFilter)
           found = diagnosticFilter(found);
       if (!found.length)
           return null;
       return {
           pos: stackStart,
           end: stackEnd,
           above: view.state.doc.lineAt(stackStart).to < stackEnd,
           create() {
               return { dom: diagnosticsTooltip(view, found) };
           }
       };
   }
   function diagnosticsTooltip(view, diagnostics) {
       return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map(d => renderDiagnostic(view, d, false)));
   }
   /**
   Command to open and focus the lint panel.
   */
   const openLintPanel = (view) => {
       let field = view.state.field(lintState, false);
       if (!field || !field.panel)
           view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
       let panel = getPanel(view, LintPanel.open);
       if (panel)
           panel.dom.querySelector(".cm-panel-lint ul").focus();
       return true;
   };
   /**
   Command to close the lint panel, when open.
   */
   const closeLintPanel = (view) => {
       let field = view.state.field(lintState, false);
       if (!field || !field.panel)
           return false;
       view.dispatch({ effects: togglePanel.of(false) });
       return true;
   };
   /**
   Move the selection to the next diagnostic.
   */
   const nextDiagnostic = (view) => {
       let field = view.state.field(lintState, false);
       if (!field)
           return false;
       let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
       if (!next.value) {
           next = field.diagnostics.iter(0);
           if (!next.value || next.from == sel.from && next.to == sel.to)
               return false;
       }
       view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
       return true;
   };
   /**
   A set of default key bindings for the lint functionality.

   - Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
   - F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
   */
   const lintKeymap = [
       { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
       { key: "F8", run: nextDiagnostic }
   ];
   const lintConfig = /*@__PURE__*/Facet.define({
       combine(input) {
           return Object.assign({ sources: input.map(i => i.source) }, combineConfig(input.map(i => i.config), {
               delay: 750,
               markerFilter: null,
               tooltipFilter: null,
               needsRefresh: null
           }, {
               needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)
           }));
       }
   });
   function assignKeys(actions) {
       let assigned = [];
       if (actions)
           actions: for (let { name } of actions) {
               for (let i = 0; i < name.length; i++) {
                   let ch = name[i];
                   if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                       assigned.push(ch);
                       continue actions;
                   }
               }
               assigned.push("");
           }
       return assigned;
   }
   function renderDiagnostic(view, diagnostic, inPanel) {
       var _a;
       let keys = inPanel ? assignKeys(diagnostic.actions) : [];
       return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
           let fired = false, click = (e) => {
               e.preventDefault();
               if (fired)
                   return;
               fired = true;
               let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
               if (found)
                   action.apply(view, found.from, found.to);
           };
           let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
           let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),
               crelt("u", name.slice(keyIndex, keyIndex + 1)),
               name.slice(keyIndex + 1)];
           return crelt("button", {
               type: "button",
               class: "cm-diagnosticAction",
               onclick: click,
               onmousedown: click,
               "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
           }, nameElt);
       }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
   }
   class DiagnosticWidget extends WidgetType {
       constructor(diagnostic) {
           super();
           this.diagnostic = diagnostic;
       }
       eq(other) { return other.diagnostic == this.diagnostic; }
       toDOM() {
           return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
       }
   }
   class PanelItem {
       constructor(view, diagnostic) {
           this.diagnostic = diagnostic;
           this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
           this.dom = renderDiagnostic(view, diagnostic, true);
           this.dom.id = this.id;
           this.dom.setAttribute("role", "option");
       }
   }
   class LintPanel {
       constructor(view) {
           this.view = view;
           this.items = [];
           let onkeydown = (event) => {
               if (event.keyCode == 27) { // Escape
                   closeLintPanel(this.view);
                   this.view.focus();
               }
               else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp
                   this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
               }
               else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown
                   this.moveSelection((this.selectedIndex + 1) % this.items.length);
               }
               else if (event.keyCode == 36) { // Home
                   this.moveSelection(0);
               }
               else if (event.keyCode == 35) { // End
                   this.moveSelection(this.items.length - 1);
               }
               else if (event.keyCode == 13) { // Enter
                   this.view.focus();
               }
               else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z
                   let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                   for (let i = 0; i < keys.length; i++)
                       if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                           let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                           if (found)
                               diagnostic.actions[i].apply(view, found.from, found.to);
                       }
               }
               else {
                   return;
               }
               event.preventDefault();
           };
           let onclick = (event) => {
               for (let i = 0; i < this.items.length; i++) {
                   if (this.items[i].dom.contains(event.target))
                       this.moveSelection(i);
               }
           };
           this.list = crelt("ul", {
               tabIndex: 0,
               role: "listbox",
               "aria-label": this.view.state.phrase("Diagnostics"),
               onkeydown,
               onclick
           });
           this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
               type: "button",
               name: "close",
               "aria-label": this.view.state.phrase("close"),
               onclick: () => closeLintPanel(this.view)
           }, "×"));
           this.update();
       }
       get selectedIndex() {
           let selected = this.view.state.field(lintState).selected;
           if (!selected)
               return -1;
           for (let i = 0; i < this.items.length; i++)
               if (this.items[i].diagnostic == selected.diagnostic)
                   return i;
           return -1;
       }
       update() {
           let { diagnostics, selected } = this.view.state.field(lintState);
           let i = 0, needsSync = false, newSelectedItem = null;
           diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
               let found = -1, item;
               for (let j = i; j < this.items.length; j++)
                   if (this.items[j].diagnostic == spec.diagnostic) {
                       found = j;
                       break;
                   }
               if (found < 0) {
                   item = new PanelItem(this.view, spec.diagnostic);
                   this.items.splice(i, 0, item);
                   needsSync = true;
               }
               else {
                   item = this.items[found];
                   if (found > i) {
                       this.items.splice(i, found - i);
                       needsSync = true;
                   }
               }
               if (selected && item.diagnostic == selected.diagnostic) {
                   if (!item.dom.hasAttribute("aria-selected")) {
                       item.dom.setAttribute("aria-selected", "true");
                       newSelectedItem = item;
                   }
               }
               else if (item.dom.hasAttribute("aria-selected")) {
                   item.dom.removeAttribute("aria-selected");
               }
               i++;
           });
           while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
               needsSync = true;
               this.items.pop();
           }
           if (this.items.length == 0) {
               this.items.push(new PanelItem(this.view, {
                   from: -1, to: -1,
                   severity: "info",
                   message: this.view.state.phrase("No diagnostics")
               }));
               needsSync = true;
           }
           if (newSelectedItem) {
               this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
               this.view.requestMeasure({
                   key: this,
                   read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                   write: ({ sel, panel }) => {
                       if (sel.top < panel.top)
                           this.list.scrollTop -= panel.top - sel.top;
                       else if (sel.bottom > panel.bottom)
                           this.list.scrollTop += sel.bottom - panel.bottom;
                   }
               });
           }
           else if (this.selectedIndex < 0) {
               this.list.removeAttribute("aria-activedescendant");
           }
           if (needsSync)
               this.sync();
       }
       sync() {
           let domPos = this.list.firstChild;
           function rm() {
               let prev = domPos;
               domPos = prev.nextSibling;
               prev.remove();
           }
           for (let item of this.items) {
               if (item.dom.parentNode == this.list) {
                   while (domPos != item.dom)
                       rm();
                   domPos = item.dom.nextSibling;
               }
               else {
                   this.list.insertBefore(item.dom, domPos);
               }
           }
           while (domPos)
               rm();
       }
       moveSelection(selectedIndex) {
           if (this.selectedIndex < 0)
               return;
           let field = this.view.state.field(lintState);
           let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
           if (!selection)
               return;
           this.view.dispatch({
               selection: { anchor: selection.from, head: selection.to },
               scrollIntoView: true,
               effects: movePanelSelection.of(selection)
           });
       }
       static open(view) { return new LintPanel(view); }
   }
   function svg(content, attrs = `viewBox="0 0 40 40"`) {
       return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
   }
   function underline(color) {
       return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
   }
   const baseTheme = /*@__PURE__*/EditorView.baseTheme({
       ".cm-diagnostic": {
           padding: "3px 6px 3px 8px",
           marginLeft: "-1px",
           display: "block",
           whiteSpace: "pre-wrap"
       },
       ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
       ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
       ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
       ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
       ".cm-diagnosticAction": {
           font: "inherit",
           border: "none",
           padding: "2px 4px",
           backgroundColor: "#444",
           color: "white",
           borderRadius: "3px",
           marginLeft: "8px",
           cursor: "pointer"
       },
       ".cm-diagnosticSource": {
           fontSize: "70%",
           opacity: .7
       },
       ".cm-lintRange": {
           backgroundPosition: "left bottom",
           backgroundRepeat: "repeat-x",
           paddingBottom: "0.7px",
       },
       ".cm-lintRange-error": { backgroundImage: /*@__PURE__*/underline("#d11") },
       ".cm-lintRange-warning": { backgroundImage: /*@__PURE__*/underline("orange") },
       ".cm-lintRange-info": { backgroundImage: /*@__PURE__*/underline("#999") },
       ".cm-lintRange-hint": { backgroundImage: /*@__PURE__*/underline("#66d") },
       ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
       ".cm-tooltip-lint": {
           padding: 0,
           margin: 0
       },
       ".cm-lintPoint": {
           position: "relative",
           "&:after": {
               content: '""',
               position: "absolute",
               bottom: 0,
               left: "-2px",
               borderLeft: "3px solid transparent",
               borderRight: "3px solid transparent",
               borderBottom: "4px solid #d11"
           }
       },
       ".cm-lintPoint-warning": {
           "&:after": { borderBottomColor: "orange" }
       },
       ".cm-lintPoint-info": {
           "&:after": { borderBottomColor: "#999" }
       },
       ".cm-lintPoint-hint": {
           "&:after": { borderBottomColor: "#66d" }
       },
       ".cm-panel.cm-panel-lint": {
           position: "relative",
           "& ul": {
               maxHeight: "100px",
               overflowY: "auto",
               "& [aria-selected]": {
                   backgroundColor: "#ddd",
                   "& u": { textDecoration: "underline" }
               },
               "&:focus [aria-selected]": {
                   background_fallback: "#bdf",
                   backgroundColor: "Highlight",
                   color_fallback: "white",
                   color: "HighlightText"
               },
               "& u": { textDecoration: "none" },
               padding: 0,
               margin: 0
           },
           "& [name=close]": {
               position: "absolute",
               top: "0",
               right: "2px",
               background: "inherit",
               border: "none",
               font: "inherit",
               padding: 0,
               margin: 0
           }
       }
   });
   const lintExtensions = [
       lintState,
       /*@__PURE__*/EditorView.decorations.compute([lintState], state => {
           let { selected, panel } = state.field(lintState);
           return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
               activeMark.range(selected.from, selected.to)
           ]);
       }),
       /*@__PURE__*/hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
       baseTheme
   ];

   // (The superfluous function calls around the list of extensions work
   // around current limitations in tree-shaking software.)
   /**
   This is an extension value that just pulls together a number of
   extensions that you might want in a basic editor. It is meant as a
   convenient helper to quickly set up CodeMirror without installing
   and importing a lot of separate packages.

   Specifically, it includes...

    - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)
    - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)
    - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)
    - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)
    - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)
    - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)
    - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)
    - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
    - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)
    - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)
    - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)
    - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)
    - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)
    - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)
    - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)
    - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)
    - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)
    - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)
    - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)

   (You'll probably want to add some language package to your setup
   too.)

   This extension does not allow customization. The idea is that,
   once you decide you want to configure your editor more precisely,
   you take this package's source (which is just a bunch of imports
   and an array literal), copy it into your own code, and adjust it
   as desired.
   */
   const basicSetup = /*@__PURE__*/(() => [
       lineNumbers(),
       highlightActiveLineGutter(),
       highlightSpecialChars(),
       history(),
       foldGutter(),
       drawSelection(),
       dropCursor(),
       EditorState.allowMultipleSelections.of(true),
       indentOnInput(),
       syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
       bracketMatching(),
       closeBrackets(),
       autocompletion(),
       rectangularSelection(),
       crosshairCursor(),
       highlightActiveLine(),
       highlightSelectionMatches(),
       keymap.of([
           ...closeBracketsKeymap,
           ...defaultKeymap,
           ...searchKeymap,
           ...historyKeymap,
           ...foldKeymap,
           ...completionKeymap,
           ...lintKeymap
       ])
   ])();

   function _extends$1() {
     _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
       for (var i = 1; i < arguments.length; i++) {
         var source = arguments[i];
         for (var key in source) {
           if (Object.prototype.hasOwnProperty.call(source, key)) {
             target[key] = source[key];
           }
         }
       }
       return target;
     };
     return _extends$1.apply(this, arguments);
   }

   var DEFAULT_CONFIG = {
     // minimum relative difference between two compared values,
     // used by all comparison functions
     epsilon: 1e-12,
     // type of default matrix output. Choose 'matrix' (default) or 'array'
     matrix: 'Matrix',
     // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
     number: 'number',
     // number of significant digits in BigNumbers
     precision: 64,
     // predictable output type of functions. When true, output type depends only
     // on the input types. When false (default), output type can vary depending
     // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
     // predictable is false, and returns `NaN` when true.
     predictable: false,
     // random seed for seeded pseudo random number generation
     // null = randomly seed
     randomSeed: null
   };

   // type checks for all known types
   //
   // note that:
   //
   // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
   //   instanceof cannot be used because that would not allow to pass data from
   //   one instance of math.js to another since each has it's own instance of Unit.
   // - check the `isUnit` property via the constructor, so there will be no
   //   matches for "fake" instances like plain objects with a property `isUnit`.
   //   That is important for security reasons.
   // - It must not be possible to override the type checks used internally,
   //   for security reasons, so these functions are not exposed in the expression
   //   parser.

   function isNumber(x) {
     return typeof x === 'number';
   }
   function isBigNumber(x) {
     if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {
       return false;
     }
     if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {
       return true;
     }
     if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {
       return true;
     }
     return false;
   }
   function isComplex(x) {
     return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
   }
   function isFraction(x) {
     return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
   }
   function isUnit(x) {
     return x && x.constructor.prototype.isUnit === true || false;
   }
   function isString(x) {
     return typeof x === 'string';
   }
   var isArray = Array.isArray;
   function isMatrix(x) {
     return x && x.constructor.prototype.isMatrix === true || false;
   }

   /**
    * Test whether a value is a collection: an Array or Matrix
    * @param {*} x
    * @returns {boolean} isCollection
    */
   function isCollection(x) {
     return Array.isArray(x) || isMatrix(x);
   }
   function isDenseMatrix(x) {
     return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
   }
   function isSparseMatrix(x) {
     return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
   }
   function isRange(x) {
     return x && x.constructor.prototype.isRange === true || false;
   }
   function isIndex(x) {
     return x && x.constructor.prototype.isIndex === true || false;
   }
   function isBoolean(x) {
     return typeof x === 'boolean';
   }
   function isResultSet(x) {
     return x && x.constructor.prototype.isResultSet === true || false;
   }
   function isHelp(x) {
     return x && x.constructor.prototype.isHelp === true || false;
   }
   function isFunction(x) {
     return typeof x === 'function';
   }
   function isDate(x) {
     return x instanceof Date;
   }
   function isRegExp(x) {
     return x instanceof RegExp;
   }
   function isObject(x) {
     return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
   }
   function isNull(x) {
     return x === null;
   }
   function isUndefined(x) {
     return x === undefined;
   }
   function isAccessorNode(x) {
     return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isArrayNode(x) {
     return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isAssignmentNode(x) {
     return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isBlockNode(x) {
     return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isConditionalNode(x) {
     return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isConstantNode(x) {
     return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
   }

   /* Very specialized: returns true for those nodes which in the numerator of
      a fraction means that the division in that fraction has precedence over implicit
      multiplication, e.g. -2/3 x parses as (-2/3) x and 3/4 x parses as (3/4) x but
      6!/8 x parses as 6! / (8x). It is located here because it is shared between
      parse.js and OperatorNode.js (for parsing and printing, respectively).

      This should *not* be exported from mathjs, unlike most of the tests here.
      Its name does not start with 'is' to prevent utils/snapshot.js from thinking
      it should be exported.
   */
   function rule2Node(node) {
     return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && '-+~'.includes(node.op);
   }
   function isFunctionAssignmentNode(x) {
     return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isFunctionNode(x) {
     return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isIndexNode(x) {
     return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isNode(x) {
     return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isObjectNode(x) {
     return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isOperatorNode(x) {
     return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isParenthesisNode(x) {
     return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isRangeNode(x) {
     return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isRelationalNode(x) {
     return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isSymbolNode(x) {
     return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
   }
   function isChain(x) {
     return x && x.constructor.prototype.isChain === true || false;
   }
   function typeOf$1(x) {
     var t = typeof x;
     if (t === 'object') {
       if (x === null) return 'null';
       if (isBigNumber(x)) return 'BigNumber'; // Special: weird mashup with Decimal
       if (x.constructor && x.constructor.name) return x.constructor.name;
       return 'Object'; // just in case
     }

     return t; // can be 'string', 'number', 'boolean', 'function', 'bigint', ...
   }

   /**
    * Clone an object
    *
    *     clone(x)
    *
    * Can clone any primitive type, array, and object.
    * If x has a function clone, this function will be invoked to clone the object.
    *
    * @param {*} x
    * @return {*} clone
    */
   function clone$3(x) {
     var type = typeof x;

     // immutable primitive types
     if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
       return x;
     }

     // use clone function of the object when available
     if (typeof x.clone === 'function') {
       return x.clone();
     }

     // array
     if (Array.isArray(x)) {
       return x.map(function (value) {
         return clone$3(value);
       });
     }
     if (x instanceof Date) return new Date(x.valueOf());
     if (isBigNumber(x)) return x; // bignumbers are immutable
     if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp

     // object
     return mapObject(x, clone$3);
   }

   /**
    * Apply map to all properties of an object
    * @param {Object} object
    * @param {function} callback
    * @return {Object} Returns a copy of the object with mapped properties
    */
   function mapObject(object, callback) {
     var clone = {};
     for (var key in object) {
       if (hasOwnProperty(object, key)) {
         clone[key] = callback(object[key]);
       }
     }
     return clone;
   }

   /**
    * Extend object a with the properties of object b
    * @param {Object} a
    * @param {Object} b
    * @return {Object} a
    */
   function extend(a, b) {
     for (var prop in b) {
       if (hasOwnProperty(b, prop)) {
         a[prop] = b[prop];
       }
     }
     return a;
   }

   /**
    * Deep test equality of all fields in two pairs of arrays or objects.
    * Compares values and functions strictly (ie. 2 is not the same as '2').
    * @param {Array | Object} a
    * @param {Array | Object} b
    * @returns {boolean}
    */
   function deepStrictEqual(a, b) {
     var prop, i, len;
     if (Array.isArray(a)) {
       if (!Array.isArray(b)) {
         return false;
       }
       if (a.length !== b.length) {
         return false;
       }
       for (i = 0, len = a.length; i < len; i++) {
         if (!deepStrictEqual(a[i], b[i])) {
           return false;
         }
       }
       return true;
     } else if (typeof a === 'function') {
       return a === b;
     } else if (a instanceof Object) {
       if (Array.isArray(b) || !(b instanceof Object)) {
         return false;
       }
       for (prop in a) {
         // noinspection JSUnfilteredForInLoop
         if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
           return false;
         }
       }
       for (prop in b) {
         // noinspection JSUnfilteredForInLoop
         if (!(prop in a)) {
           return false;
         }
       }
       return true;
     } else {
       return a === b;
     }
   }

   /**
    * Attach a lazy loading property to a constant.
    * The given function `fn` is called once when the property is first requested.
    *
    * @param {Object} object         Object where to add the property
    * @param {string} prop           Property name
    * @param {Function} valueResolver Function returning the property value. Called
    *                                without arguments.
    */
   function lazy(object, prop, valueResolver) {
     var _uninitialized = true;
     var _value;
     Object.defineProperty(object, prop, {
       get: function get() {
         if (_uninitialized) {
           _value = valueResolver();
           _uninitialized = false;
         }
         return _value;
       },
       set: function set(value) {
         _value = value;
         _uninitialized = false;
       },
       configurable: true,
       enumerable: true
     });
   }

   /**
    * A safe hasOwnProperty
    * @param {Object} object
    * @param {string} property
    */
   function hasOwnProperty(object, property) {
     return object && Object.hasOwnProperty.call(object, property);
   }

   /**
    * Shallow version of pick, creating an object composed of the picked object properties
    * but not for nested properties
    * @param {Object} object
    * @param {string[]} properties
    * @return {Object}
    */
   function pickShallow(object, properties) {
     var copy = {};
     for (var i = 0; i < properties.length; i++) {
       var key = properties[i];
       var value = object[key];
       if (value !== undefined) {
         copy[key] = value;
       }
     }
     return copy;
   }

   var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix
   var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

   // create a read-only version of config
   var config$1 = function config(options) {
     if (options) {
       throw new Error('The global config is readonly. \n' + 'Please create a mathjs instance if you want to change the default configuration. \n' + 'Example:\n' + '\n' + '  import { create, all } from \'mathjs\';\n' + '  const mathjs = create(all);\n' + '  mathjs.config({ number: \'BigNumber\' });\n');
     }
     return Object.freeze(DEFAULT_CONFIG);
   };
   _extends$1(config$1, DEFAULT_CONFIG, {
     MATRIX_OPTIONS,
     NUMBER_OPTIONS
   });

   var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

   function getDefaultExportFromCjs (x) {
   	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
   }

   function getAugmentedNamespace(n) {
     if (n.__esModule) return n;
     var f = n.default;
   	if (typeof f == "function") {
   		var a = function a () {
   			if (this instanceof a) {
           return Reflect.construct(f, arguments, this.constructor);
   			}
   			return f.apply(this, arguments);
   		};
   		a.prototype = f.prototype;
     } else a = {};
     Object.defineProperty(a, '__esModule', {value: true});
   	Object.keys(n).forEach(function (k) {
   		var d = Object.getOwnPropertyDescriptor(n, k);
   		Object.defineProperty(a, k, d.get ? d : {
   			enumerable: true,
   			get: function () {
   				return n[k];
   			}
   		});
   	});
   	return a;
   }

   var typedFunction$1 = {exports: {}};

   (function (module, exports) {
   	(function (global, factory) {
   	  module.exports = factory() ;
   	})(commonjsGlobal, (function () {
   	  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

   	  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

   	  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

   	  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

   	  function ok() {
   	    return true;
   	  }

   	  function notOk() {
   	    return false;
   	  }

   	  function undef() {
   	    return undefined;
   	  }

   	  var NOT_TYPED_FUNCTION = 'Argument is not a typed-function.';
   	  /**
   	   * @typedef {{
   	   *   params: Param[],
   	   *   fn: function,
   	   *   test: function,
   	   *   implementation: function
   	   * }} Signature
   	   *
   	   * @typedef {{
   	   *   types: Type[],
   	   *   hasAny: boolean,
   	   *   hasConversion: boolean,
   	   *   restParam: boolean
   	   * }} Param
   	   *
   	   * @typedef {{
   	   *   name: string,
   	   *   typeIndex: number,
   	   *   test: function,
   	   *   isAny: boolean,
   	   *   conversion?: ConversionDef,
   	   *   conversionIndex: number,
   	   * }} Type
   	   *
   	   * @typedef {{
   	   *   from: string,
   	   *   to: string,
   	   *   convert: function (*) : *
   	   * }} ConversionDef
   	   *
   	   * @typedef {{
   	   *   name: string,
   	   *   test: function(*) : boolean,
   	   *   isAny?: boolean
   	   * }} TypeDef
   	   */

   	  /**
   	   * @returns {() => function}
   	   */

   	  function create() {
   	    // data type tests

   	    /**
   	     * Returns true if the argument is a non-null "plain" object
   	     */
   	    function isPlainObject(x) {
   	      return _typeof(x) === 'object' && x !== null && x.constructor === Object;
   	    }

   	    var _types = [{
   	      name: 'number',
   	      test: function test(x) {
   	        return typeof x === 'number';
   	      }
   	    }, {
   	      name: 'string',
   	      test: function test(x) {
   	        return typeof x === 'string';
   	      }
   	    }, {
   	      name: 'boolean',
   	      test: function test(x) {
   	        return typeof x === 'boolean';
   	      }
   	    }, {
   	      name: 'Function',
   	      test: function test(x) {
   	        return typeof x === 'function';
   	      }
   	    }, {
   	      name: 'Array',
   	      test: Array.isArray
   	    }, {
   	      name: 'Date',
   	      test: function test(x) {
   	        return x instanceof Date;
   	      }
   	    }, {
   	      name: 'RegExp',
   	      test: function test(x) {
   	        return x instanceof RegExp;
   	      }
   	    }, {
   	      name: 'Object',
   	      test: isPlainObject
   	    }, {
   	      name: 'null',
   	      test: function test(x) {
   	        return x === null;
   	      }
   	    }, {
   	      name: 'undefined',
   	      test: function test(x) {
   	        return x === undefined;
   	      }
   	    }];
   	    var anyType = {
   	      name: 'any',
   	      test: ok,
   	      isAny: true
   	    }; // Data structures to track the types. As these are local variables in
   	    // create(), each typed universe will get its own copy, but the variables
   	    // will only be accessible through the (closures of the) functions supplied
   	    // as properties of the typed object, not directly.
   	    // These will be initialized in clear() below

   	    var typeMap; // primary store of all types

   	    var typeList; // Array of just type names, for the sake of ordering
   	    // And similar data structures for the type conversions:

   	    var nConversions = 0; // the actual conversions are stored on a property of the destination types
   	    // This is a temporary object, will be replaced with a function at the end

   	    var typed = {
   	      createCount: 0
   	    };
   	    /**
   	     * Takes a type name and returns the corresponding official type object
   	     * for that type.
   	     *
   	     * @param {string} typeName
   	     * @returns {TypeDef} type
   	     */

   	    function findType(typeName) {
   	      var type = typeMap.get(typeName);

   	      if (type) {
   	        return type;
   	      } // Remainder is error handling


   	      var message = 'Unknown type "' + typeName + '"';
   	      var name = typeName.toLowerCase();
   	      var otherName;

   	      var _iterator = _createForOfIteratorHelper(typeList),
   	          _step;

   	      try {
   	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
   	          otherName = _step.value;

   	          if (otherName.toLowerCase() === name) {
   	            message += '. Did you mean "' + otherName + '" ?';
   	            break;
   	          }
   	        }
   	      } catch (err) {
   	        _iterator.e(err);
   	      } finally {
   	        _iterator.f();
   	      }

   	      throw new TypeError(message);
   	    }
   	    /**
   	     * Adds an array `types` of type definitions to this typed instance.
   	     * Each type definition should be an object with properties:
   	     * 'name' - a string giving the name of the type; 'test' - function
   	     * returning a boolean that tests membership in the type; and optionally
   	     * 'isAny' - true only for the 'any' type.
   	     *
   	     * The second optional argument, `before`, gives the name of a type that
   	     * these types should be added before. The new types are added in the
   	     * order specified.
   	     * @param {TypeDef[]} types
   	     * @param {string | boolean} [beforeSpec='any'] before
   	     */


   	    function addTypes(types) {
   	      var beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
   	      var beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
   	      var newTypes = [];

   	      for (var i = 0; i < types.length; ++i) {
   	        if (!types[i] || typeof types[i].name !== 'string' || typeof types[i].test !== 'function') {
   	          throw new TypeError('Object with properties {name: string, test: function} expected');
   	        }

   	        var typeName = types[i].name;

   	        if (typeMap.has(typeName)) {
   	          throw new TypeError('Duplicate type name "' + typeName + '"');
   	        }

   	        newTypes.push(typeName);
   	        typeMap.set(typeName, {
   	          name: typeName,
   	          test: types[i].test,
   	          isAny: types[i].isAny,
   	          index: beforeIndex + i,
   	          conversionsTo: [] // Newly added type can't have any conversions to it

   	        });
   	      } // update the typeList


   	      var affectedTypes = typeList.slice(beforeIndex);
   	      typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes); // Fix the indices

   	      for (var _i = beforeIndex + newTypes.length; _i < typeList.length; ++_i) {
   	        typeMap.get(typeList[_i]).index = _i;
   	      }
   	    }
   	    /**
   	     * Removes all types and conversions from this typed instance.
   	     * May cause previously constructed typed-functions to throw
   	     * strange errors when they are called with types that do not
   	     * match any of their signatures.
   	     */


   	    function clear() {
   	      typeMap = new Map();
   	      typeList = [];
   	      nConversions = 0;
   	      addTypes([anyType], false);
   	    } // initialize the types to the default list


   	    clear();
   	    addTypes(_types);
   	    /**
   	     * Removes all conversions, leaving the types alone.
   	     */

   	    function clearConversions() {
   	      var typeName;

   	      var _iterator2 = _createForOfIteratorHelper(typeList),
   	          _step2;

   	      try {
   	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
   	          typeName = _step2.value;
   	          typeMap.get(typeName).conversionsTo = [];
   	        }
   	      } catch (err) {
   	        _iterator2.e(err);
   	      } finally {
   	        _iterator2.f();
   	      }

   	      nConversions = 0;
   	    }
   	    /**
   	     * Find the type names that match a value.
   	     * @param {*} value
   	     * @return {string[]} Array of names of types for which
   	     *                  the type test matches the value.
   	     */


   	    function findTypeNames(value) {
   	      var matches = typeList.filter(function (name) {
   	        var type = typeMap.get(name);
   	        return !type.isAny && type.test(value);
   	      });

   	      if (matches.length) {
   	        return matches;
   	      }

   	      return ['any'];
   	    }
   	    /**
   	     * Check if an entity is a typed function created by any instance
   	     * @param {any} entity
   	     * @returns {boolean}
   	     */


   	    function isTypedFunction(entity) {
   	      return entity && typeof entity === 'function' && '_typedFunctionData' in entity;
   	    }
   	    /**
   	     * Find a specific signature from a (composed) typed function, for example:
   	     *
   	     *   typed.findSignature(fn, ['number', 'string'])
   	     *   typed.findSignature(fn, 'number, string')
   	     *   typed.findSignature(fn, 'number,string', {exact: true})
   	     *
   	     * This function findSignature will by default return the best match to
   	     * the given signature, possibly employing type conversions.
   	     *
   	     * The (optional) third argument is a plain object giving options
   	     * controlling the signature search. Currently the only implemented
   	     * option is `exact`: if specified as true (default is false), only
   	     * exact matches will be returned (i.e. signatures for which `fn` was
   	     * directly defined). Note that a (possibly different) type matching
   	     * `any`, or one or more instances of TYPE matching `...TYPE` are
   	     * considered exact matches in this regard, as no conversions are used.
   	     *
   	     * This function returns a "signature" object, as does `typed.resolve()`,
   	     * which is a plain object with four keys: `params` (the array of parameters
   	     * for this signature), `fn` (the originally supplied function for this
   	     * signature), `test` (a generated function that determines if an argument
   	     * list matches this signature, and `implementation` (the function to call
   	     * on a matching argument list, that performs conversions if necessary and
   	     * then calls the originally supplied function).
   	     *
   	     * @param {Function} fn                   A typed-function
   	     * @param {string | string[]} signature
   	     *     Signature to be found, can be an array or a comma separated string.
   	     * @param {object} options  Controls the signature search as documented
   	     * @return {{ params: Param[], fn: function, test: function, implementation: function }}
   	     *     Returns the matching signature, or throws an error when no signature
   	     *     is found.
   	     */


   	    function findSignature(fn, signature, options) {
   	      if (!isTypedFunction(fn)) {
   	        throw new TypeError(NOT_TYPED_FUNCTION);
   	      } // Canonicalize input


   	      var exact = options && options.exact;
   	      var stringSignature = Array.isArray(signature) ? signature.join(',') : signature;
   	      var params = parseSignature(stringSignature);
   	      var canonicalSignature = stringifyParams(params); // First hope we get lucky and exactly match a signature

   	      if (!exact || canonicalSignature in fn.signatures) {
   	        // OK, we can check the internal signatures
   	        var match = fn._typedFunctionData.signatureMap.get(canonicalSignature);

   	        if (match) {
   	          return match;
   	        }
   	      } // Oh well, we did not; so we have to go back and check the parameters
   	      // one by one, in order to catch things like `any` and rest params.
   	      // Note here we can assume there is at least one parameter, because
   	      // the empty signature would have matched successfully above.


   	      var nParams = params.length;
   	      var remainingSignatures;

   	      if (exact) {
   	        remainingSignatures = [];
   	        var name;

   	        for (name in fn.signatures) {
   	          remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));
   	        }
   	      } else {
   	        remainingSignatures = fn._typedFunctionData.signatures;
   	      }

   	      for (var i = 0; i < nParams; ++i) {
   	        var want = params[i];
   	        var filteredSignatures = [];
   	        var possibility = void 0;

   	        var _iterator3 = _createForOfIteratorHelper(remainingSignatures),
   	            _step3;

   	        try {
   	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
   	            possibility = _step3.value;
   	            var have = getParamAtIndex(possibility.params, i);

   	            if (!have || want.restParam && !have.restParam) {
   	              continue;
   	            }

   	            if (!have.hasAny) {
   	              var _ret = function () {
   	                // have to check all of the wanted types are available
   	                var haveTypes = paramTypeSet(have);

   	                if (want.types.some(function (wtype) {
   	                  return !haveTypes.has(wtype.name);
   	                })) {
   	                  return "continue";
   	                }
   	              }();

   	              if (_ret === "continue") continue;
   	            } // OK, this looks good


   	            filteredSignatures.push(possibility);
   	          }
   	        } catch (err) {
   	          _iterator3.e(err);
   	        } finally {
   	          _iterator3.f();
   	        }

   	        remainingSignatures = filteredSignatures;
   	        if (remainingSignatures.length === 0) break;
   	      } // Return the first remaining signature that was totally matched:


   	      var candidate;

   	      var _iterator4 = _createForOfIteratorHelper(remainingSignatures),
   	          _step4;

   	      try {
   	        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
   	          candidate = _step4.value;

   	          if (candidate.params.length <= nParams) {
   	            return candidate;
   	          }
   	        }
   	      } catch (err) {
   	        _iterator4.e(err);
   	      } finally {
   	        _iterator4.f();
   	      }

   	      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))');
   	    }
   	    /**
   	     * Find the proper function to call for a specific signature from
   	     * a (composed) typed function, for example:
   	     *
   	     *   typed.find(fn, ['number', 'string'])
   	     *   typed.find(fn, 'number, string')
   	     *   typed.find(fn, 'number,string', {exact: true})
   	     *
   	     * This function find will by default return the best match to
   	     * the given signature, possibly employing type conversions (and returning
   	     * a function that will perform those conversions as needed). The
   	     * (optional) third argument is a plain object giving options contolling
   	     * the signature search. Currently only the option `exact` is implemented,
   	     * which defaults to "false". If `exact` is specified as true, then only
   	     * exact matches will be returned (i.e. signatures for which `fn` was
   	     * directly defined). Uses of `any` and `...TYPE` are considered exact if
   	     * no conversions are necessary to apply the corresponding function.
   	     *
   	     * @param {Function} fn                   A typed-function
   	     * @param {string | string[]} signature
   	     *     Signature to be found, can be an array or a comma separated string.
   	     * @param {object} options  Controls the signature match as documented
   	     * @return {function}
   	     *     Returns the function to call for the given signature, or throws an
   	     *     error if no match is found.
   	     */


   	    function find(fn, signature, options) {
   	      return findSignature(fn, signature, options).implementation;
   	    }
   	    /**
   	     * Convert a given value to another data type, specified by type name.
   	     *
   	     * @param {*} value
   	     * @param {string} typeName
   	     */


   	    function convert(value, typeName) {
   	      // check conversion is needed
   	      var type = findType(typeName);

   	      if (type.test(value)) {
   	        return value;
   	      }

   	      var conversions = type.conversionsTo;

   	      if (conversions.length === 0) {
   	        throw new Error('There are no conversions to ' + typeName + ' defined.');
   	      }

   	      for (var i = 0; i < conversions.length; i++) {
   	        var fromType = findType(conversions[i].from);

   	        if (fromType.test(value)) {
   	          return conversions[i].convert(value);
   	        }
   	      }

   	      throw new Error('Cannot convert ' + value + ' to ' + typeName);
   	    }
   	    /**
   	     * Stringify parameters in a normalized way
   	     * @param {Param[]} params
   	     * @param {string} [','] separator
   	     * @return {string}
   	     */


   	    function stringifyParams(params) {
   	      var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
   	      return params.map(function (p) {
   	        return p.name;
   	      }).join(separator);
   	    }
   	    /**
   	     * Parse a parameter, like "...number | boolean"
   	     * @param {string} param
   	     * @return {Param} param
   	     */


   	    function parseParam(param) {
   	      var restParam = param.indexOf('...') === 0;
   	      var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';
   	      var typeDefs = types.split('|').map(function (s) {
   	        return findType(s.trim());
   	      });
   	      var hasAny = false;
   	      var paramName = restParam ? '...' : '';
   	      var exactTypes = typeDefs.map(function (type) {
   	        hasAny = type.isAny || hasAny;
   	        paramName += type.name + '|';
   	        return {
   	          name: type.name,
   	          typeIndex: type.index,
   	          test: type.test,
   	          isAny: type.isAny,
   	          conversion: null,
   	          conversionIndex: -1
   	        };
   	      });
   	      return {
   	        types: exactTypes,
   	        name: paramName.slice(0, -1),
   	        // remove trailing '|' from above
   	        hasAny: hasAny,
   	        hasConversion: false,
   	        restParam: restParam
   	      };
   	    }
   	    /**
   	     * Expands a parsed parameter with the types available from currently
   	     * defined conversions.
   	     * @param {Param} param
   	     * @return {Param} param
   	     */


   	    function expandParam(param) {
   	      var typeNames = param.types.map(function (t) {
   	        return t.name;
   	      });
   	      var matchingConversions = availableConversions(typeNames);
   	      var hasAny = param.hasAny;
   	      var newName = param.name;
   	      var convertibleTypes = matchingConversions.map(function (conversion) {
   	        var type = findType(conversion.from);
   	        hasAny = type.isAny || hasAny;
   	        newName += '|' + conversion.from;
   	        return {
   	          name: conversion.from,
   	          typeIndex: type.index,
   	          test: type.test,
   	          isAny: type.isAny,
   	          conversion: conversion,
   	          conversionIndex: conversion.index
   	        };
   	      });
   	      return {
   	        types: param.types.concat(convertibleTypes),
   	        name: newName,
   	        hasAny: hasAny,
   	        hasConversion: convertibleTypes.length > 0,
   	        restParam: param.restParam
   	      };
   	    }
   	    /**
   	     * Return the set of type names in a parameter.
   	     * Caches the result for efficiency
   	     *
   	     * @param {Param} param
   	     * @return {Set<string>} typenames
   	     */


   	    function paramTypeSet(param) {
   	      if (!param.typeSet) {
   	        param.typeSet = new Set();
   	        param.types.forEach(function (type) {
   	          return param.typeSet.add(type.name);
   	        });
   	      }

   	      return param.typeSet;
   	    }
   	    /**
   	     * Parse a signature with comma separated parameters,
   	     * like "number | boolean, ...string"
   	     *
   	     * @param {string} signature
   	     * @return {Param[]} params
   	     */


   	    function parseSignature(rawSignature) {
   	      var params = [];

   	      if (typeof rawSignature !== 'string') {
   	        throw new TypeError('Signatures must be strings');
   	      }

   	      var signature = rawSignature.trim();

   	      if (signature === '') {
   	        return params;
   	      }

   	      var rawParams = signature.split(',');

   	      for (var i = 0; i < rawParams.length; ++i) {
   	        var parsedParam = parseParam(rawParams[i].trim());

   	        if (parsedParam.restParam && i !== rawParams.length - 1) {
   	          throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": ' + 'only allowed for the last parameter');
   	        } // if invalid, short-circuit (all the types may have been filtered)


   	        if (parsedParam.types.length === 0) {
   	          return null;
   	        }

   	        params.push(parsedParam);
   	      }

   	      return params;
   	    }
   	    /**
   	     * Test whether a set of params contains a restParam
   	     * @param {Param[]} params
   	     * @return {boolean} Returns true when the last parameter is a restParam
   	     */


   	    function hasRestParam(params) {
   	      var param = last(params);
   	      return param ? param.restParam : false;
   	    }
   	    /**
   	     * Create a type test for a single parameter, which can have one or multiple
   	     * types.
   	     * @param {Param} param
   	     * @return {function(x: *) : boolean} Returns a test function
   	     */


   	    function compileTest(param) {
   	      if (!param || param.types.length === 0) {
   	        // nothing to do
   	        return ok;
   	      } else if (param.types.length === 1) {
   	        return findType(param.types[0].name).test;
   	      } else if (param.types.length === 2) {
   	        var test0 = findType(param.types[0].name).test;
   	        var test1 = findType(param.types[1].name).test;
   	        return function or(x) {
   	          return test0(x) || test1(x);
   	        };
   	      } else {
   	        // param.types.length > 2
   	        var tests = param.types.map(function (type) {
   	          return findType(type.name).test;
   	        });
   	        return function or(x) {
   	          for (var i = 0; i < tests.length; i++) {
   	            if (tests[i](x)) {
   	              return true;
   	            }
   	          }

   	          return false;
   	        };
   	      }
   	    }
   	    /**
   	     * Create a test for all parameters of a signature
   	     * @param {Param[]} params
   	     * @return {function(args: Array<*>) : boolean}
   	     */


   	    function compileTests(params) {
   	      var tests, test0, test1;

   	      if (hasRestParam(params)) {
   	        // variable arguments like '...number'
   	        tests = initial(params).map(compileTest);
   	        var varIndex = tests.length;
   	        var lastTest = compileTest(last(params));

   	        var testRestParam = function testRestParam(args) {
   	          for (var i = varIndex; i < args.length; i++) {
   	            if (!lastTest(args[i])) {
   	              return false;
   	            }
   	          }

   	          return true;
   	        };

   	        return function testArgs(args) {
   	          for (var i = 0; i < tests.length; i++) {
   	            if (!tests[i](args[i])) {
   	              return false;
   	            }
   	          }

   	          return testRestParam(args) && args.length >= varIndex + 1;
   	        };
   	      } else {
   	        // no variable arguments
   	        if (params.length === 0) {
   	          return function testArgs(args) {
   	            return args.length === 0;
   	          };
   	        } else if (params.length === 1) {
   	          test0 = compileTest(params[0]);
   	          return function testArgs(args) {
   	            return test0(args[0]) && args.length === 1;
   	          };
   	        } else if (params.length === 2) {
   	          test0 = compileTest(params[0]);
   	          test1 = compileTest(params[1]);
   	          return function testArgs(args) {
   	            return test0(args[0]) && test1(args[1]) && args.length === 2;
   	          };
   	        } else {
   	          // arguments.length > 2
   	          tests = params.map(compileTest);
   	          return function testArgs(args) {
   	            for (var i = 0; i < tests.length; i++) {
   	              if (!tests[i](args[i])) {
   	                return false;
   	              }
   	            }

   	            return args.length === tests.length;
   	          };
   	        }
   	      }
   	    }
   	    /**
   	     * Find the parameter at a specific index of a Params list.
   	     * Handles rest parameters.
   	     * @param {Param[]} params
   	     * @param {number} index
   	     * @return {Param | null} Returns the matching parameter when found,
   	     *                        null otherwise.
   	     */


   	    function getParamAtIndex(params, index) {
   	      return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
   	    }
   	    /**
   	     * Get all type names of a parameter
   	     * @param {Params[]} params
   	     * @param {number} index
   	     * @return {string[]} Returns an array with type names
   	     */


   	    function getTypeSetAtIndex(params, index) {
   	      var param = getParamAtIndex(params, index);

   	      if (!param) {
   	        return new Set();
   	      }

   	      return paramTypeSet(param);
   	    }
   	    /**
   	     * Test whether a type is an exact type or conversion
   	     * @param {Type} type
   	     * @return {boolean} Returns true when
   	     */


   	    function isExactType(type) {
   	      return type.conversion === null || type.conversion === undefined;
   	    }
   	    /**
   	     * Helper function for creating error messages: create an array with
   	     * all available types on a specific argument index.
   	     * @param {Signature[]} signatures
   	     * @param {number} index
   	     * @return {string[]} Returns an array with available types
   	     */


   	    function mergeExpectedParams(signatures, index) {
   	      var typeSet = new Set();
   	      signatures.forEach(function (signature) {
   	        var paramSet = getTypeSetAtIndex(signature.params, index);
   	        var name;

   	        var _iterator5 = _createForOfIteratorHelper(paramSet),
   	            _step5;

   	        try {
   	          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
   	            name = _step5.value;
   	            typeSet.add(name);
   	          }
   	        } catch (err) {
   	          _iterator5.e(err);
   	        } finally {
   	          _iterator5.f();
   	        }
   	      });
   	      return typeSet.has('any') ? ['any'] : Array.from(typeSet);
   	    }
   	    /**
   	     * Create
   	     * @param {string} name             The name of the function
   	     * @param {array.<*>} args          The actual arguments passed to the function
   	     * @param {Signature[]} signatures  A list with available signatures
   	     * @return {TypeError} Returns a type error with additional data
   	     *                     attached to it in the property `data`
   	     */


   	    function createError(name, args, signatures) {
   	      var err, expected;

   	      var _name = name || 'unnamed'; // test for wrong type at some index


   	      var matchingSignatures = signatures;
   	      var index;

   	      var _loop = function _loop() {
   	        var nextMatchingDefs = [];
   	        matchingSignatures.forEach(function (signature) {
   	          var param = getParamAtIndex(signature.params, index);
   	          var test = compileTest(param);

   	          if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
   	            nextMatchingDefs.push(signature);
   	          }
   	        });

   	        if (nextMatchingDefs.length === 0) {
   	          // no matching signatures anymore, throw error "wrong type"
   	          expected = mergeExpectedParams(matchingSignatures, index);

   	          if (expected.length > 0) {
   	            var actualTypes = findTypeNames(args[index]);
   	            err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualTypes.join(' | ') + ', index: ' + index + ')');
   	            err.data = {
   	              category: 'wrongType',
   	              fn: _name,
   	              index: index,
   	              actual: actualTypes,
   	              expected: expected
   	            };
   	            return {
   	              v: err
   	            };
   	          }
   	        } else {
   	          matchingSignatures = nextMatchingDefs;
   	        }
   	      };

   	      for (index = 0; index < args.length; index++) {
   	        var _ret2 = _loop();

   	        if (_typeof(_ret2) === "object") return _ret2.v;
   	      } // test for too few arguments


   	      var lengths = matchingSignatures.map(function (signature) {
   	        return hasRestParam(signature.params) ? Infinity : signature.params.length;
   	      });

   	      if (args.length < Math.min.apply(null, lengths)) {
   	        expected = mergeExpectedParams(matchingSignatures, index);
   	        err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');
   	        err.data = {
   	          category: 'tooFewArgs',
   	          fn: _name,
   	          index: args.length,
   	          expected: expected
   	        };
   	        return err;
   	      } // test for too many arguments


   	      var maxLength = Math.max.apply(null, lengths);

   	      if (args.length > maxLength) {
   	        err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
   	        err.data = {
   	          category: 'tooManyArgs',
   	          fn: _name,
   	          index: args.length,
   	          expectedLength: maxLength
   	        };
   	        return err;
   	      } // Generic error


   	      var argTypes = [];

   	      for (var i = 0; i < args.length; ++i) {
   	        argTypes.push(findTypeNames(args[i]).join('|'));
   	      }

   	      err = new TypeError('Arguments of type "' + argTypes.join(', ') + '" do not match any of the defined signatures of function ' + _name + '.');
   	      err.data = {
   	        category: 'mismatch',
   	        actual: argTypes
   	      };
   	      return err;
   	    }
   	    /**
   	     * Find the lowest index of all exact types of a parameter (no conversions)
   	     * @param {Param} param
   	     * @return {number} Returns the index of the lowest type in typed.types
   	     */


   	    function getLowestTypeIndex(param) {
   	      var min = typeList.length + 1;

   	      for (var i = 0; i < param.types.length; i++) {
   	        if (isExactType(param.types[i])) {
   	          min = Math.min(min, param.types[i].typeIndex);
   	        }
   	      }

   	      return min;
   	    }
   	    /**
   	     * Find the lowest index of the conversion of all types of the parameter
   	     * having a conversion
   	     * @param {Param} param
   	     * @return {number} Returns the lowest index of the conversions of this type
   	     */


   	    function getLowestConversionIndex(param) {
   	      var min = nConversions + 1;

   	      for (var i = 0; i < param.types.length; i++) {
   	        if (!isExactType(param.types[i])) {
   	          min = Math.min(min, param.types[i].conversionIndex);
   	        }
   	      }

   	      return min;
   	    }
   	    /**
   	     * Compare two params
   	     * @param {Param} param1
   	     * @param {Param} param2
   	     * @return {number} returns -1 when param1 must get a lower
   	     *                  index than param2, 1 when the opposite,
   	     *                  or zero when both are equal
   	     */


   	    function compareParams(param1, param2) {
   	      // We compare a number of metrics on a param in turn:
   	      // 1) 'any' parameters are the least preferred
   	      if (param1.hasAny) {
   	        if (!param2.hasAny) {
   	          return 1;
   	        }
   	      } else if (param2.hasAny) {
   	        return -1;
   	      } // 2) Prefer non-rest to rest parameters


   	      if (param1.restParam) {
   	        if (!param2.restParam) {
   	          return 1;
   	        }
   	      } else if (param2.restParam) {
   	        return -1;
   	      } // 3) Prefer exact type match to conversions


   	      if (param1.hasConversion) {
   	        if (!param2.hasConversion) {
   	          return 1;
   	        }
   	      } else if (param2.hasConversion) {
   	        return -1;
   	      } // 4) Prefer lower type index:


   	      var typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);

   	      if (typeDiff < 0) {
   	        return -1;
   	      }

   	      if (typeDiff > 0) {
   	        return 1;
   	      } // 5) Prefer lower conversion index


   	      var convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);

   	      if (convDiff < 0) {
   	        return -1;
   	      }

   	      if (convDiff > 0) {
   	        return 1;
   	      } // Don't have a basis for preference


   	      return 0;
   	    }
   	    /**
   	     * Compare two signatures
   	     * @param {Signature} signature1
   	     * @param {Signature} signature2
   	     * @return {number} returns a negative number when param1 must get a lower
   	     *                  index than param2, a positive number when the opposite,
   	     *                  or zero when both are equal
   	     */


   	    function compareSignatures(signature1, signature2) {
   	      var pars1 = signature1.params;
   	      var pars2 = signature2.params;
   	      var last1 = last(pars1);
   	      var last2 = last(pars2);
   	      var hasRest1 = hasRestParam(pars1);
   	      var hasRest2 = hasRestParam(pars2); // We compare a number of metrics on signatures in turn:
   	      // 1) An "any rest param" is least preferred

   	      if (hasRest1 && last1.hasAny) {
   	        if (!hasRest2 || !last2.hasAny) {
   	          return 1;
   	        }
   	      } else if (hasRest2 && last2.hasAny) {
   	        return -1;
   	      } // 2) Minimize the number of 'any' parameters


   	      var any1 = 0;
   	      var conv1 = 0;
   	      var par;

   	      var _iterator6 = _createForOfIteratorHelper(pars1),
   	          _step6;

   	      try {
   	        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
   	          par = _step6.value;
   	          if (par.hasAny) ++any1;
   	          if (par.hasConversion) ++conv1;
   	        }
   	      } catch (err) {
   	        _iterator6.e(err);
   	      } finally {
   	        _iterator6.f();
   	      }

   	      var any2 = 0;
   	      var conv2 = 0;

   	      var _iterator7 = _createForOfIteratorHelper(pars2),
   	          _step7;

   	      try {
   	        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
   	          par = _step7.value;
   	          if (par.hasAny) ++any2;
   	          if (par.hasConversion) ++conv2;
   	        }
   	      } catch (err) {
   	        _iterator7.e(err);
   	      } finally {
   	        _iterator7.f();
   	      }

   	      if (any1 !== any2) {
   	        return any1 - any2;
   	      } // 3) A conversion rest param is less preferred


   	      if (hasRest1 && last1.hasConversion) {
   	        if (!hasRest2 || !last2.hasConversion) {
   	          return 1;
   	        }
   	      } else if (hasRest2 && last2.hasConversion) {
   	        return -1;
   	      } // 4) Minimize the number of conversions


   	      if (conv1 !== conv2) {
   	        return conv1 - conv2;
   	      } // 5) Prefer no rest param


   	      if (hasRest1) {
   	        if (!hasRest2) {
   	          return 1;
   	        }
   	      } else if (hasRest2) {
   	        return -1;
   	      } // 6) Prefer shorter with rest param, longer without


   	      var lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);

   	      if (lengthCriterion !== 0) {
   	        return lengthCriterion;
   	      } // Signatures are identical in each of the above metrics.
   	      // In particular, they are the same length.
   	      // We can therefore compare the parameters one by one.
   	      // First we count which signature has more preferred parameters.


   	      var comparisons = [];
   	      var tc = 0;

   	      for (var i = 0; i < pars1.length; ++i) {
   	        var thisComparison = compareParams(pars1[i], pars2[i]);
   	        comparisons.push(thisComparison);
   	        tc += thisComparison;
   	      }

   	      if (tc !== 0) {
   	        return tc;
   	      } // They have the same number of preferred parameters, so go by the
   	      // earliest parameter in which we have a preference.
   	      // In other words, dispatch is driven somewhat more by earlier
   	      // parameters than later ones.


   	      var c;

   	      for (var _i2 = 0, _comparisons = comparisons; _i2 < _comparisons.length; _i2++) {
   	        c = _comparisons[_i2];

   	        if (c !== 0) {
   	          return c;
   	        }
   	      } // It's a tossup:


   	      return 0;
   	    }
   	    /**
   	     * Produce a list of all conversions from distinct types to one of
   	     * the given types.
   	     *
   	     * @param {string[]} typeNames
   	     * @return {ConversionDef[]} Returns the conversions that are available
   	     *                        resulting in any given type (if any)
   	     */


   	    function availableConversions(typeNames) {
   	      if (typeNames.length === 0) {
   	        return [];
   	      }

   	      var types = typeNames.map(findType);

   	      if (typeNames.length > 1) {
   	        types.sort(function (t1, t2) {
   	          return t1.index - t2.index;
   	        });
   	      }

   	      var matches = types[0].conversionsTo;

   	      if (typeNames.length === 1) {
   	        return matches;
   	      }

   	      matches = matches.concat([]); // shallow copy the matches
   	      // Since the types are now in index order, we just want the first
   	      // occurrence of any from type:

   	      var knownTypes = new Set(typeNames);

   	      for (var i = 1; i < types.length; ++i) {
   	        var newMatch = void 0;

   	        var _iterator8 = _createForOfIteratorHelper(types[i].conversionsTo),
   	            _step8;

   	        try {
   	          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
   	            newMatch = _step8.value;

   	            if (!knownTypes.has(newMatch.from)) {
   	              matches.push(newMatch);
   	              knownTypes.add(newMatch.from);
   	            }
   	          }
   	        } catch (err) {
   	          _iterator8.e(err);
   	        } finally {
   	          _iterator8.f();
   	        }
   	      }

   	      return matches;
   	    }
   	    /**
   	     * Preprocess arguments before calling the original function:
   	     * - if needed convert the parameters
   	     * - in case of rest parameters, move the rest parameters into an Array
   	     * @param {Param[]} params
   	     * @param {function} fn
   	     * @return {function} Returns a wrapped function
   	     */


   	    function compileArgsPreprocessing(params, fn) {
   	      var fnConvert = fn; // TODO: can we make this wrapper function smarter/simpler?

   	      if (params.some(function (p) {
   	        return p.hasConversion;
   	      })) {
   	        var restParam = hasRestParam(params);
   	        var compiledConversions = params.map(compileArgConversion);

   	        fnConvert = function convertArgs() {
   	          var args = [];
   	          var last = restParam ? arguments.length - 1 : arguments.length;

   	          for (var i = 0; i < last; i++) {
   	            args[i] = compiledConversions[i](arguments[i]);
   	          }

   	          if (restParam) {
   	            args[last] = arguments[last].map(compiledConversions[last]);
   	          }

   	          return fn.apply(this, args);
   	        };
   	      }

   	      var fnPreprocess = fnConvert;

   	      if (hasRestParam(params)) {
   	        var offset = params.length - 1;

   	        fnPreprocess = function preprocessRestParams() {
   	          return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
   	        };
   	      }

   	      return fnPreprocess;
   	    }
   	    /**
   	     * Compile conversion for a parameter to the right type
   	     * @param {Param} param
   	     * @return {function} Returns the wrapped function that will convert arguments
   	     *
   	     */


   	    function compileArgConversion(param) {
   	      var test0, test1, conversion0, conversion1;
   	      var tests = [];
   	      var conversions = [];
   	      param.types.forEach(function (type) {
   	        if (type.conversion) {
   	          tests.push(findType(type.conversion.from).test);
   	          conversions.push(type.conversion.convert);
   	        }
   	      }); // create optimized conversion functions depending on the number of conversions

   	      switch (conversions.length) {
   	        case 0:
   	          return function convertArg(arg) {
   	            return arg;
   	          };

   	        case 1:
   	          test0 = tests[0];
   	          conversion0 = conversions[0];
   	          return function convertArg(arg) {
   	            if (test0(arg)) {
   	              return conversion0(arg);
   	            }

   	            return arg;
   	          };

   	        case 2:
   	          test0 = tests[0];
   	          test1 = tests[1];
   	          conversion0 = conversions[0];
   	          conversion1 = conversions[1];
   	          return function convertArg(arg) {
   	            if (test0(arg)) {
   	              return conversion0(arg);
   	            }

   	            if (test1(arg)) {
   	              return conversion1(arg);
   	            }

   	            return arg;
   	          };

   	        default:
   	          return function convertArg(arg) {
   	            for (var i = 0; i < conversions.length; i++) {
   	              if (tests[i](arg)) {
   	                return conversions[i](arg);
   	              }
   	            }

   	            return arg;
   	          };
   	      }
   	    }
   	    /**
   	     * Split params with union types in to separate params.
   	     *
   	     * For example:
   	     *
   	     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
   	     *     // returns:
   	     *     // [
   	     *     //   ['Array', 'string'],
   	     *     //   ['Array', 'RegExp'],
   	     *     //   ['Object', 'string'],
   	     *     //   ['Object', 'RegExp']
   	     *     // ]
   	     *
   	     * @param {Param[]} params
   	     * @return {Param[]}
   	     */


   	    function splitParams(params) {
   	      function _splitParams(params, index, paramsSoFar) {
   	        if (index < params.length) {
   	          var param = params[index];
   	          var resultingParams = [];

   	          if (param.restParam) {
   	            // split the types of a rest parameter in two:
   	            // one with only exact types, and one with exact types and conversions
   	            var exactTypes = param.types.filter(isExactType);

   	            if (exactTypes.length < param.types.length) {
   	              resultingParams.push({
   	                types: exactTypes,
   	                name: '...' + exactTypes.map(function (t) {
   	                  return t.name;
   	                }).join('|'),
   	                hasAny: exactTypes.some(function (t) {
   	                  return t.isAny;
   	                }),
   	                hasConversion: false,
   	                restParam: true
   	              });
   	            }

   	            resultingParams.push(param);
   	          } else {
   	            // split all the types of a regular parameter into one type per param
   	            resultingParams = param.types.map(function (type) {
   	              return {
   	                types: [type],
   	                name: type.name,
   	                hasAny: type.isAny,
   	                hasConversion: type.conversion,
   	                restParam: false
   	              };
   	            });
   	          } // recurse over the groups with types


   	          return flatMap(resultingParams, function (nextParam) {
   	            return _splitParams(params, index + 1, paramsSoFar.concat([nextParam]));
   	          });
   	        } else {
   	          // we've reached the end of the parameters.
   	          return [paramsSoFar];
   	        }
   	      }

   	      return _splitParams(params, 0, []);
   	    }
   	    /**
   	     * Test whether two param lists represent conflicting signatures
   	     * @param {Param[]} params1
   	     * @param {Param[]} params2
   	     * @return {boolean} Returns true when the signatures conflict, false otherwise.
   	     */


   	    function conflicting(params1, params2) {
   	      var ii = Math.max(params1.length, params2.length);

   	      for (var i = 0; i < ii; i++) {
   	        var typeSet1 = getTypeSetAtIndex(params1, i);
   	        var typeSet2 = getTypeSetAtIndex(params2, i);
   	        var overlap = false;
   	        var name = void 0;

   	        var _iterator9 = _createForOfIteratorHelper(typeSet2),
   	            _step9;

   	        try {
   	          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
   	            name = _step9.value;

   	            if (typeSet1.has(name)) {
   	              overlap = true;
   	              break;
   	            }
   	          }
   	        } catch (err) {
   	          _iterator9.e(err);
   	        } finally {
   	          _iterator9.f();
   	        }

   	        if (!overlap) {
   	          return false;
   	        }
   	      }

   	      var len1 = params1.length;
   	      var len2 = params2.length;
   	      var restParam1 = hasRestParam(params1);
   	      var restParam2 = hasRestParam(params2);
   	      return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
   	    }
   	    /**
   	     * Helper function for `resolveReferences` that returns a copy of
   	     * functionList wihe any prior resolutions cleared out, in case we are
   	     * recycling signatures from a prior typed function construction.
   	     *
   	     * @param {Array.<function|typed-reference>} functionList
   	     * @return {Array.<function|typed-reference>}
   	     */


   	    function clearResolutions(functionList) {
   	      return functionList.map(function (fn) {
   	        if (isReferToSelf(fn)) {
   	          return referToSelf(fn.referToSelf.callback);
   	        }

   	        if (isReferTo(fn)) {
   	          return makeReferTo(fn.referTo.references, fn.referTo.callback);
   	        }

   	        return fn;
   	      });
   	    }
   	    /**
   	     * Take a list of references, a list of functions functionList, and a
   	     * signatureMap indexing signatures into functionList, and return
   	     * the list of resolutions, or a false-y value if they don't all
   	     * resolve in a valid way (yet).
   	     *
   	     * @param {string[]} references
   	     * @param {Array<function|typed-reference} functionList
   	     * @param {Object.<string, integer>} signatureMap
   	     * @return {function[] | false} resolutions
   	     */


   	    function collectResolutions(references, functionList, signatureMap) {
   	      var resolvedReferences = [];
   	      var reference;

   	      var _iterator10 = _createForOfIteratorHelper(references),
   	          _step10;

   	      try {
   	        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
   	          reference = _step10.value;
   	          var resolution = signatureMap[reference];

   	          if (typeof resolution !== 'number') {
   	            throw new TypeError('No definition for referenced signature "' + reference + '"');
   	          }

   	          resolution = functionList[resolution];

   	          if (typeof resolution !== 'function') {
   	            return false;
   	          }

   	          resolvedReferences.push(resolution);
   	        }
   	      } catch (err) {
   	        _iterator10.e(err);
   	      } finally {
   	        _iterator10.f();
   	      }

   	      return resolvedReferences;
   	    }
   	    /**
   	     * Resolve any references in the functionList for the typed function
   	     * itself. The signatureMap tells which index in the functionList a
   	     * given signature should be mapped to (for use in resolving typed.referTo)
   	     * and self provides the destions of a typed.referToSelf.
   	     *
   	     * @param {Array<function | typed-reference-object>} functionList
   	     * @param {Object.<string, function>} signatureMap
   	     * @param {function} self  The typed-function itself
   	     * @return {Array<function>} The list of resolved functions
   	     */


   	    function resolveReferences(functionList, signatureMap, self) {
   	      var resolvedFunctions = clearResolutions(functionList);
   	      var isResolved = new Array(resolvedFunctions.length).fill(false);
   	      var leftUnresolved = true;

   	      while (leftUnresolved) {
   	        leftUnresolved = false;
   	        var nothingResolved = true;

   	        for (var i = 0; i < resolvedFunctions.length; ++i) {
   	          if (isResolved[i]) continue;
   	          var fn = resolvedFunctions[i];

   	          if (isReferToSelf(fn)) {
   	            resolvedFunctions[i] = fn.referToSelf.callback(self); // Preserve reference in case signature is reused someday:

   	            resolvedFunctions[i].referToSelf = fn.referToSelf;
   	            isResolved[i] = true;
   	            nothingResolved = false;
   	          } else if (isReferTo(fn)) {
   	            var resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);

   	            if (resolvedReferences) {
   	              resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences); // Preserve reference in case signature is reused someday:

   	              resolvedFunctions[i].referTo = fn.referTo;
   	              isResolved[i] = true;
   	              nothingResolved = false;
   	            } else {
   	              leftUnresolved = true;
   	            }
   	          }
   	        }

   	        if (nothingResolved && leftUnresolved) {
   	          throw new SyntaxError('Circular reference detected in resolving typed.referTo');
   	        }
   	      }

   	      return resolvedFunctions;
   	    }
   	    /**
   	     * Validate whether any of the function bodies contains a self-reference
   	     * usage like `this(...)` or `this.signatures`. This self-referencing is
   	     * deprecated since typed-function v3. It has been replaced with
   	     * the functions typed.referTo and typed.referToSelf.
   	     * @param {Object.<string, function>} signaturesMap
   	     */


   	    function validateDeprecatedThis(signaturesMap) {
   	      // TODO: remove this deprecation warning logic some day (it's introduced in v3)
   	      // match occurrences like 'this(' and 'this.signatures'
   	      var deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
   	      Object.keys(signaturesMap).forEach(function (signature) {
   	        var fn = signaturesMap[signature];

   	        if (deprecatedThisRegex.test(fn.toString())) {
   	          throw new SyntaxError('Using `this` to self-reference a function ' + 'is deprecated since typed-function@3. ' + 'Use typed.referTo and typed.referToSelf instead.');
   	        }
   	      });
   	    }
   	    /**
   	     * Create a typed function
   	     * @param {String} name               The name for the typed function
   	     * @param {Object.<string, function>} rawSignaturesMap
   	     *                                    An object with one or
   	     *                                    multiple signatures as key, and the
   	     *                                    function corresponding to the
   	     *                                    signature as value.
   	     * @return {function}  Returns the created typed function.
   	     */


   	    function createTypedFunction(name, rawSignaturesMap) {
   	      typed.createCount++;

   	      if (Object.keys(rawSignaturesMap).length === 0) {
   	        throw new SyntaxError('No signatures provided');
   	      }

   	      if (typed.warnAgainstDeprecatedThis) {
   	        validateDeprecatedThis(rawSignaturesMap);
   	      } // Main processing loop for signatures


   	      var parsedParams = [];
   	      var originalFunctions = [];
   	      var signaturesMap = {};
   	      var preliminarySignatures = []; // may have duplicates from conversions

   	      var signature;

   	      var _loop2 = function _loop2() {
   	        // A) Protect against polluted Object prototype:
   	        if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
   	          return "continue";
   	        } // B) Parse the signature


   	        var params = parseSignature(signature);
   	        if (!params) return "continue"; // C) Check for conflicts

   	        parsedParams.forEach(function (pp) {
   	          if (conflicting(pp, params)) {
   	            throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
   	          }
   	        });
   	        parsedParams.push(params); // D) Store the provided function and add conversions

   	        var functionIndex = originalFunctions.length;
   	        originalFunctions.push(rawSignaturesMap[signature]);
   	        var conversionParams = params.map(expandParam); // E) Split the signatures and collect them up

   	        var sp = void 0;

   	        var _iterator11 = _createForOfIteratorHelper(splitParams(conversionParams)),
   	            _step11;

   	        try {
   	          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
   	            sp = _step11.value;
   	            var spName = stringifyParams(sp);
   	            preliminarySignatures.push({
   	              params: sp,
   	              name: spName,
   	              fn: functionIndex
   	            });

   	            if (sp.every(function (p) {
   	              return !p.hasConversion;
   	            })) {
   	              signaturesMap[spName] = functionIndex;
   	            }
   	          }
   	        } catch (err) {
   	          _iterator11.e(err);
   	        } finally {
   	          _iterator11.f();
   	        }
   	      };

   	      for (signature in rawSignaturesMap) {
   	        var _ret3 = _loop2();

   	        if (_ret3 === "continue") continue;
   	      }

   	      preliminarySignatures.sort(compareSignatures); // Note the forward reference to theTypedFn

   	      var resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn); // Fill in the proper function for each signature

   	      var s;

   	      for (s in signaturesMap) {
   	        if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
   	          signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
   	        }
   	      }

   	      var signatures = [];
   	      var internalSignatureMap = new Map(); // benchmarks faster than object

   	      for (var _i3 = 0, _preliminarySignature = preliminarySignatures; _i3 < _preliminarySignature.length; _i3++) {
   	        s = _preliminarySignature[_i3];

   	        // Note it's only safe to eliminate duplicates like this
   	        // _after_ the signature sorting step above; otherwise we might
   	        // remove the wrong one.
   	        if (!internalSignatureMap.has(s.name)) {
   	          s.fn = resolvedFunctions[s.fn];
   	          signatures.push(s);
   	          internalSignatureMap.set(s.name, s);
   	        }
   	      } // we create a highly optimized checks for the first couple of signatures with max 2 arguments


   	      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
   	      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
   	      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
   	      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
   	      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
   	      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
   	      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5; // compile the tests

   	      for (var i = 0; i < signatures.length; ++i) {
   	        signatures[i].test = compileTests(signatures[i].params);
   	      }

   	      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
   	      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
   	      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
   	      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
   	      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
   	      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
   	      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
   	      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
   	      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
   	      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
   	      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
   	      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk; // compile the functions

   	      for (var _i4 = 0; _i4 < signatures.length; ++_i4) {
   	        signatures[_i4].implementation = compileArgsPreprocessing(signatures[_i4].params, signatures[_i4].fn);
   	      }

   	      var fn0 = ok0 ? signatures[0].implementation : undef;
   	      var fn1 = ok1 ? signatures[1].implementation : undef;
   	      var fn2 = ok2 ? signatures[2].implementation : undef;
   	      var fn3 = ok3 ? signatures[3].implementation : undef;
   	      var fn4 = ok4 ? signatures[4].implementation : undef;
   	      var fn5 = ok5 ? signatures[5].implementation : undef;
   	      var len0 = ok0 ? signatures[0].params.length : -1;
   	      var len1 = ok1 ? signatures[1].params.length : -1;
   	      var len2 = ok2 ? signatures[2].params.length : -1;
   	      var len3 = ok3 ? signatures[3].params.length : -1;
   	      var len4 = ok4 ? signatures[4].params.length : -1;
   	      var len5 = ok5 ? signatures[5].params.length : -1; // simple and generic, but also slow

   	      var iStart = allOk ? 6 : 0;
   	      var iEnd = signatures.length; // de-reference ahead for execution speed:

   	      var tests = signatures.map(function (s) {
   	        return s.test;
   	      });
   	      var fns = signatures.map(function (s) {
   	        return s.implementation;
   	      });

   	      var generic = function generic() {

   	        for (var _i5 = iStart; _i5 < iEnd; _i5++) {
   	          if (tests[_i5](arguments)) {
   	            return fns[_i5].apply(this, arguments);
   	          }
   	        }

   	        return typed.onMismatch(name, arguments, signatures);
   	      }; // create the typed function
   	      // fast, specialized version. Falls back to the slower, generic one if needed


   	      function theTypedFn(arg0, arg1) {

   	        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
   	          return fn0.apply(this, arguments);
   	        }

   	        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
   	          return fn1.apply(this, arguments);
   	        }

   	        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
   	          return fn2.apply(this, arguments);
   	        }

   	        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
   	          return fn3.apply(this, arguments);
   	        }

   	        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
   	          return fn4.apply(this, arguments);
   	        }

   	        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
   	          return fn5.apply(this, arguments);
   	        }

   	        return generic.apply(this, arguments);
   	      } // attach name the typed function


   	      try {
   	        Object.defineProperty(theTypedFn, 'name', {
   	          value: name
   	        });
   	      } catch (err) {// old browsers do not support Object.defineProperty and some don't support setting the name property
   	        // the function name is not essential for the functioning, it's mostly useful for debugging,
   	        // so it's fine to have unnamed functions.
   	      } // attach signatures to the function.
   	      // This property is close to the original collection of signatures
   	      // used to create the typed-function, just with unions split:


   	      theTypedFn.signatures = signaturesMap; // Store internal data for functions like resolve, find, etc.
   	      // Also serves as the flag that this is a typed-function

   	      theTypedFn._typedFunctionData = {
   	        signatures: signatures,
   	        signatureMap: internalSignatureMap
   	      };
   	      return theTypedFn;
   	    }
   	    /**
   	     * Action to take on mismatch
   	     * @param {string} name      Name of function that was attempted to be called
   	     * @param {Array} args       Actual arguments to the call
   	     * @param {Array} signatures Known signatures of the named typed-function
   	     */


   	    function _onMismatch(name, args, signatures) {
   	      throw createError(name, args, signatures);
   	    }
   	    /**
   	     * Return all but the last items of an array or function Arguments
   	     * @param {Array | Arguments} arr
   	     * @return {Array}
   	     */


   	    function initial(arr) {
   	      return slice(arr, 0, arr.length - 1);
   	    }
   	    /**
   	     * return the last item of an array or function Arguments
   	     * @param {Array | Arguments} arr
   	     * @return {*}
   	     */


   	    function last(arr) {
   	      return arr[arr.length - 1];
   	    }
   	    /**
   	     * Slice an array or function Arguments
   	     * @param {Array | Arguments | IArguments} arr
   	     * @param {number} start
   	     * @param {number} [end]
   	     * @return {Array}
   	     */


   	    function slice(arr, start, end) {
   	      return Array.prototype.slice.call(arr, start, end);
   	    }
   	    /**
   	     * Return the first item from an array for which test(arr[i]) returns true
   	     * @param {Array} arr
   	     * @param {function} test
   	     * @return {* | undefined} Returns the first matching item
   	     *                         or undefined when there is no match
   	     */


   	    function findInArray(arr, test) {
   	      for (var i = 0; i < arr.length; i++) {
   	        if (test(arr[i])) {
   	          return arr[i];
   	        }
   	      }

   	      return undefined;
   	    }
   	    /**
   	     * Flat map the result invoking a callback for every item in an array.
   	     * https://gist.github.com/samgiles/762ee337dff48623e729
   	     * @param {Array} arr
   	     * @param {function} callback
   	     * @return {Array}
   	     */


   	    function flatMap(arr, callback) {
   	      return Array.prototype.concat.apply([], arr.map(callback));
   	    }
   	    /**
   	     * Create a reference callback to one or multiple signatures
   	     *
   	     * Syntax:
   	     *
   	     *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {
   	     *       // ...
   	     *     })
   	     *
   	     * @returns {{referTo: {references: string[], callback}}}
   	     */


   	    function referTo() {
   	      var references = initial(arguments).map(function (s) {
   	        return stringifyParams(parseSignature(s));
   	      });
   	      var callback = last(arguments);

   	      if (typeof callback !== 'function') {
   	        throw new TypeError('Callback function expected as last argument');
   	      }

   	      return makeReferTo(references, callback);
   	    }

   	    function makeReferTo(references, callback) {
   	      return {
   	        referTo: {
   	          references: references,
   	          callback: callback
   	        }
   	      };
   	    }
   	    /**
   	     * Create a reference callback to the typed-function itself
   	     *
   	     * @param {(self: function) => function} callback
   	     * @returns {{referToSelf: { callback: function }}}
   	     */


   	    function referToSelf(callback) {
   	      if (typeof callback !== 'function') {
   	        throw new TypeError('Callback function expected as first argument');
   	      }

   	      return {
   	        referToSelf: {
   	          callback: callback
   	        }
   	      };
   	    }
   	    /**
   	     * Test whether something is a referTo object, holding a list with reference
   	     * signatures and a callback.
   	     *
   	     * @param {Object | function} objectOrFn
   	     * @returns {boolean}
   	     */


   	    function isReferTo(objectOrFn) {
   	      return objectOrFn && _typeof(objectOrFn.referTo) === 'object' && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === 'function';
   	    }
   	    /**
   	     * Test whether something is a referToSelf object, holding a callback where
   	     * to pass `self`.
   	     *
   	     * @param {Object | function} objectOrFn
   	     * @returns {boolean}
   	     */


   	    function isReferToSelf(objectOrFn) {
   	      return objectOrFn && _typeof(objectOrFn.referToSelf) === 'object' && typeof objectOrFn.referToSelf.callback === 'function';
   	    }
   	    /**
   	     * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw
   	     * an error in case (C).
   	     *
   	     * @param { string | undefined } nameSoFar
   	     * @param { string | undefined } newName
   	     * @returns { string } updated name
   	     */


   	    function checkName(nameSoFar, newName) {
   	      if (!nameSoFar) {
   	        return newName;
   	      }

   	      if (newName && newName !== nameSoFar) {
   	        var err = new Error('Function names do not match (expected: ' + nameSoFar + ', actual: ' + newName + ')');
   	        err.data = {
   	          actual: newName,
   	          expected: nameSoFar
   	        };
   	        throw err;
   	      }

   	      return nameSoFar;
   	    }
   	    /**
   	     * Retrieve the implied name from an object with signature keys
   	     * and function values, checking whether all value names match
   	     *
   	     * @param { {string: function} } obj
   	     */


   	    function getObjectName(obj) {
   	      var name;

   	      for (var key in obj) {
   	        // Only pay attention to own properties, and only if their values
   	        // are typed functions or functions with a signature property
   	        if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === 'string')) {
   	          name = checkName(name, obj[key].name);
   	        }
   	      }

   	      return name;
   	    }
   	    /**
   	     * Copy all of the signatures from the second argument into the first,
   	     * which is modified by side effect, checking for conflicts
   	     *
   	     * @param {Object.<string, function|typed-reference>} dest
   	     * @param {Object.<string, function|typed-reference>} source
   	     */


   	    function mergeSignatures(dest, source) {
   	      var key;

   	      for (key in source) {
   	        if (Object.prototype.hasOwnProperty.call(source, key)) {
   	          if (key in dest) {
   	            if (source[key] !== dest[key]) {
   	              var err = new Error('Signature "' + key + '" is defined twice');
   	              err.data = {
   	                signature: key,
   	                sourceFunction: source[key],
   	                destFunction: dest[key]
   	              };
   	              throw err;
   	            } // else: both signatures point to the same function, that's fine

   	          }

   	          dest[key] = source[key];
   	        }
   	      }
   	    }

   	    var saveTyped = typed;
   	    /**
   	     * Originally the main function was a typed function itself, but then
   	     * it might not be able to generate error messages if the client
   	     * replaced the type system with different names.
   	     *
   	     * Main entry: typed([name], functions/objects with signatures...)
   	     *
   	     * Assembles and returns a new typed-function from the given items
   	     * that provide signatures and implementations, each of which may be
   	     * * a plain object mapping (string) signatures to implementing functions,
   	     * * a previously constructed typed function, or
   	     * * any other single function with a string-valued property `signature`.
   	      * The name of the resulting typed-function will be given by the
   	     * string-valued name argument if present, or if not, by the name
   	     * of any of the arguments that have one, as long as any that do are
   	     * consistent with each other. If no name is specified, the name will be
   	     * an empty string.
   	     *
   	     * @param {string} maybeName [optional]
   	     * @param {(function|object)[]} signature providers
   	     * @returns {typed-function}
   	     */

   	    typed = function typed(maybeName) {
   	      var named = typeof maybeName === 'string';
   	      var start = named ? 1 : 0;
   	      var name = named ? maybeName : '';
   	      var allSignatures = {};

   	      for (var i = start; i < arguments.length; ++i) {
   	        var item = arguments[i];
   	        var theseSignatures = {};
   	        var thisName = void 0;

   	        if (typeof item === 'function') {
   	          thisName = item.name;

   	          if (typeof item.signature === 'string') {
   	            // Case 1: Ordinary function with a string 'signature' property
   	            theseSignatures[item.signature] = item;
   	          } else if (isTypedFunction(item)) {
   	            // Case 2: Existing typed function
   	            theseSignatures = item.signatures;
   	          }
   	        } else if (isPlainObject(item)) {
   	          // Case 3: Plain object, assume keys = signatures, values = functions
   	          theseSignatures = item;

   	          if (!named) {
   	            thisName = getObjectName(item);
   	          }
   	        }

   	        if (Object.keys(theseSignatures).length === 0) {
   	          var err = new TypeError('Argument to \'typed\' at index ' + i + ' is not a (typed) function, ' + 'nor an object with signatures as keys and functions as values.');
   	          err.data = {
   	            index: i,
   	            argument: item
   	          };
   	          throw err;
   	        }

   	        if (!named) {
   	          name = checkName(name, thisName);
   	        }

   	        mergeSignatures(allSignatures, theseSignatures);
   	      }

   	      return createTypedFunction(name || '', allSignatures);
   	    };

   	    typed.create = create;
   	    typed.createCount = saveTyped.createCount;
   	    typed.onMismatch = _onMismatch;
   	    typed.throwMismatchError = _onMismatch;
   	    typed.createError = createError;
   	    typed.clear = clear;
   	    typed.clearConversions = clearConversions;
   	    typed.addTypes = addTypes;
   	    typed._findType = findType; // For unit testing only

   	    typed.referTo = referTo;
   	    typed.referToSelf = referToSelf;
   	    typed.convert = convert;
   	    typed.findSignature = findSignature;
   	    typed.find = find;
   	    typed.isTypedFunction = isTypedFunction;
   	    typed.warnAgainstDeprecatedThis = true;
   	    /**
   	     * add a type (convenience wrapper for typed.addTypes)
   	     * @param {{name: string, test: function}} type
   	     * @param {boolean} [beforeObjectTest=true]
   	     *                          If true, the new test will be inserted before
   	     *                          the test with name 'Object' (if any), since
   	     *                          tests for Object match Array and classes too.
   	     */

   	    typed.addType = function (type, beforeObjectTest) {
   	      var before = 'any';

   	      if (beforeObjectTest !== false && typeMap.has('Object')) {
   	        before = 'Object';
   	      }

   	      typed.addTypes([type], before);
   	    };
   	    /**
   	     * Verify that the ConversionDef conversion has a valid format.
   	     *
   	     * @param {conversionDef} conversion
   	     * @return {void}
   	     * @throws {TypeError|SyntaxError}
   	     */


   	    function _validateConversion(conversion) {
   	      if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {
   	        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
   	      }

   	      if (conversion.to === conversion.from) {
   	        throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
   	      }
   	    }
   	    /**
   	     * Add a conversion
   	     *
   	     * @param {ConversionDef} conversion
   	     * @returns {void}
   	     * @throws {TypeError}
   	     */


   	    typed.addConversion = function (conversion) {
   	      _validateConversion(conversion);

   	      var to = findType(conversion.to);

   	      if (to.conversionsTo.every(function (other) {
   	        return other.from !== conversion.from;
   	      })) {
   	        to.conversionsTo.push({
   	          from: conversion.from,
   	          convert: conversion.convert,
   	          index: nConversions++
   	        });
   	      } else {
   	        throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
   	      }
   	    };
   	    /**
   	     * Convenience wrapper to call addConversion on each conversion in a list.
   	     *
   	     @param {ConversionDef[]} conversions
   	     @returns {void}
   	     @throws {TypeError}
   	     */


   	    typed.addConversions = function (conversions) {
   	      conversions.forEach(typed.addConversion);
   	    };
   	    /**
   	     * Remove the specified conversion. The format is the same as for
   	     * addConversion, and the convert function must match or an error
   	     * is thrown.
   	     *
   	     * @param {{from: string, to: string, convert: function}} conversion
   	     * @returns {void}
   	     * @throws {TypeError|SyntaxError|Error}
   	     */


   	    typed.removeConversion = function (conversion) {
   	      _validateConversion(conversion);

   	      var to = findType(conversion.to);
   	      var existingConversion = findInArray(to.conversionsTo, function (c) {
   	        return c.from === conversion.from;
   	      });

   	      if (!existingConversion) {
   	        throw new Error('Attempt to remove nonexistent conversion from ' + conversion.from + ' to ' + conversion.to);
   	      }

   	      if (existingConversion.convert !== conversion.convert) {
   	        throw new Error('Conversion to remove does not match existing conversion');
   	      }

   	      var index = to.conversionsTo.indexOf(existingConversion);
   	      to.conversionsTo.splice(index, 1);
   	    };
   	    /**
   	     * Produce the specific signature that a typed function
   	     * will execute on the given arguments. Here, a "signature" is an
   	     * object with properties 'params', 'test', 'fn', and 'implementation'.
   	     * This last property is a function that converts params as necessary
   	     * and then calls 'fn'. Returns null if there is no matching signature.
   	     * @param {typed-function} tf
   	     * @param {any[]} argList
   	     * @returns {{params: string, test: function, fn: function, implementation: function}}
   	     */


   	    typed.resolve = function (tf, argList) {
   	      if (!isTypedFunction(tf)) {
   	        throw new TypeError(NOT_TYPED_FUNCTION);
   	      }

   	      var sigs = tf._typedFunctionData.signatures;

   	      for (var i = 0; i < sigs.length; ++i) {
   	        if (sigs[i].test(argList)) {
   	          return sigs[i];
   	        }
   	      }

   	      return null;
   	    };

   	    return typed;
   	  }

   	  var typedFunction = create();

   	  return typedFunction;

   	}));
   	
   } (typedFunction$1));

   var typedFunctionExports = typedFunction$1.exports;
   var typedFunction = /*@__PURE__*/getDefaultExportFromCjs(typedFunctionExports);

   /**
    * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
    */

   /**
    * Check if a number is integer
    * @param {number | boolean} value
    * @return {boolean} isInteger
    */
   function isInteger$1(value) {
     if (typeof value === 'boolean') {
       return true;
     }
     return isFinite(value) ? value === Math.round(value) : false;
   }

   /**
    * Calculate the sign of a number
    * @param {number} x
    * @returns {number}
    */
   var sign$2 = Math.sign || function (x) {
     if (x > 0) {
       return 1;
     } else if (x < 0) {
       return -1;
     } else {
       return 0;
     }
   };

   /**
    * Calculate the base-2 logarithm of a number
    * @param {number} x
    * @returns {number}
    */
   var log2$2 = Math.log2 || function log2(x) {
     return Math.log(x) / Math.LN2;
   };

   /**
    * Calculate the base-10 logarithm of a number
    * @param {number} x
    * @returns {number}
    */
   var log10$2 = Math.log10 || function log10(x) {
     return Math.log(x) / Math.LN10;
   };

   /**
    * Calculate the natural logarithm of a number + 1
    * @param {number} x
    * @returns {number}
    */
   var log1p$1 = Math.log1p || function (x) {
     return Math.log(x + 1);
   };

   /**
    * Calculate cubic root for a number
    *
    * Code from es6-shim.js:
    *   https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1564-L1577
    *
    * @param {number} x
    * @returns {number} Returns the cubic root of x
    */
   var cbrt$2 = Math.cbrt || function cbrt(x) {
     if (x === 0) {
       return x;
     }
     var negate = x < 0;
     var result;
     if (negate) {
       x = -x;
     }
     if (isFinite(x)) {
       result = Math.exp(Math.log(x) / 3);
       // from https://en.wikipedia.org/wiki/Cube_root#Numerical_methods
       result = (x / (result * result) + 2 * result) / 3;
     } else {
       result = x;
     }
     return negate ? -result : result;
   };

   /**
    * Calculates exponentiation minus 1
    * @param {number} x
    * @return {number} res
    */
   var expm1$1 = Math.expm1 || function expm1(x) {
     return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
   };

   /**
    * Formats a number in a given base
    * @param {number} n
    * @param {number} base
    * @param {number} size
    * @returns {string}
    */
   function formatNumberToBase(n, base, size) {
     var prefixes = {
       2: '0b',
       8: '0o',
       16: '0x'
     };
     var prefix = prefixes[base];
     var suffix = '';
     if (size) {
       if (size < 1) {
         throw new Error('size must be in greater than 0');
       }
       if (!isInteger$1(size)) {
         throw new Error('size must be an integer');
       }
       if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
         throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
       }
       if (!isInteger$1(n)) {
         throw new Error('Value must be an integer');
       }
       if (n < 0) {
         n = n + 2 ** size;
       }
       suffix = "i".concat(size);
     }
     var sign = '';
     if (n < 0) {
       n = -n;
       sign = '-';
     }
     return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
   }

   /**
    * Convert a number to a formatted string representation.
    *
    * Syntax:
    *
    *    format(value)
    *    format(value, options)
    *    format(value, precision)
    *    format(value, fn)
    *
    * Where:
    *
    *    {number} value   The value to be formatted
    *    {Object} options An object with formatting options. Available options:
    *                     {string} notation
    *                         Number notation. Choose from:
    *                         'fixed'          Always use regular number notation.
    *                                          For example '123.40' and '14000000'
    *                         'exponential'    Always use exponential notation.
    *                                          For example '1.234e+2' and '1.4e+7'
    *                         'engineering'    Always use engineering notation.
    *                                          For example '123.4e+0' and '14.0e+6'
    *                         'auto' (default) Regular number notation for numbers
    *                                          having an absolute value between
    *                                          `lowerExp` and `upperExp` bounds, and
    *                                          uses exponential notation elsewhere.
    *                                          Lower bound is included, upper bound
    *                                          is excluded.
    *                                          For example '123.4' and '1.4e7'.
    *                         'bin', 'oct, or
    *                         'hex'            Format the number using binary, octal,
    *                                          or hexadecimal notation.
    *                                          For example '0b1101' and '0x10fe'.
    *                     {number} wordSize    The word size in bits to use for formatting
    *                                          in binary, octal, or hexadecimal notation.
    *                                          To be used only with 'bin', 'oct', or 'hex'
    *                                          values for 'notation' option. When this option
    *                                          is defined the value is formatted as a signed
    *                                          twos complement integer of the given word size
    *                                          and the size suffix is appended to the output.
    *                                          For example
    *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
    *                                          Default value is undefined.
    *                     {number} precision   A number between 0 and 16 to round
    *                                          the digits of the number.
    *                                          In case of notations 'exponential',
    *                                          'engineering', and 'auto',
    *                                          `precision` defines the total
    *                                          number of significant digits returned.
    *                                          In case of notation 'fixed',
    *                                          `precision` defines the number of
    *                                          significant digits after the decimal
    *                                          point.
    *                                          `precision` is undefined by default,
    *                                          not rounding any digits.
    *                     {number} lowerExp    Exponent determining the lower boundary
    *                                          for formatting a value with an exponent
    *                                          when `notation='auto`.
    *                                          Default value is `-3`.
    *                     {number} upperExp    Exponent determining the upper boundary
    *                                          for formatting a value with an exponent
    *                                          when `notation='auto`.
    *                                          Default value is `5`.
    *    {Function} fn    A custom formatting function. Can be used to override the
    *                     built-in notations. Function `fn` is called with `value` as
    *                     parameter and must return a string. Is useful for example to
    *                     format all values inside a matrix in a particular way.
    *
    * Examples:
    *
    *    format(6.4)                                        // '6.4'
    *    format(1240000)                                    // '1.24e6'
    *    format(1/3)                                        // '0.3333333333333333'
    *    format(1/3, 3)                                     // '0.333'
    *    format(21385, 2)                                   // '21000'
    *    format(12.071, {notation: 'fixed'})                // '12'
    *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
    *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
    *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
    *
    * @param {number} value
    * @param {Object | Function | number} [options]
    * @return {string} str The formatted value
    */
   function format$3(value, options) {
     if (typeof options === 'function') {
       // handle format(value, fn)
       return options(value);
     }

     // handle special cases
     if (value === Infinity) {
       return 'Infinity';
     } else if (value === -Infinity) {
       return '-Infinity';
     } else if (isNaN(value)) {
       return 'NaN';
     }

     // default values for options
     var notation = 'auto';
     var precision;
     var wordSize;
     if (options) {
       // determine notation from options
       if (options.notation) {
         notation = options.notation;
       }

       // determine precision from options
       if (isNumber(options)) {
         precision = options;
       } else if (isNumber(options.precision)) {
         precision = options.precision;
       }
       if (options.wordSize) {
         wordSize = options.wordSize;
         if (typeof wordSize !== 'number') {
           throw new Error('Option "wordSize" must be a number');
         }
       }
     }

     // handle the various notations
     switch (notation) {
       case 'fixed':
         return toFixed$1(value, precision);
       case 'exponential':
         return toExponential$1(value, precision);
       case 'engineering':
         return toEngineering$1(value, precision);
       case 'bin':
         return formatNumberToBase(value, 2, wordSize);
       case 'oct':
         return formatNumberToBase(value, 8, wordSize);
       case 'hex':
         return formatNumberToBase(value, 16, wordSize);
       case 'auto':
         // remove trailing zeros after the decimal point
         return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function () {
           var digits = arguments[2];
           var e = arguments[4];
           return digits !== '.' ? digits + e : e;
         });
       default:
         throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
     }
   }

   /**
    * Split a number into sign, coefficients, and exponent
    * @param {number | string} value
    * @return {SplitValue}
    *              Returns an object containing sign, coefficients, and exponent
    */
   function splitNumber(value) {
     // parse the input value
     var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
     if (!match) {
       throw new SyntaxError('Invalid number ' + value);
     }
     var sign = match[1];
     var digits = match[2];
     var exponent = parseFloat(match[4] || '0');
     var dot = digits.indexOf('.');
     exponent += dot !== -1 ? dot - 1 : digits.length - 1;
     var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
     .replace(/^0*/, function (zeros) {
       // remove leading zeros, add their count to the exponent
       exponent -= zeros.length;
       return '';
     }).replace(/0*$/, '') // remove trailing zeros
     .split('').map(function (d) {
       return parseInt(d);
     });
     if (coefficients.length === 0) {
       coefficients.push(0);
       exponent++;
     }
     return {
       sign,
       coefficients,
       exponent
     };
   }

   /**
    * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
    * @param {number | string} value
    * @param {number} [precision]        Optional number of significant figures to return.
    */
   function toEngineering$1(value, precision) {
     if (isNaN(value) || !isFinite(value)) {
       return String(value);
     }
     var split = splitNumber(value);
     var rounded = roundDigits(split, precision);
     var e = rounded.exponent;
     var c = rounded.coefficients;

     // find nearest lower multiple of 3 for exponent
     var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
     if (isNumber(precision)) {
       // add zeroes to give correct sig figs
       while (precision > c.length || e - newExp + 1 > c.length) {
         c.push(0);
       }
     } else {
       // concatenate coefficients with necessary zeros
       // add zeros if necessary (for example: 1e+8 -> 100e+6)
       var missingZeros = Math.abs(e - newExp) - (c.length - 1);
       for (var i = 0; i < missingZeros; i++) {
         c.push(0);
       }
     }

     // find difference in exponents
     var expDiff = Math.abs(e - newExp);
     var decimalIdx = 1;

     // push decimal index over by expDiff times
     while (expDiff > 0) {
       decimalIdx++;
       expDiff--;
     }

     // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
     // otherwise concat with the rest of the coefficients
     var decimals = c.slice(decimalIdx).join('');
     var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
     var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
     return rounded.sign + str;
   }

   /**
    * Format a number with fixed notation.
    * @param {number | string} value
    * @param {number} [precision=undefined]  Optional number of decimals after the
    *                                        decimal point. null by default.
    */
   function toFixed$1(value, precision) {
     if (isNaN(value) || !isFinite(value)) {
       return String(value);
     }
     var splitValue = splitNumber(value);
     var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
     var c = rounded.coefficients;
     var p = rounded.exponent + 1; // exponent may have changed

     // append zeros if needed
     var pp = p + (precision || 0);
     if (c.length < pp) {
       c = c.concat(zeros$1(pp - c.length));
     }

     // prepend zeros if needed
     if (p < 0) {
       c = zeros$1(-p + 1).concat(c);
       p = 1;
     }

     // insert a dot if needed
     if (p < c.length) {
       c.splice(p, 0, p === 0 ? '0.' : '.');
     }
     return rounded.sign + c.join('');
   }

   /**
    * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
    * @param {number | string} value
    * @param {number} [precision]  Number of digits in formatted output.
    *                              If not provided, the maximum available digits
    *                              is used.
    */
   function toExponential$1(value, precision) {
     if (isNaN(value) || !isFinite(value)) {
       return String(value);
     }

     // round if needed, else create a clone
     var split = splitNumber(value);
     var rounded = precision ? roundDigits(split, precision) : split;
     var c = rounded.coefficients;
     var e = rounded.exponent;

     // append zeros if needed
     if (c.length < precision) {
       c = c.concat(zeros$1(precision - c.length));
     }

     // format as `C.CCCe+EEE` or `C.CCCe-EEE`
     var first = c.shift();
     return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
   }

   /**
    * Format a number with a certain precision
    * @param {number | string} value
    * @param {number} [precision=undefined] Optional number of digits.
    * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
    *                                       By default:
    *                                         lowerExp = -3 (incl)
    *                                         upper = +5 (excl)
    * @return {string}
    */
   function toPrecision(value, precision, options) {
     if (isNaN(value) || !isFinite(value)) {
       return String(value);
     }

     // determine lower and upper bound for exponential notation.
     var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
     var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
     var split = splitNumber(value);
     var rounded = precision ? roundDigits(split, precision) : split;
     if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
       // exponential notation
       return toExponential$1(value, precision);
     } else {
       var c = rounded.coefficients;
       var e = rounded.exponent;

       // append trailing zeros
       if (c.length < precision) {
         c = c.concat(zeros$1(precision - c.length));
       }

       // append trailing zeros
       // TODO: simplify the next statement
       c = c.concat(zeros$1(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));

       // prepend zeros
       c = zeros$1(-e).concat(c);
       var dot = e > 0 ? e : 0;
       if (dot < c.length - 1) {
         c.splice(dot + 1, 0, '.');
       }
       return rounded.sign + c.join('');
     }
   }

   /**
    * Round the number of digits of a number *
    * @param {SplitValue} split       A value split with .splitNumber(value)
    * @param {number} precision  A positive integer
    * @return {SplitValue}
    *              Returns an object containing sign, coefficients, and exponent
    *              with rounded digits
    */
   function roundDigits(split, precision) {
     // create a clone
     var rounded = {
       sign: split.sign,
       coefficients: split.coefficients,
       exponent: split.exponent
     };
     var c = rounded.coefficients;

     // prepend zeros if needed
     while (precision <= 0) {
       c.unshift(0);
       rounded.exponent++;
       precision++;
     }
     if (c.length > precision) {
       var removed = c.splice(precision, c.length - precision);
       if (removed[0] >= 5) {
         var i = precision - 1;
         c[i]++;
         while (c[i] === 10) {
           c.pop();
           if (i === 0) {
             c.unshift(0);
             rounded.exponent++;
             i++;
           }
           i--;
           c[i]++;
         }
       }
     }
     return rounded;
   }

   /**
    * Create an array filled with zeros.
    * @param {number} length
    * @return {Array}
    */
   function zeros$1(length) {
     var arr = [];
     for (var i = 0; i < length; i++) {
       arr.push(0);
     }
     return arr;
   }

   /**
    * Count the number of significant digits of a number.
    *
    * For example:
    *   2.34 returns 3
    *   0.0034 returns 2
    *   120.5e+30 returns 4
    *
    * @param {number} value
    * @return {number} digits   Number of significant digits
    */
   function digits(value) {
     return value.toExponential().replace(/e.*$/, '') // remove exponential notation
     .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
     .length;
   }

   /**
    * Minimum number added to one that makes the result different than one
    */
   var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;

   /**
    * Compares two floating point numbers.
    * @param {number} x          First value to compare
    * @param {number} y          Second value to compare
    * @param {number} [epsilon]  The maximum relative difference between x and y
    *                            If epsilon is undefined or null, the function will
    *                            test whether x and y are exactly equal.
    * @return {boolean} whether the two numbers are nearly equal
   */
   function nearlyEqual$1(x, y, epsilon) {
     // if epsilon is null or undefined, test whether x and y are exactly equal
     if (epsilon === null || epsilon === undefined) {
       return x === y;
     }
     if (x === y) {
       return true;
     }

     // NaN
     if (isNaN(x) || isNaN(y)) {
       return false;
     }

     // at this point x and y should be finite
     if (isFinite(x) && isFinite(y)) {
       // check numbers are very close, needed when comparing numbers near zero
       var diff = Math.abs(x - y);
       if (diff < DBL_EPSILON) {
         return true;
       } else {
         // use relative error
         return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
       }
     }

     // Infinite and Number or negative Infinite and positive Infinite cases
     return false;
   }

   /**
    * Calculate the hyperbolic arccos of a number
    * @param {number} x
    * @return {number}
    */
   var acosh$2 = Math.acosh || function (x) {
     return Math.log(Math.sqrt(x * x - 1) + x);
   };
   var asinh$2 = Math.asinh || function (x) {
     return Math.log(Math.sqrt(x * x + 1) + x);
   };

   /**
    * Calculate the hyperbolic arctangent of a number
    * @param {number} x
    * @return {number}
    */
   var atanh$2 = Math.atanh || function (x) {
     return Math.log((1 + x) / (1 - x)) / 2;
   };

   /**
    * Calculate the hyperbolic cosine of a number
    * @param {number} x
    * @returns {number}
    */
   var cosh$2 = Math.cosh || function (x) {
     return (Math.exp(x) + Math.exp(-x)) / 2;
   };

   /**
    * Calculate the hyperbolic sine of a number
    * @param {number} x
    * @returns {number}
    */
   var sinh$2 = Math.sinh || function (x) {
     return (Math.exp(x) - Math.exp(-x)) / 2;
   };

   /**
    * Calculate the hyperbolic tangent of a number
    * @param {number} x
    * @returns {number}
    */
   var tanh$2 = Math.tanh || function (x) {
     var e = Math.exp(2 * x);
     return (e - 1) / (e + 1);
   };

   /**
    * Returns a value with the magnitude of x and the sign of y.
    * @param {number} x
    * @param {number} y
    * @returns {number}
    */
   function copysign(x, y) {
     var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
     var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
     return signx ^ signy ? -x : x;
   }

   /**
    * Formats a BigNumber in a given base
    * @param {BigNumber} n
    * @param {number} base
    * @param {number} size
    * @returns {string}
    */
   function formatBigNumberToBase(n, base, size) {
     var BigNumberCtor = n.constructor;
     var big2 = new BigNumberCtor(2);
     var suffix = '';
     if (size) {
       if (size < 1) {
         throw new Error('size must be in greater than 0');
       }
       if (!isInteger$1(size)) {
         throw new Error('size must be an integer');
       }
       if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
         throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
       }
       if (!n.isInteger()) {
         throw new Error('Value must be an integer');
       }
       if (n.lessThan(0)) {
         n = n.add(big2.pow(size));
       }
       suffix = "i".concat(size);
     }
     switch (base) {
       case 2:
         return "".concat(n.toBinary()).concat(suffix);
       case 8:
         return "".concat(n.toOctal()).concat(suffix);
       case 16:
         return "".concat(n.toHexadecimal()).concat(suffix);
       default:
         throw new Error("Base ".concat(base, " not supported "));
     }
   }

   /**
    * Convert a BigNumber to a formatted string representation.
    *
    * Syntax:
    *
    *    format(value)
    *    format(value, options)
    *    format(value, precision)
    *    format(value, fn)
    *
    * Where:
    *
    *    {number} value   The value to be formatted
    *    {Object} options An object with formatting options. Available options:
    *                     {string} notation
    *                         Number notation. Choose from:
    *                         'fixed'          Always use regular number notation.
    *                                          For example '123.40' and '14000000'
    *                         'exponential'    Always use exponential notation.
    *                                          For example '1.234e+2' and '1.4e+7'
    *                         'auto' (default) Regular number notation for numbers
    *                                          having an absolute value between
    *                                          `lower` and `upper` bounds, and uses
    *                                          exponential notation elsewhere.
    *                                          Lower bound is included, upper bound
    *                                          is excluded.
    *                                          For example '123.4' and '1.4e7'.
    *                         'bin', 'oct, or
    *                         'hex'            Format the number using binary, octal,
    *                                          or hexadecimal notation.
    *                                          For example '0b1101' and '0x10fe'.
    *                     {number} wordSize    The word size in bits to use for formatting
    *                                          in binary, octal, or hexadecimal notation.
    *                                          To be used only with 'bin', 'oct', or 'hex'
    *                                          values for 'notation' option. When this option
    *                                          is defined the value is formatted as a signed
    *                                          twos complement integer of the given word size
    *                                          and the size suffix is appended to the output.
    *                                          For example
    *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
    *                                          Default value is undefined.
    *                     {number} precision   A number between 0 and 16 to round
    *                                          the digits of the number.
    *                                          In case of notations 'exponential',
    *                                          'engineering', and 'auto',
    *                                          `precision` defines the total
    *                                          number of significant digits returned.
    *                                          In case of notation 'fixed',
    *                                          `precision` defines the number of
    *                                          significant digits after the decimal
    *                                          point.
    *                                          `precision` is undefined by default.
    *                     {number} lowerExp    Exponent determining the lower boundary
    *                                          for formatting a value with an exponent
    *                                          when `notation='auto`.
    *                                          Default value is `-3`.
    *                     {number} upperExp    Exponent determining the upper boundary
    *                                          for formatting a value with an exponent
    *                                          when `notation='auto`.
    *                                          Default value is `5`.
    *    {Function} fn    A custom formatting function. Can be used to override the
    *                     built-in notations. Function `fn` is called with `value` as
    *                     parameter and must return a string. Is useful for example to
    *                     format all values inside a matrix in a particular way.
    *
    * Examples:
    *
    *    format(6.4)                                        // '6.4'
    *    format(1240000)                                    // '1.24e6'
    *    format(1/3)                                        // '0.3333333333333333'
    *    format(1/3, 3)                                     // '0.333'
    *    format(21385, 2)                                   // '21000'
    *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
    *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
    *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
    *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
    *
    * @param {BigNumber} value
    * @param {Object | Function | number} [options]
    * @return {string} str The formatted value
    */
   function format$2(value, options) {
     if (typeof options === 'function') {
       // handle format(value, fn)
       return options(value);
     }

     // handle special cases
     if (!value.isFinite()) {
       return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
     }

     // default values for options
     var notation = 'auto';
     var precision;
     var wordSize;
     if (options !== undefined) {
       // determine notation from options
       if (options.notation) {
         notation = options.notation;
       }

       // determine precision from options
       if (typeof options === 'number') {
         precision = options;
       } else if (options.precision !== undefined) {
         precision = options.precision;
       }
       if (options.wordSize) {
         wordSize = options.wordSize;
         if (typeof wordSize !== 'number') {
           throw new Error('Option "wordSize" must be a number');
         }
       }
     }

     // handle the various notations
     switch (notation) {
       case 'fixed':
         return toFixed(value, precision);
       case 'exponential':
         return toExponential(value, precision);
       case 'engineering':
         return toEngineering(value, precision);
       case 'bin':
         return formatBigNumberToBase(value, 2, wordSize);
       case 'oct':
         return formatBigNumberToBase(value, 8, wordSize);
       case 'hex':
         return formatBigNumberToBase(value, 16, wordSize);
       case 'auto':
         {
           // determine lower and upper bound for exponential notation.
           // TODO: implement support for upper and lower to be BigNumbers themselves
           var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
           var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;

           // handle special case zero
           if (value.isZero()) return '0';

           // determine whether or not to output exponential notation
           var str;
           var rounded = value.toSignificantDigits(precision);
           var exp = rounded.e;
           if (exp >= lowerExp && exp < upperExp) {
             // normal number notation
             str = rounded.toFixed();
           } else {
             // exponential notation
             str = toExponential(value, precision);
           }

           // remove trailing zeros after the decimal point
           return str.replace(/((\.\d*?)(0+))($|e)/, function () {
             var digits = arguments[2];
             var e = arguments[4];
             return digits !== '.' ? digits + e : e;
           });
         }
       default:
         throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
     }
   }

   /**
    * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
    * @param {BigNumber} value
    * @param {number} [precision]        Optional number of significant figures to return.
    */
   function toEngineering(value, precision) {
     // find nearest lower multiple of 3 for exponent
     var e = value.e;
     var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;

     // find difference in exponents, and calculate the value without exponent
     var valueWithoutExp = value.mul(Math.pow(10, -newExp));
     var valueStr = valueWithoutExp.toPrecision(precision);
     if (valueStr.indexOf('e') !== -1) {
       var BigNumber = value.constructor;
       valueStr = new BigNumber(valueStr).toFixed();
     }
     return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
   }

   /**
    * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
    * @param {BigNumber} value
    * @param {number} [precision]  Number of digits in formatted output.
    *                              If not provided, the maximum available digits
    *                              is used.
    * @returns {string} str
    */
   function toExponential(value, precision) {
     if (precision !== undefined) {
       return value.toExponential(precision - 1); // Note the offset of one
     } else {
       return value.toExponential();
     }
   }

   /**
    * Format a number with fixed notation.
    * @param {BigNumber} value
    * @param {number} [precision=undefined] Optional number of decimals after the
    *                                       decimal point. Undefined by default.
    */
   function toFixed(value, precision) {
     return value.toFixed(precision);
   }

   /**
    * Check if a text ends with a certain string.
    * @param {string} text
    * @param {string} search
    */
   function endsWith(text, search) {
     var start = text.length - search.length;
     var end = text.length;
     return text.substring(start, end) === search;
   }

   /**
    * Format a value of any type into a string.
    *
    * Usage:
    *     math.format(value)
    *     math.format(value, precision)
    *     math.format(value, options)
    *
    * When value is a function:
    *
    * - When the function has a property `syntax`, it returns this
    *   syntax description.
    * - In other cases, a string `'function'` is returned.
    *
    * When `value` is an Object:
    *
    * - When the object contains a property `format` being a function, this
    *   function is invoked as `value.format(options)` and the result is returned.
    * - When the object has its own `toString` method, this method is invoked
    *   and the result is returned.
    * - In other cases the function will loop over all object properties and
    *   return JSON object notation like '{"a": 2, "b": 3}'.
    *
    * Example usage:
    *     math.format(2/7)                // '0.2857142857142857'
    *     math.format(math.pi, 3)         // '3.14'
    *     math.format(new Complex(2, 3))  // '2 + 3i'
    *     math.format('hello')            // '"hello"'
    *
    * @param {*} value             Value to be stringified
    * @param {Object | number | Function} [options]
    *     Formatting options. See src/utils/number.js:format for a
    *     description of the available options controlling number output.
    *     This generic "format" also supports the option property `truncate: NN`
    *     giving the maximum number NN of characters to return (if there would
    *     have been more, they are deleted and replaced by an ellipsis).
    * @return {string} str
    */
   function format$1(value, options) {
     var result = _format(value, options);
     if (options && typeof options === 'object' && 'truncate' in options && result.length > options.truncate) {
       return result.substring(0, options.truncate - 3) + '...';
     }
     return result;
   }
   function _format(value, options) {
     if (typeof value === 'number') {
       return format$3(value, options);
     }
     if (isBigNumber(value)) {
       return format$2(value, options);
     }

     // note: we use unsafe duck-typing here to check for Fractions, this is
     // ok here since we're only invoking toString or concatenating its values
     if (looksLikeFraction(value)) {
       if (!options || options.fraction !== 'decimal') {
         // output as ratio, like '1/3'
         return value.s * value.n + '/' + value.d;
       } else {
         // output as decimal, like '0.(3)'
         return value.toString();
       }
     }
     if (Array.isArray(value)) {
       return formatArray(value, options);
     }
     if (isString(value)) {
       return '"' + value + '"';
     }
     if (typeof value === 'function') {
       return value.syntax ? String(value.syntax) : 'function';
     }
     if (value && typeof value === 'object') {
       if (typeof value.format === 'function') {
         return value.format(options);
       } else if (value && value.toString(options) !== {}.toString()) {
         // this object has a non-native toString method, use that one
         return value.toString(options);
       } else {
         var entries = Object.keys(value).map(key => {
           return '"' + key + '": ' + format$1(value[key], options);
         });
         return '{' + entries.join(', ') + '}';
       }
     }
     return String(value);
   }

   /**
    * Stringify a value into a string enclosed in double quotes.
    * Unescaped double quotes and backslashes inside the value are escaped.
    * @param {*} value
    * @return {string}
    */
   function stringify(value) {
     var text = String(value);
     var escaped = '';
     var i = 0;
     while (i < text.length) {
       var c = text.charAt(i);
       if (c === '\\') {
         escaped += c;
         i++;
         c = text.charAt(i);
         if (c === '' || '"\\/bfnrtu'.indexOf(c) === -1) {
           escaped += '\\'; // no valid escape character -> escape it
         }

         escaped += c;
       } else if (c === '"') {
         escaped += '\\"';
       } else {
         escaped += c;
       }
       i++;
     }
     return '"' + escaped + '"';
   }

   /**
    * Escape special HTML characters
    * @param {*} value
    * @return {string}
    */
   function escape(value) {
     var text = String(value);
     text = text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
     return text;
   }

   /**
    * Recursively format an n-dimensional matrix
    * Example output: "[[1, 2], [3, 4]]"
    * @param {Array} array
    * @param {Object | number | Function} [options]  Formatting options. See
    *                                                lib/utils/number:format for a
    *                                                description of the available
    *                                                options.
    * @returns {string} str
    */
   function formatArray(array, options) {
     if (Array.isArray(array)) {
       var str = '[';
       var len = array.length;
       for (var i = 0; i < len; i++) {
         if (i !== 0) {
           str += ', ';
         }
         str += formatArray(array[i], options);
       }
       str += ']';
       return str;
     } else {
       return format$1(array, options);
     }
   }

   /**
    * Check whether a value looks like a Fraction (unsafe duck-type check)
    * @param {*} value
    * @return {boolean}
    */
   function looksLikeFraction(value) {
     return value && typeof value === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;
   }

   /**
    * Compare two strings
    * @param {string} x
    * @param {string} y
    * @returns {number}
    */
   function compareText$1(x, y) {
     // we don't want to convert numbers to string, only accept string input
     if (!isString(x)) {
       throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf$1(x) + ', index: 0)');
     }
     if (!isString(y)) {
       throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf$1(y) + ', index: 1)');
     }
     return x === y ? 0 : x > y ? 1 : -1;
   }

   /**
    * Create a range error with the message:
    *     'Dimension mismatch (<actual size> != <expected size>)'
    * @param {number | number[]} actual        The actual size
    * @param {number | number[]} expected      The expected size
    * @param {string} [relation='!=']          Optional relation between actual
    *                                          and expected size: '!=', '<', etc.
    * @extends RangeError
    */
   function DimensionError(actual, expected, relation) {
     if (!(this instanceof DimensionError)) {
       throw new SyntaxError('Constructor must be called with the new operator');
     }
     this.actual = actual;
     this.expected = expected;
     this.relation = relation;
     this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';
     this.stack = new Error().stack;
   }
   DimensionError.prototype = new RangeError();
   DimensionError.prototype.constructor = RangeError;
   DimensionError.prototype.name = 'DimensionError';
   DimensionError.prototype.isDimensionError = true;

   /**
    * Create a range error with the message:
    *     'Index out of range (index < min)'
    *     'Index out of range (index < max)'
    *
    * @param {number} index     The actual index
    * @param {number} [min=0]   Minimum index (included)
    * @param {number} [max]     Maximum index (excluded)
    * @extends RangeError
    */
   function IndexError(index, min, max) {
     if (!(this instanceof IndexError)) {
       throw new SyntaxError('Constructor must be called with the new operator');
     }
     this.index = index;
     if (arguments.length < 3) {
       this.min = 0;
       this.max = min;
     } else {
       this.min = min;
       this.max = max;
     }
     if (this.min !== undefined && this.index < this.min) {
       this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
     } else if (this.max !== undefined && this.index >= this.max) {
       this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
     } else {
       this.message = 'Index out of range (' + this.index + ')';
     }
     this.stack = new Error().stack;
   }
   IndexError.prototype = new RangeError();
   IndexError.prototype.constructor = RangeError;
   IndexError.prototype.name = 'IndexError';
   IndexError.prototype.isIndexError = true;

   /**
    * Calculate the size of a multi dimensional array.
    * This function checks the size of the first entry, it does not validate
    * whether all dimensions match. (use function `validate` for that)
    * @param {Array} x
    * @Return {Number[]} size
    */
   function arraySize(x) {
     var s = [];
     while (Array.isArray(x)) {
       s.push(x.length);
       x = x[0];
     }
     return s;
   }

   /**
    * Recursively validate whether each element in a multi dimensional array
    * has a size corresponding to the provided size array.
    * @param {Array} array    Array to be validated
    * @param {number[]} size  Array with the size of each dimension
    * @param {number} dim   Current dimension
    * @throws DimensionError
    * @private
    */
   function _validate(array, size, dim) {
     var i;
     var len = array.length;
     if (len !== size[dim]) {
       throw new DimensionError(len, size[dim]);
     }
     if (dim < size.length - 1) {
       // recursively validate each child array
       var dimNext = dim + 1;
       for (i = 0; i < len; i++) {
         var child = array[i];
         if (!Array.isArray(child)) {
           throw new DimensionError(size.length - 1, size.length, '<');
         }
         _validate(array[i], size, dimNext);
       }
     } else {
       // last dimension. none of the childs may be an array
       for (i = 0; i < len; i++) {
         if (Array.isArray(array[i])) {
           throw new DimensionError(size.length + 1, size.length, '>');
         }
       }
     }
   }

   /**
    * Validate whether each element in a multi dimensional array has
    * a size corresponding to the provided size array.
    * @param {Array} array    Array to be validated
    * @param {number[]} size  Array with the size of each dimension
    * @throws DimensionError
    */
   function validate(array, size) {
     var isScalar = size.length === 0;
     if (isScalar) {
       // scalar
       if (Array.isArray(array)) {
         throw new DimensionError(array.length, 0);
       }
     } else {
       // array
       _validate(array, size, 0);
     }
   }

   /**
    * Validate whether the source of the index matches the size of the Array
    * @param {Array | Matrix} array    Array to be validated
    * @param {Index} index  Index with the source information to validate
    * @throws DimensionError
    */
   function validateIndexSourceSize(value, index) {
     var valueSize = value.isMatrix ? value._size : arraySize(value);
     var sourceSize = index._sourceSize;
     // checks if the source size is not null and matches the valueSize
     sourceSize.forEach((sourceDim, i) => {
       if (sourceDim !== null && sourceDim !== valueSize[i]) {
         throw new DimensionError(sourceDim, valueSize[i]);
       }
     });
   }

   /**
    * Test whether index is an integer number with index >= 0 and index < length
    * when length is provided
    * @param {number} index    Zero-based index
    * @param {number} [length] Length of the array
    */
   function validateIndex(index, length) {
     if (index !== undefined) {
       if (!isNumber(index) || !isInteger$1(index)) {
         throw new TypeError('Index must be an integer (value: ' + index + ')');
       }
       if (index < 0 || typeof length === 'number' && index >= length) {
         throw new IndexError(index, length);
       }
     }
   }

   /**
    * Test if and index has empty values
    * @param {number} index    Zero-based index
    */
   function isEmptyIndex(index) {
     for (var i = 0; i < index._dimensions.length; ++i) {
       var dimension = index._dimensions[i];
       if (dimension._data && isArray(dimension._data)) {
         if (dimension._size[0] === 0) {
           return true;
         }
       } else if (dimension.isRange) {
         if (dimension.start === dimension.end) {
           return true;
         }
       } else if (isString(dimension)) {
         if (dimension.length === 0) {
           return true;
         }
       }
     }
     return false;
   }

   /**
    * Resize a multi dimensional array. The resized array is returned.
    * @param {Array | number} array         Array to be resized
    * @param {number[]} size Array with the size of each dimension
    * @param {*} [defaultValue=0]  Value to be filled in in new entries,
    *                              zero by default. Specify for example `null`,
    *                              to clearly see entries that are not explicitly
    *                              set.
    * @return {Array} array         The resized array
    */
   function resize$1(array, size, defaultValue) {
     // check the type of the arguments
     if (!Array.isArray(size)) {
       throw new TypeError('Array expected');
     }
     if (size.length === 0) {
       throw new Error('Resizing to scalar is not supported');
     }

     // check whether size contains positive integers
     size.forEach(function (value) {
       if (!isNumber(value) || !isInteger$1(value) || value < 0) {
         throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$1(size) + ')');
       }
     });

     // convert number to an array
     if (isNumber(array) || isBigNumber(array)) {
       array = [array];
     }

     // recursively resize the array
     var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
     _resize(array, size, 0, _defaultValue);
     return array;
   }

   /**
    * Recursively resize a multi dimensional array
    * @param {Array} array         Array to be resized
    * @param {number[]} size       Array with the size of each dimension
    * @param {number} dim          Current dimension
    * @param {*} [defaultValue]    Value to be filled in in new entries,
    *                              undefined by default.
    * @private
    */
   function _resize(array, size, dim, defaultValue) {
     var i;
     var elem;
     var oldLen = array.length;
     var newLen = size[dim];
     var minLen = Math.min(oldLen, newLen);

     // apply new length
     array.length = newLen;
     if (dim < size.length - 1) {
       // non-last dimension
       var dimNext = dim + 1;

       // resize existing child arrays
       for (i = 0; i < minLen; i++) {
         // resize child array
         elem = array[i];
         if (!Array.isArray(elem)) {
           elem = [elem]; // add a dimension
           array[i] = elem;
         }
         _resize(elem, size, dimNext, defaultValue);
       }

       // create new child arrays
       for (i = minLen; i < newLen; i++) {
         // get child array
         elem = [];
         array[i] = elem;

         // resize new child array
         _resize(elem, size, dimNext, defaultValue);
       }
     } else {
       // last dimension

       // remove dimensions of existing values
       for (i = 0; i < minLen; i++) {
         while (Array.isArray(array[i])) {
           array[i] = array[i][0];
         }
       }

       // fill new elements with the default value
       for (i = minLen; i < newLen; i++) {
         array[i] = defaultValue;
       }
     }
   }

   /**
    * Re-shape a multi dimensional array to fit the specified dimensions
    * @param {Array} array           Array to be reshaped
    * @param {number[]} sizes        List of sizes for each dimension
    * @returns {Array}               Array whose data has been formatted to fit the
    *                                specified dimensions
    *
    * @throws {DimensionError}       If the product of the new dimension sizes does
    *                                not equal that of the old ones
    */
   function reshape$1(array, sizes) {
     var flatArray = flatten$1(array);
     var currentLength = flatArray.length;
     if (!Array.isArray(array) || !Array.isArray(sizes)) {
       throw new TypeError('Array expected');
     }
     if (sizes.length === 0) {
       throw new DimensionError(0, currentLength, '!=');
     }
     sizes = processSizesWildcard(sizes, currentLength);
     var newLength = product$1(sizes);
     if (currentLength !== newLength) {
       throw new DimensionError(newLength, currentLength, '!=');
     }
     try {
       return _reshape(flatArray, sizes);
     } catch (e) {
       if (e instanceof DimensionError) {
         throw new DimensionError(newLength, currentLength, '!=');
       }
       throw e;
     }
   }

   /**
    * Replaces the wildcard -1 in the sizes array.
    * @param {number[]} sizes  List of sizes for each dimension. At most on wildcard.
    * @param {number} currentLength  Number of elements in the array.
    * @throws {Error}                If more than one wildcard or unable to replace it.
    * @returns {number[]}      The sizes array with wildcard replaced.
    */
   function processSizesWildcard(sizes, currentLength) {
     var newLength = product$1(sizes);
     var processedSizes = sizes.slice();
     var WILDCARD = -1;
     var wildCardIndex = sizes.indexOf(WILDCARD);
     var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
     if (isMoreThanOneWildcard) {
       throw new Error('More than one wildcard in sizes');
     }
     var hasWildcard = wildCardIndex >= 0;
     var canReplaceWildcard = currentLength % newLength === 0;
     if (hasWildcard) {
       if (canReplaceWildcard) {
         processedSizes[wildCardIndex] = -currentLength / newLength;
       } else {
         throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);
       }
     }
     return processedSizes;
   }

   /**
    * Computes the product of all array elements.
    * @param {number[]} array Array of factors
    * @returns {number}            Product of all elements
    */
   function product$1(array) {
     return array.reduce((prev, curr) => prev * curr, 1);
   }

   /**
    * Iteratively re-shape a multi dimensional array to fit the specified dimensions
    * @param {Array} array           Array to be reshaped
    * @param {number[]} sizes  List of sizes for each dimension
    * @returns {Array}               Array whose data has been formatted to fit the
    *                                specified dimensions
    */

   function _reshape(array, sizes) {
     // testing if there are enough elements for the requested shape
     var tmpArray = array;
     var tmpArray2;
     // for each dimensions starting by the last one and ignoring the first one
     for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
       var size = sizes[sizeIndex];
       tmpArray2 = [];

       // aggregate the elements of the current tmpArray in elements of the requested size
       var length = tmpArray.length / size;
       for (var i = 0; i < length; i++) {
         tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
       }
       // set it as the new tmpArray for the next loop turn or for return
       tmpArray = tmpArray2;
     }
     return tmpArray;
   }

   /**
    * Squeeze a multi dimensional array
    * @param {Array} array
    * @param {Array} [size]
    * @returns {Array} returns the array itself
    */
   function squeeze$1(array, size) {
     var s = size || arraySize(array);

     // squeeze outer dimensions
     while (Array.isArray(array) && array.length === 1) {
       array = array[0];
       s.shift();
     }

     // find the first dimension to be squeezed
     var dims = s.length;
     while (s[dims - 1] === 1) {
       dims--;
     }

     // squeeze inner dimensions
     if (dims < s.length) {
       array = _squeeze(array, dims, 0);
       s.length = dims;
     }
     return array;
   }

   /**
    * Recursively squeeze a multi dimensional array
    * @param {Array} array
    * @param {number} dims Required number of dimensions
    * @param {number} dim  Current dimension
    * @returns {Array | *} Returns the squeezed array
    * @private
    */
   function _squeeze(array, dims, dim) {
     var i, ii;
     if (dim < dims) {
       var next = dim + 1;
       for (i = 0, ii = array.length; i < ii; i++) {
         array[i] = _squeeze(array[i], dims, next);
       }
     } else {
       while (Array.isArray(array)) {
         array = array[0];
       }
     }
     return array;
   }

   /**
    * Unsqueeze a multi dimensional array: add dimensions when missing
    *
    * Paramter `size` will be mutated to match the new, unqueezed matrix size.
    *
    * @param {Array} array
    * @param {number} dims       Desired number of dimensions of the array
    * @param {number} [outer]    Number of outer dimensions to be added
    * @param {Array} [size] Current size of array.
    * @returns {Array} returns the array itself
    * @private
    */
   function unsqueeze(array, dims, outer, size) {
     var s = size || arraySize(array);

     // unsqueeze outer dimensions
     if (outer) {
       for (var i = 0; i < outer; i++) {
         array = [array];
         s.unshift(1);
       }
     }

     // unsqueeze inner dimensions
     array = _unsqueeze(array, dims, 0);
     while (s.length < dims) {
       s.push(1);
     }
     return array;
   }

   /**
    * Recursively unsqueeze a multi dimensional array
    * @param {Array} array
    * @param {number} dims Required number of dimensions
    * @param {number} dim  Current dimension
    * @returns {Array | *} Returns the squeezed array
    * @private
    */
   function _unsqueeze(array, dims, dim) {
     var i, ii;
     if (Array.isArray(array)) {
       var next = dim + 1;
       for (i = 0, ii = array.length; i < ii; i++) {
         array[i] = _unsqueeze(array[i], dims, next);
       }
     } else {
       for (var d = dim; d < dims; d++) {
         array = [array];
       }
     }
     return array;
   }
   /**
    * Flatten a multi dimensional array, put all elements in a one dimensional
    * array
    * @param {Array} array   A multi dimensional array
    * @return {Array}        The flattened array (1 dimensional)
    */
   function flatten$1(array) {
     if (!Array.isArray(array)) {
       // if not an array, return as is
       return array;
     }
     var flat = [];
     array.forEach(function callback(value) {
       if (Array.isArray(value)) {
         value.forEach(callback); // traverse through sub-arrays recursively
       } else {
         flat.push(value);
       }
     });
     return flat;
   }

   /**
    * A safe map
    * @param {Array} array
    * @param {function} callback
    */
   function map$1(array, callback) {
     return Array.prototype.map.call(array, callback);
   }

   /**
    * A safe forEach
    * @param {Array} array
    * @param {function} callback
    */
   function forEach$1(array, callback) {
     Array.prototype.forEach.call(array, callback);
   }

   /**
    * A safe filter
    * @param {Array} array
    * @param {function} callback
    */
   function filter$1(array, callback) {
     if (arraySize(array).length !== 1) {
       throw new Error('Only one dimensional matrices supported');
     }
     return Array.prototype.filter.call(array, callback);
   }

   /**
    * Filter values in a callback given a regular expression
    * @param {Array} array
    * @param {RegExp} regexp
    * @return {Array} Returns the filtered array
    * @private
    */
   function filterRegExp(array, regexp) {
     if (arraySize(array).length !== 1) {
       throw new Error('Only one dimensional matrices supported');
     }
     return Array.prototype.filter.call(array, entry => regexp.test(entry));
   }

   /**
    * A safe join
    * @param {Array} array
    * @param {string} separator
    */
   function join(array, separator) {
     return Array.prototype.join.call(array, separator);
   }

   /**
    * Assign a numeric identifier to every element of a sorted array
    * @param {Array} a  An array
    * @return {Array} An array of objects containing the original value and its identifier
    */
   function identify(a) {
     if (!Array.isArray(a)) {
       throw new TypeError('Array input expected');
     }
     if (a.length === 0) {
       return a;
     }
     var b = [];
     var count = 0;
     b[0] = {
       value: a[0],
       identifier: 0
     };
     for (var i = 1; i < a.length; i++) {
       if (a[i] === a[i - 1]) {
         count++;
       } else {
         count = 0;
       }
       b.push({
         value: a[i],
         identifier: count
       });
     }
     return b;
   }

   /**
    * Remove the numeric identifier from the elements
    * @param {array} a  An array
    * @return {array} An array of values without identifiers
    */
   function generalize(a) {
     if (!Array.isArray(a)) {
       throw new TypeError('Array input expected');
     }
     if (a.length === 0) {
       return a;
     }
     var b = [];
     for (var i = 0; i < a.length; i++) {
       b.push(a[i].value);
     }
     return b;
   }

   /**
    * Check the datatype of a given object
    * This is a low level implementation that should only be used by
    * parent Matrix classes such as SparseMatrix or DenseMatrix
    * This method does not validate Array Matrix shape
    * @param {Array} array
    * @param {function} typeOf   Callback function to use to determine the type of a value
    * @return {string}
    */
   function getArrayDataType(array, typeOf) {
     var type; // to hold type info
     var length = 0; // to hold length value to ensure it has consistent sizes

     for (var i = 0; i < array.length; i++) {
       var item = array[i];
       var _isArray = Array.isArray(item);

       // Saving the target matrix row size
       if (i === 0 && _isArray) {
         length = item.length;
       }

       // If the current item is an array but the length does not equal the targetVectorSize
       if (_isArray && item.length !== length) {
         return undefined;
       }
       var itemType = _isArray ? getArrayDataType(item, typeOf) // recurse into a nested array
       : typeOf(item);
       if (type === undefined) {
         type = itemType; // first item
       } else if (type !== itemType) {
         return 'mixed';
       } else ;
     }
     return type;
   }

   /**
    * Recursively concatenate two matrices.
    * The contents of the matrices is not cloned.
    * @param {Array} a             Multi dimensional array
    * @param {Array} b             Multi dimensional array
    * @param {number} concatDim    The dimension on which to concatenate (zero-based)
    * @param {number} dim          The current dim (zero-based)
    * @return {Array} c            The concatenated matrix
    * @private
    */
   function concatRecursive(a, b, concatDim, dim) {
     if (dim < concatDim) {
       // recurse into next dimension
       if (a.length !== b.length) {
         throw new DimensionError(a.length, b.length);
       }
       var c = [];
       for (var i = 0; i < a.length; i++) {
         c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);
       }
       return c;
     } else {
       // concatenate this dimension
       return a.concat(b);
     }
   }

   /**
    * Concatenates many arrays in the specified direction
    * @param {...Array} arrays All the arrays to concatenate
    * @param {number} concatDim The dimension on which to concatenate (zero-based)
    * @returns
   */
   function concat$1() {
     var arrays = Array.prototype.slice.call(arguments, 0, -1);
     var concatDim = Array.prototype.slice.call(arguments, -1);
     if (arrays.length === 1) {
       return arrays[0];
     }
     if (arrays.length > 1) {
       return arrays.slice(1).reduce(function (A, B) {
         return concatRecursive(A, B, concatDim, 0);
       }, arrays[0]);
     } else {
       throw new Error('Wrong number of arguments in function concat');
     }
   }

   /**
    * Receives two or more sizes and get's the broadcasted size for both.
    * @param  {...number[]} sizes Sizes to broadcast together
    * @returns
    */
   function broadcastSizes() {
     for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
       sizes[_key] = arguments[_key];
     }
     var dimensions = sizes.map(s => s.length);
     var N = Math.max(...dimensions);
     var sizeMax = new Array(N).fill(null);
     // check for every size
     for (var i = 0; i < sizes.length; i++) {
       var size = sizes[i];
       var dim = dimensions[i];
       for (var j = 0; j < dim; j++) {
         var n = N - dim + j;
         if (size[j] > sizeMax[n]) {
           sizeMax[n] = size[j];
         }
       }
     }
     for (var _i = 0; _i < sizes.length; _i++) {
       checkBroadcastingRules(sizes[_i], sizeMax);
     }
     return sizeMax;
   }

   /**
    * Checks if it's possible to broadcast a size to another size
    * @param {number[]} size The size of the array to check
    * @param {number[]} toSize The size of the array to validate if it can be broadcasted to
    */
   function checkBroadcastingRules(size, toSize) {
     var N = toSize.length;
     var dim = size.length;
     for (var j = 0; j < dim; j++) {
       var n = N - dim + j;
       if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {
         throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size[j], " to size ").concat(toSize[n]));
       }
     }
   }

   /**
    * Broadcasts a single array to a certain size
    * @param {array} array Array to be broadcasted
    * @param {number[]} toSize Size to broadcast the array
    * @returns The broadcasted array
    */
   function broadcastTo(array, toSize) {
     var Asize = arraySize(array);
     if (deepStrictEqual(Asize, toSize)) {
       return array;
     }
     checkBroadcastingRules(Asize, toSize);
     var broadcastedSize = broadcastSizes(Asize, toSize);
     var N = broadcastedSize.length;
     var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
     var A = clone$2(array);
     // reshape A if needed to make it ready for concat
     if (Asize.length < N) {
       A = reshape$1(A, paddedSize);
       Asize = arraySize(A);
     }

     // stretches the array on each dimension to make it the same size as index
     for (var dim = 0; dim < N; dim++) {
       if (Asize[dim] < broadcastedSize[dim]) {
         A = stretch(A, broadcastedSize[dim], dim);
         Asize = arraySize(A);
       }
     }
     return A;
   }

   /**
    * stretches a matrix up to a certain size in a certain dimension
    * @param {Array} arrayToStretch
    * @param {number[]} sizeToStretch
    * @param {number} dimToStretch
    * @returns
    */
   function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
     return concat$1(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
   }

   /**
    * Deep clones a multidimensional array
    * @param {Array} array
    * @returns cloned array
    */
   function clone$2(array) {
     return _extends$1([], array);
   }

   /**
    * Create a factory function, which can be used to inject dependencies.
    *
    * The created functions are memoized, a consecutive call of the factory
    * with the exact same inputs will return the same function instance.
    * The memoized cache is exposed on `factory.cache` and can be cleared
    * if needed.
    *
    * Example:
    *
    *     const name = 'log'
    *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
    *
    *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
    *       // ... create the function log here and return it
    *     }
    *
    * @param {string} name           Name of the function to be created
    * @param {string[]} dependencies The names of all required dependencies
    * @param {function} create       Callback function called with an object with all dependencies
    * @param {Object} [meta]         Optional object with meta information that will be attached
    *                                to the created factory function as property `meta`.
    * @returns {function}
    */
   function factory(name, dependencies, create, meta) {
     function assertAndCreate(scope) {
       // we only pass the requested dependencies to the factory function
       // to prevent functions to rely on dependencies that are not explicitly
       // requested.
       var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
       assertDependencies(name, dependencies, scope);
       return create(deps);
     }
     assertAndCreate.isFactory = true;
     assertAndCreate.fn = name;
     assertAndCreate.dependencies = dependencies.slice().sort();
     if (meta) {
       assertAndCreate.meta = meta;
     }
     return assertAndCreate;
   }

   /**
    * Assert that all dependencies of a list with dependencies are available in the provided scope.
    *
    * Will throw an exception when there are dependencies missing.
    *
    * @param {string} name   Name for the function to be created. Used to generate a useful error message
    * @param {string[]} dependencies
    * @param {Object} scope
    */
   function assertDependencies(name, dependencies, scope) {
     var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals
     .every(dependency => scope[dependency] !== undefined);
     if (!allDefined) {
       var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);

       // TODO: create a custom error class for this, a MathjsError or something like that
       throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map(d => "\"".concat(d, "\"")).join(', '), "."));
     }
   }
   function isOptionalDependency(dependency) {
     return dependency && dependency[0] === '?';
   }
   function stripOptionalNotation(dependency) {
     return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
   }

   /**
    * Get a property of a plain object
    * Throws an error in case the object is not a plain object or the
    * property is not defined on the object itself
    * @param {Object} object
    * @param {string} prop
    * @return {*} Returns the property value when safe
    */
   function getSafeProperty(object, prop) {
     // only allow getting safe properties of a plain object
     if (isPlainObject(object) && isSafeProperty(object, prop)) {
       return object[prop];
     }
     if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
       throw new Error('Cannot access method "' + prop + '" as a property');
     }
     throw new Error('No access to property "' + prop + '"');
   }

   /**
    * Set a property on a plain object.
    * Throws an error in case the object is not a plain object or the
    * property would override an inherited property like .constructor or .toString
    * @param {Object} object
    * @param {string} prop
    * @param {*} value
    * @return {*} Returns the value
    */
   // TODO: merge this function into access.js?
   function setSafeProperty(object, prop, value) {
     // only allow setting safe properties of a plain object
     if (isPlainObject(object) && isSafeProperty(object, prop)) {
       object[prop] = value;
       return value;
     }
     throw new Error('No access to property "' + prop + '"');
   }
   function hasSafeProperty(object, prop) {
     return prop in object;
   }

   /**
    * Test whether a property is safe to use for an object.
    * For example .toString and .constructor are not safe
    * @param {string} prop
    * @return {boolean} Returns true when safe
    */
   function isSafeProperty(object, prop) {
     if (!object || typeof object !== 'object') {
       return false;
     }
     // SAFE: whitelisted
     // e.g length
     if (hasOwnProperty(safeNativeProperties, prop)) {
       return true;
     }
     // UNSAFE: inherited from Object prototype
     // e.g constructor
     if (prop in Object.prototype) {
       // 'in' is used instead of hasOwnProperty for nodejs v0.10
       // which is inconsistent on root prototypes. It is safe
       // here because Object.prototype is a root object
       return false;
     }
     // UNSAFE: inherited from Function prototype
     // e.g call, apply
     if (prop in Function.prototype) {
       // 'in' is used instead of hasOwnProperty for nodejs v0.10
       // which is inconsistent on root prototypes. It is safe
       // here because Function.prototype is a root object
       return false;
     }
     return true;
   }

   /**
    * Validate whether a method is safe.
    * Throws an error when that's not the case.
    * @param {Object} object
    * @param {string} method
    * @return {function} Returns the method when valid
    */
   function getSafeMethod(object, method) {
     if (!isSafeMethod(object, method)) {
       throw new Error('No access to method "' + method + '"');
     }
     return object[method];
   }

   /**
    * Check whether a method is safe.
    * Throws an error when that's not the case (for example for `constructor`).
    * @param {Object} object
    * @param {string} method
    * @return {boolean} Returns true when safe, false otherwise
    */
   function isSafeMethod(object, method) {
     if (object === null || object === undefined || typeof object[method] !== 'function') {
       return false;
     }
     // UNSAFE: ghosted
     // e.g overridden toString
     // Note that IE10 doesn't support __proto__ and we can't do this check there.
     if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
       return false;
     }
     // SAFE: whitelisted
     // e.g toString
     if (hasOwnProperty(safeNativeMethods, method)) {
       return true;
     }
     // UNSAFE: inherited from Object prototype
     // e.g constructor
     if (method in Object.prototype) {
       // 'in' is used instead of hasOwnProperty for nodejs v0.10
       // which is inconsistent on root prototypes. It is safe
       // here because Object.prototype is a root object
       return false;
     }
     // UNSAFE: inherited from Function prototype
     // e.g call, apply
     if (method in Function.prototype) {
       // 'in' is used instead of hasOwnProperty for nodejs v0.10
       // which is inconsistent on root prototypes. It is safe
       // here because Function.prototype is a root object
       return false;
     }
     return true;
   }
   function isPlainObject(object) {
     return typeof object === 'object' && object && object.constructor === Object;
   }
   var safeNativeProperties = {
     length: true,
     name: true
   };
   var safeNativeMethods = {
     toString: true,
     valueOf: true,
     toLocaleString: true
   };

   /**
    * A map facade on a bare object.
    *
    * The small number of methods needed to implement a scope,
    * forwarding on to the SafeProperty functions. Over time, the codebase
    * will stop using this method, as all objects will be Maps, rather than
    * more security prone objects.
    */
   class ObjectWrappingMap {
     constructor(object) {
       this.wrappedObject = object;
     }
     keys() {
       return Object.keys(this.wrappedObject);
     }
     get(key) {
       return getSafeProperty(this.wrappedObject, key);
     }
     set(key, value) {
       setSafeProperty(this.wrappedObject, key, value);
       return this;
     }
     has(key) {
       return hasSafeProperty(this.wrappedObject, key);
     }
   }

   /**
    * Creates an empty map, or whatever your platform's polyfill is.
    *
    * @returns an empty Map or Map like object.
    */
   function createEmptyMap() {
     return new Map();
   }

   /**
    * Creates a Map from the given object.
    *
    * @param { Map | { [key: string]: unknown } | undefined } mapOrObject
    * @returns
    */
   function createMap$1(mapOrObject) {
     if (!mapOrObject) {
       return createEmptyMap();
     }
     if (isMap(mapOrObject)) {
       return mapOrObject;
     }
     if (isObject(mapOrObject)) {
       return new ObjectWrappingMap(mapOrObject);
     }
     throw new Error('createMap can create maps from objects or Maps');
   }

   /**
    * Unwraps a map into an object.
    *
    * @param {Map} map
    * @returns { [key: string]: unknown }
    */
   function toObject(map) {
     if (map instanceof ObjectWrappingMap) {
       return map.wrappedObject;
     }
     var object = {};
     for (var key of map.keys()) {
       var value = map.get(key);
       setSafeProperty(object, key, value);
     }
     return object;
   }

   /**
    * Returns `true` if the passed object appears to be a Map (i.e. duck typing).
    *
    * Methods looked for are `get`, `set`, `keys` and `has`.
    *
    * @param {Map | object} object
    * @returns
    */
   function isMap(object) {
     // We can use the fast instanceof, or a slower duck typing check.
     // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
     if (!object) {
       return false;
     }
     return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';
   }

   /**
    * Copies the contents of key-value pairs from each `objects` in to `map`.
    *
    * Object is `objects` can be a `Map` or object.
    *
    * This is the `Map` analog to `Object.assign`.
    */
   function assign(map) {
     for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       objects[_key - 1] = arguments[_key];
     }
     for (var args of objects) {
       if (!args) {
         continue;
       }
       if (isMap(args)) {
         for (var key of args.keys()) {
           map.set(key, args.get(key));
         }
       } else if (isObject(args)) {
         for (var _key2 of Object.keys(args)) {
           map.set(_key2, args[_key2]);
         }
       }
     }
     return map;
   }

   /**
    * Create a typed-function which checks the types of the arguments and
    * can match them against multiple provided signatures. The typed-function
    * automatically converts inputs in order to find a matching signature.
    * Typed functions throw informative errors in case of wrong input arguments.
    *
    * See the library [typed-function](https://github.com/josdejong/typed-function)
    * for detailed documentation.
    *
    * Syntax:
    *
    *     math.typed(name, signatures) : function
    *     math.typed(signatures) : function
    *
    * Examples:
    *
    *     // create a typed function with multiple types per argument (type union)
    *     const fn2 = typed({
    *       'number | boolean': function (b) {
    *         return 'b is a number or boolean'
    *       },
    *       'string, number | boolean': function (a, b) {
    *         return 'a is a string, b is a number or boolean'
    *       }
    *     })
    *
    *     // create a typed function with an any type argument
    *     const log = typed({
    *       'string, any': function (event, data) {
    *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
    *       }
    *     })
    *
    * @param {string} [name]                          Optional name for the typed-function
    * @param {Object<string, function>} signatures   Object with one or multiple function signatures
    * @returns {function} The created typed-function.
    */


   // returns a new instance of typed-function
   var _createTyped2 = function _createTyped() {
     // initially, return the original instance of typed-function
     // consecutively, return a new instance from typed.create.
     _createTyped2 = typedFunction.create;
     return typedFunction;
   };
   var dependencies$4O = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];

   /**
    * Factory function for creating a new typed instance
    * @param {Object} dependencies   Object with data types like Complex and BigNumber
    * @returns {Function}
    */
   var createTyped = /* #__PURE__ */factory('typed', dependencies$4O, function createTyped(_ref) {
     var {
       BigNumber,
       Complex,
       DenseMatrix,
       Fraction
     } = _ref;
     // TODO: typed-function must be able to silently ignore signatures with unknown data types

     // get a new instance of typed-function
     var typed = _createTyped2();

     // define all types. The order of the types determines in which order function
     // arguments are type-checked (so for performance it's important to put the
     // most used types first).
     typed.clear();
     typed.addTypes([{
       name: 'number',
       test: isNumber
     }, {
       name: 'Complex',
       test: isComplex
     }, {
       name: 'BigNumber',
       test: isBigNumber
     }, {
       name: 'Fraction',
       test: isFraction
     }, {
       name: 'Unit',
       test: isUnit
     },
     // The following type matches a valid variable name, i.e., an alphanumeric
     // string starting with an alphabetic character. It is used (at least)
     // in the definition of the derivative() function, as the argument telling
     // what to differentiate over must (currently) be a variable.
     {
       name: 'identifier',
       test: s => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
     }, {
       name: 'string',
       test: isString
     }, {
       name: 'Chain',
       test: isChain
     }, {
       name: 'Array',
       test: isArray
     }, {
       name: 'Matrix',
       test: isMatrix
     }, {
       name: 'DenseMatrix',
       test: isDenseMatrix
     }, {
       name: 'SparseMatrix',
       test: isSparseMatrix
     }, {
       name: 'Range',
       test: isRange
     }, {
       name: 'Index',
       test: isIndex
     }, {
       name: 'boolean',
       test: isBoolean
     }, {
       name: 'ResultSet',
       test: isResultSet
     }, {
       name: 'Help',
       test: isHelp
     }, {
       name: 'function',
       test: isFunction
     }, {
       name: 'Date',
       test: isDate
     }, {
       name: 'RegExp',
       test: isRegExp
     }, {
       name: 'null',
       test: isNull
     }, {
       name: 'undefined',
       test: isUndefined
     }, {
       name: 'AccessorNode',
       test: isAccessorNode
     }, {
       name: 'ArrayNode',
       test: isArrayNode
     }, {
       name: 'AssignmentNode',
       test: isAssignmentNode
     }, {
       name: 'BlockNode',
       test: isBlockNode
     }, {
       name: 'ConditionalNode',
       test: isConditionalNode
     }, {
       name: 'ConstantNode',
       test: isConstantNode
     }, {
       name: 'FunctionNode',
       test: isFunctionNode
     }, {
       name: 'FunctionAssignmentNode',
       test: isFunctionAssignmentNode
     }, {
       name: 'IndexNode',
       test: isIndexNode
     }, {
       name: 'Node',
       test: isNode
     }, {
       name: 'ObjectNode',
       test: isObjectNode
     }, {
       name: 'OperatorNode',
       test: isOperatorNode
     }, {
       name: 'ParenthesisNode',
       test: isParenthesisNode
     }, {
       name: 'RangeNode',
       test: isRangeNode
     }, {
       name: 'RelationalNode',
       test: isRelationalNode
     }, {
       name: 'SymbolNode',
       test: isSymbolNode
     }, {
       name: 'Map',
       test: isMap
     }, {
       name: 'Object',
       test: isObject
     } // order 'Object' last, it matches on other classes too
     ]);

     typed.addConversions([{
       from: 'number',
       to: 'BigNumber',
       convert: function convert(x) {
         if (!BigNumber) {
           throwNoBignumber(x);
         }

         // note: conversion from number to BigNumber can fail if x has >15 digits
         if (digits(x) > 15) {
           throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');
         }
         return new BigNumber(x);
       }
     }, {
       from: 'number',
       to: 'Complex',
       convert: function convert(x) {
         if (!Complex) {
           throwNoComplex(x);
         }
         return new Complex(x, 0);
       }
     }, {
       from: 'BigNumber',
       to: 'Complex',
       convert: function convert(x) {
         if (!Complex) {
           throwNoComplex(x);
         }
         return new Complex(x.toNumber(), 0);
       }
     }, {
       from: 'Fraction',
       to: 'BigNumber',
       convert: function convert(x) {
         throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
       }
     }, {
       from: 'Fraction',
       to: 'Complex',
       convert: function convert(x) {
         if (!Complex) {
           throwNoComplex(x);
         }
         return new Complex(x.valueOf(), 0);
       }
     }, {
       from: 'number',
       to: 'Fraction',
       convert: function convert(x) {
         if (!Fraction) {
           throwNoFraction(x);
         }
         var f = new Fraction(x);
         if (f.valueOf() !== x) {
           throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');
         }
         return f;
       }
     }, {
       // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
       //  from: 'Fraction',
       //  to: 'number',
       //  convert: function (x) {
       //    return x.valueOf()
       //  }
       // }, {
       from: 'string',
       to: 'number',
       convert: function convert(x) {
         var n = Number(x);
         if (isNaN(n)) {
           throw new Error('Cannot convert "' + x + '" to a number');
         }
         return n;
       }
     }, {
       from: 'string',
       to: 'BigNumber',
       convert: function convert(x) {
         if (!BigNumber) {
           throwNoBignumber(x);
         }
         try {
           return new BigNumber(x);
         } catch (err) {
           throw new Error('Cannot convert "' + x + '" to BigNumber');
         }
       }
     }, {
       from: 'string',
       to: 'Fraction',
       convert: function convert(x) {
         if (!Fraction) {
           throwNoFraction(x);
         }
         try {
           return new Fraction(x);
         } catch (err) {
           throw new Error('Cannot convert "' + x + '" to Fraction');
         }
       }
     }, {
       from: 'string',
       to: 'Complex',
       convert: function convert(x) {
         if (!Complex) {
           throwNoComplex(x);
         }
         try {
           return new Complex(x);
         } catch (err) {
           throw new Error('Cannot convert "' + x + '" to Complex');
         }
       }
     }, {
       from: 'boolean',
       to: 'number',
       convert: function convert(x) {
         return +x;
       }
     }, {
       from: 'boolean',
       to: 'BigNumber',
       convert: function convert(x) {
         if (!BigNumber) {
           throwNoBignumber(x);
         }
         return new BigNumber(+x);
       }
     }, {
       from: 'boolean',
       to: 'Fraction',
       convert: function convert(x) {
         if (!Fraction) {
           throwNoFraction(x);
         }
         return new Fraction(+x);
       }
     }, {
       from: 'boolean',
       to: 'string',
       convert: function convert(x) {
         return String(x);
       }
     }, {
       from: 'Array',
       to: 'Matrix',
       convert: function convert(array) {
         if (!DenseMatrix) {
           throwNoMatrix();
         }
         return new DenseMatrix(array);
       }
     }, {
       from: 'Matrix',
       to: 'Array',
       convert: function convert(matrix) {
         return matrix.valueOf();
       }
     }]);

     // Provide a suggestion on how to call a function elementwise
     // This was added primarily as guidance for the v10 -> v11 transition,
     // and could potentially be removed in the future if it no longer seems
     // to be helpful.
     typed.onMismatch = (name, args, signatures) => {
       var usualError = typed.createError(name, args, signatures);
       if (['wrongType', 'mismatch'].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) &&
       // check if the function can be unary:
       signatures.some(sig => !sig.params.includes(','))) {
         var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
         err.data = usualError.data;
         throw err;
       }
       throw usualError;
     };

     // Provide a suggestion on how to call a function elementwise
     // This was added primarily as guidance for the v10 -> v11 transition,
     // and could potentially be removed in the future if it no longer seems
     // to be helpful.
     typed.onMismatch = (name, args, signatures) => {
       var usualError = typed.createError(name, args, signatures);
       if (['wrongType', 'mismatch'].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) &&
       // check if the function can be unary:
       signatures.some(sig => !sig.params.includes(','))) {
         var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
         err.data = usualError.data;
         throw err;
       }
       throw usualError;
     };
     return typed;
   });
   function throwNoBignumber(x) {
     throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
   }
   function throwNoComplex(x) {
     throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
   }
   function throwNoMatrix() {
     throw new Error('Cannot convert array into a Matrix: no class \'DenseMatrix\' provided');
   }
   function throwNoFraction(x) {
     throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
   }

   var name$4O = 'ResultSet';
   var dependencies$4N = [];
   var createResultSet = /* #__PURE__ */factory(name$4O, dependencies$4N, () => {
     /**
      * A ResultSet contains a list or results
      * @class ResultSet
      * @param {Array} entries
      * @constructor ResultSet
      */
     function ResultSet(entries) {
       if (!(this instanceof ResultSet)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       this.entries = entries || [];
     }

     /**
      * Attach type information
      */
     ResultSet.prototype.type = 'ResultSet';
     ResultSet.prototype.isResultSet = true;

     /**
      * Returns the array with results hold by this ResultSet
      * @memberof ResultSet
      * @returns {Array} entries
      */
     ResultSet.prototype.valueOf = function () {
       return this.entries;
     };

     /**
      * Returns the stringified results of the ResultSet
      * @memberof ResultSet
      * @returns {string} string
      */
     ResultSet.prototype.toString = function () {
       return '[' + this.entries.join(', ') + ']';
     };

     /**
      * Get a JSON representation of the ResultSet
      * @memberof ResultSet
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "ResultSet", "entries": [...]}`
      */
     ResultSet.prototype.toJSON = function () {
       return {
         mathjs: 'ResultSet',
         entries: this.entries
       };
     };

     /**
      * Instantiate a ResultSet from a JSON object
      * @memberof ResultSet
      * @param {Object} json  A JSON object structured as:
      *                       `{"mathjs": "ResultSet", "entries": [...]}`
      * @return {ResultSet}
      */
     ResultSet.fromJSON = function (json) {
       return new ResultSet(json.entries);
     };
     return ResultSet;
   }, {
     isClass: true
   });

   /*!
    *  decimal.js v10.4.3
    *  An arbitrary-precision Decimal type for JavaScript.
    *  https://github.com/MikeMcl/decimal.js
    *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
    *  MIT Licence
    */


   // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


     // The maximum exponent magnitude.
     // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
   var EXP_LIMIT = 9e15,                      // 0 to 9e15

     // The limit on the value of `precision`, and on the value of the first argument to
     // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
     MAX_DIGITS = 1e9,                        // 0 to 1e9

     // Base conversion alphabet.
     NUMERALS = '0123456789abcdef',

     // The natural logarithm of 10 (1025 digits).
     LN10$1 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

     // Pi (1025 digits).
     PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


     // The initial configuration properties of the Decimal constructor.
     DEFAULTS = {

       // These values must be integers within the stated ranges (inclusive).
       // Most of these values can be changed at run-time using the `Decimal.config` method.

       // The maximum number of significant digits of the result of a calculation or base conversion.
       // E.g. `Decimal.config({ precision: 20 });`
       precision: 20,                         // 1 to MAX_DIGITS

       // The rounding mode used when rounding to `precision`.
       //
       // ROUND_UP         0 Away from zero.
       // ROUND_DOWN       1 Towards zero.
       // ROUND_CEIL       2 Towards +Infinity.
       // ROUND_FLOOR      3 Towards -Infinity.
       // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
       // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
       // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
       // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
       // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
       //
       // E.g.
       // `Decimal.rounding = 4;`
       // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
       rounding: 4,                           // 0 to 8

       // The modulo mode used when calculating the modulus: a mod n.
       // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
       // The remainder (r) is calculated as: r = a - n * q.
       //
       // UP         0 The remainder is positive if the dividend is negative, else is negative.
       // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
       // FLOOR      3 The remainder has the same sign as the divisor (Python %).
       // HALF_EVEN  6 The IEEE 754 remainder function.
       // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
       //
       // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
       // division (9) are commonly used for the modulus operation. The other rounding modes can also
       // be used, but they may not give useful results.
       modulo: 1,                             // 0 to 9

       // The exponent value at and beneath which `toString` returns exponential notation.
       // JavaScript numbers: -7
       toExpNeg: -7,                          // 0 to -EXP_LIMIT

       // The exponent value at and above which `toString` returns exponential notation.
       // JavaScript numbers: 21
       toExpPos:  21,                         // 0 to EXP_LIMIT

       // The minimum exponent value, beneath which underflow to zero occurs.
       // JavaScript numbers: -324  (5e-324)
       minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

       // The maximum exponent value, above which overflow to Infinity occurs.
       // JavaScript numbers: 308  (1.7976931348623157e+308)
       maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

       // Whether to use cryptographically-secure random number generation, if available.
       crypto: false                          // true/false
     },


   // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


     inexact, quadrant,
     external = true,

     decimalError = '[DecimalError] ',
     invalidArgument = decimalError + 'Invalid argument: ',
     precisionLimitExceeded = decimalError + 'Precision limit exceeded',
     cryptoUnavailable = decimalError + 'crypto unavailable',
     tag = '[object Decimal]',

     mathfloor = Math.floor,
     mathpow = Math.pow,

     isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
     isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
     isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
     isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

     BASE = 1e7,
     LOG_BASE = 7,
     MAX_SAFE_INTEGER = 9007199254740991,

     LN10_PRECISION = LN10$1.length - 1,
     PI_PRECISION = PI.length - 1,

     // Decimal.prototype object
     P$1 = { toStringTag: tag };


   // Decimal prototype methods


   /*
    *  absoluteValue             abs
    *  ceil
    *  clampedTo                 clamp
    *  comparedTo                cmp
    *  cosine                    cos
    *  cubeRoot                  cbrt
    *  decimalPlaces             dp
    *  dividedBy                 div
    *  dividedToIntegerBy        divToInt
    *  equals                    eq
    *  floor
    *  greaterThan               gt
    *  greaterThanOrEqualTo      gte
    *  hyperbolicCosine          cosh
    *  hyperbolicSine            sinh
    *  hyperbolicTangent         tanh
    *  inverseCosine             acos
    *  inverseHyperbolicCosine   acosh
    *  inverseHyperbolicSine     asinh
    *  inverseHyperbolicTangent  atanh
    *  inverseSine               asin
    *  inverseTangent            atan
    *  isFinite
    *  isInteger                 isInt
    *  isNaN
    *  isNegative                isNeg
    *  isPositive                isPos
    *  isZero
    *  lessThan                  lt
    *  lessThanOrEqualTo         lte
    *  logarithm                 log
    *  [maximum]                 [max]
    *  [minimum]                 [min]
    *  minus                     sub
    *  modulo                    mod
    *  naturalExponential        exp
    *  naturalLogarithm          ln
    *  negated                   neg
    *  plus                      add
    *  precision                 sd
    *  round
    *  sine                      sin
    *  squareRoot                sqrt
    *  tangent                   tan
    *  times                     mul
    *  toBinary
    *  toDecimalPlaces           toDP
    *  toExponential
    *  toFixed
    *  toFraction
    *  toHexadecimal             toHex
    *  toNearest
    *  toNumber
    *  toOctal
    *  toPower                   pow
    *  toPrecision
    *  toSignificantDigits       toSD
    *  toString
    *  truncated                 trunc
    *  valueOf                   toJSON
    */


   /*
    * Return a new Decimal whose value is the absolute value of this Decimal.
    *
    */
   P$1.absoluteValue = P$1.abs = function () {
     var x = new this.constructor(this);
     if (x.s < 0) x.s = 1;
     return finalise(x);
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
    * direction of positive Infinity.
    *
    */
   P$1.ceil = function () {
     return finalise(new this.constructor(this), this.e + 1, 2);
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal clamped to the range
    * delineated by `min` and `max`.
    *
    * min {number|string|Decimal}
    * max {number|string|Decimal}
    *
    */
   P$1.clampedTo = P$1.clamp = function (min, max) {
     var k,
       x = this,
       Ctor = x.constructor;
     min = new Ctor(min);
     max = new Ctor(max);
     if (!min.s || !max.s) return new Ctor(NaN);
     if (min.gt(max)) throw Error(invalidArgument + max);
     k = x.cmp(min);
     return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
   };


   /*
    * Return
    *   1    if the value of this Decimal is greater than the value of `y`,
    *  -1    if the value of this Decimal is less than the value of `y`,
    *   0    if they have the same value,
    *   NaN  if the value of either Decimal is NaN.
    *
    */
   P$1.comparedTo = P$1.cmp = function (y) {
     var i, j, xdL, ydL,
       x = this,
       xd = x.d,
       yd = (y = new x.constructor(y)).d,
       xs = x.s,
       ys = y.s;

     // Either NaN or ±Infinity?
     if (!xd || !yd) {
       return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
     }

     // Either zero?
     if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

     // Signs differ?
     if (xs !== ys) return xs;

     // Compare exponents.
     if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

     xdL = xd.length;
     ydL = yd.length;

     // Compare digit by digit.
     for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
       if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
     }

     // Compare lengths.
     return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
   };


   /*
    * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-1, 1]
    *
    * cos(0)         = 1
    * cos(-0)        = 1
    * cos(Infinity)  = NaN
    * cos(-Infinity) = NaN
    * cos(NaN)       = NaN
    *
    */
   P$1.cosine = P$1.cos = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (!x.d) return new Ctor(NaN);

     // cos(0) = cos(-0) = 1
     if (!x.d[0]) return new Ctor(1);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
     Ctor.rounding = 1;

     x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
   };


   /*
    *
    * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    *  cbrt(0)  =  0
    *  cbrt(-0) = -0
    *  cbrt(1)  =  1
    *  cbrt(-1) = -1
    *  cbrt(N)  =  N
    *  cbrt(-I) = -I
    *  cbrt(I)  =  I
    *
    * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
    *
    */
   P$1.cubeRoot = P$1.cbrt = function () {
     var e, m, n, r, rep, s, sd, t, t3, t3plusx,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite() || x.isZero()) return new Ctor(x);
     external = false;

     // Initial estimate.
     s = x.s * mathpow(x.s * x, 1 / 3);

      // Math.cbrt underflow/overflow?
      // Pass x to Math.pow as integer, then adjust the exponent of the result.
     if (!s || Math.abs(s) == 1 / 0) {
       n = digitsToString(x.d);
       e = x.e;

       // Adjust n exponent so it is a multiple of 3 away from x exponent.
       if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
       s = mathpow(n, 1 / 3);

       // Rarely, e may be one less than the result exponent value.
       e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

       if (s == 1 / 0) {
         n = '5e' + e;
       } else {
         n = s.toExponential();
         n = n.slice(0, n.indexOf('e') + 1) + e;
       }

       r = new Ctor(n);
       r.s = x.s;
     } else {
       r = new Ctor(s.toString());
     }

     sd = (e = Ctor.precision) + 3;

     // Halley's method.
     // TODO? Compare Newton's method.
     for (;;) {
       t = r;
       t3 = t.times(t).times(t);
       t3plusx = t3.plus(x);
       r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

       // TODO? Replace with for-loop and checkRoundingDigits.
       if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
         n = n.slice(sd - 3, sd + 1);

         // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
         // , i.e. approaching a rounding boundary, continue the iteration.
         if (n == '9999' || !rep && n == '4999') {

           // On the first iteration only, check to see if rounding up gives the exact result as the
           // nines may infinitely repeat.
           if (!rep) {
             finalise(t, e + 1, 0);

             if (t.times(t).times(t).eq(x)) {
               r = t;
               break;
             }
           }

           sd += 4;
           rep = 1;
         } else {

           // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
           // If not, then there are further digits and m will be truthy.
           if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

             // Truncate to the first rounding digit.
             finalise(r, e + 1, 1);
             m = !r.times(r).times(r).eq(x);
           }

           break;
         }
       }
     }

     external = true;

     return finalise(r, e, Ctor.rounding, m);
   };


   /*
    * Return the number of decimal places of the value of this Decimal.
    *
    */
   P$1.decimalPlaces = P$1.dp = function () {
     var w,
       d = this.d,
       n = NaN;

     if (d) {
       w = d.length - 1;
       n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

       // Subtract the number of trailing zeros of the last word.
       w = d[w];
       if (w) for (; w % 10 == 0; w /= 10) n--;
       if (n < 0) n = 0;
     }

     return n;
   };


   /*
    *  n / 0 = I
    *  n / N = N
    *  n / I = 0
    *  0 / n = 0
    *  0 / 0 = N
    *  0 / N = N
    *  0 / I = 0
    *  N / n = N
    *  N / 0 = N
    *  N / N = N
    *  N / I = N
    *  I / n = I
    *  I / 0 = I
    *  I / N = N
    *  I / I = N
    *
    * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    */
   P$1.dividedBy = P$1.div = function (y) {
     return divide$1(this, new this.constructor(y));
   };


   /*
    * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
    * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
    *
    */
   P$1.dividedToIntegerBy = P$1.divToInt = function (y) {
     var x = this,
       Ctor = x.constructor;
     return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
   };


   /*
    * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
    *
    */
   P$1.equals = P$1.eq = function (y) {
     return this.cmp(y) === 0;
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
    * direction of negative Infinity.
    *
    */
   P$1.floor = function () {
     return finalise(new this.constructor(this), this.e + 1, 3);
   };


   /*
    * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
    * false.
    *
    */
   P$1.greaterThan = P$1.gt = function (y) {
     return this.cmp(y) > 0;
   };


   /*
    * Return true if the value of this Decimal is greater than or equal to the value of `y`,
    * otherwise return false.
    *
    */
   P$1.greaterThanOrEqualTo = P$1.gte = function (y) {
     var k = this.cmp(y);
     return k == 1 || k === 0;
   };


   /*
    * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
    * Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [1, Infinity]
    *
    * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
    *
    * cosh(0)         = 1
    * cosh(-0)        = 1
    * cosh(Infinity)  = Infinity
    * cosh(-Infinity) = Infinity
    * cosh(NaN)       = NaN
    *
    *  x        time taken (ms)   result
    * 1000      9                 9.8503555700852349694e+433
    * 10000     25                4.4034091128314607936e+4342
    * 100000    171               1.4033316802130615897e+43429
    * 1000000   3817              1.5166076984010437725e+434294
    * 10000000  abandoned after 2 minute wait
    *
    * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
    *
    */
   P$1.hyperbolicCosine = P$1.cosh = function () {
     var k, n, pr, rm, len,
       x = this,
       Ctor = x.constructor,
       one = new Ctor(1);

     if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
     if (x.isZero()) return one;

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
     Ctor.rounding = 1;
     len = x.d.length;

     // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
     // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

     // Estimate the optimum number of times to use the argument reduction.
     // TODO? Estimation reused from cosine() and may not be optimal here.
     if (len < 32) {
       k = Math.ceil(len / 3);
       n = (1 / tinyPow(4, k)).toString();
     } else {
       k = 16;
       n = '2.3283064365386962890625e-10';
     }

     x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

     // Reverse argument reduction
     var cosh2_x,
       i = k,
       d8 = new Ctor(8);
     for (; i--;) {
       cosh2_x = x.times(x);
       x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
     }

     return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
   };


   /*
    * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
    * Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-Infinity, Infinity]
    *
    * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
    *
    * sinh(0)         = 0
    * sinh(-0)        = -0
    * sinh(Infinity)  = Infinity
    * sinh(-Infinity) = -Infinity
    * sinh(NaN)       = NaN
    *
    * x        time taken (ms)
    * 10       2 ms
    * 100      5 ms
    * 1000     14 ms
    * 10000    82 ms
    * 100000   886 ms            1.4033316802130615897e+43429
    * 200000   2613 ms
    * 300000   5407 ms
    * 400000   8824 ms
    * 500000   13026 ms          8.7080643612718084129e+217146
    * 1000000  48543 ms
    *
    * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
    *
    */
   P$1.hyperbolicSine = P$1.sinh = function () {
     var k, pr, rm, len,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite() || x.isZero()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
     Ctor.rounding = 1;
     len = x.d.length;

     if (len < 3) {
       x = taylorSeries(Ctor, 2, x, x, true);
     } else {

       // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
       // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
       // 3 multiplications and 1 addition

       // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
       // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
       // 4 multiplications and 2 additions

       // Estimate the optimum number of times to use the argument reduction.
       k = 1.4 * Math.sqrt(len);
       k = k > 16 ? 16 : k | 0;

       x = x.times(1 / tinyPow(5, k));
       x = taylorSeries(Ctor, 2, x, x, true);

       // Reverse argument reduction
       var sinh2_x,
         d5 = new Ctor(5),
         d16 = new Ctor(16),
         d20 = new Ctor(20);
       for (; k--;) {
         sinh2_x = x.times(x);
         x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
       }
     }

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return finalise(x, pr, rm, true);
   };


   /*
    * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
    * Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-1, 1]
    *
    * tanh(x) = sinh(x) / cosh(x)
    *
    * tanh(0)         = 0
    * tanh(-0)        = -0
    * tanh(Infinity)  = 1
    * tanh(-Infinity) = -1
    * tanh(NaN)       = NaN
    *
    */
   P$1.hyperbolicTangent = P$1.tanh = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite()) return new Ctor(x.s);
     if (x.isZero()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + 7;
     Ctor.rounding = 1;

     return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
   };


   /*
    * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
    * this Decimal.
    *
    * Domain: [-1, 1]
    * Range: [0, pi]
    *
    * acos(x) = pi/2 - asin(x)
    *
    * acos(0)       = pi/2
    * acos(-0)      = pi/2
    * acos(1)       = 0
    * acos(-1)      = pi
    * acos(1/2)     = pi/3
    * acos(-1/2)    = 2*pi/3
    * acos(|x| > 1) = NaN
    * acos(NaN)     = NaN
    *
    */
   P$1.inverseCosine = P$1.acos = function () {
     var halfPi,
       x = this,
       Ctor = x.constructor,
       k = x.abs().cmp(1),
       pr = Ctor.precision,
       rm = Ctor.rounding;

     if (k !== -1) {
       return k === 0
         // |x| is 1
         ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
         // |x| > 1 or x is NaN
         : new Ctor(NaN);
     }

     if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

     // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

     Ctor.precision = pr + 6;
     Ctor.rounding = 1;

     x = x.asin();
     halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return halfPi.minus(x);
   };


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
    * value of this Decimal.
    *
    * Domain: [1, Infinity]
    * Range: [0, Infinity]
    *
    * acosh(x) = ln(x + sqrt(x^2 - 1))
    *
    * acosh(x < 1)     = NaN
    * acosh(NaN)       = NaN
    * acosh(Infinity)  = Infinity
    * acosh(-Infinity) = NaN
    * acosh(0)         = NaN
    * acosh(-0)        = NaN
    * acosh(1)         = 0
    * acosh(-1)        = NaN
    *
    */
   P$1.inverseHyperbolicCosine = P$1.acosh = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
     if (!x.isFinite()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
     Ctor.rounding = 1;
     external = false;

     x = x.times(x).minus(1).sqrt().plus(x);

     external = true;
     Ctor.precision = pr;
     Ctor.rounding = rm;

     return x.ln();
   };


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
    * of this Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-Infinity, Infinity]
    *
    * asinh(x) = ln(x + sqrt(x^2 + 1))
    *
    * asinh(NaN)       = NaN
    * asinh(Infinity)  = Infinity
    * asinh(-Infinity) = -Infinity
    * asinh(0)         = 0
    * asinh(-0)        = -0
    *
    */
   P$1.inverseHyperbolicSine = P$1.asinh = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite() || x.isZero()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
     Ctor.rounding = 1;
     external = false;

     x = x.times(x).plus(1).sqrt().plus(x);

     external = true;
     Ctor.precision = pr;
     Ctor.rounding = rm;

     return x.ln();
   };


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
    * value of this Decimal.
    *
    * Domain: [-1, 1]
    * Range: [-Infinity, Infinity]
    *
    * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
    *
    * atanh(|x| > 1)   = NaN
    * atanh(NaN)       = NaN
    * atanh(Infinity)  = NaN
    * atanh(-Infinity) = NaN
    * atanh(0)         = 0
    * atanh(-0)        = -0
    * atanh(1)         = Infinity
    * atanh(-1)        = -Infinity
    *
    */
   P$1.inverseHyperbolicTangent = P$1.atanh = function () {
     var pr, rm, wpr, xsd,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite()) return new Ctor(NaN);
     if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     xsd = x.sd();

     if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

     Ctor.precision = wpr = xsd - x.e;

     x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

     Ctor.precision = pr + 4;
     Ctor.rounding = 1;

     x = x.ln();

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return x.times(0.5);
   };


   /*
    * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
    * Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-pi/2, pi/2]
    *
    * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
    *
    * asin(0)       = 0
    * asin(-0)      = -0
    * asin(1/2)     = pi/6
    * asin(-1/2)    = -pi/6
    * asin(1)       = pi/2
    * asin(-1)      = -pi/2
    * asin(|x| > 1) = NaN
    * asin(NaN)     = NaN
    *
    * TODO? Compare performance of Taylor series.
    *
    */
   P$1.inverseSine = P$1.asin = function () {
     var halfPi, k,
       pr, rm,
       x = this,
       Ctor = x.constructor;

     if (x.isZero()) return new Ctor(x);

     k = x.abs().cmp(1);
     pr = Ctor.precision;
     rm = Ctor.rounding;

     if (k !== -1) {

       // |x| is 1
       if (k === 0) {
         halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
         halfPi.s = x.s;
         return halfPi;
       }

       // |x| > 1 or x is NaN
       return new Ctor(NaN);
     }

     // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

     Ctor.precision = pr + 6;
     Ctor.rounding = 1;

     x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return x.times(2);
   };


   /*
    * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
    * of this Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-pi/2, pi/2]
    *
    * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    *
    * atan(0)         = 0
    * atan(-0)        = -0
    * atan(1)         = pi/4
    * atan(-1)        = -pi/4
    * atan(Infinity)  = pi/2
    * atan(-Infinity) = -pi/2
    * atan(NaN)       = NaN
    *
    */
   P$1.inverseTangent = P$1.atan = function () {
     var i, j, k, n, px, t, r, wpr, x2,
       x = this,
       Ctor = x.constructor,
       pr = Ctor.precision,
       rm = Ctor.rounding;

     if (!x.isFinite()) {
       if (!x.s) return new Ctor(NaN);
       if (pr + 4 <= PI_PRECISION) {
         r = getPi(Ctor, pr + 4, rm).times(0.5);
         r.s = x.s;
         return r;
       }
     } else if (x.isZero()) {
       return new Ctor(x);
     } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
       r = getPi(Ctor, pr + 4, rm).times(0.25);
       r.s = x.s;
       return r;
     }

     Ctor.precision = wpr = pr + 10;
     Ctor.rounding = 1;

     // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

     // Argument reduction
     // Ensure |x| < 0.42
     // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

     k = Math.min(28, wpr / LOG_BASE + 2 | 0);

     for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

     external = false;

     j = Math.ceil(wpr / LOG_BASE);
     n = 1;
     x2 = x.times(x);
     r = new Ctor(x);
     px = x;

     // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
     for (; i !== -1;) {
       px = px.times(x2);
       t = r.minus(px.div(n += 2));

       px = px.times(x2);
       r = t.plus(px.div(n += 2));

       if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
     }

     if (k) r = r.times(2 << (k - 1));

     external = true;

     return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
   };


   /*
    * Return true if the value of this Decimal is a finite number, otherwise return false.
    *
    */
   P$1.isFinite = function () {
     return !!this.d;
   };


   /*
    * Return true if the value of this Decimal is an integer, otherwise return false.
    *
    */
   P$1.isInteger = P$1.isInt = function () {
     return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
   };


   /*
    * Return true if the value of this Decimal is NaN, otherwise return false.
    *
    */
   P$1.isNaN = function () {
     return !this.s;
   };


   /*
    * Return true if the value of this Decimal is negative, otherwise return false.
    *
    */
   P$1.isNegative = P$1.isNeg = function () {
     return this.s < 0;
   };


   /*
    * Return true if the value of this Decimal is positive, otherwise return false.
    *
    */
   P$1.isPositive = P$1.isPos = function () {
     return this.s > 0;
   };


   /*
    * Return true if the value of this Decimal is 0 or -0, otherwise return false.
    *
    */
   P$1.isZero = function () {
     return !!this.d && this.d[0] === 0;
   };


   /*
    * Return true if the value of this Decimal is less than `y`, otherwise return false.
    *
    */
   P$1.lessThan = P$1.lt = function (y) {
     return this.cmp(y) < 0;
   };


   /*
    * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
    *
    */
   P$1.lessThanOrEqualTo = P$1.lte = function (y) {
     return this.cmp(y) < 1;
   };


   /*
    * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * If no base is specified, return log[10](arg).
    *
    * log[base](arg) = ln(arg) / ln(base)
    *
    * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
    * otherwise:
    *
    * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
    * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
    * between the result and the correctly rounded result will be one ulp (unit in the last place).
    *
    * log[-b](a)       = NaN
    * log[0](a)        = NaN
    * log[1](a)        = NaN
    * log[NaN](a)      = NaN
    * log[Infinity](a) = NaN
    * log[b](0)        = -Infinity
    * log[b](-0)       = -Infinity
    * log[b](-a)       = NaN
    * log[b](1)        = 0
    * log[b](Infinity) = Infinity
    * log[b](NaN)      = NaN
    *
    * [base] {number|string|Decimal} The base of the logarithm.
    *
    */
   P$1.logarithm = P$1.log = function (base) {
     var isBase10, d, denominator, k, inf, num, sd, r,
       arg = this,
       Ctor = arg.constructor,
       pr = Ctor.precision,
       rm = Ctor.rounding,
       guard = 5;

     // Default base is 10.
     if (base == null) {
       base = new Ctor(10);
       isBase10 = true;
     } else {
       base = new Ctor(base);
       d = base.d;

       // Return NaN if base is negative, or non-finite, or is 0 or 1.
       if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

       isBase10 = base.eq(10);
     }

     d = arg.d;

     // Is arg negative, non-finite, 0 or 1?
     if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
       return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
     }

     // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
     // integer power of 10.
     if (isBase10) {
       if (d.length > 1) {
         inf = true;
       } else {
         for (k = d[0]; k % 10 === 0;) k /= 10;
         inf = k !== 1;
       }
     }

     external = false;
     sd = pr + guard;
     num = naturalLogarithm(arg, sd);
     denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

     // The result will have 5 rounding digits.
     r = divide$1(num, denominator, sd, 1);

     // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
     // calculate 10 further digits.
     //
     // If the result is known to have an infinite decimal expansion, repeat this until it is clear
     // that the result is above or below the boundary. Otherwise, if after calculating the 10
     // further digits, the last 14 are nines, round up and assume the result is exact.
     // Also assume the result is exact if the last 14 are zero.
     //
     // Example of a result that will be incorrectly rounded:
     // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
     // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
     // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
     // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
     // place is still 2.6.
     if (checkRoundingDigits(r.d, k = pr, rm)) {

       do {
         sd += 10;
         num = naturalLogarithm(arg, sd);
         denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
         r = divide$1(num, denominator, sd, 1);

         if (!inf) {

           // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
           if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
             r = finalise(r, pr + 1, 0);
           }

           break;
         }
       } while (checkRoundingDigits(r.d, k += 10, rm));
     }

     external = true;

     return finalise(r, pr, rm);
   };


   /*
    * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
    *
    * arguments {number|string|Decimal}
    *
   P.max = function () {
     Array.prototype.push.call(arguments, this);
     return maxOrMin(this.constructor, arguments, 'lt');
   };
    */


   /*
    * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
    *
    * arguments {number|string|Decimal}
    *
   P.min = function () {
     Array.prototype.push.call(arguments, this);
     return maxOrMin(this.constructor, arguments, 'gt');
   };
    */


   /*
    *  n - 0 = n
    *  n - N = N
    *  n - I = -I
    *  0 - n = -n
    *  0 - 0 = 0
    *  0 - N = N
    *  0 - I = -I
    *  N - n = N
    *  N - 0 = N
    *  N - N = N
    *  N - I = N
    *  I - n = I
    *  I - 0 = I
    *  I - N = N
    *  I - I = N
    *
    * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    */
   P$1.minus = P$1.sub = function (y) {
     var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
       x = this,
       Ctor = x.constructor;

     y = new Ctor(y);

     // If either is not finite...
     if (!x.d || !y.d) {

       // Return NaN if either is NaN.
       if (!x.s || !y.s) y = new Ctor(NaN);

       // Return y negated if x is finite and y is ±Infinity.
       else if (x.d) y.s = -y.s;

       // Return x if y is finite and x is ±Infinity.
       // Return x if both are ±Infinity with different signs.
       // Return NaN if both are ±Infinity with the same sign.
       else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

       return y;
     }

     // If signs differ...
     if (x.s != y.s) {
       y.s = -y.s;
       return x.plus(y);
     }

     xd = x.d;
     yd = y.d;
     pr = Ctor.precision;
     rm = Ctor.rounding;

     // If either is zero...
     if (!xd[0] || !yd[0]) {

       // Return y negated if x is zero and y is non-zero.
       if (yd[0]) y.s = -y.s;

       // Return x if y is zero and x is non-zero.
       else if (xd[0]) y = new Ctor(x);

       // Return zero if both are zero.
       // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
       else return new Ctor(rm === 3 ? -0 : 0);

       return external ? finalise(y, pr, rm) : y;
     }

     // x and y are finite, non-zero numbers with the same sign.

     // Calculate base 1e7 exponents.
     e = mathfloor(y.e / LOG_BASE);
     xe = mathfloor(x.e / LOG_BASE);

     xd = xd.slice();
     k = xe - e;

     // If base 1e7 exponents differ...
     if (k) {
       xLTy = k < 0;

       if (xLTy) {
         d = xd;
         k = -k;
         len = yd.length;
       } else {
         d = yd;
         e = xe;
         len = xd.length;
       }

       // Numbers with massively different exponents would result in a very high number of
       // zeros needing to be prepended, but this can be avoided while still ensuring correct
       // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
       i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

       if (k > i) {
         k = i;
         d.length = 1;
       }

       // Prepend zeros to equalise exponents.
       d.reverse();
       for (i = k; i--;) d.push(0);
       d.reverse();

     // Base 1e7 exponents equal.
     } else {

       // Check digits to determine which is the bigger number.

       i = xd.length;
       len = yd.length;
       xLTy = i < len;
       if (xLTy) len = i;

       for (i = 0; i < len; i++) {
         if (xd[i] != yd[i]) {
           xLTy = xd[i] < yd[i];
           break;
         }
       }

       k = 0;
     }

     if (xLTy) {
       d = xd;
       xd = yd;
       yd = d;
       y.s = -y.s;
     }

     len = xd.length;

     // Append zeros to `xd` if shorter.
     // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
     for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

     // Subtract yd from xd.
     for (i = yd.length; i > k;) {

       if (xd[--i] < yd[i]) {
         for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
         --xd[j];
         xd[i] += BASE;
       }

       xd[i] -= yd[i];
     }

     // Remove trailing zeros.
     for (; xd[--len] === 0;) xd.pop();

     // Remove leading zeros and adjust exponent accordingly.
     for (; xd[0] === 0; xd.shift()) --e;

     // Zero?
     if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

     y.d = xd;
     y.e = getBase10Exponent(xd, e);

     return external ? finalise(y, pr, rm) : y;
   };


   /*
    *   n % 0 =  N
    *   n % N =  N
    *   n % I =  n
    *   0 % n =  0
    *  -0 % n = -0
    *   0 % 0 =  N
    *   0 % N =  N
    *   0 % I =  0
    *   N % n =  N
    *   N % 0 =  N
    *   N % N =  N
    *   N % I =  N
    *   I % n =  N
    *   I % 0 =  N
    *   I % N =  N
    *   I % I =  N
    *
    * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    * The result depends on the modulo mode.
    *
    */
   P$1.modulo = P$1.mod = function (y) {
     var q,
       x = this,
       Ctor = x.constructor;

     y = new Ctor(y);

     // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
     if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

     // Return x if y is ±Infinity or x is ±0.
     if (!y.d || x.d && !x.d[0]) {
       return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
     }

     // Prevent rounding of intermediate calculations.
     external = false;

     if (Ctor.modulo == 9) {

       // Euclidian division: q = sign(y) * floor(x / abs(y))
       // result = x - q * y    where  0 <= result < abs(y)
       q = divide$1(x, y.abs(), 0, 3, 1);
       q.s *= y.s;
     } else {
       q = divide$1(x, y, 0, Ctor.modulo, 1);
     }

     q = q.times(y);

     external = true;

     return x.minus(q);
   };


   /*
    * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
    * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    */
   P$1.naturalExponential = P$1.exp = function () {
     return naturalExponential(this);
   };


   /*
    * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
    * rounded to `precision` significant digits using rounding mode `rounding`.
    *
    */
   P$1.naturalLogarithm = P$1.ln = function () {
     return naturalLogarithm(this);
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
    * -1.
    *
    */
   P$1.negated = P$1.neg = function () {
     var x = new this.constructor(this);
     x.s = -x.s;
     return finalise(x);
   };


   /*
    *  n + 0 = n
    *  n + N = N
    *  n + I = I
    *  0 + n = n
    *  0 + 0 = 0
    *  0 + N = N
    *  0 + I = I
    *  N + n = N
    *  N + 0 = N
    *  N + N = N
    *  N + I = N
    *  I + n = I
    *  I + 0 = I
    *  I + N = N
    *  I + I = I
    *
    * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    */
   P$1.plus = P$1.add = function (y) {
     var carry, d, e, i, k, len, pr, rm, xd, yd,
       x = this,
       Ctor = x.constructor;

     y = new Ctor(y);

     // If either is not finite...
     if (!x.d || !y.d) {

       // Return NaN if either is NaN.
       if (!x.s || !y.s) y = new Ctor(NaN);

       // Return x if y is finite and x is ±Infinity.
       // Return x if both are ±Infinity with the same sign.
       // Return NaN if both are ±Infinity with different signs.
       // Return y if x is finite and y is ±Infinity.
       else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

       return y;
     }

      // If signs differ...
     if (x.s != y.s) {
       y.s = -y.s;
       return x.minus(y);
     }

     xd = x.d;
     yd = y.d;
     pr = Ctor.precision;
     rm = Ctor.rounding;

     // If either is zero...
     if (!xd[0] || !yd[0]) {

       // Return x if y is zero.
       // Return y if y is non-zero.
       if (!yd[0]) y = new Ctor(x);

       return external ? finalise(y, pr, rm) : y;
     }

     // x and y are finite, non-zero numbers with the same sign.

     // Calculate base 1e7 exponents.
     k = mathfloor(x.e / LOG_BASE);
     e = mathfloor(y.e / LOG_BASE);

     xd = xd.slice();
     i = k - e;

     // If base 1e7 exponents differ...
     if (i) {

       if (i < 0) {
         d = xd;
         i = -i;
         len = yd.length;
       } else {
         d = yd;
         e = k;
         len = xd.length;
       }

       // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
       k = Math.ceil(pr / LOG_BASE);
       len = k > len ? k + 1 : len + 1;

       if (i > len) {
         i = len;
         d.length = 1;
       }

       // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
       d.reverse();
       for (; i--;) d.push(0);
       d.reverse();
     }

     len = xd.length;
     i = yd.length;

     // If yd is longer than xd, swap xd and yd so xd points to the longer array.
     if (len - i < 0) {
       i = len;
       d = yd;
       yd = xd;
       xd = d;
     }

     // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
     for (carry = 0; i;) {
       carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
       xd[i] %= BASE;
     }

     if (carry) {
       xd.unshift(carry);
       ++e;
     }

     // Remove trailing zeros.
     // No need to check for zero, as +x + +y != 0 && -x + -y != 0
     for (len = xd.length; xd[--len] == 0;) xd.pop();

     y.d = xd;
     y.e = getBase10Exponent(xd, e);

     return external ? finalise(y, pr, rm) : y;
   };


   /*
    * Return the number of significant digits of the value of this Decimal.
    *
    * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
    *
    */
   P$1.precision = P$1.sd = function (z) {
     var k,
       x = this;

     if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

     if (x.d) {
       k = getPrecision(x.d);
       if (z && x.e + 1 > k) k = x.e + 1;
     } else {
       k = NaN;
     }

     return k;
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
    * rounding mode `rounding`.
    *
    */
   P$1.round = function () {
     var x = this,
       Ctor = x.constructor;

     return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
   };


   /*
    * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-1, 1]
    *
    * sin(x) = x - x^3/3! + x^5/5! - ...
    *
    * sin(0)         = 0
    * sin(-0)        = -0
    * sin(Infinity)  = NaN
    * sin(-Infinity) = NaN
    * sin(NaN)       = NaN
    *
    */
   P$1.sine = P$1.sin = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite()) return new Ctor(NaN);
     if (x.isZero()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
     Ctor.rounding = 1;

     x = sine(Ctor, toLessThanHalfPi(Ctor, x));

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
   };


   /*
    * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    *  sqrt(-n) =  N
    *  sqrt(N)  =  N
    *  sqrt(-I) =  N
    *  sqrt(I)  =  I
    *  sqrt(0)  =  0
    *  sqrt(-0) = -0
    *
    */
   P$1.squareRoot = P$1.sqrt = function () {
     var m, n, sd, r, rep, t,
       x = this,
       d = x.d,
       e = x.e,
       s = x.s,
       Ctor = x.constructor;

     // Negative/NaN/Infinity/zero?
     if (s !== 1 || !d || !d[0]) {
       return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
     }

     external = false;

     // Initial estimate.
     s = Math.sqrt(+x);

     // Math.sqrt underflow/overflow?
     // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
     if (s == 0 || s == 1 / 0) {
       n = digitsToString(d);

       if ((n.length + e) % 2 == 0) n += '0';
       s = Math.sqrt(n);
       e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

       if (s == 1 / 0) {
         n = '5e' + e;
       } else {
         n = s.toExponential();
         n = n.slice(0, n.indexOf('e') + 1) + e;
       }

       r = new Ctor(n);
     } else {
       r = new Ctor(s.toString());
     }

     sd = (e = Ctor.precision) + 3;

     // Newton-Raphson iteration.
     for (;;) {
       t = r;
       r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);

       // TODO? Replace with for-loop and checkRoundingDigits.
       if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
         n = n.slice(sd - 3, sd + 1);

         // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
         // 4999, i.e. approaching a rounding boundary, continue the iteration.
         if (n == '9999' || !rep && n == '4999') {

           // On the first iteration only, check to see if rounding up gives the exact result as the
           // nines may infinitely repeat.
           if (!rep) {
             finalise(t, e + 1, 0);

             if (t.times(t).eq(x)) {
               r = t;
               break;
             }
           }

           sd += 4;
           rep = 1;
         } else {

           // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
           // If not, then there are further digits and m will be truthy.
           if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

             // Truncate to the first rounding digit.
             finalise(r, e + 1, 1);
             m = !r.times(r).eq(x);
           }

           break;
         }
       }
     }

     external = true;

     return finalise(r, e, Ctor.rounding, m);
   };


   /*
    * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-Infinity, Infinity]
    *
    * tan(0)         = 0
    * tan(-0)        = -0
    * tan(Infinity)  = NaN
    * tan(-Infinity) = NaN
    * tan(NaN)       = NaN
    *
    */
   P$1.tangent = P$1.tan = function () {
     var pr, rm,
       x = this,
       Ctor = x.constructor;

     if (!x.isFinite()) return new Ctor(NaN);
     if (x.isZero()) return new Ctor(x);

     pr = Ctor.precision;
     rm = Ctor.rounding;
     Ctor.precision = pr + 10;
     Ctor.rounding = 1;

     x = x.sin();
     x.s = 1;
     x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

     Ctor.precision = pr;
     Ctor.rounding = rm;

     return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
   };


   /*
    *  n * 0 = 0
    *  n * N = N
    *  n * I = I
    *  0 * n = 0
    *  0 * 0 = 0
    *  0 * N = N
    *  0 * I = N
    *  N * n = N
    *  N * 0 = N
    *  N * N = N
    *  N * I = N
    *  I * n = I
    *  I * 0 = N
    *  I * N = N
    *  I * I = I
    *
    * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    */
   P$1.times = P$1.mul = function (y) {
     var carry, e, i, k, r, rL, t, xdL, ydL,
       x = this,
       Ctor = x.constructor,
       xd = x.d,
       yd = (y = new Ctor(y)).d;

     y.s *= x.s;

      // If either is NaN, ±Infinity or ±0...
     if (!xd || !xd[0] || !yd || !yd[0]) {

       return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

         // Return NaN if either is NaN.
         // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
         ? NaN

         // Return ±Infinity if either is ±Infinity.
         // Return ±0 if either is ±0.
         : !xd || !yd ? y.s / 0 : y.s * 0);
     }

     e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
     xdL = xd.length;
     ydL = yd.length;

     // Ensure xd points to the longer array.
     if (xdL < ydL) {
       r = xd;
       xd = yd;
       yd = r;
       rL = xdL;
       xdL = ydL;
       ydL = rL;
     }

     // Initialise the result array with zeros.
     r = [];
     rL = xdL + ydL;
     for (i = rL; i--;) r.push(0);

     // Multiply!
     for (i = ydL; --i >= 0;) {
       carry = 0;
       for (k = xdL + i; k > i;) {
         t = r[k] + yd[i] * xd[k - i - 1] + carry;
         r[k--] = t % BASE | 0;
         carry = t / BASE | 0;
       }

       r[k] = (r[k] + carry) % BASE | 0;
     }

     // Remove trailing zeros.
     for (; !r[--rL];) r.pop();

     if (carry) ++e;
     else r.shift();

     y.d = r;
     y.e = getBase10Exponent(r, e);

     return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
   };


   /*
    * Return a string representing the value of this Decimal in base 2, round to `sd` significant
    * digits using rounding mode `rm`.
    *
    * If the optional `sd` argument is present then return binary exponential notation.
    *
    * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toBinary = function (sd, rm) {
     return toStringBinary(this, 2, sd, rm);
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
    * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
    *
    * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
    *
    * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toDecimalPlaces = P$1.toDP = function (dp, rm) {
     var x = this,
       Ctor = x.constructor;

     x = new Ctor(x);
     if (dp === void 0) return x;

     checkInt32(dp, 0, MAX_DIGITS);

     if (rm === void 0) rm = Ctor.rounding;
     else checkInt32(rm, 0, 8);

     return finalise(x, dp + x.e + 1, rm);
   };


   /*
    * Return a string representing the value of this Decimal in exponential notation rounded to
    * `dp` fixed decimal places using rounding mode `rounding`.
    *
    * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toExponential = function (dp, rm) {
     var str,
       x = this,
       Ctor = x.constructor;

     if (dp === void 0) {
       str = finiteToString(x, true);
     } else {
       checkInt32(dp, 0, MAX_DIGITS);

       if (rm === void 0) rm = Ctor.rounding;
       else checkInt32(rm, 0, 8);

       x = finalise(new Ctor(x), dp + 1, rm);
       str = finiteToString(x, true, dp + 1);
     }

     return x.isNeg() && !x.isZero() ? '-' + str : str;
   };


   /*
    * Return a string representing the value of this Decimal in normal (fixed-point) notation to
    * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
    * omitted.
    *
    * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
    *
    * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
    * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
    * (-0).toFixed(3) is '0.000'.
    * (-0.5).toFixed(0) is '-0'.
    *
    */
   P$1.toFixed = function (dp, rm) {
     var str, y,
       x = this,
       Ctor = x.constructor;

     if (dp === void 0) {
       str = finiteToString(x);
     } else {
       checkInt32(dp, 0, MAX_DIGITS);

       if (rm === void 0) rm = Ctor.rounding;
       else checkInt32(rm, 0, 8);

       y = finalise(new Ctor(x), dp + x.e + 1, rm);
       str = finiteToString(y, false, dp + y.e + 1);
     }

     // To determine whether to add the minus sign look at the value before it was rounded,
     // i.e. look at `x` rather than `y`.
     return x.isNeg() && !x.isZero() ? '-' + str : str;
   };


   /*
    * Return an array representing the value of this Decimal as a simple fraction with an integer
    * numerator and an integer denominator.
    *
    * The denominator will be a positive non-zero value less than or equal to the specified maximum
    * denominator. If a maximum denominator is not specified, the denominator will be the lowest
    * value necessary to represent the number exactly.
    *
    * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
    *
    */
   P$1.toFraction = function (maxD) {
     var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
       x = this,
       xd = x.d,
       Ctor = x.constructor;

     if (!xd) return new Ctor(x);

     n1 = d0 = new Ctor(1);
     d1 = n0 = new Ctor(0);

     d = new Ctor(d1);
     e = d.e = getPrecision(xd) - x.e - 1;
     k = e % LOG_BASE;
     d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

     if (maxD == null) {

       // d is 10**e, the minimum max-denominator needed.
       maxD = e > 0 ? d : n1;
     } else {
       n = new Ctor(maxD);
       if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
       maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
     }

     external = false;
     n = new Ctor(digitsToString(xd));
     pr = Ctor.precision;
     Ctor.precision = e = xd.length * LOG_BASE * 2;

     for (;;)  {
       q = divide$1(n, d, 0, 1, 1);
       d2 = d0.plus(q.times(d1));
       if (d2.cmp(maxD) == 1) break;
       d0 = d1;
       d1 = d2;
       d2 = n1;
       n1 = n0.plus(q.times(d2));
       n0 = d2;
       d2 = d;
       d = n.minus(q.times(d2));
       n = d2;
     }

     d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
     n0 = n0.plus(d2.times(n1));
     d0 = d0.plus(d2.times(d1));
     n0.s = n1.s = x.s;

     // Determine which fraction is closer to x, n0/d0 or n1/d1?
     r = divide$1(n1, d1, e, 1).minus(x).abs().cmp(divide$1(n0, d0, e, 1).minus(x).abs()) < 1
         ? [n1, d1] : [n0, d0];

     Ctor.precision = pr;
     external = true;

     return r;
   };


   /*
    * Return a string representing the value of this Decimal in base 16, round to `sd` significant
    * digits using rounding mode `rm`.
    *
    * If the optional `sd` argument is present then return binary exponential notation.
    *
    * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toHexadecimal = P$1.toHex = function (sd, rm) {
     return toStringBinary(this, 16, sd, rm);
   };


   /*
    * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
    * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
    *
    * The return value will always have the same sign as this Decimal, unless either this Decimal
    * or `y` is NaN, in which case the return value will be also be NaN.
    *
    * The return value is not affected by the value of `precision`.
    *
    * y {number|string|Decimal} The magnitude to round to a multiple of.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    * 'toNearest() rounding mode not an integer: {rm}'
    * 'toNearest() rounding mode out of range: {rm}'
    *
    */
   P$1.toNearest = function (y, rm) {
     var x = this,
       Ctor = x.constructor;

     x = new Ctor(x);

     if (y == null) {

       // If x is not finite, return x.
       if (!x.d) return x;

       y = new Ctor(1);
       rm = Ctor.rounding;
     } else {
       y = new Ctor(y);
       if (rm === void 0) {
         rm = Ctor.rounding;
       } else {
         checkInt32(rm, 0, 8);
       }

       // If x is not finite, return x if y is not NaN, else NaN.
       if (!x.d) return y.s ? x : y;

       // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
       if (!y.d) {
         if (y.s) y.s = x.s;
         return y;
       }
     }

     // If y is not zero, calculate the nearest multiple of y to x.
     if (y.d[0]) {
       external = false;
       x = divide$1(x, y, 0, rm, 1).times(y);
       external = true;
       finalise(x);

     // If y is zero, return zero with the sign of x.
     } else {
       y.s = x.s;
       x = y;
     }

     return x;
   };


   /*
    * Return the value of this Decimal converted to a number primitive.
    * Zero keeps its sign.
    *
    */
   P$1.toNumber = function () {
     return +this;
   };


   /*
    * Return a string representing the value of this Decimal in base 8, round to `sd` significant
    * digits using rounding mode `rm`.
    *
    * If the optional `sd` argument is present then return binary exponential notation.
    *
    * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toOctal = function (sd, rm) {
     return toStringBinary(this, 8, sd, rm);
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
    * to `precision` significant digits using rounding mode `rounding`.
    *
    * ECMAScript compliant.
    *
    *   pow(x, NaN)                           = NaN
    *   pow(x, ±0)                            = 1

    *   pow(NaN, non-zero)                    = NaN
    *   pow(abs(x) > 1, +Infinity)            = +Infinity
    *   pow(abs(x) > 1, -Infinity)            = +0
    *   pow(abs(x) == 1, ±Infinity)           = NaN
    *   pow(abs(x) < 1, +Infinity)            = +0
    *   pow(abs(x) < 1, -Infinity)            = +Infinity
    *   pow(+Infinity, y > 0)                 = +Infinity
    *   pow(+Infinity, y < 0)                 = +0
    *   pow(-Infinity, odd integer > 0)       = -Infinity
    *   pow(-Infinity, even integer > 0)      = +Infinity
    *   pow(-Infinity, odd integer < 0)       = -0
    *   pow(-Infinity, even integer < 0)      = +0
    *   pow(+0, y > 0)                        = +0
    *   pow(+0, y < 0)                        = +Infinity
    *   pow(-0, odd integer > 0)              = -0
    *   pow(-0, even integer > 0)             = +0
    *   pow(-0, odd integer < 0)              = -Infinity
    *   pow(-0, even integer < 0)             = +Infinity
    *   pow(finite x < 0, finite non-integer) = NaN
    *
    * For non-integer or very large exponents pow(x, y) is calculated using
    *
    *   x^y = exp(y*ln(x))
    *
    * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
    * probability of an incorrectly rounded result
    * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
    * i.e. 1 in 250,000,000,000,000
    *
    * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
    *
    * y {number|string|Decimal} The power to which to raise this Decimal.
    *
    */
   P$1.toPower = P$1.pow = function (y) {
     var e, k, pr, r, rm, s,
       x = this,
       Ctor = x.constructor,
       yn = +(y = new Ctor(y));

     // Either ±Infinity, NaN or ±0?
     if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

     x = new Ctor(x);

     if (x.eq(1)) return x;

     pr = Ctor.precision;
     rm = Ctor.rounding;

     if (y.eq(1)) return finalise(x, pr, rm);

     // y exponent
     e = mathfloor(y.e / LOG_BASE);

     // If y is a small integer use the 'exponentiation by squaring' algorithm.
     if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
       r = intPow(Ctor, x, k, pr);
       return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
     }

     s = x.s;

     // if x is negative
     if (s < 0) {

       // if y is not an integer
       if (e < y.d.length - 1) return new Ctor(NaN);

       // Result is positive if x is negative and the last digit of integer y is even.
       if ((y.d[e] & 1) == 0) s = 1;

       // if x.eq(-1)
       if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
         x.s = s;
         return x;
       }
     }

     // Estimate result exponent.
     // x^y = 10^e,  where e = y * log10(x)
     // log10(x) = log10(x_significand) + x_exponent
     // log10(x_significand) = ln(x_significand) / ln(10)
     k = mathpow(+x, yn);
     e = k == 0 || !isFinite(k)
       ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
       : new Ctor(k + '').e;

     // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

     // Overflow/underflow?
     if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

     external = false;
     Ctor.rounding = x.s = 1;

     // Estimate the extra guard digits needed to ensure five correct rounding digits from
     // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
     // new Decimal(2.32456).pow('2087987436534566.46411')
     // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
     k = Math.min(12, (e + '').length);

     // r = x^y = exp(y*ln(x))
     r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

     // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
     if (r.d) {

       // Truncate to the required precision plus five rounding digits.
       r = finalise(r, pr + 5, 1);

       // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
       // the result.
       if (checkRoundingDigits(r.d, pr, rm)) {
         e = pr + 10;

         // Truncate to the increased precision plus five rounding digits.
         r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

         // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
         if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
           r = finalise(r, pr + 1, 0);
         }
       }
     }

     r.s = s;
     external = true;
     Ctor.rounding = rm;

     return finalise(r, pr, rm);
   };


   /*
    * Return a string representing the value of this Decimal rounded to `sd` significant digits
    * using rounding mode `rounding`.
    *
    * Return exponential notation if `sd` is less than the number of digits necessary to represent
    * the integer part of the value in normal notation.
    *
    * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    */
   P$1.toPrecision = function (sd, rm) {
     var str,
       x = this,
       Ctor = x.constructor;

     if (sd === void 0) {
       str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
     } else {
       checkInt32(sd, 1, MAX_DIGITS);

       if (rm === void 0) rm = Ctor.rounding;
       else checkInt32(rm, 0, 8);

       x = finalise(new Ctor(x), sd, rm);
       str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
     }

     return x.isNeg() && !x.isZero() ? '-' + str : str;
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
    * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
    * omitted.
    *
    * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
    * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
    *
    * 'toSD() digits out of range: {sd}'
    * 'toSD() digits not an integer: {sd}'
    * 'toSD() rounding mode not an integer: {rm}'
    * 'toSD() rounding mode out of range: {rm}'
    *
    */
   P$1.toSignificantDigits = P$1.toSD = function (sd, rm) {
     var x = this,
       Ctor = x.constructor;

     if (sd === void 0) {
       sd = Ctor.precision;
       rm = Ctor.rounding;
     } else {
       checkInt32(sd, 1, MAX_DIGITS);

       if (rm === void 0) rm = Ctor.rounding;
       else checkInt32(rm, 0, 8);
     }

     return finalise(new Ctor(x), sd, rm);
   };


   /*
    * Return a string representing the value of this Decimal.
    *
    * Return exponential notation if this Decimal has a positive exponent equal to or greater than
    * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
    *
    */
   P$1.toString = function () {
     var x = this,
       Ctor = x.constructor,
       str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

     return x.isNeg() && !x.isZero() ? '-' + str : str;
   };


   /*
    * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
    *
    */
   P$1.truncated = P$1.trunc = function () {
     return finalise(new this.constructor(this), this.e + 1, 1);
   };


   /*
    * Return a string representing the value of this Decimal.
    * Unlike `toString`, negative zero will include the minus sign.
    *
    */
   P$1.valueOf = P$1.toJSON = function () {
     var x = this,
       Ctor = x.constructor,
       str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

     return x.isNeg() ? '-' + str : str;
   };


   // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


   /*
    *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
    *                           finiteToString, naturalExponential, naturalLogarithm
    *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
    *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
    *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
    *  convertBase              toStringBinary, parseOther
    *  cos                      P.cos
    *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
    *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
    *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
    *                           taylorSeries, atan2, parseOther
    *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
    *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
    *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
    *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
    *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
    *                           P.truncated, divide, getLn10, getPi, naturalExponential,
    *                           naturalLogarithm, ceil, floor, round, trunc
    *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
    *                           toStringBinary
    *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
    *  getLn10                  P.logarithm, naturalLogarithm
    *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
    *  getPrecision             P.precision, P.toFraction
    *  getZeroString            digitsToString, finiteToString
    *  intPow                   P.toPower, parseOther
    *  isOdd                    toLessThanHalfPi
    *  maxOrMin                 max, min
    *  naturalExponential       P.naturalExponential, P.toPower
    *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
    *                           P.toPower, naturalExponential
    *  nonFiniteToString        finiteToString, toStringBinary
    *  parseDecimal             Decimal
    *  parseOther               Decimal
    *  sin                      P.sin
    *  taylorSeries             P.cosh, P.sinh, cos, sin
    *  toLessThanHalfPi         P.cos, P.sin
    *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
    *  truncate                 intPow
    *
    *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
    *                           naturalLogarithm, config, parseOther, random, Decimal
    */


   function digitsToString(d) {
     var i, k, ws,
       indexOfLastWord = d.length - 1,
       str = '',
       w = d[0];

     if (indexOfLastWord > 0) {
       str += w;
       for (i = 1; i < indexOfLastWord; i++) {
         ws = d[i] + '';
         k = LOG_BASE - ws.length;
         if (k) str += getZeroString(k);
         str += ws;
       }

       w = d[i];
       ws = w + '';
       k = LOG_BASE - ws.length;
       if (k) str += getZeroString(k);
     } else if (w === 0) {
       return '0';
     }

     // Remove trailing zeros of last w.
     for (; w % 10 === 0;) w /= 10;

     return str + w;
   }


   function checkInt32(i, min, max) {
     if (i !== ~~i || i < min || i > max) {
       throw Error(invalidArgument + i);
     }
   }


   /*
    * Check 5 rounding digits if `repeating` is null, 4 otherwise.
    * `repeating == null` if caller is `log` or `pow`,
    * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
    */
   function checkRoundingDigits(d, i, rm, repeating) {
     var di, k, r, rd;

     // Get the length of the first word of the array d.
     for (k = d[0]; k >= 10; k /= 10) --i;

     // Is the rounding digit in the first word of d?
     if (--i < 0) {
       i += LOG_BASE;
       di = 0;
     } else {
       di = Math.ceil((i + 1) / LOG_BASE);
       i %= LOG_BASE;
     }

     // i is the index (0 - 6) of the rounding digit.
     // E.g. if within the word 3487563 the first rounding digit is 5,
     // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
     k = mathpow(10, LOG_BASE - i);
     rd = d[di] % k | 0;

     if (repeating == null) {
       if (i < 3) {
         if (i == 0) rd = rd / 100 | 0;
         else if (i == 1) rd = rd / 10 | 0;
         r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
       } else {
         r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
           (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
             (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
       }
     } else {
       if (i < 4) {
         if (i == 0) rd = rd / 1000 | 0;
         else if (i == 1) rd = rd / 100 | 0;
         else if (i == 2) rd = rd / 10 | 0;
         r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
       } else {
         r = ((repeating || rm < 4) && rd + 1 == k ||
         (!repeating && rm > 3) && rd + 1 == k / 2) &&
           (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
       }
     }

     return r;
   }


   // Convert string of `baseIn` to an array of numbers of `baseOut`.
   // Eg. convertBase('255', 10, 16) returns [15, 15].
   // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
   function convertBase(str, baseIn, baseOut) {
     var j,
       arr = [0],
       arrL,
       i = 0,
       strL = str.length;

     for (; i < strL;) {
       for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
       arr[0] += NUMERALS.indexOf(str.charAt(i++));
       for (j = 0; j < arr.length; j++) {
         if (arr[j] > baseOut - 1) {
           if (arr[j + 1] === void 0) arr[j + 1] = 0;
           arr[j + 1] += arr[j] / baseOut | 0;
           arr[j] %= baseOut;
         }
       }
     }

     return arr.reverse();
   }


   /*
    * cos(x) = 1 - x^2/2! + x^4/4! - ...
    * |x| < pi/2
    *
    */
   function cosine(Ctor, x) {
     var k, len, y;

     if (x.isZero()) return x;

     // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
     // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

     // Estimate the optimum number of times to use the argument reduction.
     len = x.d.length;
     if (len < 32) {
       k = Math.ceil(len / 3);
       y = (1 / tinyPow(4, k)).toString();
     } else {
       k = 16;
       y = '2.3283064365386962890625e-10';
     }

     Ctor.precision += k;

     x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

     // Reverse argument reduction
     for (var i = k; i--;) {
       var cos2x = x.times(x);
       x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
     }

     Ctor.precision -= k;

     return x;
   }


   /*
    * Perform division in the specified base.
    */
   var divide$1 = (function () {

     // Assumes non-zero x and k, and hence non-zero result.
     function multiplyInteger(x, k, base) {
       var temp,
         carry = 0,
         i = x.length;

       for (x = x.slice(); i--;) {
         temp = x[i] * k + carry;
         x[i] = temp % base | 0;
         carry = temp / base | 0;
       }

       if (carry) x.unshift(carry);

       return x;
     }

     function compare(a, b, aL, bL) {
       var i, r;

       if (aL != bL) {
         r = aL > bL ? 1 : -1;
       } else {
         for (i = r = 0; i < aL; i++) {
           if (a[i] != b[i]) {
             r = a[i] > b[i] ? 1 : -1;
             break;
           }
         }
       }

       return r;
     }

     function subtract(a, b, aL, base) {
       var i = 0;

       // Subtract b from a.
       for (; aL--;) {
         a[aL] -= i;
         i = a[aL] < b[aL] ? 1 : 0;
         a[aL] = i * base + a[aL] - b[aL];
       }

       // Remove leading zeros.
       for (; !a[0] && a.length > 1;) a.shift();
     }

     return function (x, y, pr, rm, dp, base) {
       var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
         yL, yz,
         Ctor = x.constructor,
         sign = x.s == y.s ? 1 : -1,
         xd = x.d,
         yd = y.d;

       // Either NaN, Infinity or 0?
       if (!xd || !xd[0] || !yd || !yd[0]) {

         return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

           // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
           xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
       }

       if (base) {
         logBase = 1;
         e = x.e - y.e;
       } else {
         base = BASE;
         logBase = LOG_BASE;
         e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
       }

       yL = yd.length;
       xL = xd.length;
       q = new Ctor(sign);
       qd = q.d = [];

       // Result exponent may be one less than e.
       // The digit array of a Decimal from toStringBinary may have trailing zeros.
       for (i = 0; yd[i] == (xd[i] || 0); i++);

       if (yd[i] > (xd[i] || 0)) e--;

       if (pr == null) {
         sd = pr = Ctor.precision;
         rm = Ctor.rounding;
       } else if (dp) {
         sd = pr + (x.e - y.e) + 1;
       } else {
         sd = pr;
       }

       if (sd < 0) {
         qd.push(1);
         more = true;
       } else {

         // Convert precision in number of base 10 digits to base 1e7 digits.
         sd = sd / logBase + 2 | 0;
         i = 0;

         // divisor < 1e7
         if (yL == 1) {
           k = 0;
           yd = yd[0];
           sd++;

           // k is the carry.
           for (; (i < xL || k) && sd--; i++) {
             t = k * base + (xd[i] || 0);
             qd[i] = t / yd | 0;
             k = t % yd | 0;
           }

           more = k || i < xL;

         // divisor >= 1e7
         } else {

           // Normalise xd and yd so highest order digit of yd is >= base/2
           k = base / (yd[0] + 1) | 0;

           if (k > 1) {
             yd = multiplyInteger(yd, k, base);
             xd = multiplyInteger(xd, k, base);
             yL = yd.length;
             xL = xd.length;
           }

           xi = yL;
           rem = xd.slice(0, yL);
           remL = rem.length;

           // Add zeros to make remainder as long as divisor.
           for (; remL < yL;) rem[remL++] = 0;

           yz = yd.slice();
           yz.unshift(0);
           yd0 = yd[0];

           if (yd[1] >= base / 2) ++yd0;

           do {
             k = 0;

             // Compare divisor and remainder.
             cmp = compare(yd, rem, yL, remL);

             // If divisor < remainder.
             if (cmp < 0) {

               // Calculate trial digit, k.
               rem0 = rem[0];
               if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

               // k will be how many times the divisor goes into the current remainder.
               k = rem0 / yd0 | 0;

               //  Algorithm:
               //  1. product = divisor * trial digit (k)
               //  2. if product > remainder: product -= divisor, k--
               //  3. remainder -= product
               //  4. if product was < remainder at 2:
               //    5. compare new remainder and divisor
               //    6. If remainder > divisor: remainder -= divisor, k++

               if (k > 1) {
                 if (k >= base) k = base - 1;

                 // product = divisor * trial digit.
                 prod = multiplyInteger(yd, k, base);
                 prodL = prod.length;
                 remL = rem.length;

                 // Compare product and remainder.
                 cmp = compare(prod, rem, prodL, remL);

                 // product > remainder.
                 if (cmp == 1) {
                   k--;

                   // Subtract divisor from product.
                   subtract(prod, yL < prodL ? yz : yd, prodL, base);
                 }
               } else {

                 // cmp is -1.
                 // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                 // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                 if (k == 0) cmp = k = 1;
                 prod = yd.slice();
               }

               prodL = prod.length;
               if (prodL < remL) prod.unshift(0);

               // Subtract product from remainder.
               subtract(rem, prod, remL, base);

               // If product was < previous remainder.
               if (cmp == -1) {
                 remL = rem.length;

                 // Compare divisor and new remainder.
                 cmp = compare(yd, rem, yL, remL);

                 // If divisor < new remainder, subtract divisor from remainder.
                 if (cmp < 1) {
                   k++;

                   // Subtract divisor from remainder.
                   subtract(rem, yL < remL ? yz : yd, remL, base);
                 }
               }

               remL = rem.length;
             } else if (cmp === 0) {
               k++;
               rem = [0];
             }    // if cmp === 1, k will be 0

             // Add the next digit, k, to the result array.
             qd[i++] = k;

             // Update the remainder.
             if (cmp && rem[0]) {
               rem[remL++] = xd[xi] || 0;
             } else {
               rem = [xd[xi]];
               remL = 1;
             }

           } while ((xi++ < xL || rem[0] !== void 0) && sd--);

           more = rem[0] !== void 0;
         }

         // Leading zero?
         if (!qd[0]) qd.shift();
       }

       // logBase is 1 when divide is being used for base conversion.
       if (logBase == 1) {
         q.e = e;
         inexact = more;
       } else {

         // To calculate q.e, first get the number of digits of qd[0].
         for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
         q.e = i + e * logBase - 1;

         finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
       }

       return q;
     };
   })();


   /*
    * Round `x` to `sd` significant digits using rounding mode `rm`.
    * Check for over/under-flow.
    */
    function finalise(x, sd, rm, isTruncated) {
     var digits, i, j, k, rd, roundUp, w, xd, xdi,
       Ctor = x.constructor;

     // Don't round if sd is null or undefined.
     out: if (sd != null) {
       xd = x.d;

       // Infinity/NaN.
       if (!xd) return x;

       // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
       // w: the word of xd containing rd, a base 1e7 number.
       // xdi: the index of w within xd.
       // digits: the number of digits of w.
       // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
       // they had leading zeros)
       // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

       // Get the length of the first word of the digits array xd.
       for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
       i = sd - digits;

       // Is the rounding digit in the first word of xd?
       if (i < 0) {
         i += LOG_BASE;
         j = sd;
         w = xd[xdi = 0];

         // Get the rounding digit at index j of w.
         rd = w / mathpow(10, digits - j - 1) % 10 | 0;
       } else {
         xdi = Math.ceil((i + 1) / LOG_BASE);
         k = xd.length;
         if (xdi >= k) {
           if (isTruncated) {

             // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
             for (; k++ <= xdi;) xd.push(0);
             w = rd = 0;
             digits = 1;
             i %= LOG_BASE;
             j = i - LOG_BASE + 1;
           } else {
             break out;
           }
         } else {
           w = k = xd[xdi];

           // Get the number of digits of w.
           for (digits = 1; k >= 10; k /= 10) digits++;

           // Get the index of rd within w.
           i %= LOG_BASE;

           // Get the index of rd within w, adjusted for leading zeros.
           // The number of leading zeros of w is given by LOG_BASE - digits.
           j = i - LOG_BASE + digits;

           // Get the rounding digit at index j of w.
           rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
         }
       }

       // Are there any non-zero digits after the rounding digit?
       isTruncated = isTruncated || sd < 0 ||
         xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

       // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
       // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
       // will give 714.

       roundUp = rm < 4
         ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

           // Check whether the digit to the left of the rounding digit is odd.
           ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

       if (sd < 1 || !xd[0]) {
         xd.length = 0;
         if (roundUp) {

           // Convert sd to decimal places.
           sd -= x.e + 1;

           // 1, 0.1, 0.01, 0.001, 0.0001 etc.
           xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
           x.e = -sd || 0;
         } else {

           // Zero.
           xd[0] = x.e = 0;
         }

         return x;
       }

       // Remove excess digits.
       if (i == 0) {
         xd.length = xdi;
         k = 1;
         xdi--;
       } else {
         xd.length = xdi + 1;
         k = mathpow(10, LOG_BASE - i);

         // E.g. 56700 becomes 56000 if 7 is the rounding digit.
         // j > 0 means i > number of leading zeros of w.
         xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
       }

       if (roundUp) {
         for (;;) {

           // Is the digit to be rounded up in the first word of xd?
           if (xdi == 0) {

             // i will be the length of xd[0] before k is added.
             for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
             j = xd[0] += k;
             for (k = 1; j >= 10; j /= 10) k++;

             // if i != k the length has increased.
             if (i != k) {
               x.e++;
               if (xd[0] == BASE) xd[0] = 1;
             }

             break;
           } else {
             xd[xdi] += k;
             if (xd[xdi] != BASE) break;
             xd[xdi--] = 0;
             k = 1;
           }
         }
       }

       // Remove trailing zeros.
       for (i = xd.length; xd[--i] === 0;) xd.pop();
     }

     if (external) {

       // Overflow?
       if (x.e > Ctor.maxE) {

         // Infinity.
         x.d = null;
         x.e = NaN;

       // Underflow?
       } else if (x.e < Ctor.minE) {

         // Zero.
         x.e = 0;
         x.d = [0];
         // Ctor.underflow = true;
       } // else Ctor.underflow = false;
     }

     return x;
   }


   function finiteToString(x, isExp, sd) {
     if (!x.isFinite()) return nonFiniteToString(x);
     var k,
       e = x.e,
       str = digitsToString(x.d),
       len = str.length;

     if (isExp) {
       if (sd && (k = sd - len) > 0) {
         str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
       } else if (len > 1) {
         str = str.charAt(0) + '.' + str.slice(1);
       }

       str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
     } else if (e < 0) {
       str = '0.' + getZeroString(-e - 1) + str;
       if (sd && (k = sd - len) > 0) str += getZeroString(k);
     } else if (e >= len) {
       str += getZeroString(e + 1 - len);
       if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
     } else {
       if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
       if (sd && (k = sd - len) > 0) {
         if (e + 1 === len) str += '.';
         str += getZeroString(k);
       }
     }

     return str;
   }


   // Calculate the base 10 exponent from the base 1e7 exponent.
   function getBase10Exponent(digits, e) {
     var w = digits[0];

     // Add the number of digits of the first word of the digits array.
     for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
     return e;
   }


   function getLn10(Ctor, sd, pr) {
     if (sd > LN10_PRECISION) {

       // Reset global state in case the exception is caught.
       external = true;
       if (pr) Ctor.precision = pr;
       throw Error(precisionLimitExceeded);
     }
     return finalise(new Ctor(LN10$1), sd, 1, true);
   }


   function getPi(Ctor, sd, rm) {
     if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
     return finalise(new Ctor(PI), sd, rm, true);
   }


   function getPrecision(digits) {
     var w = digits.length - 1,
       len = w * LOG_BASE + 1;

     w = digits[w];

     // If non-zero...
     if (w) {

       // Subtract the number of trailing zeros of the last word.
       for (; w % 10 == 0; w /= 10) len--;

       // Add the number of digits of the first word.
       for (w = digits[0]; w >= 10; w /= 10) len++;
     }

     return len;
   }


   function getZeroString(k) {
     var zs = '';
     for (; k--;) zs += '0';
     return zs;
   }


   /*
    * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
    * integer of type number.
    *
    * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
    *
    */
   function intPow(Ctor, x, n, pr) {
     var isTruncated,
       r = new Ctor(1),

       // Max n of 9007199254740991 takes 53 loop iterations.
       // Maximum digits array length; leaves [28, 34] guard digits.
       k = Math.ceil(pr / LOG_BASE + 4);

     external = false;

     for (;;) {
       if (n % 2) {
         r = r.times(x);
         if (truncate(r.d, k)) isTruncated = true;
       }

       n = mathfloor(n / 2);
       if (n === 0) {

         // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
         n = r.d.length - 1;
         if (isTruncated && r.d[n] === 0) ++r.d[n];
         break;
       }

       x = x.times(x);
       truncate(x.d, k);
     }

     external = true;

     return r;
   }


   function isOdd(n) {
     return n.d[n.d.length - 1] & 1;
   }


   /*
    * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
    */
   function maxOrMin(Ctor, args, ltgt) {
     var y,
       x = new Ctor(args[0]),
       i = 0;

     for (; ++i < args.length;) {
       y = new Ctor(args[i]);
       if (!y.s) {
         x = y;
         break;
       } else if (x[ltgt](y)) {
         x = y;
       }
     }

     return x;
   }


   /*
    * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
    * digits.
    *
    * Taylor/Maclaurin series.
    *
    * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
    *
    * Argument reduction:
    *   Repeat x = x / 32, k += 5, until |x| < 0.1
    *   exp(x) = exp(x / 2^k)^(2^k)
    *
    * Previously, the argument was initially reduced by
    * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
    * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
    * found to be slower than just dividing repeatedly by 32 as above.
    *
    * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
    * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
    * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
    *
    *  exp(Infinity)  = Infinity
    *  exp(-Infinity) = 0
    *  exp(NaN)       = NaN
    *  exp(±0)        = 1
    *
    *  exp(x) is non-terminating for any finite, non-zero x.
    *
    *  The result will always be correctly rounded.
    *
    */
   function naturalExponential(x, sd) {
     var denominator, guard, j, pow, sum, t, wpr,
       rep = 0,
       i = 0,
       k = 0,
       Ctor = x.constructor,
       rm = Ctor.rounding,
       pr = Ctor.precision;

     // 0/NaN/Infinity?
     if (!x.d || !x.d[0] || x.e > 17) {

       return new Ctor(x.d
         ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
         : x.s ? x.s < 0 ? 0 : x : 0 / 0);
     }

     if (sd == null) {
       external = false;
       wpr = pr;
     } else {
       wpr = sd;
     }

     t = new Ctor(0.03125);

     // while abs(x) >= 0.1
     while (x.e > -2) {

       // x = x / 2^5
       x = x.times(t);
       k += 5;
     }

     // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
     // necessary to ensure the first 4 rounding digits are correct.
     guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
     wpr += guard;
     denominator = pow = sum = new Ctor(1);
     Ctor.precision = wpr;

     for (;;) {
       pow = finalise(pow.times(x), wpr, 1);
       denominator = denominator.times(++i);
       t = sum.plus(divide$1(pow, denominator, wpr, 1));

       if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
         j = k;
         while (j--) sum = finalise(sum.times(sum), wpr, 1);

         // Check to see if the first 4 rounding digits are [49]999.
         // If so, repeat the summation with a higher precision, otherwise
         // e.g. with precision: 18, rounding: 1
         // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
         // `wpr - guard` is the index of first rounding digit.
         if (sd == null) {

           if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
             Ctor.precision = wpr += 10;
             denominator = pow = t = new Ctor(1);
             i = 0;
             rep++;
           } else {
             return finalise(sum, Ctor.precision = pr, rm, external = true);
           }
         } else {
           Ctor.precision = pr;
           return sum;
         }
       }

       sum = t;
     }
   }


   /*
    * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
    * digits.
    *
    *  ln(-n)        = NaN
    *  ln(0)         = -Infinity
    *  ln(-0)        = -Infinity
    *  ln(1)         = 0
    *  ln(Infinity)  = Infinity
    *  ln(-Infinity) = NaN
    *  ln(NaN)       = NaN
    *
    *  ln(n) (n != 1) is non-terminating.
    *
    */
   function naturalLogarithm(y, sd) {
     var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
       n = 1,
       guard = 10,
       x = y,
       xd = x.d,
       Ctor = x.constructor,
       rm = Ctor.rounding,
       pr = Ctor.precision;

     // Is x negative or Infinity, NaN, 0 or 1?
     if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
       return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
     }

     if (sd == null) {
       external = false;
       wpr = pr;
     } else {
       wpr = sd;
     }

     Ctor.precision = wpr += guard;
     c = digitsToString(xd);
     c0 = c.charAt(0);

     if (Math.abs(e = x.e) < 1.5e15) {

       // Argument reduction.
       // The series converges faster the closer the argument is to 1, so using
       // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
       // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
       // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
       // later be divided by this number, then separate out the power of 10 using
       // ln(a*10^b) = ln(a) + b*ln(10).

       // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
       //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
       // max n is 6 (gives 0.7 - 1.3)
       while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
         x = x.times(y);
         c = digitsToString(x.d);
         c0 = c.charAt(0);
         n++;
       }

       e = x.e;

       if (c0 > 1) {
         x = new Ctor('0.' + c);
         e++;
       } else {
         x = new Ctor(c0 + '.' + c.slice(1));
       }
     } else {

       // The argument reduction method above may result in overflow if the argument y is a massive
       // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
       // function using ln(x*10^e) = ln(x) + e*ln(10).
       t = getLn10(Ctor, wpr + 2, pr).times(e + '');
       x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
       Ctor.precision = pr;

       return sd == null ? finalise(x, pr, rm, external = true) : x;
     }

     // x1 is x reduced to a value near 1.
     x1 = x;

     // Taylor series.
     // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
     // where x = (y - 1)/(y + 1)    (|x| < 1)
     sum = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
     x2 = finalise(x.times(x), wpr, 1);
     denominator = 3;

     for (;;) {
       numerator = finalise(numerator.times(x2), wpr, 1);
       t = sum.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));

       if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
         sum = sum.times(2);

         // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
         // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
         if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
         sum = divide$1(sum, new Ctor(n), wpr, 1);

         // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
         // been repeated previously) and the first 4 rounding digits 9999?
         // If so, restart the summation with a higher precision, otherwise
         // e.g. with precision: 12, rounding: 1
         // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
         // `wpr - guard` is the index of first rounding digit.
         if (sd == null) {
           if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
             Ctor.precision = wpr += guard;
             t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
             x2 = finalise(x.times(x), wpr, 1);
             denominator = rep = 1;
           } else {
             return finalise(sum, Ctor.precision = pr, rm, external = true);
           }
         } else {
           Ctor.precision = pr;
           return sum;
         }
       }

       sum = t;
       denominator += 2;
     }
   }


   // ±Infinity, NaN.
   function nonFiniteToString(x) {
     // Unsigned.
     return String(x.s * x.s / 0);
   }


   /*
    * Parse the value of a new Decimal `x` from string `str`.
    */
   function parseDecimal(x, str) {
     var e, i, len;

     // Decimal point?
     if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

     // Exponential form?
     if ((i = str.search(/e/i)) > 0) {

       // Determine exponent.
       if (e < 0) e = i;
       e += +str.slice(i + 1);
       str = str.substring(0, i);
     } else if (e < 0) {

       // Integer.
       e = str.length;
     }

     // Determine leading zeros.
     for (i = 0; str.charCodeAt(i) === 48; i++);

     // Determine trailing zeros.
     for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
     str = str.slice(i, len);

     if (str) {
       len -= i;
       x.e = e = e - i - 1;
       x.d = [];

       // Transform base

       // e is the base 10 exponent.
       // i is where to slice str to get the first word of the digits array.
       i = (e + 1) % LOG_BASE;
       if (e < 0) i += LOG_BASE;

       if (i < len) {
         if (i) x.d.push(+str.slice(0, i));
         for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
         str = str.slice(i);
         i = LOG_BASE - str.length;
       } else {
         i -= len;
       }

       for (; i--;) str += '0';
       x.d.push(+str);

       if (external) {

         // Overflow?
         if (x.e > x.constructor.maxE) {

           // Infinity.
           x.d = null;
           x.e = NaN;

         // Underflow?
         } else if (x.e < x.constructor.minE) {

           // Zero.
           x.e = 0;
           x.d = [0];
           // x.constructor.underflow = true;
         } // else x.constructor.underflow = false;
       }
     } else {

       // Zero.
       x.e = 0;
       x.d = [0];
     }

     return x;
   }


   /*
    * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
    */
   function parseOther(x, str) {
     var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

     if (str.indexOf('_') > -1) {
       str = str.replace(/(\d)_(?=\d)/g, '$1');
       if (isDecimal.test(str)) return parseDecimal(x, str);
     } else if (str === 'Infinity' || str === 'NaN') {
       if (!+str) x.s = NaN;
       x.e = NaN;
       x.d = null;
       return x;
     }

     if (isHex.test(str))  {
       base = 16;
       str = str.toLowerCase();
     } else if (isBinary.test(str))  {
       base = 2;
     } else if (isOctal.test(str))  {
       base = 8;
     } else {
       throw Error(invalidArgument + str);
     }

     // Is there a binary exponent part?
     i = str.search(/p/i);

     if (i > 0) {
       p = +str.slice(i + 1);
       str = str.substring(2, i);
     } else {
       str = str.slice(2);
     }

     // Convert `str` as an integer then divide the result by `base` raised to a power such that the
     // fraction part will be restored.
     i = str.indexOf('.');
     isFloat = i >= 0;
     Ctor = x.constructor;

     if (isFloat) {
       str = str.replace('.', '');
       len = str.length;
       i = len - i;

       // log[10](16) = 1.2041... , log[10](88) = 1.9444....
       divisor = intPow(Ctor, new Ctor(base), i, i * 2);
     }

     xd = convertBase(str, base, BASE);
     xe = xd.length - 1;

     // Remove trailing zeros.
     for (i = xe; xd[i] === 0; --i) xd.pop();
     if (i < 0) return new Ctor(x.s * 0);
     x.e = getBase10Exponent(xd, xe);
     x.d = xd;
     external = false;

     // At what precision to perform the division to ensure exact conversion?
     // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
     // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
     // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
     // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
     // Therefore using 4 * the number of digits of str will always be enough.
     if (isFloat) x = divide$1(x, divisor, len * 4);

     // Multiply by the binary exponent part if present.
     if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
     external = true;

     return x;
   }


   /*
    * sin(x) = x - x^3/3! + x^5/5! - ...
    * |x| < pi/2
    *
    */
   function sine(Ctor, x) {
     var k,
       len = x.d.length;

     if (len < 3) {
       return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
     }

     // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
     // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
     // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

     // Estimate the optimum number of times to use the argument reduction.
     k = 1.4 * Math.sqrt(len);
     k = k > 16 ? 16 : k | 0;

     x = x.times(1 / tinyPow(5, k));
     x = taylorSeries(Ctor, 2, x, x);

     // Reverse argument reduction
     var sin2_x,
       d5 = new Ctor(5),
       d16 = new Ctor(16),
       d20 = new Ctor(20);
     for (; k--;) {
       sin2_x = x.times(x);
       x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
     }

     return x;
   }


   // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
   function taylorSeries(Ctor, n, x, y, isHyperbolic) {
     var j, t, u, x2,
       pr = Ctor.precision,
       k = Math.ceil(pr / LOG_BASE);

     external = false;
     x2 = x.times(x);
     u = new Ctor(y);

     for (;;) {
       t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
       u = isHyperbolic ? y.plus(t) : y.minus(t);
       y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
       t = u.plus(y);

       if (t.d[k] !== void 0) {
         for (j = k; t.d[j] === u.d[j] && j--;);
         if (j == -1) break;
       }

       j = u;
       u = y;
       y = t;
       t = j;
     }

     external = true;
     t.d.length = k + 1;

     return t;
   }


   // Exponent e must be positive and non-zero.
   function tinyPow(b, e) {
     var n = b;
     while (--e) n *= b;
     return n;
   }


   // Return the absolute value of `x` reduced to less than or equal to half pi.
   function toLessThanHalfPi(Ctor, x) {
     var t,
       isNeg = x.s < 0,
       pi = getPi(Ctor, Ctor.precision, 1),
       halfPi = pi.times(0.5);

     x = x.abs();

     if (x.lte(halfPi)) {
       quadrant = isNeg ? 4 : 1;
       return x;
     }

     t = x.divToInt(pi);

     if (t.isZero()) {
       quadrant = isNeg ? 3 : 2;
     } else {
       x = x.minus(t.times(pi));

       // 0 <= x < pi
       if (x.lte(halfPi)) {
         quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
         return x;
       }

       quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
     }

     return x.minus(pi).abs();
   }


   /*
    * Return the value of Decimal `x` as a string in base `baseOut`.
    *
    * If the optional `sd` argument is present include a binary exponent suffix.
    */
   function toStringBinary(x, baseOut, sd, rm) {
     var base, e, i, k, len, roundUp, str, xd, y,
       Ctor = x.constructor,
       isExp = sd !== void 0;

     if (isExp) {
       checkInt32(sd, 1, MAX_DIGITS);
       if (rm === void 0) rm = Ctor.rounding;
       else checkInt32(rm, 0, 8);
     } else {
       sd = Ctor.precision;
       rm = Ctor.rounding;
     }

     if (!x.isFinite()) {
       str = nonFiniteToString(x);
     } else {
       str = finiteToString(x);
       i = str.indexOf('.');

       // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
       // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
       // minBinaryExponent = floor(decimalExponent * log[2](10))
       // log[2](10) = 3.321928094887362347870319429489390175864

       if (isExp) {
         base = 2;
         if (baseOut == 16) {
           sd = sd * 4 - 3;
         } else if (baseOut == 8) {
           sd = sd * 3 - 2;
         }
       } else {
         base = baseOut;
       }

       // Convert the number as an integer then divide the result by its base raised to a power such
       // that the fraction part will be restored.

       // Non-integer.
       if (i >= 0) {
         str = str.replace('.', '');
         y = new Ctor(1);
         y.e = str.length - i;
         y.d = convertBase(finiteToString(y), 10, base);
         y.e = y.d.length;
       }

       xd = convertBase(str, 10, base);
       e = len = xd.length;

       // Remove trailing zeros.
       for (; xd[--len] == 0;) xd.pop();

       if (!xd[0]) {
         str = isExp ? '0p+0' : '0';
       } else {
         if (i < 0) {
           e--;
         } else {
           x = new Ctor(x);
           x.d = xd;
           x.e = e;
           x = divide$1(x, y, sd, rm, 0, base);
           xd = x.d;
           e = x.e;
           roundUp = inexact;
         }

         // The rounding digit, i.e. the digit after the digit that may be rounded up.
         i = xd[sd];
         k = base / 2;
         roundUp = roundUp || xd[sd + 1] !== void 0;

         roundUp = rm < 4
           ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
           : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
             rm === (x.s < 0 ? 8 : 7));

         xd.length = sd;

         if (roundUp) {

           // Rounding up may mean the previous digit has to be rounded up and so on.
           for (; ++xd[--sd] > base - 1;) {
             xd[sd] = 0;
             if (!sd) {
               ++e;
               xd.unshift(1);
             }
           }
         }

         // Determine trailing zeros.
         for (len = xd.length; !xd[len - 1]; --len);

         // E.g. [4, 11, 15] becomes 4bf.
         for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

         // Add binary exponent suffix?
         if (isExp) {
           if (len > 1) {
             if (baseOut == 16 || baseOut == 8) {
               i = baseOut == 16 ? 4 : 3;
               for (--len; len % i; len++) str += '0';
               xd = convertBase(str, base, baseOut);
               for (len = xd.length; !xd[len - 1]; --len);

               // xd[0] will always be be 1
               for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
             } else {
               str = str.charAt(0) + '.' + str.slice(1);
             }
           }

           str =  str + (e < 0 ? 'p' : 'p+') + e;
         } else if (e < 0) {
           for (; ++e;) str = '0' + str;
           str = '0.' + str;
         } else {
           if (++e > len) for (e -= len; e-- ;) str += '0';
           else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
         }
       }

       str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
     }

     return x.s < 0 ? '-' + str : str;
   }


   // Does not strip trailing zeros.
   function truncate(arr, len) {
     if (arr.length > len) {
       arr.length = len;
       return true;
     }
   }


   // Decimal methods


   /*
    *  abs
    *  acos
    *  acosh
    *  add
    *  asin
    *  asinh
    *  atan
    *  atanh
    *  atan2
    *  cbrt
    *  ceil
    *  clamp
    *  clone
    *  config
    *  cos
    *  cosh
    *  div
    *  exp
    *  floor
    *  hypot
    *  ln
    *  log
    *  log2
    *  log10
    *  max
    *  min
    *  mod
    *  mul
    *  pow
    *  random
    *  round
    *  set
    *  sign
    *  sin
    *  sinh
    *  sqrt
    *  sub
    *  sum
    *  tan
    *  tanh
    *  trunc
    */


   /*
    * Return a new Decimal whose value is the absolute value of `x`.
    *
    * x {number|string|Decimal}
    *
    */
   function abs$1(x) {
     return new this(x).abs();
   }


   /*
    * Return a new Decimal whose value is the arccosine in radians of `x`.
    *
    * x {number|string|Decimal}
    *
    */
   function acos$1(x) {
     return new this(x).acos();
   }


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function acosh$1(x) {
     return new this(x).acosh();
   }


   /*
    * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    * y {number|string|Decimal}
    *
    */
   function add$1(x, y) {
     return new this(x).plus(y);
   }


   /*
    * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function asin$1(x) {
     return new this(x).asin();
   }


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function asinh$1(x) {
     return new this(x).asinh();
   }


   /*
    * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function atan$1(x) {
     return new this(x).atan();
   }


   /*
    * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
    * `precision` significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function atanh$1(x) {
     return new this(x).atanh();
   }


   /*
    * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
    * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
    *
    * Domain: [-Infinity, Infinity]
    * Range: [-pi, pi]
    *
    * y {number|string|Decimal} The y-coordinate.
    * x {number|string|Decimal} The x-coordinate.
    *
    * atan2(±0, -0)               = ±pi
    * atan2(±0, +0)               = ±0
    * atan2(±0, -x)               = ±pi for x > 0
    * atan2(±0, x)                = ±0 for x > 0
    * atan2(-y, ±0)               = -pi/2 for y > 0
    * atan2(y, ±0)                = pi/2 for y > 0
    * atan2(±y, -Infinity)        = ±pi for finite y > 0
    * atan2(±y, +Infinity)        = ±0 for finite y > 0
    * atan2(±Infinity, x)         = ±pi/2 for finite x
    * atan2(±Infinity, -Infinity) = ±3*pi/4
    * atan2(±Infinity, +Infinity) = ±pi/4
    * atan2(NaN, x) = NaN
    * atan2(y, NaN) = NaN
    *
    */
   function atan2$1(y, x) {
     y = new this(y);
     x = new this(x);
     var r,
       pr = this.precision,
       rm = this.rounding,
       wpr = pr + 4;

     // Either NaN
     if (!y.s || !x.s) {
       r = new this(NaN);

     // Both ±Infinity
     } else if (!y.d && !x.d) {
       r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
       r.s = y.s;

     // x is ±Infinity or y is ±0
     } else if (!x.d || y.isZero()) {
       r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
       r.s = y.s;

     // y is ±Infinity or x is ±0
     } else if (!y.d || x.isZero()) {
       r = getPi(this, wpr, 1).times(0.5);
       r.s = y.s;

     // Both non-zero and finite
     } else if (x.s < 0) {
       this.precision = wpr;
       this.rounding = 1;
       r = this.atan(divide$1(y, x, wpr, 1));
       x = getPi(this, wpr, 1);
       this.precision = pr;
       this.rounding = rm;
       r = y.s < 0 ? r.minus(x) : r.plus(x);
     } else {
       r = this.atan(divide$1(y, x, wpr, 1));
     }

     return r;
   }


   /*
    * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function cbrt$1(x) {
     return new this(x).cbrt();
   }


   /*
    * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
    *
    * x {number|string|Decimal}
    *
    */
   function ceil$1(x) {
     return finalise(x = new this(x), x.e + 1, 2);
   }


   /*
    * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
    *
    * x {number|string|Decimal}
    * min {number|string|Decimal}
    * max {number|string|Decimal}
    *
    */
   function clamp(x, min, max) {
     return new this(x).clamp(min, max);
   }


   /*
    * Configure global settings for a Decimal constructor.
    *
    * `obj` is an object with one or more of the following properties,
    *
    *   precision  {number}
    *   rounding   {number}
    *   toExpNeg   {number}
    *   toExpPos   {number}
    *   maxE       {number}
    *   minE       {number}
    *   modulo     {number}
    *   crypto     {boolean|number}
    *   defaults   {true}
    *
    * E.g. Decimal.config({ precision: 20, rounding: 4 })
    *
    */
   function config(obj) {
     if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
     var i, p, v,
       useDefaults = obj.defaults === true,
       ps = [
         'precision', 1, MAX_DIGITS,
         'rounding', 0, 8,
         'toExpNeg', -EXP_LIMIT, 0,
         'toExpPos', 0, EXP_LIMIT,
         'maxE', 0, EXP_LIMIT,
         'minE', -EXP_LIMIT, 0,
         'modulo', 0, 9
       ];

     for (i = 0; i < ps.length; i += 3) {
       if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
       if ((v = obj[p]) !== void 0) {
         if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
         else throw Error(invalidArgument + p + ': ' + v);
       }
     }

     if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
     if ((v = obj[p]) !== void 0) {
       if (v === true || v === false || v === 0 || v === 1) {
         if (v) {
           if (typeof crypto != 'undefined' && crypto &&
             (crypto.getRandomValues || crypto.randomBytes)) {
             this[p] = true;
           } else {
             throw Error(cryptoUnavailable);
           }
         } else {
           this[p] = false;
         }
       } else {
         throw Error(invalidArgument + p + ': ' + v);
       }
     }

     return this;
   }


   /*
    * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function cos$1(x) {
     return new this(x).cos();
   }


   /*
    * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function cosh$1(x) {
     return new this(x).cosh();
   }


   /*
    * Create and return a Decimal constructor with the same configuration properties as this Decimal
    * constructor.
    *
    */
   function clone$1(obj) {
     var i, p, ps;

     /*
      * The Decimal constructor and exported function.
      * Return a new Decimal instance.
      *
      * v {number|string|Decimal} A numeric value.
      *
      */
     function Decimal(v) {
       var e, i, t,
         x = this;

       // Decimal called without new.
       if (!(x instanceof Decimal)) return new Decimal(v);

       // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
       // which points to Object.
       x.constructor = Decimal;

       // Duplicate.
       if (isDecimalInstance(v)) {
         x.s = v.s;

         if (external) {
           if (!v.d || v.e > Decimal.maxE) {

             // Infinity.
             x.e = NaN;
             x.d = null;
           } else if (v.e < Decimal.minE) {

             // Zero.
             x.e = 0;
             x.d = [0];
           } else {
             x.e = v.e;
             x.d = v.d.slice();
           }
         } else {
           x.e = v.e;
           x.d = v.d ? v.d.slice() : v.d;
         }

         return;
       }

       t = typeof v;

       if (t === 'number') {
         if (v === 0) {
           x.s = 1 / v < 0 ? -1 : 1;
           x.e = 0;
           x.d = [0];
           return;
         }

         if (v < 0) {
           v = -v;
           x.s = -1;
         } else {
           x.s = 1;
         }

         // Fast path for small integers.
         if (v === ~~v && v < 1e7) {
           for (e = 0, i = v; i >= 10; i /= 10) e++;

           if (external) {
             if (e > Decimal.maxE) {
               x.e = NaN;
               x.d = null;
             } else if (e < Decimal.minE) {
               x.e = 0;
               x.d = [0];
             } else {
               x.e = e;
               x.d = [v];
             }
           } else {
             x.e = e;
             x.d = [v];
           }

           return;

         // Infinity, NaN.
         } else if (v * 0 !== 0) {
           if (!v) x.s = NaN;
           x.e = NaN;
           x.d = null;
           return;
         }

         return parseDecimal(x, v.toString());

       } else if (t !== 'string') {
         throw Error(invalidArgument + v);
       }

       // Minus sign?
       if ((i = v.charCodeAt(0)) === 45) {
         v = v.slice(1);
         x.s = -1;
       } else {
         // Plus sign?
         if (i === 43) v = v.slice(1);
         x.s = 1;
       }

       return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
     }

     Decimal.prototype = P$1;

     Decimal.ROUND_UP = 0;
     Decimal.ROUND_DOWN = 1;
     Decimal.ROUND_CEIL = 2;
     Decimal.ROUND_FLOOR = 3;
     Decimal.ROUND_HALF_UP = 4;
     Decimal.ROUND_HALF_DOWN = 5;
     Decimal.ROUND_HALF_EVEN = 6;
     Decimal.ROUND_HALF_CEIL = 7;
     Decimal.ROUND_HALF_FLOOR = 8;
     Decimal.EUCLID = 9;

     Decimal.config = Decimal.set = config;
     Decimal.clone = clone$1;
     Decimal.isDecimal = isDecimalInstance;

     Decimal.abs = abs$1;
     Decimal.acos = acos$1;
     Decimal.acosh = acosh$1;        // ES6
     Decimal.add = add$1;
     Decimal.asin = asin$1;
     Decimal.asinh = asinh$1;        // ES6
     Decimal.atan = atan$1;
     Decimal.atanh = atanh$1;        // ES6
     Decimal.atan2 = atan2$1;
     Decimal.cbrt = cbrt$1;          // ES6
     Decimal.ceil = ceil$1;
     Decimal.clamp = clamp;
     Decimal.cos = cos$1;
     Decimal.cosh = cosh$1;          // ES6
     Decimal.div = div;
     Decimal.exp = exp$1;
     Decimal.floor = floor$1;
     Decimal.hypot = hypot$1;        // ES6
     Decimal.ln = ln;
     Decimal.log = log$1;
     Decimal.log10 = log10$1;        // ES6
     Decimal.log2 = log2$1;          // ES6
     Decimal.max = max$1;
     Decimal.min = min$1;
     Decimal.mod = mod$1;
     Decimal.mul = mul;
     Decimal.pow = pow$1;
     Decimal.random = random$1;
     Decimal.round = round$1;
     Decimal.sign = sign$1;          // ES6
     Decimal.sin = sin$1;
     Decimal.sinh = sinh$1;          // ES6
     Decimal.sqrt = sqrt$1;
     Decimal.sub = sub;
     Decimal.sum = sum$1;
     Decimal.tan = tan$1;
     Decimal.tanh = tanh$1;          // ES6
     Decimal.trunc = trunc;        // ES6

     if (obj === void 0) obj = {};
     if (obj) {
       if (obj.defaults !== true) {
         ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
         for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
       }
     }

     Decimal.config(obj);

     return Decimal;
   }


   /*
    * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    * y {number|string|Decimal}
    *
    */
   function div(x, y) {
     return new this(x).div(y);
   }


   /*
    * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} The power to which to raise the base of the natural log.
    *
    */
   function exp$1(x) {
     return new this(x).exp();
   }


   /*
    * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
    *
    * x {number|string|Decimal}
    *
    */
   function floor$1(x) {
     return finalise(x = new this(x), x.e + 1, 3);
   }


   /*
    * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
    * rounded to `precision` significant digits using rounding mode `rounding`.
    *
    * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
    *
    * arguments {number|string|Decimal}
    *
    */
   function hypot$1() {
     var i, n,
       t = new this(0);

     external = false;

     for (i = 0; i < arguments.length;) {
       n = new this(arguments[i++]);
       if (!n.d) {
         if (n.s) {
           external = true;
           return new this(1 / 0);
         }
         t = n;
       } else if (t.d) {
         t = t.plus(n.times(n));
       }
     }

     external = true;

     return t.sqrt();
   }


   /*
    * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
    * otherwise return false.
    *
    */
   function isDecimalInstance(obj) {
     return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
   }


   /*
    * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function ln(x) {
     return new this(x).ln();
   }


   /*
    * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
    * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
    *
    * log[y](x)
    *
    * x {number|string|Decimal} The argument of the logarithm.
    * y {number|string|Decimal} The base of the logarithm.
    *
    */
   function log$1(x, y) {
     return new this(x).log(y);
   }


   /*
    * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function log2$1(x) {
     return new this(x).log(2);
   }


   /*
    * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function log10$1(x) {
     return new this(x).log(10);
   }


   /*
    * Return a new Decimal whose value is the maximum of the arguments.
    *
    * arguments {number|string|Decimal}
    *
    */
   function max$1() {
     return maxOrMin(this, arguments, 'lt');
   }


   /*
    * Return a new Decimal whose value is the minimum of the arguments.
    *
    * arguments {number|string|Decimal}
    *
    */
   function min$1() {
     return maxOrMin(this, arguments, 'gt');
   }


   /*
    * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
    * using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    * y {number|string|Decimal}
    *
    */
   function mod$1(x, y) {
     return new this(x).mod(y);
   }


   /*
    * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    * y {number|string|Decimal}
    *
    */
   function mul(x, y) {
     return new this(x).mul(y);
   }


   /*
    * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} The base.
    * y {number|string|Decimal} The exponent.
    *
    */
   function pow$1(x, y) {
     return new this(x).pow(y);
   }


   /*
    * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
    * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
    * are produced).
    *
    * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
    *
    */
   function random$1(sd) {
     var d, e, k, n,
       i = 0,
       r = new this(1),
       rd = [];

     if (sd === void 0) sd = this.precision;
     else checkInt32(sd, 1, MAX_DIGITS);

     k = Math.ceil(sd / LOG_BASE);

     if (!this.crypto) {
       for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

     // Browsers supporting crypto.getRandomValues.
     } else if (crypto.getRandomValues) {
       d = crypto.getRandomValues(new Uint32Array(k));

       for (; i < k;) {
         n = d[i];

         // 0 <= n < 4294967296
         // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
         if (n >= 4.29e9) {
           d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
         } else {

           // 0 <= n <= 4289999999
           // 0 <= (n % 1e7) <= 9999999
           rd[i++] = n % 1e7;
         }
       }

     // Node.js supporting crypto.randomBytes.
     } else if (crypto.randomBytes) {

       // buffer
       d = crypto.randomBytes(k *= 4);

       for (; i < k;) {

         // 0 <= n < 2147483648
         n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

         // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
         if (n >= 2.14e9) {
           crypto.randomBytes(4).copy(d, i);
         } else {

           // 0 <= n <= 2139999999
           // 0 <= (n % 1e7) <= 9999999
           rd.push(n % 1e7);
           i += 4;
         }
       }

       i = k / 4;
     } else {
       throw Error(cryptoUnavailable);
     }

     k = rd[--i];
     sd %= LOG_BASE;

     // Convert trailing digits to zeros according to sd.
     if (k && sd) {
       n = mathpow(10, LOG_BASE - sd);
       rd[i] = (k / n | 0) * n;
     }

     // Remove trailing words which are zero.
     for (; rd[i] === 0; i--) rd.pop();

     // Zero?
     if (i < 0) {
       e = 0;
       rd = [0];
     } else {
       e = -1;

       // Remove leading words which are zero and adjust exponent accordingly.
       for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

       // Count the digits of the first word of rd to determine leading zeros.
       for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

       // Adjust the exponent for leading zeros of the first word of rd.
       if (k < LOG_BASE) e -= LOG_BASE - k;
     }

     r.e = e;
     r.d = rd;

     return r;
   }


   /*
    * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
    *
    * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
    *
    * x {number|string|Decimal}
    *
    */
   function round$1(x) {
     return finalise(x = new this(x), x.e + 1, this.rounding);
   }


   /*
    * Return
    *   1    if x > 0,
    *  -1    if x < 0,
    *   0    if x is 0,
    *  -0    if x is -0,
    *   NaN  otherwise
    *
    * x {number|string|Decimal}
    *
    */
   function sign$1(x) {
     x = new this(x);
     return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
   }


   /*
    * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
    * using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function sin$1(x) {
     return new this(x).sin();
   }


   /*
    * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function sinh$1(x) {
     return new this(x).sinh();
   }


   /*
    * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    *
    */
   function sqrt$1(x) {
     return new this(x).sqrt();
   }


   /*
    * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
    * using rounding mode `rounding`.
    *
    * x {number|string|Decimal}
    * y {number|string|Decimal}
    *
    */
   function sub(x, y) {
     return new this(x).sub(y);
   }


   /*
    * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * Only the result is rounded, not the intermediate calculations.
    *
    * arguments {number|string|Decimal}
    *
    */
   function sum$1() {
     var i = 0,
       args = arguments,
       x = new this(args[i]);

     external = false;
     for (; x.s && ++i < args.length;) x = x.plus(args[i]);
     external = true;

     return finalise(x, this.precision, this.rounding);
   }


   /*
    * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
    * digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function tan$1(x) {
     return new this(x).tan();
   }


   /*
    * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
    * significant digits using rounding mode `rounding`.
    *
    * x {number|string|Decimal} A value in radians.
    *
    */
   function tanh$1(x) {
     return new this(x).tanh();
   }


   /*
    * Return a new Decimal whose value is `x` truncated to an integer.
    *
    * x {number|string|Decimal}
    *
    */
   function trunc(x) {
     return finalise(x = new this(x), x.e + 1, 1);
   }


   P$1[Symbol.for('nodejs.util.inspect.custom')] = P$1.toString;
   P$1[Symbol.toStringTag] = 'Decimal';

   // Create and configure initial Decimal constructor.
   var Decimal = P$1.constructor = clone$1(DEFAULTS);

   // Create the internal constants from their string values.
   LN10$1 = new Decimal(LN10$1);
   PI = new Decimal(PI);

   var name$4N = 'BigNumber';
   var dependencies$4M = ['?on', 'config'];
   var createBigNumberClass = /* #__PURE__ */factory(name$4N, dependencies$4M, _ref => {
     var {
       on,
       config
     } = _ref;
     var BigNumber = Decimal.clone({
       precision: config.precision,
       modulo: Decimal.EUCLID
     });
     BigNumber.prototype = Object.create(BigNumber.prototype);

     /**
      * Attach type information
      */
     BigNumber.prototype.type = 'BigNumber';
     BigNumber.prototype.isBigNumber = true;

     /**
      * Get a JSON representation of a BigNumber containing
      * type information
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "BigNumber", "value": "0.2"}`
      */
     BigNumber.prototype.toJSON = function () {
       return {
         mathjs: 'BigNumber',
         value: this.toString()
       };
     };

     /**
      * Instantiate a BigNumber from a JSON object
      * @param {Object} json  a JSON object structured as:
      *                       `{"mathjs": "BigNumber", "value": "0.2"}`
      * @return {BigNumber}
      */
     BigNumber.fromJSON = function (json) {
       return new BigNumber(json.value);
     };
     if (on) {
       // listen for changed in the configuration, automatically apply changed precision
       on('config', function (curr, prev) {
         if (curr.precision !== prev.precision) {
           BigNumber.config({
             precision: curr.precision
           });
         }
       });
     }
     return BigNumber;
   }, {
     isClass: true
   });

   var complex$1 = {exports: {}};

   /**
    * @license Complex.js v2.1.1 12/05/2020
    *
    * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
    * Dual licensed under the MIT or GPL Version 2 licenses.
    **/

   (function (module, exports) {
   	/**
   	 *
   	 * This class allows the manipulation of complex numbers.
   	 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
   	 *
   	 * Object form
   	 * { re: <real>, im: <imaginary> }
   	 * { arg: <angle>, abs: <radius> }
   	 * { phi: <angle>, r: <radius> }
   	 *
   	 * Array / Vector form
   	 * [ real, imaginary ]
   	 *
   	 * Double form
   	 * 99.3 - Single double value
   	 *
   	 * String form
   	 * '23.1337' - Simple real number
   	 * '15+3i' - a simple complex number
   	 * '3-i' - a simple complex number
   	 *
   	 * Example:
   	 *
   	 * var c = new Complex('99.3+8i');
   	 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
   	 *
   	 */

   	(function(root) {

   	  var cosh = Math.cosh || function(x) {
   	    return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
   	  };

   	  var sinh = Math.sinh || function(x) {
   	    return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
   	  };

   	  /**
   	   * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).
   	   *
   	   * @param {number} x
   	   * @returns {number} cos(x) - 1
   	   */
   	  var cosm1 = function(x) {

   	    var b = Math.PI / 4;
   	    if (-b > x || x > b) {
   	      return Math.cos(x) - 1.0;
   	    }

   	    /* Calculate horner form of polynomial of taylor series in Q
   	    var fac = 1, alt = 1, pol = {};
   	    for (var i = 0; i <= 16; i++) {
   	      fac*= i || 1;
   	      if (i % 2 == 0) {
   	        pol[i] = new Fraction(1, alt * fac);
   	        alt = -alt;
   	      }
   	    }
   	    console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
   	    */

   	    var xx = x * x;
   	    return xx * (
   	      xx * (
   	        xx * (
   	          xx * (
   	            xx * (
   	              xx * (
   	                xx * (
   	                  xx / 20922789888000
   	                  - 1 / 87178291200)
   	                + 1 / 479001600)
   	              - 1 / 3628800)
   	            + 1 / 40320)
   	          - 1 / 720)
   	        + 1 / 24)
   	      - 1 / 2);
   	  };

   	  var hypot = function(x, y) {

   	    var a = Math.abs(x);
   	    var b = Math.abs(y);

   	    if (a < 3000 && b < 3000) {
   	      return Math.sqrt(a * a + b * b);
   	    }

   	    if (a < b) {
   	      a = b;
   	      b = x / y;
   	    } else {
   	      b = y / x;
   	    }
   	    return a * Math.sqrt(1 + b * b);
   	  };

   	  var parser_exit = function() {
   	    throw SyntaxError('Invalid Param');
   	  };

   	  /**
   	   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
   	   *
   	   * @param {number} a
   	   * @param {number} b
   	   * @returns {number}
   	   */
   	  function logHypot(a, b) {

   	    var _a = Math.abs(a);
   	    var _b = Math.abs(b);

   	    if (a === 0) {
   	      return Math.log(_b);
   	    }

   	    if (b === 0) {
   	      return Math.log(_a);
   	    }

   	    if (_a < 3000 && _b < 3000) {
   	      return Math.log(a * a + b * b) * 0.5;
   	    }

   	    /* I got 4 ideas to compute this property without overflow:
   	     *
   	     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
   	     *
   	     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

   	     Math.log(a * a + b * b) / 2

   	     *
   	     *
   	     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

   	     var fn = function(a, b) {
   	     a = Math.abs(a);
   	     b = Math.abs(b);
   	     var t = Math.min(a, b);
   	     a = Math.max(a, b);
   	     t = t / a;

   	     return Math.log(a) + Math.log(1 + t * t) / 2;
   	     };

   	     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

   	     Math.log(a / Math.cos(Math.atan2(b, a)))

   	     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

   	     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

   	     */

   	     a = a / 2;
   	     b = b / 2;

   	    return 0.5 * Math.log(a * a + b * b) + Math.LN2;
   	  }

   	  var parse = function(a, b) {

   	    var z = { 're': 0, 'im': 0 };

   	    if (a === undefined || a === null) {
   	      z['re'] =
   	      z['im'] = 0;
   	    } else if (b !== undefined) {
   	      z['re'] = a;
   	      z['im'] = b;
   	    } else
   	      switch (typeof a) {

   	        case 'object':

   	          if ('im' in a && 're' in a) {
   	            z['re'] = a['re'];
   	            z['im'] = a['im'];
   	          } else if ('abs' in a && 'arg' in a) {
   	            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
   	              return Complex['INFINITY'];
   	            }
   	            z['re'] = a['abs'] * Math.cos(a['arg']);
   	            z['im'] = a['abs'] * Math.sin(a['arg']);
   	          } else if ('r' in a && 'phi' in a) {
   	            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
   	              return Complex['INFINITY'];
   	            }
   	            z['re'] = a['r'] * Math.cos(a['phi']);
   	            z['im'] = a['r'] * Math.sin(a['phi']);
   	          } else if (a.length === 2) { // Quick array check
   	            z['re'] = a[0];
   	            z['im'] = a[1];
   	          } else {
   	            parser_exit();
   	          }
   	          break;

   	        case 'string':

   	          z['im'] = /* void */
   	          z['re'] = 0;

   	          var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
   	          var plus = 1;
   	          var minus = 0;

   	          if (tokens === null) {
   	            parser_exit();
   	          }

   	          for (var i = 0; i < tokens.length; i++) {

   	            var c = tokens[i];

   	            if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
   	              plus++;
   	            } else if (c === '-') {
   	              minus++;
   	            } else if (c === 'i' || c === 'I') {

   	              if (plus + minus === 0) {
   	                parser_exit();
   	              }

   	              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
   	                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
   	                i++;
   	              } else {
   	                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
   	              }
   	              plus = minus = 0;

   	            } else {

   	              if (plus + minus === 0 || isNaN(c)) {
   	                parser_exit();
   	              }

   	              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
   	                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
   	                i++;
   	              } else {
   	                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
   	              }
   	              plus = minus = 0;
   	            }
   	          }

   	          // Still something on the stack
   	          if (plus + minus > 0) {
   	            parser_exit();
   	          }
   	          break;

   	        case 'number':
   	          z['im'] = 0;
   	          z['re'] = a;
   	          break;

   	        default:
   	          parser_exit();
   	      }

   	    if (isNaN(z['re']) || isNaN(z['im'])) ;

   	    return z;
   	  };

   	  /**
   	   * @constructor
   	   * @returns {Complex}
   	   */
   	  function Complex(a, b) {

   	    if (!(this instanceof Complex)) {
   	      return new Complex(a, b);
   	    }

   	    var z = parse(a, b);

   	    this['re'] = z['re'];
   	    this['im'] = z['im'];
   	  }

   	  Complex.prototype = {

   	    're': 0,
   	    'im': 0,

   	    /**
   	     * Calculates the sign of a complex number, which is a normalized complex
   	     *
   	     * @returns {Complex}
   	     */
   	    'sign': function() {

   	      var abs = this['abs']();

   	      return new Complex(
   	        this['re'] / abs,
   	        this['im'] / abs);
   	    },

   	    /**
   	     * Adds two complex numbers
   	     *
   	     * @returns {Complex}
   	     */
   	    'add': function(a, b) {

   	      var z = new Complex(a, b);

   	      // Infinity + Infinity = NaN
   	      if (this['isInfinite']() && z['isInfinite']()) {
   	        return Complex['NAN'];
   	      }

   	      // Infinity + z = Infinity { where z != Infinity }
   	      if (this['isInfinite']() || z['isInfinite']()) {
   	        return Complex['INFINITY'];
   	      }

   	      return new Complex(
   	        this['re'] + z['re'],
   	        this['im'] + z['im']);
   	    },

   	    /**
   	     * Subtracts two complex numbers
   	     *
   	     * @returns {Complex}
   	     */
   	    'sub': function(a, b) {

   	      var z = new Complex(a, b);

   	      // Infinity - Infinity = NaN
   	      if (this['isInfinite']() && z['isInfinite']()) {
   	        return Complex['NAN'];
   	      }

   	      // Infinity - z = Infinity { where z != Infinity }
   	      if (this['isInfinite']() || z['isInfinite']()) {
   	        return Complex['INFINITY'];
   	      }

   	      return new Complex(
   	        this['re'] - z['re'],
   	        this['im'] - z['im']);
   	    },

   	    /**
   	     * Multiplies two complex numbers
   	     *
   	     * @returns {Complex}
   	     */
   	    'mul': function(a, b) {

   	      var z = new Complex(a, b);

   	      // Infinity * 0 = NaN
   	      if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
   	        return Complex['NAN'];
   	      }

   	      // Infinity * z = Infinity { where z != 0 }
   	      if (this['isInfinite']() || z['isInfinite']()) {
   	        return Complex['INFINITY'];
   	      }

   	      // Short circuit for real values
   	      if (z['im'] === 0 && this['im'] === 0) {
   	        return new Complex(this['re'] * z['re'], 0);
   	      }

   	      return new Complex(
   	        this['re'] * z['re'] - this['im'] * z['im'],
   	        this['re'] * z['im'] + this['im'] * z['re']);
   	    },

   	    /**
   	     * Divides two complex numbers
   	     *
   	     * @returns {Complex}
   	     */
   	    'div': function(a, b) {

   	      var z = new Complex(a, b);

   	      // 0 / 0 = NaN and Infinity / Infinity = NaN
   	      if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
   	        return Complex['NAN'];
   	      }

   	      // Infinity / 0 = Infinity
   	      if (this['isInfinite']() || z['isZero']()) {
   	        return Complex['INFINITY'];
   	      }

   	      // 0 / Infinity = 0
   	      if (this['isZero']() || z['isInfinite']()) {
   	        return Complex['ZERO'];
   	      }

   	      a = this['re'];
   	      b = this['im'];

   	      var c = z['re'];
   	      var d = z['im'];
   	      var t, x;

   	      if (0 === d) {
   	        // Divisor is real
   	        return new Complex(a / c, b / c);
   	      }

   	      if (Math.abs(c) < Math.abs(d)) {

   	        x = c / d;
   	        t = c * x + d;

   	        return new Complex(
   	          (a * x + b) / t,
   	          (b * x - a) / t);

   	      } else {

   	        x = d / c;
   	        t = d * x + c;

   	        return new Complex(
   	          (a + b * x) / t,
   	          (b - a * x) / t);
   	      }
   	    },

   	    /**
   	     * Calculate the power of two complex numbers
   	     *
   	     * @returns {Complex}
   	     */
   	    'pow': function(a, b) {

   	      var z = new Complex(a, b);

   	      a = this['re'];
   	      b = this['im'];

   	      if (z['isZero']()) {
   	        return Complex['ONE'];
   	      }

   	      // If the exponent is real
   	      if (z['im'] === 0) {

   	        if (b === 0 && a > 0) {

   	          return new Complex(Math.pow(a, z['re']), 0);

   	        } else if (a === 0) { // If base is fully imaginary

   	          switch ((z['re'] % 4 + 4) % 4) {
   	            case 0:
   	              return new Complex(Math.pow(b, z['re']), 0);
   	            case 1:
   	              return new Complex(0, Math.pow(b, z['re']));
   	            case 2:
   	              return new Complex(-Math.pow(b, z['re']), 0);
   	            case 3:
   	              return new Complex(0, -Math.pow(b, z['re']));
   	          }
   	        }
   	      }

   	      /* I couldn't find a good formula, so here is a derivation and optimization
   	       *
   	       * z_1^z_2 = (a + bi)^(c + di)
   	       *         = exp((c + di) * log(a + bi)
   	       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
   	       * =>...
   	       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
   	       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
   	       *
   	       * =>...
   	       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
   	       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
   	       *
   	       * =>
   	       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
   	       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
   	       *
   	       */

   	      if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
   	        return Complex['ZERO'];
   	      }

   	      var arg = Math.atan2(b, a);
   	      var loh = logHypot(a, b);

   	      a = Math.exp(z['re'] * loh - z['im'] * arg);
   	      b = z['im'] * loh + z['re'] * arg;
   	      return new Complex(
   	        a * Math.cos(b),
   	        a * Math.sin(b));
   	    },

   	    /**
   	     * Calculate the complex square root
   	     *
   	     * @returns {Complex}
   	     */
   	    'sqrt': function() {

   	      var a = this['re'];
   	      var b = this['im'];
   	      var r = this['abs']();

   	      var re, im;

   	      if (a >= 0) {

   	        if (b === 0) {
   	          return new Complex(Math.sqrt(a), 0);
   	        }

   	        re = 0.5 * Math.sqrt(2.0 * (r + a));
   	      } else {
   	        re = Math.abs(b) / Math.sqrt(2 * (r - a));
   	      }

   	      if (a <= 0) {
   	        im = 0.5 * Math.sqrt(2.0 * (r - a));
   	      } else {
   	        im = Math.abs(b) / Math.sqrt(2 * (r + a));
   	      }

   	      return new Complex(re, b < 0 ? -im : im);
   	    },

   	    /**
   	     * Calculate the complex exponent
   	     *
   	     * @returns {Complex}
   	     */
   	    'exp': function() {

   	      var tmp = Math.exp(this['re']);

   	      if (this['im'] === 0) ;
   	      return new Complex(
   	        tmp * Math.cos(this['im']),
   	        tmp * Math.sin(this['im']));
   	    },

   	    /**
   	     * Calculate the complex exponent and subtracts one.
   	     *
   	     * This may be more accurate than `Complex(x).exp().sub(1)` if
   	     * `x` is small.
   	     *
   	     * @returns {Complex}
   	     */
   	    'expm1': function() {

   	      /**
   	       * exp(a + i*b) - 1
   	       = exp(a) * (cos(b) + j*sin(b)) - 1
   	       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
   	       */

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        Math.expm1(a) * Math.cos(b) + cosm1(b),
   	        Math.exp(a) * Math.sin(b));
   	    },

   	    /**
   	     * Calculate the natural log
   	     *
   	     * @returns {Complex}
   	     */
   	    'log': function() {

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        logHypot(a, b),
   	        Math.atan2(b, a));
   	    },

   	    /**
   	     * Calculate the magnitude of the complex number
   	     *
   	     * @returns {number}
   	     */
   	    'abs': function() {

   	      return hypot(this['re'], this['im']);
   	    },

   	    /**
   	     * Calculate the angle of the complex number
   	     *
   	     * @returns {number}
   	     */
   	    'arg': function() {

   	      return Math.atan2(this['im'], this['re']);
   	    },

   	    /**
   	     * Calculate the sine of the complex number
   	     *
   	     * @returns {Complex}
   	     */
   	    'sin': function() {

   	      // sin(z) = ( e^iz - e^-iz ) / 2i 
   	      //        = sin(a)cosh(b) + i cos(a)sinh(b)

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        Math.sin(a) * cosh(b),
   	        Math.cos(a) * sinh(b));
   	    },

   	    /**
   	     * Calculate the cosine
   	     *
   	     * @returns {Complex}
   	     */
   	    'cos': function() {

   	      // cos(z) = ( e^iz + e^-iz ) / 2 
   	      //        = cos(a)cosh(b) - i sin(a)sinh(b)

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        Math.cos(a) * cosh(b),
   	        -Math.sin(a) * sinh(b));
   	    },

   	    /**
   	     * Calculate the tangent
   	     *
   	     * @returns {Complex}
   	     */
   	    'tan': function() {

   	      // tan(z) = sin(z) / cos(z) 
   	      //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
   	      //        = ( e^2iz - 1 ) / i( e^2iz + 1 )
   	      //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )

   	      var a = 2 * this['re'];
   	      var b = 2 * this['im'];
   	      var d = Math.cos(a) + cosh(b);

   	      return new Complex(
   	        Math.sin(a) / d,
   	        sinh(b) / d);
   	    },

   	    /**
   	     * Calculate the cotangent
   	     *
   	     * @returns {Complex}
   	     */
   	    'cot': function() {

   	      // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

   	      var a = 2 * this['re'];
   	      var b = 2 * this['im'];
   	      var d = Math.cos(a) - cosh(b);

   	      return new Complex(
   	        -Math.sin(a) / d,
   	        sinh(b) / d);
   	    },

   	    /**
   	     * Calculate the secant
   	     *
   	     * @returns {Complex}
   	     */
   	    'sec': function() {

   	      // sec(c) = 2 / (e^(ci) + e^(-ci))

   	      var a = this['re'];
   	      var b = this['im'];
   	      var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

   	      return new Complex(
   	        Math.cos(a) * cosh(b) / d,
   	        Math.sin(a) * sinh(b) / d);
   	    },

   	    /**
   	     * Calculate the cosecans
   	     *
   	     * @returns {Complex}
   	     */
   	    'csc': function() {

   	      // csc(c) = 2i / (e^(ci) - e^(-ci))

   	      var a = this['re'];
   	      var b = this['im'];
   	      var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

   	      return new Complex(
   	        Math.sin(a) * cosh(b) / d,
   	        -Math.cos(a) * sinh(b) / d);
   	    },

   	    /**
   	     * Calculate the complex arcus sinus
   	     *
   	     * @returns {Complex}
   	     */
   	    'asin': function() {

   	      // asin(c) = -i * log(ci + sqrt(1 - c^2))

   	      var a = this['re'];
   	      var b = this['im'];

   	      var t1 = new Complex(
   	        b * b - a * a + 1,
   	        -2 * a * b)['sqrt']();

   	      var t2 = new Complex(
   	        t1['re'] - b,
   	        t1['im'] + a)['log']();

   	      return new Complex(t2['im'], -t2['re']);
   	    },

   	    /**
   	     * Calculate the complex arcus cosinus
   	     *
   	     * @returns {Complex}
   	     */
   	    'acos': function() {

   	      // acos(c) = i * log(c - i * sqrt(1 - c^2))

   	      var a = this['re'];
   	      var b = this['im'];

   	      var t1 = new Complex(
   	        b * b - a * a + 1,
   	        -2 * a * b)['sqrt']();

   	      var t2 = new Complex(
   	        t1['re'] - b,
   	        t1['im'] + a)['log']();

   	      return new Complex(Math.PI / 2 - t2['im'], t2['re']);
   	    },

   	    /**
   	     * Calculate the complex arcus tangent
   	     *
   	     * @returns {Complex}
   	     */
   	    'atan': function() {

   	      // atan(c) = i / 2 log((i + x) / (i - x))

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (a === 0) {

   	        if (b === 1) {
   	          return new Complex(0, Infinity);
   	        }

   	        if (b === -1) {
   	          return new Complex(0, -Infinity);
   	        }
   	      }

   	      var d = a * a + (1.0 - b) * (1.0 - b);

   	      var t1 = new Complex(
   	        (1 - b * b - a * a) / d,
   	        -2 * a / d).log();

   	      return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
   	    },

   	    /**
   	     * Calculate the complex arcus cotangent
   	     *
   	     * @returns {Complex}
   	     */
   	    'acot': function() {

   	      // acot(c) = i / 2 log((c - i) / (c + i))

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (b === 0) {
   	        return new Complex(Math.atan2(1, a), 0);
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).atan()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).atan();
   	    },

   	    /**
   	     * Calculate the complex arcus secant
   	     *
   	     * @returns {Complex}
   	     */
   	    'asec': function() {

   	      // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (a === 0 && b === 0) {
   	        return new Complex(0, Infinity);
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).acos()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).acos();
   	    },

   	    /**
   	     * Calculate the complex arcus cosecans
   	     *
   	     * @returns {Complex}
   	     */
   	    'acsc': function() {

   	      // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (a === 0 && b === 0) {
   	        return new Complex(Math.PI / 2, Infinity);
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).asin()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).asin();
   	    },

   	    /**
   	     * Calculate the complex sinh
   	     *
   	     * @returns {Complex}
   	     */
   	    'sinh': function() {

   	      // sinh(c) = (e^c - e^-c) / 2

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        sinh(a) * Math.cos(b),
   	        cosh(a) * Math.sin(b));
   	    },

   	    /**
   	     * Calculate the complex cosh
   	     *
   	     * @returns {Complex}
   	     */
   	    'cosh': function() {

   	      // cosh(c) = (e^c + e^-c) / 2

   	      var a = this['re'];
   	      var b = this['im'];

   	      return new Complex(
   	        cosh(a) * Math.cos(b),
   	        sinh(a) * Math.sin(b));
   	    },

   	    /**
   	     * Calculate the complex tanh
   	     *
   	     * @returns {Complex}
   	     */
   	    'tanh': function() {

   	      // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

   	      var a = 2 * this['re'];
   	      var b = 2 * this['im'];
   	      var d = cosh(a) + Math.cos(b);

   	      return new Complex(
   	        sinh(a) / d,
   	        Math.sin(b) / d);
   	    },

   	    /**
   	     * Calculate the complex coth
   	     *
   	     * @returns {Complex}
   	     */
   	    'coth': function() {

   	      // coth(c) = (e^c + e^-c) / (e^c - e^-c)

   	      var a = 2 * this['re'];
   	      var b = 2 * this['im'];
   	      var d = cosh(a) - Math.cos(b);

   	      return new Complex(
   	        sinh(a) / d,
   	        -Math.sin(b) / d);
   	    },

   	    /**
   	     * Calculate the complex coth
   	     *
   	     * @returns {Complex}
   	     */
   	    'csch': function() {

   	      // csch(c) = 2 / (e^c - e^-c)

   	      var a = this['re'];
   	      var b = this['im'];
   	      var d = Math.cos(2 * b) - cosh(2 * a);

   	      return new Complex(
   	        -2 * sinh(a) * Math.cos(b) / d,
   	        2 * cosh(a) * Math.sin(b) / d);
   	    },

   	    /**
   	     * Calculate the complex sech
   	     *
   	     * @returns {Complex}
   	     */
   	    'sech': function() {

   	      // sech(c) = 2 / (e^c + e^-c)

   	      var a = this['re'];
   	      var b = this['im'];
   	      var d = Math.cos(2 * b) + cosh(2 * a);

   	      return new Complex(
   	        2 * cosh(a) * Math.cos(b) / d,
   	        -2 * sinh(a) * Math.sin(b) / d);
   	    },

   	    /**
   	     * Calculate the complex asinh
   	     *
   	     * @returns {Complex}
   	     */
   	    'asinh': function() {

   	      // asinh(c) = log(c + sqrt(c^2 + 1))

   	      var tmp = this['im'];
   	      this['im'] = -this['re'];
   	      this['re'] = tmp;
   	      var res = this['asin']();

   	      this['re'] = -this['im'];
   	      this['im'] = tmp;
   	      tmp = res['re'];

   	      res['re'] = -res['im'];
   	      res['im'] = tmp;
   	      return res;
   	    },

   	    /**
   	     * Calculate the complex acosh
   	     *
   	     * @returns {Complex}
   	     */
   	    'acosh': function() {

   	      // acosh(c) = log(c + sqrt(c^2 - 1))

   	      var res = this['acos']();
   	      if (res['im'] <= 0) {
   	        var tmp = res['re'];
   	        res['re'] = -res['im'];
   	        res['im'] = tmp;
   	      } else {
   	        var tmp = res['im'];
   	        res['im'] = -res['re'];
   	        res['re'] = tmp;
   	      }
   	      return res;
   	    },

   	    /**
   	     * Calculate the complex atanh
   	     *
   	     * @returns {Complex}
   	     */
   	    'atanh': function() {

   	      // atanh(c) = log((1+c) / (1-c)) / 2

   	      var a = this['re'];
   	      var b = this['im'];

   	      var noIM = a > 1 && b === 0;
   	      var oneMinus = 1 - a;
   	      var onePlus = 1 + a;
   	      var d = oneMinus * oneMinus + b * b;

   	      var x = (d !== 0)
   	        ? new Complex(
   	          (onePlus * oneMinus - b * b) / d,
   	          (b * oneMinus + onePlus * b) / d)
   	        : new Complex(
   	          (a !== -1) ? (a / 0) : 0,
   	          (b !== 0) ? (b / 0) : 0);

   	      var temp = x['re'];
   	      x['re'] = logHypot(x['re'], x['im']) / 2;
   	      x['im'] = Math.atan2(x['im'], temp) / 2;
   	      if (noIM) {
   	        x['im'] = -x['im'];
   	      }
   	      return x;
   	    },

   	    /**
   	     * Calculate the complex acoth
   	     *
   	     * @returns {Complex}
   	     */
   	    'acoth': function() {

   	      // acoth(c) = log((c+1) / (c-1)) / 2

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (a === 0 && b === 0) {
   	        return new Complex(0, Math.PI / 2);
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).atanh()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).atanh();
   	    },

   	    /**
   	     * Calculate the complex acsch
   	     *
   	     * @returns {Complex}
   	     */
   	    'acsch': function() {

   	      // acsch(c) = log((1+sqrt(1+c^2))/c)

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (b === 0) {

   	        return new Complex(
   	          (a !== 0)
   	            ? Math.log(a + Math.sqrt(a * a + 1))
   	            : Infinity, 0);
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).asinh()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).asinh();
   	    },

   	    /**
   	     * Calculate the complex asech
   	     *
   	     * @returns {Complex}
   	     */
   	    'asech': function() {

   	      // asech(c) = log((1+sqrt(1-c^2))/c)

   	      var a = this['re'];
   	      var b = this['im'];

   	      if (this['isZero']()) {
   	        return Complex['INFINITY'];
   	      }

   	      var d = a * a + b * b;
   	      return (d !== 0)
   	        ? new Complex(
   	          a / d,
   	          -b / d).acosh()
   	        : new Complex(
   	          (a !== 0) ? a / 0 : 0,
   	          (b !== 0) ? -b / 0 : 0).acosh();
   	    },

   	    /**
   	     * Calculate the complex inverse 1/z
   	     *
   	     * @returns {Complex}
   	     */
   	    'inverse': function() {

   	      // 1 / 0 = Infinity and 1 / Infinity = 0
   	      if (this['isZero']()) {
   	        return Complex['INFINITY'];
   	      }

   	      if (this['isInfinite']()) {
   	        return Complex['ZERO'];
   	      }

   	      var a = this['re'];
   	      var b = this['im'];

   	      var d = a * a + b * b;

   	      return new Complex(a / d, -b / d);
   	    },

   	    /**
   	     * Returns the complex conjugate
   	     *
   	     * @returns {Complex}
   	     */
   	    'conjugate': function() {

   	      return new Complex(this['re'], -this['im']);
   	    },

   	    /**
   	     * Gets the negated complex number
   	     *
   	     * @returns {Complex}
   	     */
   	    'neg': function() {

   	      return new Complex(-this['re'], -this['im']);
   	    },

   	    /**
   	     * Ceils the actual complex number
   	     *
   	     * @returns {Complex}
   	     */
   	    'ceil': function(places) {

   	      places = Math.pow(10, places || 0);

   	      return new Complex(
   	        Math.ceil(this['re'] * places) / places,
   	        Math.ceil(this['im'] * places) / places);
   	    },

   	    /**
   	     * Floors the actual complex number
   	     *
   	     * @returns {Complex}
   	     */
   	    'floor': function(places) {

   	      places = Math.pow(10, places || 0);

   	      return new Complex(
   	        Math.floor(this['re'] * places) / places,
   	        Math.floor(this['im'] * places) / places);
   	    },

   	    /**
   	     * Ceils the actual complex number
   	     *
   	     * @returns {Complex}
   	     */
   	    'round': function(places) {

   	      places = Math.pow(10, places || 0);

   	      return new Complex(
   	        Math.round(this['re'] * places) / places,
   	        Math.round(this['im'] * places) / places);
   	    },

   	    /**
   	     * Compares two complex numbers
   	     *
   	     * **Note:** new Complex(Infinity).equals(Infinity) === false
   	     *
   	     * @returns {boolean}
   	     */
   	    'equals': function(a, b) {

   	      var z = new Complex(a, b);

   	      return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
   	        Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
   	    },

   	    /**
   	     * Clones the actual object
   	     *
   	     * @returns {Complex}
   	     */
   	    'clone': function() {

   	      return new Complex(this['re'], this['im']);
   	    },

   	    /**
   	     * Gets a string of the actual complex number
   	     *
   	     * @returns {string}
   	     */
   	    'toString': function() {

   	      var a = this['re'];
   	      var b = this['im'];
   	      var ret = "";

   	      if (this['isNaN']()) {
   	        return 'NaN';
   	      }

   	      if (this['isInfinite']()) {
   	        return 'Infinity';
   	      }

   	      if (Math.abs(a) < Complex['EPSILON']) {
   	        a = 0;
   	      }

   	      if (Math.abs(b) < Complex['EPSILON']) {
   	        b = 0;
   	      }

   	      // If is real number
   	      if (b === 0) {
   	        return ret + a;
   	      }

   	      if (a !== 0) {
   	        ret += a;
   	        ret += " ";
   	        if (b < 0) {
   	          b = -b;
   	          ret += "-";
   	        } else {
   	          ret += "+";
   	        }
   	        ret += " ";
   	      } else if (b < 0) {
   	        b = -b;
   	        ret += "-";
   	      }

   	      if (1 !== b) { // b is the absolute imaginary part
   	        ret += b;
   	      }
   	      return ret + "i";
   	    },

   	    /**
   	     * Returns the actual number as a vector
   	     *
   	     * @returns {Array}
   	     */
   	    'toVector': function() {

   	      return [this['re'], this['im']];
   	    },

   	    /**
   	     * Returns the actual real value of the current object
   	     *
   	     * @returns {number|null}
   	     */
   	    'valueOf': function() {

   	      if (this['im'] === 0) {
   	        return this['re'];
   	      }
   	      return null;
   	    },

   	    /**
   	     * Determines whether a complex number is not on the Riemann sphere.
   	     *
   	     * @returns {boolean}
   	     */
   	    'isNaN': function() {
   	      return isNaN(this['re']) || isNaN(this['im']);
   	    },

   	    /**
   	     * Determines whether or not a complex number is at the zero pole of the
   	     * Riemann sphere.
   	     *
   	     * @returns {boolean}
   	     */
   	    'isZero': function() {
   	      return this['im'] === 0 && this['re'] === 0;
   	    },

   	    /**
   	     * Determines whether a complex number is not at the infinity pole of the
   	     * Riemann sphere.
   	     *
   	     * @returns {boolean}
   	     */
   	    'isFinite': function() {
   	      return isFinite(this['re']) && isFinite(this['im']);
   	    },

   	    /**
   	     * Determines whether or not a complex number is at the infinity pole of the
   	     * Riemann sphere.
   	     *
   	     * @returns {boolean}
   	     */
   	    'isInfinite': function() {
   	      return !(this['isNaN']() || this['isFinite']());
   	    }
   	  };

   	  Complex['ZERO'] = new Complex(0, 0);
   	  Complex['ONE'] = new Complex(1, 0);
   	  Complex['I'] = new Complex(0, 1);
   	  Complex['PI'] = new Complex(Math.PI, 0);
   	  Complex['E'] = new Complex(Math.E, 0);
   	  Complex['INFINITY'] = new Complex(Infinity, Infinity);
   	  Complex['NAN'] = new Complex(NaN, NaN);
   	  Complex['EPSILON'] = 1e-15;

   	  {
   	    Object.defineProperty(Complex, "__esModule", { 'value': true });
   	    Complex['default'] = Complex;
   	    Complex['Complex'] = Complex;
   	    module['exports'] = Complex;
   	  }

   	})(); 
   } (complex$1));

   var complexExports = complex$1.exports;
   var Complex$1 = /*@__PURE__*/getDefaultExportFromCjs(complexExports);

   var name$4M = 'Complex';
   var dependencies$4L = [];
   var createComplexClass = /* #__PURE__ */factory(name$4M, dependencies$4L, () => {
     /**
      * Attach type information
      */
     Object.defineProperty(Complex$1, 'name', {
       value: 'Complex'
     });
     Complex$1.prototype.constructor = Complex$1;
     Complex$1.prototype.type = 'Complex';
     Complex$1.prototype.isComplex = true;

     /**
      * Get a JSON representation of the complex number
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
      */
     Complex$1.prototype.toJSON = function () {
       return {
         mathjs: 'Complex',
         re: this.re,
         im: this.im
       };
     };

     /*
      * Return the value of the complex number in polar notation
      * The angle phi will be set in the interval of [-pi, pi].
      * @return {{r: number, phi: number}} Returns and object with properties r and phi.
      */
     Complex$1.prototype.toPolar = function () {
       return {
         r: this.abs(),
         phi: this.arg()
       };
     };

     /**
      * Get a string representation of the complex number,
      * with optional formatting options.
      * @param {Object | number | Function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @return {string} str
      */
     Complex$1.prototype.format = function (options) {
       var str = '';
       var im = this.im;
       var re = this.re;
       var strRe = format$3(this.re, options);
       var strIm = format$3(this.im, options);

       // round either re or im when smaller than the configured precision
       var precision = isNumber(options) ? options : options ? options.precision : null;
       if (precision !== null) {
         var epsilon = Math.pow(10, -precision);
         if (Math.abs(re / im) < epsilon) {
           re = 0;
         }
         if (Math.abs(im / re) < epsilon) {
           im = 0;
         }
       }
       if (im === 0) {
         // real value
         str = strRe;
       } else if (re === 0) {
         // purely complex value
         if (im === 1) {
           str = 'i';
         } else if (im === -1) {
           str = '-i';
         } else {
           str = strIm + 'i';
         }
       } else {
         // complex value
         if (im < 0) {
           if (im === -1) {
             str = strRe + ' - i';
           } else {
             str = strRe + ' - ' + strIm.substring(1) + 'i';
           }
         } else {
           if (im === 1) {
             str = strRe + ' + i';
           } else {
             str = strRe + ' + ' + strIm + 'i';
           }
         }
       }
       return str;
     };

     /**
      * Create a complex number from polar coordinates
      *
      * Usage:
      *
      *     Complex.fromPolar(r: number, phi: number) : Complex
      *     Complex.fromPolar({r: number, phi: number}) : Complex
      *
      * @param {*} args...
      * @return {Complex}
      */
     Complex$1.fromPolar = function (args) {
       switch (arguments.length) {
         case 1:
           {
             var arg = arguments[0];
             if (typeof arg === 'object') {
               return Complex$1(arg);
             } else {
               throw new TypeError('Input has to be an object with r and phi keys.');
             }
           }
         case 2:
           {
             var r = arguments[0];
             var phi = arguments[1];
             if (isNumber(r)) {
               if (isUnit(phi) && phi.hasBase('ANGLE')) {
                 // convert unit to a number in radians
                 phi = phi.toNumber('rad');
               }
               if (isNumber(phi)) {
                 return new Complex$1({
                   r,
                   phi
                 });
               }
               throw new TypeError('Phi is not a number nor an angle unit.');
             } else {
               throw new TypeError('Radius r is not a number.');
             }
           }
         default:
           throw new SyntaxError('Wrong number of arguments in function fromPolar');
       }
     };
     Complex$1.prototype.valueOf = Complex$1.prototype.toString;

     /**
      * Create a Complex number from a JSON object
      * @param {Object} json  A JSON Object structured as
      *                       {"mathjs": "Complex", "re": 2, "im": 3}
      *                       All properties are optional, default values
      *                       for `re` and `im` are 0.
      * @return {Complex} Returns a new Complex number
      */
     Complex$1.fromJSON = function (json) {
       return new Complex$1(json);
     };

     /**
      * Compare two complex numbers, `a` and `b`:
      *
      * - Returns 1 when the real part of `a` is larger than the real part of `b`
      * - Returns -1 when the real part of `a` is smaller than the real part of `b`
      * - Returns 1 when the real parts are equal
      *   and the imaginary part of `a` is larger than the imaginary part of `b`
      * - Returns -1 when the real parts are equal
      *   and the imaginary part of `a` is smaller than the imaginary part of `b`
      * - Returns 0 when both real and imaginary parts are equal.
      *
      * @params {Complex} a
      * @params {Complex} b
      * @returns {number} Returns the comparison result: -1, 0, or 1
      */
     Complex$1.compare = function (a, b) {
       if (a.re > b.re) {
         return 1;
       }
       if (a.re < b.re) {
         return -1;
       }
       if (a.im > b.im) {
         return 1;
       }
       if (a.im < b.im) {
         return -1;
       }
       return 0;
     };
     return Complex$1;
   }, {
     isClass: true
   });

   var fraction$1 = {exports: {}};

   /**
    * @license Fraction.js v4.3.0 20/08/2023
    * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
    *
    * Copyright (c) 2023, Robert Eisele (robert@raw.org)
    * Dual licensed under the MIT or GPL Version 2 licenses.
    **/

   (function (module, exports) {
   	/**
   	 *
   	 * This class offers the possibility to calculate fractions.
   	 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
   	 *
   	 * Array/Object form
   	 * [ 0 => <numerator>, 1 => <denominator> ]
   	 * [ n => <numerator>, d => <denominator> ]
   	 *
   	 * Integer form
   	 * - Single integer value
   	 *
   	 * Double form
   	 * - Single double value
   	 *
   	 * String form
   	 * 123.456 - a simple double
   	 * 123/456 - a string fraction
   	 * 123.'456' - a double with repeating decimal places
   	 * 123.(456) - synonym
   	 * 123.45'6' - a double with repeating last place
   	 * 123.45(6) - synonym
   	 *
   	 * Example:
   	 *
   	 * var f = new Fraction("9.4'31'");
   	 * f.mul([-4, 3]).div(4.9);
   	 *
   	 */

   	(function(root) {

   	  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
   	  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
   	  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
   	  var MAX_CYCLE_LEN = 2000;

   	  // Parsed data to avoid calling "new" all the time
   	  var P = {
   	    "s": 1,
   	    "n": 0,
   	    "d": 1
   	  };

   	  function assign(n, s) {

   	    if (isNaN(n = parseInt(n, 10))) {
   	      throw InvalidParameter();
   	    }
   	    return n * s;
   	  }

   	  // Creates a new Fraction internally without the need of the bulky constructor
   	  function newFraction(n, d) {

   	    if (d === 0) {
   	      throw DivisionByZero();
   	    }

   	    var f = Object.create(Fraction.prototype);
   	    f["s"] = n < 0 ? -1 : 1;

   	    n = n < 0 ? -n : n;

   	    var a = gcd(n, d);

   	    f["n"] = n / a;
   	    f["d"] = d / a;
   	    return f;
   	  }

   	  function factorize(num) {

   	    var factors = {};

   	    var n = num;
   	    var i = 2;
   	    var s = 4;

   	    while (s <= n) {

   	      while (n % i === 0) {
   	        n/= i;
   	        factors[i] = (factors[i] || 0) + 1;
   	      }
   	      s+= 1 + 2 * i++;
   	    }

   	    if (n !== num) {
   	      if (n > 1)
   	        factors[n] = (factors[n] || 0) + 1;
   	    } else {
   	      factors[num] = (factors[num] || 0) + 1;
   	    }
   	    return factors;
   	  }

   	  var parse = function(p1, p2) {

   	    var n = 0, d = 1, s = 1;
   	    var v = 0, w = 0, x = 0, y = 1, z = 1;

   	    var A = 0, B = 1;
   	    var C = 1, D = 1;

   	    var N = 10000000;
   	    var M;

   	    if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
   	      n = p1;
   	      d = p2;
   	      s = n * d;

   	      if (n % 1 !== 0 || d % 1 !== 0) {
   	        throw NonIntegerParameter();
   	      }

   	    } else
   	      switch (typeof p1) {

   	        case "object":
   	          {
   	            if ("d" in p1 && "n" in p1) {
   	              n = p1["n"];
   	              d = p1["d"];
   	              if ("s" in p1)
   	                n*= p1["s"];
   	            } else if (0 in p1) {
   	              n = p1[0];
   	              if (1 in p1)
   	                d = p1[1];
   	            } else {
   	              throw InvalidParameter();
   	            }
   	            s = n * d;
   	            break;
   	          }
   	        case "number":
   	          {
   	            if (p1 < 0) {
   	              s = p1;
   	              p1 = -p1;
   	            }

   	            if (p1 % 1 === 0) {
   	              n = p1;
   	            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

   	              if (p1 >= 1) {
   	                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
   	                p1/= z;
   	              }

   	              // Using Farey Sequences
   	              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

   	              while (B <= N && D <= N) {
   	                M = (A + C) / (B + D);

   	                if (p1 === M) {
   	                  if (B + D <= N) {
   	                    n = A + C;
   	                    d = B + D;
   	                  } else if (D > B) {
   	                    n = C;
   	                    d = D;
   	                  } else {
   	                    n = A;
   	                    d = B;
   	                  }
   	                  break;

   	                } else {

   	                  if (p1 > M) {
   	                    A+= C;
   	                    B+= D;
   	                  } else {
   	                    C+= A;
   	                    D+= B;
   	                  }

   	                  if (B > N) {
   	                    n = C;
   	                    d = D;
   	                  } else {
   	                    n = A;
   	                    d = B;
   	                  }
   	                }
   	              }
   	              n*= z;
   	            } else if (isNaN(p1) || isNaN(p2)) {
   	              d = n = NaN;
   	            }
   	            break;
   	          }
   	        case "string":
   	          {
   	            B = p1.match(/\d+|./g);

   	            if (B === null)
   	              throw InvalidParameter();

   	            if (B[A] === '-') {// Check for minus sign at the beginning
   	              s = -1;
   	              A++;
   	            } else if (B[A] === '+') {// Check for plus sign at the beginning
   	              A++;
   	            }

   	            if (B.length === A + 1) { // Check if it's just a simple number "1234"
   	              w = assign(B[A++], s);
   	            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

   	              if (B[A] !== '.') { // Handle 0.5 and .5
   	                v = assign(B[A++], s);
   	              }
   	              A++;

   	              // Check for decimal places
   	              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
   	                w = assign(B[A], s);
   	                y = Math.pow(10, B[A].length);
   	                A++;
   	              }

   	              // Check for repeating places
   	              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
   	                x = assign(B[A + 1], s);
   	                z = Math.pow(10, B[A + 1].length) - 1;
   	                A+= 3;
   	              }

   	            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
   	              w = assign(B[A], s);
   	              y = assign(B[A + 2], 1);
   	              A+= 3;
   	            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
   	              v = assign(B[A], s);
   	              w = assign(B[A + 2], s);
   	              y = assign(B[A + 4], 1);
   	              A+= 5;
   	            }

   	            if (B.length <= A) { // Check for more tokens on the stack
   	              d = y * z;
   	              s = /* void */
   	              n = x + d * v + z * w;
   	              break;
   	            }

   	            /* Fall through on error */
   	          }
   	        default:
   	          throw InvalidParameter();
   	      }

   	    if (d === 0) {
   	      throw DivisionByZero();
   	    }

   	    P["s"] = s < 0 ? -1 : 1;
   	    P["n"] = Math.abs(n);
   	    P["d"] = Math.abs(d);
   	  };

   	  function modpow(b, e, m) {

   	    var r = 1;
   	    for (; e > 0; b = (b * b) % m, e >>= 1) {

   	      if (e & 1) {
   	        r = (r * b) % m;
   	      }
   	    }
   	    return r;
   	  }


   	  function cycleLen(n, d) {

   	    for (; d % 2 === 0;
   	      d/= 2) {
   	    }

   	    for (; d % 5 === 0;
   	      d/= 5) {
   	    }

   	    if (d === 1) // Catch non-cyclic numbers
   	      return 0;

   	    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
   	    // 10^(d-1) % d == 1
   	    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
   	    // as we want to translate the numbers to strings.

   	    var rem = 10 % d;
   	    var t = 1;

   	    for (; rem !== 1; t++) {
   	      rem = rem * 10 % d;

   	      if (t > MAX_CYCLE_LEN)
   	        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
   	    }
   	    return t;
   	  }


   	  function cycleStart(n, d, len) {

   	    var rem1 = 1;
   	    var rem2 = modpow(10, len, d);

   	    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
   	      // Solve 10^s == 10^(s+t) (mod d)

   	      if (rem1 === rem2)
   	        return t;

   	      rem1 = rem1 * 10 % d;
   	      rem2 = rem2 * 10 % d;
   	    }
   	    return 0;
   	  }

   	  function gcd(a, b) {

   	    if (!a)
   	      return b;
   	    if (!b)
   	      return a;

   	    while (1) {
   	      a%= b;
   	      if (!a)
   	        return b;
   	      b%= a;
   	      if (!b)
   	        return a;
   	    }
   	  }
   	  /**
   	   * Module constructor
   	   *
   	   * @constructor
   	   * @param {number|Fraction=} a
   	   * @param {number=} b
   	   */
   	  function Fraction(a, b) {

   	    parse(a, b);

   	    if (this instanceof Fraction) {
   	      a = gcd(P["d"], P["n"]); // Abuse variable a
   	      this["s"] = P["s"];
   	      this["n"] = P["n"] / a;
   	      this["d"] = P["d"] / a;
   	    } else {
   	      return newFraction(P['s'] * P['n'], P['d']);
   	    }
   	  }

   	  var DivisionByZero = function() { return new Error("Division by Zero"); };
   	  var InvalidParameter = function() { return new Error("Invalid argument"); };
   	  var NonIntegerParameter = function() { return new Error("Parameters must be integer"); };

   	  Fraction.prototype = {

   	    "s": 1,
   	    "n": 0,
   	    "d": 1,

   	    /**
   	     * Calculates the absolute value
   	     *
   	     * Ex: new Fraction(-4).abs() => 4
   	     **/
   	    "abs": function() {

   	      return newFraction(this["n"], this["d"]);
   	    },

   	    /**
   	     * Inverts the sign of the current fraction
   	     *
   	     * Ex: new Fraction(-4).neg() => 4
   	     **/
   	    "neg": function() {

   	      return newFraction(-this["s"] * this["n"], this["d"]);
   	    },

   	    /**
   	     * Adds two rational numbers
   	     *
   	     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   	     **/
   	    "add": function(a, b) {

   	      parse(a, b);
   	      return newFraction(
   	        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
   	        this["d"] * P["d"]
   	      );
   	    },

   	    /**
   	     * Subtracts two rational numbers
   	     *
   	     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   	     **/
   	    "sub": function(a, b) {

   	      parse(a, b);
   	      return newFraction(
   	        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
   	        this["d"] * P["d"]
   	      );
   	    },

   	    /**
   	     * Multiplies two rational numbers
   	     *
   	     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   	     **/
   	    "mul": function(a, b) {

   	      parse(a, b);
   	      return newFraction(
   	        this["s"] * P["s"] * this["n"] * P["n"],
   	        this["d"] * P["d"]
   	      );
   	    },

   	    /**
   	     * Divides two rational numbers
   	     *
   	     * Ex: new Fraction("-17.(345)").inverse().div(3)
   	     **/
   	    "div": function(a, b) {

   	      parse(a, b);
   	      return newFraction(
   	        this["s"] * P["s"] * this["n"] * P["d"],
   	        this["d"] * P["n"]
   	      );
   	    },

   	    /**
   	     * Clones the actual object
   	     *
   	     * Ex: new Fraction("-17.(345)").clone()
   	     **/
   	    "clone": function() {
   	      return newFraction(this['s'] * this['n'], this['d']);
   	    },

   	    /**
   	     * Calculates the modulo of two rational numbers - a more precise fmod
   	     *
   	     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   	     **/
   	    "mod": function(a, b) {

   	      if (isNaN(this['n']) || isNaN(this['d'])) {
   	        return new Fraction(NaN);
   	      }

   	      if (a === undefined) {
   	        return newFraction(this["s"] * this["n"] % this["d"], 1);
   	      }

   	      parse(a, b);
   	      if (0 === P["n"] && 0 === this["d"]) {
   	        throw DivisionByZero();
   	      }

   	      /*
   	       * First silly attempt, kinda slow
   	       *
   	       return that["sub"]({
   	       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
   	       "d": num["d"],
   	       "s": this["s"]
   	       });*/

   	      /*
   	       * New attempt: a1 / b1 = a2 / b2 * q + r
   	       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
   	       * => (b2 * a1 % a2 * b1) / (b1 * b2)
   	       */
   	      return newFraction(
   	        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
   	        P["d"] * this["d"]
   	      );
   	    },

   	    /**
   	     * Calculates the fractional gcd of two rational numbers
   	     *
   	     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   	     */
   	    "gcd": function(a, b) {

   	      parse(a, b);

   	      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

   	      return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
   	    },

   	    /**
   	     * Calculates the fractional lcm of two rational numbers
   	     *
   	     * Ex: new Fraction(5,8).lcm(3,7) => 15
   	     */
   	    "lcm": function(a, b) {

   	      parse(a, b);

   	      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

   	      if (P["n"] === 0 && this["n"] === 0) {
   	        return newFraction(0, 1);
   	      }
   	      return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
   	    },

   	    /**
   	     * Calculates the ceil of a rational number
   	     *
   	     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   	     **/
   	    "ceil": function(places) {

   	      places = Math.pow(10, places || 0);

   	      if (isNaN(this["n"]) || isNaN(this["d"])) {
   	        return new Fraction(NaN);
   	      }
   	      return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
   	    },

   	    /**
   	     * Calculates the floor of a rational number
   	     *
   	     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   	     **/
   	    "floor": function(places) {

   	      places = Math.pow(10, places || 0);

   	      if (isNaN(this["n"]) || isNaN(this["d"])) {
   	        return new Fraction(NaN);
   	      }
   	      return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
   	    },

   	    /**
   	     * Rounds a rational numbers
   	     *
   	     * Ex: new Fraction('4.(3)').round() => (4 / 1)
   	     **/
   	    "round": function(places) {

   	      places = Math.pow(10, places || 0);

   	      if (isNaN(this["n"]) || isNaN(this["d"])) {
   	        return new Fraction(NaN);
   	      }
   	      return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
   	    },

   	    /**
   	     * Gets the inverse of the fraction, means numerator and denominator are exchanged
   	     *
   	     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   	     **/
   	    "inverse": function() {

   	      return newFraction(this["s"] * this["d"], this["n"]);
   	    },

   	    /**
   	     * Calculates the fraction to some rational exponent, if possible
   	     *
   	     * Ex: new Fraction(-1,2).pow(-3) => -8
   	     */
   	    "pow": function(a, b) {

   	      parse(a, b);

   	      // Trivial case when exp is an integer

   	      if (P['d'] === 1) {

   	        if (P['s'] < 0) {
   	          return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
   	        } else {
   	          return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
   	        }
   	      }

   	      // Negative roots become complex
   	      //     (-a/b)^(c/d) = x
   	      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
   	      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
   	      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
   	      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
   	      if (this['s'] < 0) return null;

   	      // Now prime factor n and d
   	      var N = factorize(this['n']);
   	      var D = factorize(this['d']);

   	      // Exponentiate and take root for n and d individually
   	      var n = 1;
   	      var d = 1;
   	      for (var k in N) {
   	        if (k === '1') continue;
   	        if (k === '0') {
   	          n = 0;
   	          break;
   	        }
   	        N[k]*= P['n'];

   	        if (N[k] % P['d'] === 0) {
   	          N[k]/= P['d'];
   	        } else return null;
   	        n*= Math.pow(k, N[k]);
   	      }

   	      for (var k in D) {
   	        if (k === '1') continue;
   	        D[k]*= P['n'];

   	        if (D[k] % P['d'] === 0) {
   	          D[k]/= P['d'];
   	        } else return null;
   	        d*= Math.pow(k, D[k]);
   	      }

   	      if (P['s'] < 0) {
   	        return newFraction(d, n);
   	      }
   	      return newFraction(n, d);
   	    },

   	    /**
   	     * Check if two rational numbers are the same
   	     *
   	     * Ex: new Fraction(19.6).equals([98, 5]);
   	     **/
   	    "equals": function(a, b) {

   	      parse(a, b);
   	      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
   	    },

   	    /**
   	     * Check if two rational numbers are the same
   	     *
   	     * Ex: new Fraction(19.6).equals([98, 5]);
   	     **/
   	    "compare": function(a, b) {

   	      parse(a, b);
   	      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
   	      return (0 < t) - (t < 0);
   	    },

   	    "simplify": function(eps) {

   	      if (isNaN(this['n']) || isNaN(this['d'])) {
   	        return this;
   	      }

   	      eps = eps || 0.001;

   	      var thisABS = this['abs']();
   	      var cont = thisABS['toContinued']();

   	      for (var i = 1; i < cont.length; i++) {

   	        var s = newFraction(cont[i - 1], 1);
   	        for (var k = i - 2; k >= 0; k--) {
   	          s = s['inverse']()['add'](cont[k]);
   	        }

   	        if (Math.abs(s['sub'](thisABS).valueOf()) < eps) {
   	          return s['mul'](this['s']);
   	        }
   	      }
   	      return this;
   	    },

   	    /**
   	     * Check if two rational numbers are divisible
   	     *
   	     * Ex: new Fraction(19.6).divisible(1.5);
   	     */
   	    "divisible": function(a, b) {

   	      parse(a, b);
   	      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
   	    },

   	    /**
   	     * Returns a decimal representation of the fraction
   	     *
   	     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   	     **/
   	    'valueOf': function() {

   	      return this["s"] * this["n"] / this["d"];
   	    },

   	    /**
   	     * Returns a string-fraction representation of a Fraction object
   	     *
   	     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   	     **/
   	    'toFraction': function(excludeWhole) {

   	      var whole, str = "";
   	      var n = this["n"];
   	      var d = this["d"];
   	      if (this["s"] < 0) {
   	        str+= '-';
   	      }

   	      if (d === 1) {
   	        str+= n;
   	      } else {

   	        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
   	          str+= whole;
   	          str+= " ";
   	          n%= d;
   	        }

   	        str+= n;
   	        str+= '/';
   	        str+= d;
   	      }
   	      return str;
   	    },

   	    /**
   	     * Returns a latex representation of a Fraction object
   	     *
   	     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   	     **/
   	    'toLatex': function(excludeWhole) {

   	      var whole, str = "";
   	      var n = this["n"];
   	      var d = this["d"];
   	      if (this["s"] < 0) {
   	        str+= '-';
   	      }

   	      if (d === 1) {
   	        str+= n;
   	      } else {

   	        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
   	          str+= whole;
   	          n%= d;
   	        }

   	        str+= "\\frac{";
   	        str+= n;
   	        str+= '}{';
   	        str+= d;
   	        str+= '}';
   	      }
   	      return str;
   	    },

   	    /**
   	     * Returns an array of continued fraction elements
   	     *
   	     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   	     */
   	    'toContinued': function() {

   	      var t;
   	      var a = this['n'];
   	      var b = this['d'];
   	      var res = [];

   	      if (isNaN(a) || isNaN(b)) {
   	        return res;
   	      }

   	      do {
   	        res.push(Math.floor(a / b));
   	        t = a % b;
   	        a = b;
   	        b = t;
   	      } while (a !== 1);

   	      return res;
   	    },

   	    /**
   	     * Creates a string representation of a fraction with all digits
   	     *
   	     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   	     **/
   	    'toString': function(dec) {

   	      var N = this["n"];
   	      var D = this["d"];

   	      if (isNaN(N) || isNaN(D)) {
   	        return "NaN";
   	      }

   	      dec = dec || 15; // 15 = decimal places when no repetation

   	      var cycLen = cycleLen(N, D); // Cycle length
   	      var cycOff = cycleStart(N, D, cycLen); // Cycle start

   	      var str = this['s'] < 0 ? "-" : "";

   	      str+= N / D | 0;

   	      N%= D;
   	      N*= 10;

   	      if (N)
   	        str+= ".";

   	      if (cycLen) {

   	        for (var i = cycOff; i--;) {
   	          str+= N / D | 0;
   	          N%= D;
   	          N*= 10;
   	        }
   	        str+= "(";
   	        for (var i = cycLen; i--;) {
   	          str+= N / D | 0;
   	          N%= D;
   	          N*= 10;
   	        }
   	        str+= ")";
   	      } else {
   	        for (var i = dec; N && i--;) {
   	          str+= N / D | 0;
   	          N%= D;
   	          N*= 10;
   	        }
   	      }
   	      return str;
   	    }
   	  };

   	  {
   	    Object.defineProperty(Fraction, "__esModule", { 'value': true });
   	    Fraction['default'] = Fraction;
   	    Fraction['Fraction'] = Fraction;
   	    module['exports'] = Fraction;
   	  }

   	})(); 
   } (fraction$1));

   var fractionExports = fraction$1.exports;
   var Fraction$1 = /*@__PURE__*/getDefaultExportFromCjs(fractionExports);

   var name$4L = 'Fraction';
   var dependencies$4K = [];
   var createFractionClass = /* #__PURE__ */factory(name$4L, dependencies$4K, () => {
     /**
      * Attach type information
      */
     Object.defineProperty(Fraction$1, 'name', {
       value: 'Fraction'
     });
     Fraction$1.prototype.constructor = Fraction$1;
     Fraction$1.prototype.type = 'Fraction';
     Fraction$1.prototype.isFraction = true;

     /**
      * Get a JSON representation of a Fraction containing type information
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
      */
     Fraction$1.prototype.toJSON = function () {
       return {
         mathjs: 'Fraction',
         n: this.s * this.n,
         d: this.d
       };
     };

     /**
      * Instantiate a Fraction from a JSON object
      * @param {Object} json  a JSON object structured as:
      *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
      * @return {BigNumber}
      */
     Fraction$1.fromJSON = function (json) {
       return new Fraction$1(json);
     };
     return Fraction$1;
   }, {
     isClass: true
   });

   var name$4K = 'Range';
   var dependencies$4J = [];
   var createRangeClass = /* #__PURE__ */factory(name$4K, dependencies$4J, () => {
     /**
      * Create a range. A range has a start, step, and end, and contains functions
      * to iterate over the range.
      *
      * A range can be constructed as:
      *
      *     const range = new Range(start, end)
      *     const range = new Range(start, end, step)
      *
      * To get the result of the range:
      *     range.forEach(function (x) {
      *         console.log(x)
      *     })
      *     range.map(function (x) {
      *         return math.sin(x)
      *     })
      *     range.toArray()
      *
      * Example usage:
      *
      *     const c = new Range(2, 6)       // 2:1:5
      *     c.toArray()                     // [2, 3, 4, 5]
      *     const d = new Range(2, -3, -1)  // 2:-1:-2
      *     d.toArray()                     // [2, 1, 0, -1, -2]
      *
      * @class Range
      * @constructor Range
      * @param {number} start  included lower bound
      * @param {number} end    excluded upper bound
      * @param {number} [step] step size, default value is 1
      */
     function Range(start, end, step) {
       if (!(this instanceof Range)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       var hasStart = start !== null && start !== undefined;
       var hasEnd = end !== null && end !== undefined;
       var hasStep = step !== null && step !== undefined;
       if (hasStart) {
         if (isBigNumber(start)) {
           start = start.toNumber();
         } else if (typeof start !== 'number') {
           throw new TypeError('Parameter start must be a number');
         }
       }
       if (hasEnd) {
         if (isBigNumber(end)) {
           end = end.toNumber();
         } else if (typeof end !== 'number') {
           throw new TypeError('Parameter end must be a number');
         }
       }
       if (hasStep) {
         if (isBigNumber(step)) {
           step = step.toNumber();
         } else if (typeof step !== 'number') {
           throw new TypeError('Parameter step must be a number');
         }
       }
       this.start = hasStart ? parseFloat(start) : 0;
       this.end = hasEnd ? parseFloat(end) : 0;
       this.step = hasStep ? parseFloat(step) : 1;
     }

     /**
      * Attach type information
      */
     Range.prototype.type = 'Range';
     Range.prototype.isRange = true;

     /**
      * Parse a string into a range,
      * The string contains the start, optional step, and end, separated by a colon.
      * If the string does not contain a valid range, null is returned.
      * For example str='0:2:11'.
      * @memberof Range
      * @param {string} str
      * @return {Range | null} range
      */
     Range.parse = function (str) {
       if (typeof str !== 'string') {
         return null;
       }
       var args = str.split(':');
       var nums = args.map(function (arg) {
         return parseFloat(arg);
       });
       var invalid = nums.some(function (num) {
         return isNaN(num);
       });
       if (invalid) {
         return null;
       }
       switch (nums.length) {
         case 2:
           return new Range(nums[0], nums[1]);
         case 3:
           return new Range(nums[0], nums[2], nums[1]);
         default:
           return null;
       }
     };

     /**
      * Create a clone of the range
      * @return {Range} clone
      */
     Range.prototype.clone = function () {
       return new Range(this.start, this.end, this.step);
     };

     /**
      * Retrieve the size of the range.
      * Returns an array containing one number, the number of elements in the range.
      * @memberof Range
      * @returns {number[]} size
      */
     Range.prototype.size = function () {
       var len = 0;
       var start = this.start;
       var step = this.step;
       var end = this.end;
       var diff = end - start;
       if (sign$2(step) === sign$2(diff)) {
         len = Math.ceil(diff / step);
       } else if (diff === 0) {
         len = 0;
       }
       if (isNaN(len)) {
         len = 0;
       }
       return [len];
     };

     /**
      * Calculate the minimum value in the range
      * @memberof Range
      * @return {number | undefined} min
      */
     Range.prototype.min = function () {
       var size = this.size()[0];
       if (size > 0) {
         if (this.step > 0) {
           // positive step
           return this.start;
         } else {
           // negative step
           return this.start + (size - 1) * this.step;
         }
       } else {
         return undefined;
       }
     };

     /**
      * Calculate the maximum value in the range
      * @memberof Range
      * @return {number | undefined} max
      */
     Range.prototype.max = function () {
       var size = this.size()[0];
       if (size > 0) {
         if (this.step > 0) {
           // positive step
           return this.start + (size - 1) * this.step;
         } else {
           // negative step
           return this.start;
         }
       } else {
         return undefined;
       }
     };

     /**
      * Execute a callback function for each value in the range.
      * @memberof Range
      * @param {function} callback   The callback method is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Range being traversed.
      */
     Range.prototype.forEach = function (callback) {
       var x = this.start;
       var step = this.step;
       var end = this.end;
       var i = 0;
       if (step > 0) {
         while (x < end) {
           callback(x, [i], this);
           x += step;
           i++;
         }
       } else if (step < 0) {
         while (x > end) {
           callback(x, [i], this);
           x += step;
           i++;
         }
       }
     };

     /**
      * Execute a callback function for each value in the Range, and return the
      * results as an array
      * @memberof Range
      * @param {function} callback   The callback method is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      * @returns {Array} array
      */
     Range.prototype.map = function (callback) {
       var array = [];
       this.forEach(function (value, index, obj) {
         array[index[0]] = callback(value, index, obj);
       });
       return array;
     };

     /**
      * Create an Array with a copy of the Ranges data
      * @memberof Range
      * @returns {Array} array
      */
     Range.prototype.toArray = function () {
       var array = [];
       this.forEach(function (value, index) {
         array[index[0]] = value;
       });
       return array;
     };

     /**
      * Get the primitive value of the Range, a one dimensional array
      * @memberof Range
      * @returns {Array} array
      */
     Range.prototype.valueOf = function () {
       // TODO: implement a caching mechanism for range.valueOf()
       return this.toArray();
     };

     /**
      * Get a string representation of the range, with optional formatting options.
      * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
      * @memberof Range
      * @param {Object | number | function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @returns {string} str
      */
     Range.prototype.format = function (options) {
       var str = format$3(this.start, options);
       if (this.step !== 1) {
         str += ':' + format$3(this.step, options);
       }
       str += ':' + format$3(this.end, options);
       return str;
     };

     /**
      * Get a string representation of the range.
      * @memberof Range
      * @returns {string}
      */
     Range.prototype.toString = function () {
       return this.format();
     };

     /**
      * Get a JSON representation of the range
      * @memberof Range
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
      */
     Range.prototype.toJSON = function () {
       return {
         mathjs: 'Range',
         start: this.start,
         end: this.end,
         step: this.step
       };
     };

     /**
      * Instantiate a Range from a JSON object
      * @memberof Range
      * @param {Object} json A JSON object structured as:
      *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
      * @return {Range}
      */
     Range.fromJSON = function (json) {
       return new Range(json.start, json.end, json.step);
     };
     return Range;
   }, {
     isClass: true
   });

   var name$4J = 'Matrix';
   var dependencies$4I = [];
   var createMatrixClass = /* #__PURE__ */factory(name$4J, dependencies$4I, () => {
     /**
      * @constructor Matrix
      *
      * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
      * array. A matrix can be constructed as:
      *
      *     let matrix = math.matrix(data)
      *
      * Matrix contains the functions to resize, get and set values, get the size,
      * clone the matrix and to convert the matrix to a vector, array, or scalar.
      * Furthermore, one can iterate over the matrix using map and forEach.
      * The internal Array of the Matrix can be accessed using the function valueOf.
      *
      * Example usage:
      *
      *     let matrix = math.matrix([[1, 2], [3, 4]])
      *     matix.size()              // [2, 2]
      *     matrix.resize([3, 2], 5)
      *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
      *     matrix.subset([1,2])       // 3 (indexes are zero-based)
      *
      */
     function Matrix() {
       if (!(this instanceof Matrix)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
     }

     /**
      * Attach type information
      */
     Matrix.prototype.type = 'Matrix';
     Matrix.prototype.isMatrix = true;

     /**
      * Get the storage format used by the matrix.
      *
      * Usage:
      *     const format = matrix.storage()   // retrieve storage format
      *
      * @return {string}           The storage format.
      */
     Matrix.prototype.storage = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke storage on a Matrix interface');
     };

     /**
      * Get the datatype of the data stored in the matrix.
      *
      * Usage:
      *     const format = matrix.datatype()    // retrieve matrix datatype
      *
      * @return {string}           The datatype.
      */
     Matrix.prototype.datatype = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke datatype on a Matrix interface');
     };

     /**
      * Create a new Matrix With the type of the current matrix instance
      * @param {Array | Object} data
      * @param {string} [datatype]
      */
     Matrix.prototype.create = function (data, datatype) {
       throw new Error('Cannot invoke create on a Matrix interface');
     };

     /**
      * Get a subset of the matrix, or replace a subset of the matrix.
      *
      * Usage:
      *     const subset = matrix.subset(index)               // retrieve subset
      *     const value = matrix.subset(index, replacement)   // replace subset
      *
      * @param {Index} index
      * @param {Array | Matrix | *} [replacement]
      * @param {*} [defaultValue=0]      Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be filled with zeros.
      */
     Matrix.prototype.subset = function (index, replacement, defaultValue) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke subset on a Matrix interface');
     };

     /**
      * Get a single element from the matrix.
      * @param {number[]} index   Zero-based index
      * @return {*} value
      */
     Matrix.prototype.get = function (index) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke get on a Matrix interface');
     };

     /**
      * Replace a single element in the matrix.
      * @param {number[]} index   Zero-based index
      * @param {*} value
      * @param {*} [defaultValue]        Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be left undefined.
      * @return {Matrix} self
      */
     Matrix.prototype.set = function (index, value, defaultValue) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke set on a Matrix interface');
     };

     /**
      * Resize the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (resize in place).
      *
      * @param {number[]} size           The new size the matrix should have.
      * @param {*} [defaultValue=0]      Default value, filled in on new entries.
      *                                  If not provided, the matrix elements will
      *                                  be filled with zeros.
      * @param {boolean} [copy]          Return a resized copy of the matrix
      *
      * @return {Matrix}                 The resized matrix
      */
     Matrix.prototype.resize = function (size, defaultValue) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke resize on a Matrix interface');
     };

     /**
      * Reshape the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (reshape in place).
      *
      * @param {number[]} size           The new size the matrix should have.
      * @param {boolean} [copy]          Return a reshaped copy of the matrix
      *
      * @return {Matrix}                 The reshaped matrix
      */
     Matrix.prototype.reshape = function (size, defaultValue) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke reshape on a Matrix interface');
     };

     /**
      * Create a clone of the matrix
      * @return {Matrix} clone
      */
     Matrix.prototype.clone = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke clone on a Matrix interface');
     };

     /**
      * Retrieve the size of the matrix.
      * @returns {number[]} size
      */
     Matrix.prototype.size = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke size on a Matrix interface');
     };

     /**
      * Create a new matrix with the results of the callback function executed on
      * each entry of the matrix.
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
      *
      * @return {Matrix} matrix
      */
     Matrix.prototype.map = function (callback, skipZeros) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke map on a Matrix interface');
     };

     /**
      * Execute a callback function on each entry of the matrix.
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      */
     Matrix.prototype.forEach = function (callback) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke forEach on a Matrix interface');
     };

     /**
      * Iterate over the matrix elements
      * @return {Iterable<{ value, index: number[] }>}
      */
     Matrix.prototype[Symbol.iterator] = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot iterate a Matrix interface');
     };

     /**
      * Create an Array with a copy of the data of the Matrix
      * @returns {Array} array
      */
     Matrix.prototype.toArray = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke toArray on a Matrix interface');
     };

     /**
      * Get the primitive value of the Matrix: a multidimensional array
      * @returns {Array} array
      */
     Matrix.prototype.valueOf = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke valueOf on a Matrix interface');
     };

     /**
      * Get a string representation of the matrix, with optional formatting options.
      * @param {Object | number | Function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @returns {string} str
      */
     Matrix.prototype.format = function (options) {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke format on a Matrix interface');
     };

     /**
      * Get a string representation of the matrix
      * @returns {string} str
      */
     Matrix.prototype.toString = function () {
       // must be implemented by each of the Matrix implementations
       throw new Error('Cannot invoke toString on a Matrix interface');
     };
     return Matrix;
   }, {
     isClass: true
   });

   // (c) 2018, Mariusz Nowak
   // SPDX-License-Identifier: ISC
   // Derived from https://github.com/medikoo/lru-queue
   function lruQueue(limit) {
     var size = 0;
     var base = 1;
     var queue = Object.create(null);
     var map = Object.create(null);
     var index = 0;
     var del = function del(id) {
       var oldIndex = map[id];
       if (!oldIndex) return;
       delete queue[oldIndex];
       delete map[id];
       --size;
       if (base !== oldIndex) return;
       if (!size) {
         index = 0;
         base = 1;
         return;
       }
       while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {/* empty */}
     };
     limit = Math.abs(limit);
     return {
       hit: function hit(id) {
         var oldIndex = map[id];
         var nuIndex = ++index;
         queue[nuIndex] = id;
         map[id] = nuIndex;
         if (!oldIndex) {
           ++size;
           if (size <= limit) return undefined;
           id = queue[base];
           del(id);
           return id;
         }
         delete queue[oldIndex];
         if (base !== oldIndex) return undefined;
         while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {/* empty */}
         return undefined;
       },
       delete: del,
       clear: function clear() {
         size = index = 0;
         base = 1;
         queue = Object.create(null);
         map = Object.create(null);
       }
     };
   }

   // function utils


   /**
    * Memoize a given function by caching the computed result.
    * The cache of a memoized function can be cleared by deleting the `cache`
    * property of the function.
    *
    * @param {function} fn                     The function to be memoized.
    *                                          Must be a pure function.
    * @param {Object} [options]
    * @param {function(args: Array): string} [options.hasher]
    *    A custom hash builder. Is JSON.stringify by default.
    * @param {number | undefined} [options.limit]
    *    Maximum number of values that may be cached. Undefined indicates
    *    unlimited (default)
    * @return {function}                       Returns the memoized function
    */
   function memoize(fn) {
     var {
       hasher,
       limit
     } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
     limit = limit == null ? Number.POSITIVE_INFINITY : limit;
     hasher = hasher == null ? JSON.stringify : hasher;
     return function memoize() {
       if (typeof memoize.cache !== 'object') {
         memoize.cache = {
           values: new Map(),
           lru: lruQueue(limit || Number.POSITIVE_INFINITY)
         };
       }
       var args = [];
       for (var i = 0; i < arguments.length; i++) {
         args[i] = arguments[i];
       }
       var hash = hasher(args);
       if (memoize.cache.values.has(hash)) {
         memoize.cache.lru.hit(hash);
         return memoize.cache.values.get(hash);
       }
       var newVal = fn.apply(fn, args);
       memoize.cache.values.set(hash, newVal);
       memoize.cache.values.delete(memoize.cache.lru.hit(hash));
       return newVal;
     };
   }

   /**
    * Find the maximum number of arguments expected by a typed function.
    * @param {function} fn   A typed function
    * @return {number} Returns the maximum number of expected arguments.
    *                  Returns -1 when no signatures where found on the function.
    */
   function maxArgumentCount(fn) {
     return Object.keys(fn.signatures || {}).reduce(function (args, signature) {
       var count = (signature.match(/,/g) || []).length + 1;
       return Math.max(args, count);
     }, -1);
   }

   var name$4I = 'DenseMatrix';
   var dependencies$4H = ['Matrix'];
   var createDenseMatrixClass = /* #__PURE__ */factory(name$4I, dependencies$4H, _ref => {
     var {
       Matrix
     } = _ref;
     /**
      * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
      * @class DenseMatrix
      * @enum {{ value, index: number[] }}
      */
     function DenseMatrix(data, datatype) {
       if (!(this instanceof DenseMatrix)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       if (datatype && !isString(datatype)) {
         throw new Error('Invalid datatype: ' + datatype);
       }
       if (isMatrix(data)) {
         // check data is a DenseMatrix
         if (data.type === 'DenseMatrix') {
           // clone data & size
           this._data = clone$3(data._data);
           this._size = clone$3(data._size);
           this._datatype = datatype || data._datatype;
         } else {
           // build data from existing matrix
           this._data = data.toArray();
           this._size = data.size();
           this._datatype = datatype || data._datatype;
         }
       } else if (data && isArray(data.data) && isArray(data.size)) {
         // initialize fields from JSON representation
         this._data = data.data;
         this._size = data.size;
         // verify the dimensions of the array
         validate(this._data, this._size);
         this._datatype = datatype || data.datatype;
       } else if (isArray(data)) {
         // replace nested Matrices with Arrays
         this._data = preprocess(data);
         // get the dimensions of the array
         this._size = arraySize(this._data);
         // verify the dimensions of the array, TODO: compute size while processing array
         validate(this._data, this._size);
         // data type unknown
         this._datatype = datatype;
       } else if (data) {
         // unsupported type
         throw new TypeError('Unsupported type of data (' + typeOf$1(data) + ')');
       } else {
         // nothing provided
         this._data = [];
         this._size = [0];
         this._datatype = datatype;
       }
     }
     DenseMatrix.prototype = new Matrix();

     /**
      * Create a new DenseMatrix
      */
     DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
       return new DenseMatrix(data, datatype);
     };

     /**
      * Attach type information
      */
     Object.defineProperty(DenseMatrix, 'name', {
       value: 'DenseMatrix'
     });
     DenseMatrix.prototype.constructor = DenseMatrix;
     DenseMatrix.prototype.type = 'DenseMatrix';
     DenseMatrix.prototype.isDenseMatrix = true;

     /**
      * Get the matrix type
      *
      * Usage:
      *    const matrixType = matrix.getDataType()  // retrieves the matrix type
      *
      * @memberOf DenseMatrix
      * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
      */
     DenseMatrix.prototype.getDataType = function () {
       return getArrayDataType(this._data, typeOf$1);
     };

     /**
      * Get the storage format used by the matrix.
      *
      * Usage:
      *     const format = matrix.storage()  // retrieve storage format
      *
      * @memberof DenseMatrix
      * @return {string}           The storage format.
      */
     DenseMatrix.prototype.storage = function () {
       return 'dense';
     };

     /**
      * Get the datatype of the data stored in the matrix.
      *
      * Usage:
      *     const format = matrix.datatype()   // retrieve matrix datatype
      *
      * @memberof DenseMatrix
      * @return {string}           The datatype.
      */
     DenseMatrix.prototype.datatype = function () {
       return this._datatype;
     };

     /**
      * Create a new DenseMatrix
      * @memberof DenseMatrix
      * @param {Array} data
      * @param {string} [datatype]
      */
     DenseMatrix.prototype.create = function (data, datatype) {
       return new DenseMatrix(data, datatype);
     };

     /**
      * Get a subset of the matrix, or replace a subset of the matrix.
      *
      * Usage:
      *     const subset = matrix.subset(index)               // retrieve subset
      *     const value = matrix.subset(index, replacement)   // replace subset
      *
      * @memberof DenseMatrix
      * @param {Index} index
      * @param {Array | Matrix | *} [replacement]
      * @param {*} [defaultValue=0]      Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be filled with zeros.
      */
     DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
       switch (arguments.length) {
         case 1:
           return _get(this, index);

         // intentional fall through
         case 2:
         case 3:
           return _set(this, index, replacement, defaultValue);
         default:
           throw new SyntaxError('Wrong number of arguments');
       }
     };

     /**
      * Get a single element from the matrix.
      * @memberof DenseMatrix
      * @param {number[]} index   Zero-based index
      * @return {*} value
      */
     DenseMatrix.prototype.get = function (index) {
       if (!isArray(index)) {
         throw new TypeError('Array expected');
       }
       if (index.length !== this._size.length) {
         throw new DimensionError(index.length, this._size.length);
       }

       // check index
       for (var x = 0; x < index.length; x++) {
         validateIndex(index[x], this._size[x]);
       }
       var data = this._data;
       for (var i = 0, ii = index.length; i < ii; i++) {
         var indexI = index[i];
         validateIndex(indexI, data.length);
         data = data[indexI];
       }
       return data;
     };

     /**
      * Replace a single element in the matrix.
      * @memberof DenseMatrix
      * @param {number[]} index   Zero-based index
      * @param {*} value
      * @param {*} [defaultValue]        Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be left undefined.
      * @return {DenseMatrix} self
      */
     DenseMatrix.prototype.set = function (index, value, defaultValue) {
       if (!isArray(index)) {
         throw new TypeError('Array expected');
       }
       if (index.length < this._size.length) {
         throw new DimensionError(index.length, this._size.length, '<');
       }
       var i, ii, indexI;

       // enlarge matrix when needed
       var size = index.map(function (i) {
         return i + 1;
       });
       _fit(this, size, defaultValue);

       // traverse over the dimensions
       var data = this._data;
       for (i = 0, ii = index.length - 1; i < ii; i++) {
         indexI = index[i];
         validateIndex(indexI, data.length);
         data = data[indexI];
       }

       // set new value
       indexI = index[index.length - 1];
       validateIndex(indexI, data.length);
       data[indexI] = value;
       return this;
     };

     /**
      * Get a submatrix of this matrix
      * @memberof DenseMatrix
      * @param {DenseMatrix} matrix
      * @param {Index} index   Zero-based index
      * @private
      */
     function _get(matrix, index) {
       if (!isIndex(index)) {
         throw new TypeError('Invalid index');
       }
       var isScalar = index.isScalar();
       if (isScalar) {
         // return a scalar
         return matrix.get(index.min());
       } else {
         // validate dimensions
         var size = index.size();
         if (size.length !== matrix._size.length) {
           throw new DimensionError(size.length, matrix._size.length);
         }

         // validate if any of the ranges in the index is out of range
         var min = index.min();
         var max = index.max();
         for (var i = 0, ii = matrix._size.length; i < ii; i++) {
           validateIndex(min[i], matrix._size[i]);
           validateIndex(max[i], matrix._size[i]);
         }

         // retrieve submatrix
         // TODO: more efficient when creating an empty matrix and setting _data and _size manually
         return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
       }
     }

     /**
      * Recursively get a submatrix of a multi dimensional matrix.
      * Index is not checked for correct number or length of dimensions.
      * @memberof DenseMatrix
      * @param {Array} data
      * @param {Index} index
      * @param {number} dims   Total number of dimensions
      * @param {number} dim    Current dimension
      * @return {Array} submatrix
      * @private
      */
     function _getSubmatrix(data, index, dims, dim) {
       var last = dim === dims - 1;
       var range = index.dimension(dim);
       if (last) {
         return range.map(function (i) {
           validateIndex(i, data.length);
           return data[i];
         }).valueOf();
       } else {
         return range.map(function (i) {
           validateIndex(i, data.length);
           var child = data[i];
           return _getSubmatrix(child, index, dims, dim + 1);
         }).valueOf();
       }
     }

     /**
      * Replace a submatrix in this matrix
      * Indexes are zero-based.
      * @memberof DenseMatrix
      * @param {DenseMatrix} matrix
      * @param {Index} index
      * @param {DenseMatrix | Array | *} submatrix
      * @param {*} defaultValue          Default value, filled in on new entries when
      *                                  the matrix is resized.
      * @return {DenseMatrix} matrix
      * @private
      */
     function _set(matrix, index, submatrix, defaultValue) {
       if (!index || index.isIndex !== true) {
         throw new TypeError('Invalid index');
       }

       // get index size and check whether the index contains a single value
       var iSize = index.size();
       var isScalar = index.isScalar();

       // calculate the size of the submatrix, and convert it into an Array if needed
       var sSize;
       if (isMatrix(submatrix)) {
         sSize = submatrix.size();
         submatrix = submatrix.valueOf();
       } else {
         sSize = arraySize(submatrix);
       }
       if (isScalar) {
         // set a scalar

         // check whether submatrix is a scalar
         if (sSize.length !== 0) {
           throw new TypeError('Scalar expected');
         }
         matrix.set(index.min(), submatrix, defaultValue);
       } else {
         // set a submatrix

         // broadcast submatrix
         if (!deepStrictEqual(sSize, iSize)) {
           try {
             if (sSize.length === 0) {
               submatrix = broadcastTo([submatrix], iSize);
             } else {
               submatrix = broadcastTo(submatrix, iSize);
             }
             sSize = arraySize(submatrix);
           } catch (_unused) {}
         }

         // validate dimensions
         if (iSize.length < matrix._size.length) {
           throw new DimensionError(iSize.length, matrix._size.length, '<');
         }
         if (sSize.length < iSize.length) {
           // calculate number of missing outer dimensions
           var i = 0;
           var outer = 0;
           while (iSize[i] === 1 && sSize[i] === 1) {
             i++;
           }
           while (iSize[i] === 1) {
             outer++;
             i++;
           }

           // unsqueeze both outer and inner dimensions
           submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
         }

         // check whether the size of the submatrix matches the index size
         if (!deepStrictEqual(iSize, sSize)) {
           throw new DimensionError(iSize, sSize, '>');
         }

         // enlarge matrix when needed
         var size = index.max().map(function (i) {
           return i + 1;
         });
         _fit(matrix, size, defaultValue);

         // insert the sub matrix
         var dims = iSize.length;
         var dim = 0;
         _setSubmatrix(matrix._data, index, submatrix, dims, dim);
       }
       return matrix;
     }

     /**
      * Replace a submatrix of a multi dimensional matrix.
      * @memberof DenseMatrix
      * @param {Array} data
      * @param {Index} index
      * @param {Array} submatrix
      * @param {number} dims   Total number of dimensions
      * @param {number} dim
      * @private
      */
     function _setSubmatrix(data, index, submatrix, dims, dim) {
       var last = dim === dims - 1;
       var range = index.dimension(dim);
       if (last) {
         range.forEach(function (dataIndex, subIndex) {
           validateIndex(dataIndex);
           data[dataIndex] = submatrix[subIndex[0]];
         });
       } else {
         range.forEach(function (dataIndex, subIndex) {
           validateIndex(dataIndex);
           _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
         });
       }
     }

     /**
      * Resize the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (resize in place).
      *
      * @memberof DenseMatrix
      * @param {number[] || Matrix} size The new size the matrix should have.
      * @param {*} [defaultValue=0]      Default value, filled in on new entries.
      *                                  If not provided, the matrix elements will
      *                                  be filled with zeros.
      * @param {boolean} [copy]          Return a resized copy of the matrix
      *
      * @return {Matrix}                 The resized matrix
      */
     DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
       // validate arguments
       if (!isCollection(size)) {
         throw new TypeError('Array or Matrix expected');
       }

       // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
       var sizeArray = size.valueOf().map(value => {
         return Array.isArray(value) && value.length === 1 ? value[0] : value;
       });

       // matrix to resize
       var m = copy ? this.clone() : this;
       // resize matrix
       return _resize(m, sizeArray, defaultValue);
     };
     function _resize(matrix, size, defaultValue) {
       // check size
       if (size.length === 0) {
         // first value in matrix
         var v = matrix._data;
         // go deep
         while (isArray(v)) {
           v = v[0];
         }
         return v;
       }
       // resize matrix
       matrix._size = size.slice(0); // copy the array
       matrix._data = resize$1(matrix._data, matrix._size, defaultValue);
       // return matrix
       return matrix;
     }

     /**
      * Reshape the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (reshape in place).
      *
      * NOTE: This might be better suited to copy by default, instead of modifying
      *       in place. For now, it operates in place to remain consistent with
      *       resize().
      *
      * @memberof DenseMatrix
      * @param {number[]} size           The new size the matrix should have.
      * @param {boolean} [copy]          Return a reshaped copy of the matrix
      *
      * @return {Matrix}                 The reshaped matrix
      */
     DenseMatrix.prototype.reshape = function (size, copy) {
       var m = copy ? this.clone() : this;
       m._data = reshape$1(m._data, size);
       var currentLength = m._size.reduce((length, size) => length * size);
       m._size = processSizesWildcard(size, currentLength);
       return m;
     };

     /**
      * Enlarge the matrix when it is smaller than given size.
      * If the matrix is larger or equal sized, nothing is done.
      * @memberof DenseMatrix
      * @param {DenseMatrix} matrix           The matrix to be resized
      * @param {number[]} size
      * @param {*} defaultValue          Default value, filled in on new entries.
      * @private
      */
     function _fit(matrix, size, defaultValue) {
       var
       // copy the array
       newSize = matrix._size.slice(0);
       var changed = false;

       // add dimensions when needed
       while (newSize.length < size.length) {
         newSize.push(0);
         changed = true;
       }

       // enlarge size when needed
       for (var i = 0, ii = size.length; i < ii; i++) {
         if (size[i] > newSize[i]) {
           newSize[i] = size[i];
           changed = true;
         }
       }
       if (changed) {
         // resize only when size is changed
         _resize(matrix, newSize, defaultValue);
       }
     }

     /**
      * Create a clone of the matrix
      * @memberof DenseMatrix
      * @return {DenseMatrix} clone
      */
     DenseMatrix.prototype.clone = function () {
       var m = new DenseMatrix({
         data: clone$3(this._data),
         size: clone$3(this._size),
         datatype: this._datatype
       });
       return m;
     };

     /**
      * Retrieve the size of the matrix.
      * @memberof DenseMatrix
      * @returns {number[]} size
      */
     DenseMatrix.prototype.size = function () {
       return this._size.slice(0); // return a clone of _size
     };

     /**
      * Create a new matrix with the results of the callback function executed on
      * each entry of the matrix.
      * @memberof DenseMatrix
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      *
      * @return {DenseMatrix} matrix
      */
     DenseMatrix.prototype.map = function (callback) {
       // matrix instance
       var me = this;
       var args = maxArgumentCount(callback);
       var recurse = function recurse(value, index) {
         if (isArray(value)) {
           return value.map(function (child, i) {
             return recurse(child, index.concat(i));
           });
         } else {
           // invoke the callback function with the right number of arguments
           if (args === 1) {
             return callback(value);
           } else if (args === 2) {
             return callback(value, index);
           } else {
             // 3 or -1
             return callback(value, index, me);
           }
         }
       };

       // determine the new datatype when the original matrix has datatype defined
       // TODO: should be done in matrix constructor instead
       var data = recurse(this._data, []);
       var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf$1) : undefined;
       return new DenseMatrix(data, datatype);
     };

     /**
      * Execute a callback function on each entry of the matrix.
      * @memberof DenseMatrix
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      */
     DenseMatrix.prototype.forEach = function (callback) {
       // matrix instance
       var me = this;
       var recurse = function recurse(value, index) {
         if (isArray(value)) {
           value.forEach(function (child, i) {
             recurse(child, index.concat(i));
           });
         } else {
           callback(value, index, me);
         }
       };
       recurse(this._data, []);
     };

     /**
      * Iterate over the matrix elements
      * @return {Iterable<{ value, index: number[] }>}
      */
     DenseMatrix.prototype[Symbol.iterator] = function* () {
       var recurse = function* recurse(value, index) {
         if (isArray(value)) {
           for (var i = 0; i < value.length; i++) {
             yield* recurse(value[i], index.concat(i));
           }
         } else {
           yield {
             value,
             index
           };
         }
       };
       yield* recurse(this._data, []);
     };

     /**
      * Returns an array containing the rows of a 2D matrix
      * @returns {Array<Matrix>}
      */
     DenseMatrix.prototype.rows = function () {
       var result = [];
       var s = this.size();
       if (s.length !== 2) {
         throw new TypeError('Rows can only be returned for a 2D matrix.');
       }
       var data = this._data;
       for (var row of data) {
         result.push(new DenseMatrix([row], this._datatype));
       }
       return result;
     };

     /**
      * Returns an array containing the columns of a 2D matrix
      * @returns {Array<Matrix>}
      */
     DenseMatrix.prototype.columns = function () {
       var _this = this;
       var result = [];
       var s = this.size();
       if (s.length !== 2) {
         throw new TypeError('Rows can only be returned for a 2D matrix.');
       }
       var data = this._data;
       var _loop = function _loop(i) {
         var col = data.map(row => [row[i]]);
         result.push(new DenseMatrix(col, _this._datatype));
       };
       for (var i = 0; i < s[1]; i++) {
         _loop(i);
       }
       return result;
     };

     /**
      * Create an Array with a copy of the data of the DenseMatrix
      * @memberof DenseMatrix
      * @returns {Array} array
      */
     DenseMatrix.prototype.toArray = function () {
       return clone$3(this._data);
     };

     /**
      * Get the primitive value of the DenseMatrix: a multidimensional array
      * @memberof DenseMatrix
      * @returns {Array} array
      */
     DenseMatrix.prototype.valueOf = function () {
       return this._data;
     };

     /**
      * Get a string representation of the matrix, with optional formatting options.
      * @memberof DenseMatrix
      * @param {Object | number | Function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @returns {string} str
      */
     DenseMatrix.prototype.format = function (options) {
       return format$1(this._data, options);
     };

     /**
      * Get a string representation of the matrix
      * @memberof DenseMatrix
      * @returns {string} str
      */
     DenseMatrix.prototype.toString = function () {
       return format$1(this._data);
     };

     /**
      * Get a JSON representation of the matrix
      * @memberof DenseMatrix
      * @returns {Object}
      */
     DenseMatrix.prototype.toJSON = function () {
       return {
         mathjs: 'DenseMatrix',
         data: this._data,
         size: this._size,
         datatype: this._datatype
       };
     };

     /**
      * Get the kth Matrix diagonal.
      *
      * @memberof DenseMatrix
      * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
      *
      * @returns {Matrix}                     The matrix with the diagonal values.
      */
     DenseMatrix.prototype.diagonal = function (k) {
       // validate k if any
       if (k) {
         // convert BigNumber to a number
         if (isBigNumber(k)) {
           k = k.toNumber();
         }
         // is must be an integer
         if (!isNumber(k) || !isInteger$1(k)) {
           throw new TypeError('The parameter k must be an integer number');
         }
       } else {
         // default value
         k = 0;
       }
       var kSuper = k > 0 ? k : 0;
       var kSub = k < 0 ? -k : 0;

       // rows & columns
       var rows = this._size[0];
       var columns = this._size[1];

       // number diagonal values
       var n = Math.min(rows - kSub, columns - kSuper);

       // x is a matrix get diagonal from matrix
       var data = [];

       // loop rows
       for (var i = 0; i < n; i++) {
         data[i] = this._data[i + kSub][i + kSuper];
       }

       // create DenseMatrix
       return new DenseMatrix({
         data,
         size: [n],
         datatype: this._datatype
       });
     };

     /**
      * Create a diagonal matrix.
      *
      * @memberof DenseMatrix
      * @param {Array} size                     The matrix size.
      * @param {number | Matrix | Array } value The values for the diagonal.
      * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
      * @param {number} [defaultValue]          The default value for non-diagonal
      * @param {string} [datatype]              The datatype for the diagonal
      *
      * @returns {DenseMatrix}
      */
     DenseMatrix.diagonal = function (size, value, k, defaultValue) {
       if (!isArray(size)) {
         throw new TypeError('Array expected, size parameter');
       }
       if (size.length !== 2) {
         throw new Error('Only two dimensions matrix are supported');
       }

       // map size & validate
       size = size.map(function (s) {
         // check it is a big number
         if (isBigNumber(s)) {
           // convert it
           s = s.toNumber();
         }
         // validate arguments
         if (!isNumber(s) || !isInteger$1(s) || s < 1) {
           throw new Error('Size values must be positive integers');
         }
         return s;
       });

       // validate k if any
       if (k) {
         // convert BigNumber to a number
         if (isBigNumber(k)) {
           k = k.toNumber();
         }
         // is must be an integer
         if (!isNumber(k) || !isInteger$1(k)) {
           throw new TypeError('The parameter k must be an integer number');
         }
       } else {
         // default value
         k = 0;
       }
       var kSuper = k > 0 ? k : 0;
       var kSub = k < 0 ? -k : 0;

       // rows and columns
       var rows = size[0];
       var columns = size[1];

       // number of non-zero items
       var n = Math.min(rows - kSub, columns - kSuper);

       // value extraction function
       var _value;

       // check value
       if (isArray(value)) {
         // validate array
         if (value.length !== n) {
           // number of values in array must be n
           throw new Error('Invalid value array length');
         }
         // define function
         _value = function _value(i) {
           // return value @ i
           return value[i];
         };
       } else if (isMatrix(value)) {
         // matrix size
         var ms = value.size();
         // validate matrix
         if (ms.length !== 1 || ms[0] !== n) {
           // number of values in array must be n
           throw new Error('Invalid matrix length');
         }
         // define function
         _value = function _value(i) {
           // return value @ i
           return value.get([i]);
         };
       } else {
         // define function
         _value = function _value() {
           // return value
           return value;
         };
       }

       // discover default value if needed
       if (!defaultValue) {
         // check first value in array
         defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
         : 0;
       }

       // empty array
       var data = [];

       // check we need to resize array
       if (size.length > 0) {
         // resize array
         data = resize$1(data, size, defaultValue);
         // fill diagonal
         for (var d = 0; d < n; d++) {
           data[d + kSub][d + kSuper] = _value(d);
         }
       }

       // create DenseMatrix
       return new DenseMatrix({
         data,
         size: [rows, columns]
       });
     };

     /**
      * Generate a matrix from a JSON object
      * @memberof DenseMatrix
      * @param {Object} json  An object structured like
      *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
      *                       where mathjs is optional
      * @returns {DenseMatrix}
      */
     DenseMatrix.fromJSON = function (json) {
       return new DenseMatrix(json);
     };

     /**
      * Swap rows i and j in Matrix.
      *
      * @memberof DenseMatrix
      * @param {number} i       Matrix row index 1
      * @param {number} j       Matrix row index 2
      *
      * @return {Matrix}        The matrix reference
      */
     DenseMatrix.prototype.swapRows = function (i, j) {
       // check index
       if (!isNumber(i) || !isInteger$1(i) || !isNumber(j) || !isInteger$1(j)) {
         throw new Error('Row index must be positive integers');
       }
       // check dimensions
       if (this._size.length !== 2) {
         throw new Error('Only two dimensional matrix is supported');
       }
       // validate index
       validateIndex(i, this._size[0]);
       validateIndex(j, this._size[0]);

       // swap rows
       DenseMatrix._swapRows(i, j, this._data);
       // return current instance
       return this;
     };

     /**
      * Swap rows i and j in Dense Matrix data structure.
      *
      * @param {number} i       Matrix row index 1
      * @param {number} j       Matrix row index 2
      * @param {Array} data     Matrix data
      */
     DenseMatrix._swapRows = function (i, j, data) {
       // swap values i <-> j
       var vi = data[i];
       data[i] = data[j];
       data[j] = vi;
     };

     /**
      * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
      * Matrices. Clones all (nested) Arrays, and replaces all nested Matrices with Arrays
      * @memberof DenseMatrix
      * @param {Array | Matrix} data
      * @return {Array} data
      */
     function preprocess(data) {
       if (isMatrix(data)) {
         return preprocess(data.valueOf());
       }
       if (isArray(data)) {
         return data.map(preprocess);
       }
       return data;
     }
     return DenseMatrix;
   }, {
     isClass: true
   });

   var name$4H = 'clone';
   var dependencies$4G = ['typed'];
   var createClone = /* #__PURE__ */factory(name$4H, dependencies$4G, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Clone an object. Will make a deep copy of the data.
      *
      * Syntax:
      *
      *     math.clone(x)
      *
      * Examples:
      *
      *    math.clone(3.5)                   // returns number 3.5
      *    math.clone(math.complex('2-4i'))  // returns Complex 2 - 4i
      *    math.clone(math.unit(45, 'deg'))  // returns Unit 45 deg
      *    math.clone([[1, 2], [3, 4]])      // returns Array [[1, 2], [3, 4]]
      *    math.clone("hello world")         // returns string "hello world"
      *
      * @param {*} x   Object to be cloned
      * @return {*} A clone of object x
      */
     return typed(name$4H, {
       any: clone$3
     });
   });

   /**
    * Transpose a matrix
    * @param {Array} mat
    * @returns {Array} ret
    * @private
    */
   function _switch$1(mat) {
     var I = mat.length;
     var J = mat[0].length;
     var i, j;
     var ret = [];
     for (j = 0; j < J; j++) {
       var tmp = [];
       for (i = 0; i < I; i++) {
         tmp.push(mat[i][j]);
       }
       ret.push(tmp);
     }
     return ret;
   }

   /**
    * Test whether an array contains collections
    * @param {Array} array
    * @returns {boolean} Returns true when the array contains one or multiple
    *                    collections (Arrays or Matrices). Returns false otherwise.
    */
   function containsCollections(array) {
     for (var i = 0; i < array.length; i++) {
       if (isCollection(array[i])) {
         return true;
       }
     }
     return false;
   }

   /**
    * Recursively loop over all elements in a given multi dimensional array
    * and invoke the callback on each of the elements.
    * @param {Array | Matrix} array
    * @param {Function} callback     The callback method is invoked with one
    *                                parameter: the current element in the array
    */
   function deepForEach(array, callback) {
     if (isMatrix(array)) {
       array = array.valueOf();
     }
     for (var i = 0, ii = array.length; i < ii; i++) {
       var value = array[i];
       if (Array.isArray(value)) {
         deepForEach(value, callback);
       } else {
         callback(value);
       }
     }
   }

   /**
    * Execute the callback function element wise for each element in array and any
    * nested array
    * Returns an array with the results
    * @param {Array | Matrix} array
    * @param {Function} callback   The callback is called with two parameters:
    *                              value1 and value2, which contain the current
    *                              element of both arrays.
    * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
    *
    * @return {Array | Matrix} res
    */
   function deepMap(array, callback, skipZeros) {
     if (array && typeof array.map === 'function') {
       // TODO: replace array.map with a for loop to improve performance
       return array.map(function (x) {
         return deepMap(x, callback);
       });
     } else {
       return callback(array);
     }
   }

   /**
    * Reduce a given matrix or array to a new matrix or
    * array with one less dimension, applying the given
    * callback in the selected dimension.
    * @param {Array | Matrix} mat
    * @param {number} dim
    * @param {Function} callback
    * @return {Array | Matrix} res
    */
   function reduce(mat, dim, callback) {
     var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
     if (dim < 0 || dim >= size.length) {
       // TODO: would be more clear when throwing a DimensionError here
       throw new IndexError(dim, size.length);
     }
     if (isMatrix(mat)) {
       return mat.create(_reduce(mat.valueOf(), dim, callback));
     } else {
       return _reduce(mat, dim, callback);
     }
   }

   /**
    * Recursively reduce a matrix
    * @param {Array} mat
    * @param {number} dim
    * @param {Function} callback
    * @returns {Array} ret
    * @private
    */
   function _reduce(mat, dim, callback) {
     var i, ret, val, tran;
     if (dim <= 0) {
       if (!Array.isArray(mat[0])) {
         val = mat[0];
         for (i = 1; i < mat.length; i++) {
           val = callback(val, mat[i]);
         }
         return val;
       } else {
         tran = _switch$1(mat);
         ret = [];
         for (i = 0; i < tran.length; i++) {
           ret[i] = _reduce(tran[i], dim - 1, callback);
         }
         return ret;
       }
     } else {
       ret = [];
       for (i = 0; i < mat.length; i++) {
         ret[i] = _reduce(mat[i], dim - 1, callback);
       }
       return ret;
     }
   }

   // TODO: document function scatter
   function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
     // a arrays
     var avalues = a._values;
     var aindex = a._index;
     var aptr = a._ptr;

     // vars
     var k, k0, k1, i;

     // check we need to process values (pattern matrix)
     if (x) {
       // values in j
       for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
         // row
         i = aindex[k];
         // check value exists in current j
         if (w[i] !== mark) {
           // i is new entry in j
           w[i] = mark;
           // add i to pattern of C
           cindex.push(i);
           // x(i) = A, check we need to call function this time
           if (update) {
             // copy value to workspace calling callback function
             x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
             // function was called on current row
             u[i] = mark;
           } else {
             // copy value to workspace
             x[i] = avalues[k];
           }
         } else {
           // i exists in C already
           x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
           // function was called on current row
           u[i] = mark;
         }
       }
     } else {
       // values in j
       for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
         // row
         i = aindex[k];
         // check value exists in current j
         if (w[i] !== mark) {
           // i is new entry in j
           w[i] = mark;
           // add i to pattern of C
           cindex.push(i);
         } else {
           // indicate function was called on current row
           u[i] = mark;
         }
       }
     }
   }

   var name$4G = 'isInteger';
   var dependencies$4F = ['typed'];
   var createIsInteger = /* #__PURE__ */factory(name$4G, dependencies$4F, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is an integer number.
      * The function supports `number`, `BigNumber`, and `Fraction`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isInteger(x)
      *
      * Examples:
      *
      *    math.isInteger(2)                     // returns true
      *    math.isInteger(0)                     // returns true
      *    math.isInteger(0.5)                   // returns false
      *    math.isInteger(math.bignumber(500))   // returns true
      *    math.isInteger(math.fraction(4))      // returns true
      *    math.isInteger('3')                   // returns true
      *    math.isInteger([3, 0.5, -2])          // returns [true, false, true]
      *    math.isInteger(math.complex('2-4i'))  // throws an error
      *
      * See also:
      *
      *    isNumeric, isPositive, isNegative, isZero
      *
      * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested
      * @return {boolean}  Returns true when `x` contains a numeric, integer value.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$4G, {
       number: isInteger$1,
       // TODO: what to do with isInteger(add(0.1, 0.2))  ?

       BigNumber: function BigNumber(x) {
         return x.isInt();
       },
       Fraction: function Fraction(x) {
         return x.d === 1 && isFinite(x.n);
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var n1$4 = 'number';
   var n2$2 = 'number, number';
   function absNumber(a) {
     return Math.abs(a);
   }
   absNumber.signature = n1$4;
   function addNumber(a, b) {
     return a + b;
   }
   addNumber.signature = n2$2;
   function multiplyNumber(a, b) {
     return a * b;
   }
   multiplyNumber.signature = n2$2;
   function unaryMinusNumber(x) {
     return -x;
   }
   unaryMinusNumber.signature = n1$4;
   function unaryPlusNumber(x) {
     return x;
   }
   unaryPlusNumber.signature = n1$4;
   function cbrtNumber(x) {
     return cbrt$2(x);
   }
   cbrtNumber.signature = n1$4;
   function cubeNumber(x) {
     return x * x * x;
   }
   cubeNumber.signature = n1$4;
   function expNumber(x) {
     return Math.exp(x);
   }
   expNumber.signature = n1$4;
   function expm1Number(x) {
     return expm1$1(x);
   }
   expm1Number.signature = n1$4;

   /**
    * Calculate gcd for numbers
    * @param {number} a
    * @param {number} b
    * @returns {number} Returns the greatest common denominator of a and b
    */
   function gcdNumber(a, b) {
     if (!isInteger$1(a) || !isInteger$1(b)) {
       throw new Error('Parameters in function gcd must be integer numbers');
     }

     // https://en.wikipedia.org/wiki/Euclidean_algorithm
     var r;
     while (b !== 0) {
       r = a % b;
       a = b;
       b = r;
     }
     return a < 0 ? -a : a;
   }
   gcdNumber.signature = n2$2;

   /**
    * Calculate lcm for two numbers
    * @param {number} a
    * @param {number} b
    * @returns {number} Returns the least common multiple of a and b
    */
   function lcmNumber(a, b) {
     if (!isInteger$1(a) || !isInteger$1(b)) {
       throw new Error('Parameters in function lcm must be integer numbers');
     }
     if (a === 0 || b === 0) {
       return 0;
     }

     // https://en.wikipedia.org/wiki/Euclidean_algorithm
     // evaluate lcm here inline to reduce overhead
     var t;
     var prod = a * b;
     while (b !== 0) {
       t = b;
       b = a % t;
       a = t;
     }
     return Math.abs(prod / a);
   }
   lcmNumber.signature = n2$2;

   /**
    * Calculate the logarithm of a value, optionally to a given base.
    * @param {number} x
    * @param {number | null | undefined} base
    * @return {number}
    */
   function logNumber(x, y) {
     if (y) {
       return Math.log(x) / Math.log(y);
     }
     return Math.log(x);
   }

   /**
    * Calculate the 10-base logarithm of a number
    * @param {number} x
    * @return {number}
    */
   function log10Number(x) {
     return log10$2(x);
   }
   log10Number.signature = n1$4;

   /**
    * Calculate the 2-base logarithm of a number
    * @param {number} x
    * @return {number}
    */
   function log2Number(x) {
     return log2$2(x);
   }
   log2Number.signature = n1$4;

   /**
    * Calculate the modulus of two numbers
    * @param {number} x
    * @param {number} y
    * @returns {number} res
    * @private
    */
   function modNumber(x, y) {
     if (y > 0) {
       // We don't use JavaScript's % operator here as this doesn't work
       // correctly for x < 0 and x === 0
       // see https://en.wikipedia.org/wiki/Modulo_operation
       return x - y * Math.floor(x / y);
     } else if (y === 0) {
       return x;
     } else {
       // y < 0
       // TODO: implement mod for a negative divisor
       throw new Error('Cannot calculate mod for a negative divisor');
     }
   }
   modNumber.signature = n2$2;

   /**
    * Calculate the nth root of a, solve x^root == a
    * http://rosettacode.org/wiki/Nth_root#JavaScript
    * @param {number} a
    * @param {number} [2] root
    * @private
    */
   function nthRootNumber(a) {
     var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
     var inv = root < 0;
     if (inv) {
       root = -root;
     }
     if (root === 0) {
       throw new Error('Root must be non-zero');
     }
     if (a < 0 && Math.abs(root) % 2 !== 1) {
       throw new Error('Root must be odd when a is negative.');
     }

     // edge cases zero and infinity
     if (a === 0) {
       return inv ? Infinity : 0;
     }
     if (!isFinite(a)) {
       return inv ? 0 : a;
     }
     var x = Math.pow(Math.abs(a), 1 / root);
     // If a < 0, we require that root is an odd integer,
     // so (-1) ^ (1/root) = -1
     x = a < 0 ? -x : x;
     return inv ? 1 / x : x;

     // Very nice algorithm, but fails with nthRoot(-2, 3).
     // Newton's method has some well-known problems at times:
     // https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis
     /*
     let x = 1 // Initial guess
     let xPrev = 1
     let i = 0
     const iMax = 10000
     do {
       const delta = (a / Math.pow(x, root - 1) - x) / root
       xPrev = x
       x = x + delta
       i++
     }
     while (xPrev !== x && i < iMax)
      if (xPrev !== x) {
       throw new Error('Function nthRoot failed to converge')
     }
      return inv ? 1 / x : x
     */
   }

   function signNumber(x) {
     return sign$2(x);
   }
   signNumber.signature = n1$4;
   function squareNumber(x) {
     return x * x;
   }
   squareNumber.signature = n1$4;

   /**
    * Calculate xgcd for two numbers
    * @param {number} a
    * @param {number} b
    * @return {number} result
    * @private
    */
   function xgcdNumber(a, b) {
     // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
     var t; // used to swap two variables
     var q; // quotient
     var r; // remainder
     var x = 0;
     var lastx = 1;
     var y = 1;
     var lasty = 0;
     if (!isInteger$1(a) || !isInteger$1(b)) {
       throw new Error('Parameters in function xgcd must be integer numbers');
     }
     while (b) {
       q = Math.floor(a / b);
       r = a - q * b;
       t = x;
       x = lastx - q * x;
       lastx = t;
       t = y;
       y = lasty - q * y;
       lasty = t;
       a = b;
       b = r;
     }
     var res;
     if (a < 0) {
       res = [-a, -lastx, -lasty];
     } else {
       res = [a, a ? lastx : 0, lasty];
     }
     return res;
   }
   xgcdNumber.signature = n2$2;

   /**
    * Calculates the power of x to y, x^y, for two numbers.
    * @param {number} x
    * @param {number} y
    * @return {number} res
    */
   function powNumber(x, y) {
     // x^Infinity === 0 if -1 < x < 1
     // A real number 0 is returned instead of complex(0)
     if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
       return 0;
     }
     return Math.pow(x, y);
   }
   powNumber.signature = n2$2;

   /**
    * round a number to the given number of decimals, or to zero if decimals is
    * not provided
    * @param {number} value
    * @param {number} decimals       number of decimals, between 0 and 15 (0 by default)
    * @return {number} roundedValue
    */
   function roundNumber(value) {
     var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
     if (!isInteger$1(decimals) || decimals < 0 || decimals > 15) {
       throw new Error('Number of decimals in function round must be an integer from 0 to 15 inclusive');
     }
     return parseFloat(toFixed$1(value, decimals));
   }

   var n1$3 = 'number';
   var n2$1 = 'number, number';
   function bitAndNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function bitAnd');
     }
     return x & y;
   }
   bitAndNumber.signature = n2$1;
   function bitNotNumber(x) {
     if (!isInteger$1(x)) {
       throw new Error('Integer expected in function bitNot');
     }
     return ~x;
   }
   bitNotNumber.signature = n1$3;
   function bitOrNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function bitOr');
     }
     return x | y;
   }
   bitOrNumber.signature = n2$1;
   function bitXorNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function bitXor');
     }
     return x ^ y;
   }
   bitXorNumber.signature = n2$1;
   function leftShiftNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function leftShift');
     }
     return x << y;
   }
   leftShiftNumber.signature = n2$1;
   function rightArithShiftNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function rightArithShift');
     }
     return x >> y;
   }
   rightArithShiftNumber.signature = n2$1;
   function rightLogShiftNumber(x, y) {
     if (!isInteger$1(x) || !isInteger$1(y)) {
       throw new Error('Integers expected in function rightLogShift');
     }
     return x >>> y;
   }
   rightLogShiftNumber.signature = n2$1;

   /** @param {number} i
    *  @param {number} n
    *  @returns {number} product of i to n
    */
   function product(i, n) {
     if (n < i) {
       return 1;
     }
     if (n === i) {
       return n;
     }
     var half = n + i >> 1; // divide (n + i) by 2 and truncate to integer
     return product(i, half) * product(half + 1, n);
   }

   function combinationsNumber(n, k) {
     if (!isInteger$1(n) || n < 0) {
       throw new TypeError('Positive integer value expected in function combinations');
     }
     if (!isInteger$1(k) || k < 0) {
       throw new TypeError('Positive integer value expected in function combinations');
     }
     if (k > n) {
       throw new TypeError('k must be less than or equal to n');
     }
     var nMinusk = n - k;
     var answer = 1;
     var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
     var nextdivisor = 2;
     var lastdivisor = k < nMinusk ? k : nMinusk;
     // balance multiplications and divisions to try to keep intermediate values
     // in exact-integer range as long as possible
     for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
       answer *= nextnumerator;
       while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
         answer /= nextdivisor;
         ++nextdivisor;
       }
     }
     // for big n, k, floating point may have caused weirdness in remainder
     if (nextdivisor <= lastdivisor) {
       answer /= product(nextdivisor, lastdivisor);
     }
     return answer;
   }
   combinationsNumber.signature = 'number, number';

   var pi$1 = Math.PI;
   var tau$1 = 2 * Math.PI;
   var e$1 = Math.E;
   var phi$1 = 1.6180339887498948; // eslint-disable-line no-loss-of-precision

   var n1$2 = 'number';
   var n2 = 'number, number';
   function notNumber(x) {
     return !x;
   }
   notNumber.signature = n1$2;
   function orNumber(x, y) {
     return !!(x || y);
   }
   orNumber.signature = n2;
   function xorNumber(x, y) {
     return !!x !== !!y;
   }
   xorNumber.signature = n2;
   function andNumber(x, y) {
     return !!(x && y);
   }
   andNumber.signature = n2;

   /* eslint-disable no-loss-of-precision */

   function gammaNumber(n) {
     var x;
     if (isInteger$1(n)) {
       if (n <= 0) {
         return isFinite(n) ? Infinity : NaN;
       }
       if (n > 171) {
         return Infinity; // Will overflow
       }

       return product(1, n - 1);
     }
     if (n < 0.5) {
       return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
     }
     if (n >= 171.35) {
       return Infinity; // will overflow
     }

     if (n > 85.0) {
       // Extended Stirling Approx
       var twoN = n * n;
       var threeN = twoN * n;
       var fourN = threeN * n;
       var fiveN = fourN * n;
       return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
     }
     --n;
     x = gammaP[0];
     for (var i = 1; i < gammaP.length; ++i) {
       x += gammaP[i] / (n + i);
     }
     var t = n + gammaG + 0.5;
     return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
   }
   gammaNumber.signature = 'number';

   // TODO: comment on the variables g and p

   var gammaG = 4.7421875;
   var gammaP = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];

   // lgamma implementation ref: https://mrob.com/pub/ries/lanczos-gamma.html#code

   // log(2 * pi) / 2
   var lnSqrt2PI = 0.91893853320467274178;
   var lgammaG = 5; // Lanczos parameter "g"
   var lgammaN = 7; // Range of coefficients "n"

   var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
   function lgammaNumber(n) {
     if (n < 0) return NaN;
     if (n === 0) return Infinity;
     if (!isFinite(n)) return n;
     if (n < 0.5) {
       // Use Euler's reflection formula:
       // gamma(z) = PI / (sin(PI * z) * gamma(1 - z))
       return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
     }

     // Compute the logarithm of the Gamma function using the Lanczos method

     n = n - 1;
     var base = n + lgammaG + 0.5; // Base of the Lanczos exponential
     var sum = lgammaSeries[0];

     // We start with the terms that have the smallest coefficients and largest denominator
     for (var i = lgammaN - 1; i >= 1; i--) {
       sum += lgammaSeries[i] / (n + i);
     }
     return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum);
   }
   lgammaNumber.signature = 'number';

   var n1$1 = 'number';
   function acoshNumber(x) {
     return acosh$2(x);
   }
   acoshNumber.signature = n1$1;
   function acotNumber(x) {
     return Math.atan(1 / x);
   }
   acotNumber.signature = n1$1;
   function acothNumber(x) {
     return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
   }
   acothNumber.signature = n1$1;
   function acscNumber(x) {
     return Math.asin(1 / x);
   }
   acscNumber.signature = n1$1;
   function acschNumber(x) {
     var xInv = 1 / x;
     return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
   }
   acschNumber.signature = n1$1;
   function asecNumber(x) {
     return Math.acos(1 / x);
   }
   asecNumber.signature = n1$1;
   function asechNumber(x) {
     var xInv = 1 / x;
     var ret = Math.sqrt(xInv * xInv - 1);
     return Math.log(ret + xInv);
   }
   asechNumber.signature = n1$1;
   function asinhNumber(x) {
     return asinh$2(x);
   }
   asinhNumber.signature = n1$1;
   function atanhNumber(x) {
     return atanh$2(x);
   }
   atanhNumber.signature = n1$1;
   function cotNumber(x) {
     return 1 / Math.tan(x);
   }
   cotNumber.signature = n1$1;
   function cothNumber(x) {
     var e = Math.exp(2 * x);
     return (e + 1) / (e - 1);
   }
   cothNumber.signature = n1$1;
   function cscNumber(x) {
     return 1 / Math.sin(x);
   }
   cscNumber.signature = n1$1;
   function cschNumber(x) {
     // consider values close to zero (+/-)
     if (x === 0) {
       return Number.POSITIVE_INFINITY;
     } else {
       return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign$2(x);
     }
   }
   cschNumber.signature = n1$1;
   function secNumber(x) {
     return 1 / Math.cos(x);
   }
   secNumber.signature = n1$1;
   function sechNumber(x) {
     return 2 / (Math.exp(x) + Math.exp(-x));
   }
   sechNumber.signature = n1$1;
   function sinhNumber(x) {
     return sinh$2(x);
   }
   sinhNumber.signature = n1$1;

   var n1 = 'number';
   function isNegativeNumber(x) {
     return x < 0;
   }
   isNegativeNumber.signature = n1;
   function isPositiveNumber(x) {
     return x > 0;
   }
   isPositiveNumber.signature = n1;
   function isZeroNumber(x) {
     return x === 0;
   }
   isZeroNumber.signature = n1;
   function isNaNNumber(x) {
     return Number.isNaN(x);
   }
   isNaNNumber.signature = n1;

   var name$4F = 'isNegative';
   var dependencies$4E = ['typed'];
   var createIsNegative = /* #__PURE__ */factory(name$4F, dependencies$4E, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is negative: smaller than zero.
      * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isNegative(x)
      *
      * Examples:
      *
      *    math.isNegative(3)                     // returns false
      *    math.isNegative(-2)                    // returns true
      *    math.isNegative(0)                     // returns false
      *    math.isNegative(-0)                    // returns false
      *    math.isNegative(math.bignumber(2))     // returns false
      *    math.isNegative(math.fraction(-2, 5))  // returns true
      *    math.isNegative('-2')                  // returns true
      *    math.isNegative([2, 0, -3])            // returns [false, false, true]
      *
      * See also:
      *
      *    isNumeric, isPositive, isZero, isInteger
      *
      * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
      * @return {boolean}  Returns true when `x` is larger than zero.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$4F, {
       number: isNegativeNumber,
       BigNumber: function BigNumber(x) {
         return x.isNeg() && !x.isZero() && !x.isNaN();
       },
       Fraction: function Fraction(x) {
         return x.s < 0; // It's enough to decide on the sign
       },

       Unit: typed.referToSelf(self => x => typed.find(self, x.valueType())(x.value)),
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4E = 'isNumeric';
   var dependencies$4D = ['typed'];
   var createIsNumeric = /* #__PURE__ */factory(name$4E, dependencies$4D, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is an numeric value.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isNumeric(x)
      *
      * Examples:
      *
      *    math.isNumeric(2)                     // returns true
      *    math.isNumeric('2')                   // returns false
      *    math.hasNumericValue('2')             // returns true
      *    math.isNumeric(0)                     // returns true
      *    math.isNumeric(math.bignumber(500))   // returns true
      *    math.isNumeric(math.fraction(4))      // returns true
      *    math.isNumeric(math.complex('2-4i'))  // returns false
      *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]
      *
      * See also:
      *
      *    isZero, isPositive, isNegative, isInteger, hasNumericValue
      *
      * @param {*} x       Value to be tested
      * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
      *                    `Fraction`, or `boolean`. Returns false for other types.
      *                    Throws an error in case of unknown types.
      */
     return typed(name$4E, {
       'number | BigNumber | Fraction | boolean': () => true,
       'Complex | Unit | string | null | undefined | Node': () => false,
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4D = 'hasNumericValue';
   var dependencies$4C = ['typed', 'isNumeric'];
   var createHasNumericValue = /* #__PURE__ */factory(name$4D, dependencies$4C, _ref => {
     var {
       typed,
       isNumeric
     } = _ref;
     /**
      * Test whether a value is an numeric value.
      *
      * In case of a string, true is returned if the string contains a numeric value.
      *
      * Syntax:
      *
      *     math.hasNumericValue(x)
      *
      * Examples:
      *
      *    math.hasNumericValue(2)                     // returns true
      *    math.hasNumericValue('2')                   // returns true
      *    math.isNumeric('2')                         // returns false
      *    math.hasNumericValue(0)                     // returns true
      *    math.hasNumericValue(math.bignumber(500))   // returns true
      *    math.hasNumericValue(math.fraction(4))      // returns true
      *    math.hasNumericValue(math.complex('2-4i'))  // returns false
      *    math.hasNumericValue(false)                 // returns true
      *    math.hasNumericValue([2.3, 'foo', false])   // returns [true, false, true]
      *
      * See also:
      *
      *    isZero, isPositive, isNegative, isInteger, isNumeric
      *
      * @param {*} x       Value to be tested
      * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
      *                    `Fraction`, `Boolean`, or a `String` containing number. Returns false for other types.
      *                    Throws an error in case of unknown types.
      */
     return typed(name$4D, {
       boolean: () => true,
       string: function string(x) {
         return x.trim().length > 0 && !isNaN(Number(x));
       },
       any: function any(x) {
         return isNumeric(x);
       }
     });
   });

   var name$4C = 'isPositive';
   var dependencies$4B = ['typed'];
   var createIsPositive = /* #__PURE__ */factory(name$4C, dependencies$4B, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is positive: larger than zero.
      * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isPositive(x)
      *
      * Examples:
      *
      *    math.isPositive(3)                     // returns true
      *    math.isPositive(-2)                    // returns false
      *    math.isPositive(0)                     // returns false
      *    math.isPositive(-0)                    // returns false
      *    math.isPositive(0.5)                   // returns true
      *    math.isPositive(math.bignumber(2))     // returns true
      *    math.isPositive(math.fraction(-2, 5))  // returns false
      *    math.isPositive(math.fraction(1, 3))   // returns true
      *    math.isPositive('2')                   // returns true
      *    math.isPositive([2, 0, -3])            // returns [true, false, false]
      *
      * See also:
      *
      *    isNumeric, isZero, isNegative, isInteger
      *
      * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
      * @return {boolean}  Returns true when `x` is larger than zero.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$4C, {
       number: isPositiveNumber,
       BigNumber: function BigNumber(x) {
         return !x.isNeg() && !x.isZero() && !x.isNaN();
       },
       Fraction: function Fraction(x) {
         return x.s > 0 && x.n > 0;
       },
       Unit: typed.referToSelf(self => x => typed.find(self, x.valueType())(x.value)),
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4B = 'isZero';
   var dependencies$4A = ['typed'];
   var createIsZero = /* #__PURE__ */factory(name$4B, dependencies$4A, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is zero.
      * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
      * `Complex`, and `Unit`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isZero(x)
      *
      * Examples:
      *
      *    math.isZero(0)                      // returns true
      *    math.isZero(2)                      // returns false
      *    math.isZero(0.5)                    // returns false
      *    math.isZero(math.bignumber(0))      // returns true
      *    math.isZero(math.fraction(0))       // returns true
      *    math.isZero(math.fraction(1,3))     // returns false
      *    math.isZero(math.complex('2 - 4i')) // returns false
      *    math.isZero(math.complex('0i'))     // returns true
      *    math.isZero('0')                    // returns true
      *    math.isZero('2')                    // returns false
      *    math.isZero([2, 0, -3])             // returns [false, true, false]
      *
      * See also:
      *
      *    isNumeric, isPositive, isNegative, isInteger
      *
      * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
      * @return {boolean}  Returns true when `x` is zero.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$4B, {
       number: isZeroNumber,
       BigNumber: function BigNumber(x) {
         return x.isZero();
       },
       Complex: function Complex(x) {
         return x.re === 0 && x.im === 0;
       },
       Fraction: function Fraction(x) {
         return x.d === 1 && x.n === 0;
       },
       Unit: typed.referToSelf(self => x => typed.find(self, x.valueType())(x.value)),
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4A = 'isNaN';
   var dependencies$4z = ['typed'];
   var createIsNaN = /* #__PURE__ */factory(name$4A, dependencies$4z, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is NaN (not a number).
      * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isNaN(x)
      *
      * Examples:
      *
      *    math.isNaN(3)                     // returns false
      *    math.isNaN(NaN)                   // returns true
      *    math.isNaN(0)                     // returns false
      *    math.isNaN(math.bignumber(NaN))   // returns true
      *    math.isNaN(math.bignumber(0))     // returns false
      *    math.isNaN(math.fraction(-2, 5))  // returns false
      *    math.isNaN('-2')                  // returns false
      *    math.isNaN([2, 0, -3, NaN])       // returns [false, false, false, true]
      *
      * See also:
      *
      *    isNumeric, isNegative, isPositive, isZero, isInteger
      *
      * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
      * @return {boolean}  Returns true when `x` is NaN.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$4A, {
       number: isNaNNumber,
       BigNumber: function BigNumber(x) {
         return x.isNaN();
       },
       Fraction: function Fraction(x) {
         return false;
       },
       Complex: function Complex(x) {
         return x.isNaN();
       },
       Unit: function Unit(x) {
         return Number.isNaN(x.value);
       },
       'Array | Matrix': function ArrayMatrix(x) {
         return deepMap(x, Number.isNaN);
       }
     });
   });

   var name$4z = 'typeOf';
   var dependencies$4y = ['typed'];
   var createTypeOf = /* #__PURE__ */factory(name$4z, dependencies$4y, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Determine the type of an entity.
      *
      * Syntax:
      *
      *    math.typeOf(x)
      *
      * Examples:
      *
      *    // This list is intended to include all relevant types, for testing
      *    // purposes:
      *    math.typeOf(3.5)                      // returns 'number'
      *    math.typeOf(math.complex('2-4i'))     // returns 'Complex'
      *    math.typeOf(math.unit('45 deg'))      // returns 'Unit'
      *    math.typeOf('hello world')            // returns 'string'
      *    math.typeOf(null)                     // returns 'null'
      *    math.typeOf(true)                     // returns 'boolean'
      *    math.typeOf([1, 2, 3])                // returns 'Array'
      *    math.typeOf(new Date())               // returns 'Date'
      *    math.typeOf(function () {})           // returns 'function'
      *    math.typeOf({a: 2, b: 3})             // returns 'Object'
      *    math.typeOf(/a regexp/)               // returns 'RegExp'
      *    math.typeOf(undefined)                // returns 'undefined'
      *    math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'
      *    math.typeOf(math.chain(2))            // returns 'Chain'
      *    math.typeOf(math.fraction(1, 3))      // returns 'Fraction'
      *    math.typeOf(math.help('sqrt'))        // returns 'Help'
      *    math.typeOf(math.index(1, 3))         // returns 'Index'
      *    math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'
      *    math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'
      *    math.typeOf(new math.Range(0, 10))    // returns 'Range'
      *    math.typeOf(math.evaluate('a=2\na'))  // returns 'ResultSet'
      *    math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'
      *    math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'
      *    math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'
      *    math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'
      *    math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'
      *    math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'
      *    math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'
      *    math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'
      *    math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'
      *    math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'
      *    math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'
      *    math.typeOf(math.parse('1:10'))       // returns 'RangeNode'
      *    math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'
      *    math.typeOf(math.parse('x'))          // returns 'SymbolNode'
      *
      * @param {*} x     The variable for which to test the type.
      * @return {string} Returns the name of the type. Primitive types are lower case,
      *                  non-primitive types are upper-camel-case.
      *                  For example 'number', 'string', 'Array', 'Date'.
      */
     return typed(name$4z, {
       any: typeOf$1
     });
   });

   /**
    * Compares two BigNumbers.
    * @param {BigNumber} x       First value to compare
    * @param {BigNumber} y       Second value to compare
    * @param {number} [epsilon]  The maximum relative difference between x and y
    *                            If epsilon is undefined or null, the function will
    *                            test whether x and y are exactly equal.
    * @return {boolean} whether the two numbers are nearly equal
    */
   function nearlyEqual(x, y, epsilon) {
     // if epsilon is null or undefined, test whether x and y are exactly equal
     if (epsilon === null || epsilon === undefined) {
       return x.eq(y);
     }

     // use "==" operator, handles infinities
     if (x.eq(y)) {
       return true;
     }

     // NaN
     if (x.isNaN() || y.isNaN()) {
       return false;
     }

     // at this point x and y should be finite
     if (x.isFinite() && y.isFinite()) {
       // check numbers are very close, needed when comparing numbers near zero
       var diff = x.minus(y).abs();
       if (diff.isZero()) {
         return true;
       } else {
         // use relative error
         var max = x.constructor.max(x.abs(), y.abs());
         return diff.lte(max.times(epsilon));
       }
     }

     // Infinite and Number or negative Infinite and positive Infinite cases
     return false;
   }

   /**
    * Test whether two complex values are equal provided a given epsilon.
    * Does not use or change the global Complex.EPSILON setting
    * @param {Complex} x
    * @param {Complex} y
    * @param {number} epsilon
    * @returns {boolean}
    */
   function complexEquals(x, y, epsilon) {
     return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
   }

   var createCompareUnits = /* #__PURE__ */factory('compareUnits', ['typed'], _ref => {
     var {
       typed
     } = _ref;
     return {
       'Unit, Unit': typed.referToSelf(self => (x, y) => {
         if (!x.equalBase(y)) {
           throw new Error('Cannot compare units with different base');
         }
         return typed.find(self, [x.valueType(), y.valueType()])(x.value, y.value);
       })
     };
   });

   var name$4y = 'equalScalar';
   var dependencies$4x = ['typed', 'config'];
   var createEqualScalar = /* #__PURE__ */factory(name$4y, dependencies$4x, _ref => {
     var {
       typed,
       config
     } = _ref;
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Test whether two scalar values are nearly equal.
      *
      * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
      * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
      * @private
      */
     return typed(name$4y, {
       'boolean, boolean': function booleanBoolean(x, y) {
         return x === y;
       },
       'number, number': function numberNumber(x, y) {
         return nearlyEqual$1(x, y, config.epsilon);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.eq(y) || nearlyEqual(x, y, config.epsilon);
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         return x.equals(y);
       },
       'Complex, Complex': function ComplexComplex(x, y) {
         return complexEquals(x, y, config.epsilon);
       }
     }, compareUnits);
   });
   factory(name$4y, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$4y, {
       'number, number': function numberNumber(x, y) {
         return nearlyEqual$1(x, y, config.epsilon);
       }
     });
   });

   var name$4x = 'SparseMatrix';
   var dependencies$4w = ['typed', 'equalScalar', 'Matrix'];
   var createSparseMatrixClass = /* #__PURE__ */factory(name$4x, dependencies$4w, _ref => {
     var {
       typed,
       equalScalar,
       Matrix
     } = _ref;
     /**
      * Sparse Matrix implementation. This type implements
      * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
      * format for two-dimensional sparse matrices.
      * @class SparseMatrix
      */
     function SparseMatrix(data, datatype) {
       if (!(this instanceof SparseMatrix)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       if (datatype && !isString(datatype)) {
         throw new Error('Invalid datatype: ' + datatype);
       }
       if (isMatrix(data)) {
         // create from matrix
         _createFromMatrix(this, data, datatype);
       } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
         // initialize fields
         this._values = data.values;
         this._index = data.index;
         this._ptr = data.ptr;
         this._size = data.size;
         this._datatype = datatype || data.datatype;
       } else if (isArray(data)) {
         // create from array
         _createFromArray(this, data, datatype);
       } else if (data) {
         // unsupported type
         throw new TypeError('Unsupported type of data (' + typeOf$1(data) + ')');
       } else {
         // nothing provided
         this._values = [];
         this._index = [];
         this._ptr = [0];
         this._size = [0, 0];
         this._datatype = datatype;
       }
     }
     function _createFromMatrix(matrix, source, datatype) {
       // check matrix type
       if (source.type === 'SparseMatrix') {
         // clone arrays
         matrix._values = source._values ? clone$3(source._values) : undefined;
         matrix._index = clone$3(source._index);
         matrix._ptr = clone$3(source._ptr);
         matrix._size = clone$3(source._size);
         matrix._datatype = datatype || source._datatype;
       } else {
         // build from matrix data
         _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
       }
     }
     function _createFromArray(matrix, data, datatype) {
       // initialize fields
       matrix._values = [];
       matrix._index = [];
       matrix._ptr = [];
       matrix._datatype = datatype;
       // discover rows & columns, do not use math.size() to avoid looping array twice
       var rows = data.length;
       var columns = 0;

       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       if (isString(datatype)) {
         // find signature that matches (datatype, datatype)
         eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
         // convert 0 to the same datatype
         zero = typed.convert(0, datatype);
       }

       // check we have rows (empty array)
       if (rows > 0) {
         // column index
         var j = 0;
         do {
           // store pointer to values index
           matrix._ptr.push(matrix._index.length);
           // loop rows
           for (var i = 0; i < rows; i++) {
             // current row
             var row = data[i];
             // check row is an array
             if (isArray(row)) {
               // update columns if needed (only on first column)
               if (j === 0 && columns < row.length) {
                 columns = row.length;
               }
               // check row has column
               if (j < row.length) {
                 // value
                 var v = row[j];
                 // check value != 0
                 if (!eq(v, zero)) {
                   // store value
                   matrix._values.push(v);
                   // index
                   matrix._index.push(i);
                 }
               }
             } else {
               // update columns if needed (only on first column)
               if (j === 0 && columns < 1) {
                 columns = 1;
               }
               // check value != 0 (row is a scalar)
               if (!eq(row, zero)) {
                 // store value
                 matrix._values.push(row);
                 // index
                 matrix._index.push(i);
               }
             }
           }
           // increment index
           j++;
         } while (j < columns);
       }
       // store number of values in ptr
       matrix._ptr.push(matrix._index.length);
       // size
       matrix._size = [rows, columns];
     }
     SparseMatrix.prototype = new Matrix();

     /**
      * Create a new SparseMatrix
      */
     SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
       return new SparseMatrix(data, datatype);
     };

     /**
      * Attach type information
      */
     Object.defineProperty(SparseMatrix, 'name', {
       value: 'SparseMatrix'
     });
     SparseMatrix.prototype.constructor = SparseMatrix;
     SparseMatrix.prototype.type = 'SparseMatrix';
     SparseMatrix.prototype.isSparseMatrix = true;

     /**
      * Get the matrix type
      *
      * Usage:
      *    const matrixType = matrix.getDataType()  // retrieves the matrix type
      *
      * @memberOf SparseMatrix
      * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
      */
     SparseMatrix.prototype.getDataType = function () {
       return getArrayDataType(this._values, typeOf$1);
     };

     /**
      * Get the storage format used by the matrix.
      *
      * Usage:
      *     const format = matrix.storage()   // retrieve storage format
      *
      * @memberof SparseMatrix
      * @return {string}           The storage format.
      */
     SparseMatrix.prototype.storage = function () {
       return 'sparse';
     };

     /**
      * Get the datatype of the data stored in the matrix.
      *
      * Usage:
      *     const format = matrix.datatype()    // retrieve matrix datatype
      *
      * @memberof SparseMatrix
      * @return {string}           The datatype.
      */
     SparseMatrix.prototype.datatype = function () {
       return this._datatype;
     };

     /**
      * Create a new SparseMatrix
      * @memberof SparseMatrix
      * @param {Array} data
      * @param {string} [datatype]
      */
     SparseMatrix.prototype.create = function (data, datatype) {
       return new SparseMatrix(data, datatype);
     };

     /**
      * Get the matrix density.
      *
      * Usage:
      *     const density = matrix.density()                   // retrieve matrix density
      *
      * @memberof SparseMatrix
      * @return {number}           The matrix density.
      */
     SparseMatrix.prototype.density = function () {
       // rows & columns
       var rows = this._size[0];
       var columns = this._size[1];
       // calculate density
       return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
     };

     /**
      * Get a subset of the matrix, or replace a subset of the matrix.
      *
      * Usage:
      *     const subset = matrix.subset(index)               // retrieve subset
      *     const value = matrix.subset(index, replacement)   // replace subset
      *
      * @memberof SparseMatrix
      * @param {Index} index
      * @param {Array | Matrix | *} [replacement]
      * @param {*} [defaultValue=0]      Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be filled with zeros.
      */
     SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {
       // check it is a pattern matrix
       if (!this._values) {
         throw new Error('Cannot invoke subset on a Pattern only matrix');
       }

       // check arguments
       switch (arguments.length) {
         case 1:
           return _getsubset(this, index);

         // intentional fall through
         case 2:
         case 3:
           return _setsubset(this, index, replacement, defaultValue);
         default:
           throw new SyntaxError('Wrong number of arguments');
       }
     };
     function _getsubset(matrix, idx) {
       // check idx
       if (!isIndex(idx)) {
         throw new TypeError('Invalid index');
       }
       var isScalar = idx.isScalar();
       if (isScalar) {
         // return a scalar
         return matrix.get(idx.min());
       }
       // validate dimensions
       var size = idx.size();
       if (size.length !== matrix._size.length) {
         throw new DimensionError(size.length, matrix._size.length);
       }

       // vars
       var i, ii, k, kk;

       // validate if any of the ranges in the index is out of range
       var min = idx.min();
       var max = idx.max();
       for (i = 0, ii = matrix._size.length; i < ii; i++) {
         validateIndex(min[i], matrix._size[i]);
         validateIndex(max[i], matrix._size[i]);
       }

       // matrix arrays
       var mvalues = matrix._values;
       var mindex = matrix._index;
       var mptr = matrix._ptr;

       // rows & columns dimensions for result matrix
       var rows = idx.dimension(0);
       var columns = idx.dimension(1);

       // workspace & permutation vector
       var w = [];
       var pv = [];

       // loop rows in resulting matrix
       rows.forEach(function (i, r) {
         // update permutation vector
         pv[i] = r[0];
         // mark i in workspace
         w[i] = true;
       });

       // result matrix arrays
       var values = mvalues ? [] : undefined;
       var index = [];
       var ptr = [];

       // loop columns in result matrix
       columns.forEach(function (j) {
         // update ptr
         ptr.push(index.length);
         // loop values in column j
         for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
           // row
           i = mindex[k];
           // check row is in result matrix
           if (w[i] === true) {
             // push index
             index.push(pv[i]);
             // check we need to process values
             if (values) {
               values.push(mvalues[k]);
             }
           }
         }
       });
       // update ptr
       ptr.push(index.length);

       // return matrix
       return new SparseMatrix({
         values,
         index,
         ptr,
         size,
         datatype: matrix._datatype
       });
     }
     function _setsubset(matrix, index, submatrix, defaultValue) {
       // check index
       if (!index || index.isIndex !== true) {
         throw new TypeError('Invalid index');
       }

       // get index size and check whether the index contains a single value
       var iSize = index.size();
       var isScalar = index.isScalar();

       // calculate the size of the submatrix, and convert it into an Array if needed
       var sSize;
       if (isMatrix(submatrix)) {
         // submatrix size
         sSize = submatrix.size();
         // use array representation
         submatrix = submatrix.toArray();
       } else {
         // get submatrix size (array, scalar)
         sSize = arraySize(submatrix);
       }

       // check index is a scalar
       if (isScalar) {
         // verify submatrix is a scalar
         if (sSize.length !== 0) {
           throw new TypeError('Scalar expected');
         }
         // set value
         matrix.set(index.min(), submatrix, defaultValue);
       } else {
         // validate dimensions, index size must be one or two dimensions
         if (iSize.length !== 1 && iSize.length !== 2) {
           throw new DimensionError(iSize.length, matrix._size.length, '<');
         }

         // check submatrix and index have the same dimensions
         if (sSize.length < iSize.length) {
           // calculate number of missing outer dimensions
           var i = 0;
           var outer = 0;
           while (iSize[i] === 1 && sSize[i] === 1) {
             i++;
           }
           while (iSize[i] === 1) {
             outer++;
             i++;
           }
           // unsqueeze both outer and inner dimensions
           submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
         }

         // check whether the size of the submatrix matches the index size
         if (!deepStrictEqual(iSize, sSize)) {
           throw new DimensionError(iSize, sSize, '>');
         }

         // insert the sub matrix
         if (iSize.length === 1) {
           // if the replacement index only has 1 dimension, go trough each one and set its value
           var range = index.dimension(0);
           range.forEach(function (dataIndex, subIndex) {
             validateIndex(dataIndex);
             matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
           });
         } else {
           // if the replacement index has 2 dimensions, go through each one and set the value in the correct index
           var firstDimensionRange = index.dimension(0);
           var secondDimensionRange = index.dimension(1);
           firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {
             validateIndex(firstDataIndex);
             secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {
               validateIndex(secondDataIndex);
               matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
             });
           });
         }
       }
       return matrix;
     }

     /**
      * Get a single element from the matrix.
      * @memberof SparseMatrix
      * @param {number[]} index   Zero-based index
      * @return {*} value
      */
     SparseMatrix.prototype.get = function (index) {
       if (!isArray(index)) {
         throw new TypeError('Array expected');
       }
       if (index.length !== this._size.length) {
         throw new DimensionError(index.length, this._size.length);
       }

       // check it is a pattern matrix
       if (!this._values) {
         throw new Error('Cannot invoke get on a Pattern only matrix');
       }

       // row and column
       var i = index[0];
       var j = index[1];

       // check i, j are valid
       validateIndex(i, this._size[0]);
       validateIndex(j, this._size[1]);

       // find value index
       var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
       // check k is prior to next column k and it is in the correct row
       if (k < this._ptr[j + 1] && this._index[k] === i) {
         return this._values[k];
       }
       return 0;
     };

     /**
      * Replace a single element in the matrix.
      * @memberof SparseMatrix
      * @param {number[]} index   Zero-based index
      * @param {*} v
      * @param {*} [defaultValue]        Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be set to zero.
      * @return {SparseMatrix} self
      */
     SparseMatrix.prototype.set = function (index, v, defaultValue) {
       if (!isArray(index)) {
         throw new TypeError('Array expected');
       }
       if (index.length !== this._size.length) {
         throw new DimensionError(index.length, this._size.length);
       }

       // check it is a pattern matrix
       if (!this._values) {
         throw new Error('Cannot invoke set on a Pattern only matrix');
       }

       // row and column
       var i = index[0];
       var j = index[1];

       // rows & columns
       var rows = this._size[0];
       var columns = this._size[1];

       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       if (isString(this._datatype)) {
         // find signature that matches (datatype, datatype)
         eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
         // convert 0 to the same datatype
         zero = typed.convert(0, this._datatype);
       }

       // check we need to resize matrix
       if (i > rows - 1 || j > columns - 1) {
         // resize matrix
         _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
         // update rows & columns
         rows = this._size[0];
         columns = this._size[1];
       }

       // check i, j are valid
       validateIndex(i, rows);
       validateIndex(j, columns);

       // find value index
       var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
       // check k is prior to next column k and it is in the correct row
       if (k < this._ptr[j + 1] && this._index[k] === i) {
         // check value != 0
         if (!eq(v, zero)) {
           // update value
           this._values[k] = v;
         } else {
           // remove value from matrix
           _remove(k, j, this._values, this._index, this._ptr);
         }
       } else {
         if (!eq(v, zero)) {
           // insert value @ (i, j)
           _insert(k, i, j, v, this._values, this._index, this._ptr);
         }
       }
       return this;
     };
     function _getValueIndex(i, top, bottom, index) {
       // check row is on the bottom side
       if (bottom - top === 0) {
         return bottom;
       }
       // loop rows [top, bottom[
       for (var r = top; r < bottom; r++) {
         // check we found value index
         if (index[r] === i) {
           return r;
         }
       }
       // we did not find row
       return top;
     }
     function _remove(k, j, values, index, ptr) {
       // remove value @ k
       values.splice(k, 1);
       index.splice(k, 1);
       // update pointers
       for (var x = j + 1; x < ptr.length; x++) {
         ptr[x]--;
       }
     }
     function _insert(k, i, j, v, values, index, ptr) {
       // insert value
       values.splice(k, 0, v);
       // update row for k
       index.splice(k, 0, i);
       // update column pointers
       for (var x = j + 1; x < ptr.length; x++) {
         ptr[x]++;
       }
     }

     /**
      * Resize the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (resize in place).
      *
      * @memberof SparseMatrix
      * @param {number[] | Matrix} size  The new size the matrix should have.
      *                                  Since sparse matrices are always two-dimensional,
      *                                  size must be two numbers in either an array or a matrix
      * @param {*} [defaultValue=0]      Default value, filled in on new entries.
      *                                  If not provided, the matrix elements will
      *                                  be filled with zeros.
      * @param {boolean} [copy]          Return a resized copy of the matrix
      *
      * @return {Matrix}                 The resized matrix
      */
     SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
       // validate arguments
       if (!isCollection(size)) {
         throw new TypeError('Array or Matrix expected');
       }

       // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
       var sizeArray = size.valueOf().map(value => {
         return Array.isArray(value) && value.length === 1 ? value[0] : value;
       });
       if (sizeArray.length !== 2) {
         throw new Error('Only two dimensions matrix are supported');
       }

       // check sizes
       sizeArray.forEach(function (value) {
         if (!isNumber(value) || !isInteger$1(value) || value < 0) {
           throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$1(sizeArray) + ')');
         }
       });

       // matrix to resize
       var m = copy ? this.clone() : this;
       // resize matrix
       return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
     };
     function _resize(matrix, rows, columns, defaultValue) {
       // value to insert at the time of growing matrix
       var value = defaultValue || 0;

       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       if (isString(matrix._datatype)) {
         // find signature that matches (datatype, datatype)
         eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
         // convert 0 to the same datatype
         zero = typed.convert(0, matrix._datatype);
         // convert value to the same datatype
         value = typed.convert(value, matrix._datatype);
       }

       // should we insert the value?
       var ins = !eq(value, zero);

       // old columns and rows
       var r = matrix._size[0];
       var c = matrix._size[1];
       var i, j, k;

       // check we need to increase columns
       if (columns > c) {
         // loop new columns
         for (j = c; j < columns; j++) {
           // update matrix._ptr for current column
           matrix._ptr[j] = matrix._values.length;
           // check we need to insert matrix._values
           if (ins) {
             // loop rows
             for (i = 0; i < r; i++) {
               // add new matrix._values
               matrix._values.push(value);
               // update matrix._index
               matrix._index.push(i);
             }
           }
         }
         // store number of matrix._values in matrix._ptr
         matrix._ptr[columns] = matrix._values.length;
       } else if (columns < c) {
         // truncate matrix._ptr
         matrix._ptr.splice(columns + 1, c - columns);
         // truncate matrix._values and matrix._index
         matrix._values.splice(matrix._ptr[columns], matrix._values.length);
         matrix._index.splice(matrix._ptr[columns], matrix._index.length);
       }
       // update columns
       c = columns;

       // check we need to increase rows
       if (rows > r) {
         // check we have to insert values
         if (ins) {
           // inserts
           var n = 0;
           // loop columns
           for (j = 0; j < c; j++) {
             // update matrix._ptr for current column
             matrix._ptr[j] = matrix._ptr[j] + n;
             // where to insert matrix._values
             k = matrix._ptr[j + 1] + n;
             // pointer
             var p = 0;
             // loop new rows, initialize pointer
             for (i = r; i < rows; i++, p++) {
               // add value
               matrix._values.splice(k + p, 0, value);
               // update matrix._index
               matrix._index.splice(k + p, 0, i);
               // increment inserts
               n++;
             }
           }
           // store number of matrix._values in matrix._ptr
           matrix._ptr[c] = matrix._values.length;
         }
       } else if (rows < r) {
         // deletes
         var d = 0;
         // loop columns
         for (j = 0; j < c; j++) {
           // update matrix._ptr for current column
           matrix._ptr[j] = matrix._ptr[j] - d;
           // where matrix._values start for next column
           var k0 = matrix._ptr[j];
           var k1 = matrix._ptr[j + 1] - d;
           // loop matrix._index
           for (k = k0; k < k1; k++) {
             // row
             i = matrix._index[k];
             // check we need to delete value and matrix._index
             if (i > rows - 1) {
               // remove value
               matrix._values.splice(k, 1);
               // remove item from matrix._index
               matrix._index.splice(k, 1);
               // increase deletes
               d++;
             }
           }
         }
         // update matrix._ptr for current column
         matrix._ptr[j] = matrix._values.length;
       }
       // update matrix._size
       matrix._size[0] = rows;
       matrix._size[1] = columns;
       // return matrix
       return matrix;
     }

     /**
      * Reshape the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (reshape in place).
      *
      * NOTE: This might be better suited to copy by default, instead of modifying
      *       in place. For now, it operates in place to remain consistent with
      *       resize().
      *
      * @memberof SparseMatrix
      * @param {number[]} sizes          The new size the matrix should have.
      *                                  Since sparse matrices are always two-dimensional,
      *                                  size must be two numbers in either an array or a matrix
      * @param {boolean} [copy]          Return a reshaped copy of the matrix
      *
      * @return {Matrix}                 The reshaped matrix
      */
     SparseMatrix.prototype.reshape = function (sizes, copy) {
       // validate arguments
       if (!isArray(sizes)) {
         throw new TypeError('Array expected');
       }
       if (sizes.length !== 2) {
         throw new Error('Sparse matrices can only be reshaped in two dimensions');
       }

       // check sizes
       sizes.forEach(function (value) {
         if (!isNumber(value) || !isInteger$1(value) || value <= -2 || value === 0) {
           throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format$1(sizes) + ')');
         }
       });
       var currentLength = this._size[0] * this._size[1];
       sizes = processSizesWildcard(sizes, currentLength);
       var newLength = sizes[0] * sizes[1];

       // m * n must not change
       if (currentLength !== newLength) {
         throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
       }

       // matrix to reshape
       var m = copy ? this.clone() : this;

       // return unchanged if the same shape
       if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
         return m;
       }

       // Convert to COO format (generate a column index)
       var colIndex = [];
       for (var i = 0; i < m._ptr.length; i++) {
         for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
           colIndex.push(i);
         }
       }

       // Clone the values array
       var values = m._values.slice();

       // Clone the row index array
       var rowIndex = m._index.slice();

       // Transform the (row, column) indices
       for (var _i = 0; _i < m._index.length; _i++) {
         var r1 = rowIndex[_i];
         var c1 = colIndex[_i];
         var flat = r1 * m._size[1] + c1;
         colIndex[_i] = flat % sizes[1];
         rowIndex[_i] = Math.floor(flat / sizes[1]);
       }

       // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
       // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
       // sorting several arrays based on some other array.

       // OR, we could easily just:

       // 1. Remove all values from the matrix
       m._values.length = 0;
       m._index.length = 0;
       m._ptr.length = sizes[1] + 1;
       m._size = sizes.slice();
       for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
         m._ptr[_i2] = 0;
       }

       // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
       // This step is probably the most time-consuming
       for (var h = 0; h < values.length; h++) {
         var _i3 = rowIndex[h];
         var _j = colIndex[h];
         var v = values[h];
         var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
         _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
       }

       // The value indices are inserted out of order, but apparently that's... still OK?

       return m;
     };

     /**
      * Create a clone of the matrix
      * @memberof SparseMatrix
      * @return {SparseMatrix} clone
      */
     SparseMatrix.prototype.clone = function () {
       var m = new SparseMatrix({
         values: this._values ? clone$3(this._values) : undefined,
         index: clone$3(this._index),
         ptr: clone$3(this._ptr),
         size: clone$3(this._size),
         datatype: this._datatype
       });
       return m;
     };

     /**
      * Retrieve the size of the matrix.
      * @memberof SparseMatrix
      * @returns {number[]} size
      */
     SparseMatrix.prototype.size = function () {
       return this._size.slice(0); // copy the Array
     };

     /**
      * Create a new matrix with the results of the callback function executed on
      * each entry of the matrix.
      * @memberof SparseMatrix
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
      *
      * @return {SparseMatrix} matrix
      */
     SparseMatrix.prototype.map = function (callback, skipZeros) {
       // check it is a pattern matrix
       if (!this._values) {
         throw new Error('Cannot invoke map on a Pattern only matrix');
       }
       // matrix instance
       var me = this;
       // rows and columns
       var rows = this._size[0];
       var columns = this._size[1];
       // invoke callback
       var args = maxArgumentCount(callback);
       var invoke = function invoke(v, i, j) {
         // invoke callback
         if (args === 1) return callback(v);
         if (args === 2) return callback(v, [i, j]);
         return callback(v, [i, j], me);
       };
       // invoke _map
       return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
     };

     /**
      * Create a new matrix with the results of the callback function executed on the interval
      * [minRow..maxRow, minColumn..maxColumn].
      */
     function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
       // result arrays
       var values = [];
       var index = [];
       var ptr = [];

       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       if (isString(matrix._datatype)) {
         // find signature that matches (datatype, datatype)
         eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
         // convert 0 to the same datatype
         zero = typed.convert(0, matrix._datatype);
       }

       // invoke callback
       var invoke = function invoke(v, x, y) {
         // invoke callback
         v = callback(v, x, y);
         // check value != 0
         if (!eq(v, zero)) {
           // store value
           values.push(v);
           // index
           index.push(x);
         }
       };
       // loop columns
       for (var j = minColumn; j <= maxColumn; j++) {
         // store pointer to values index
         ptr.push(values.length);
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = matrix._ptr[j];
         var k1 = matrix._ptr[j + 1];
         if (skipZeros) {
           // loop k within [k0, k1[
           for (var k = k0; k < k1; k++) {
             // row index
             var i = matrix._index[k];
             // check i is in range
             if (i >= minRow && i <= maxRow) {
               // value @ k
               invoke(matrix._values[k], i - minRow, j - minColumn);
             }
           }
         } else {
           // create a cache holding all defined values
           var _values = {};
           for (var _k = k0; _k < k1; _k++) {
             var _i4 = matrix._index[_k];
             _values[_i4] = matrix._values[_k];
           }

           // loop over all rows (indexes can be unordered so we can't use that),
           // and either read the value or zero
           for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
             var value = _i5 in _values ? _values[_i5] : 0;
             invoke(value, _i5 - minRow, j - minColumn);
           }
         }
       }

       // store number of values in ptr
       ptr.push(values.length);
       // return sparse matrix
       return new SparseMatrix({
         values,
         index,
         ptr,
         size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
       });
     }

     /**
      * Execute a callback function on each entry of the matrix.
      * @memberof SparseMatrix
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix being traversed.
      * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
      *                              If false, the indices are guaranteed to be in order,
      *                              if true, the indices can be unordered.
      */
     SparseMatrix.prototype.forEach = function (callback, skipZeros) {
       // check it is a pattern matrix
       if (!this._values) {
         throw new Error('Cannot invoke forEach on a Pattern only matrix');
       }
       // matrix instance
       var me = this;
       // rows and columns
       var rows = this._size[0];
       var columns = this._size[1];
       // loop columns
       for (var j = 0; j < columns; j++) {
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = this._ptr[j];
         var k1 = this._ptr[j + 1];
         if (skipZeros) {
           // loop k within [k0, k1[
           for (var k = k0; k < k1; k++) {
             // row index
             var i = this._index[k];

             // value @ k
             callback(this._values[k], [i, j], me);
           }
         } else {
           // create a cache holding all defined values
           var values = {};
           for (var _k2 = k0; _k2 < k1; _k2++) {
             var _i6 = this._index[_k2];
             values[_i6] = this._values[_k2];
           }

           // loop over all rows (indexes can be unordered so we can't use that),
           // and either read the value or zero
           for (var _i7 = 0; _i7 < rows; _i7++) {
             var value = _i7 in values ? values[_i7] : 0;
             callback(value, [_i7, j], me);
           }
         }
       }
     };

     /**
      * Iterate over the matrix elements, skipping zeros
      * @return {Iterable<{ value, index: number[] }>}
      */
     SparseMatrix.prototype[Symbol.iterator] = function* () {
       if (!this._values) {
         throw new Error('Cannot iterate a Pattern only matrix');
       }
       var columns = this._size[1];
       for (var j = 0; j < columns; j++) {
         var k0 = this._ptr[j];
         var k1 = this._ptr[j + 1];
         for (var k = k0; k < k1; k++) {
           // row index
           var i = this._index[k];
           yield {
             value: this._values[k],
             index: [i, j]
           };
         }
       }
     };

     /**
      * Create an Array with a copy of the data of the SparseMatrix
      * @memberof SparseMatrix
      * @returns {Array} array
      */
     SparseMatrix.prototype.toArray = function () {
       return _toArray(this._values, this._index, this._ptr, this._size, true);
     };

     /**
      * Get the primitive value of the SparseMatrix: a two dimensions array
      * @memberof SparseMatrix
      * @returns {Array} array
      */
     SparseMatrix.prototype.valueOf = function () {
       return _toArray(this._values, this._index, this._ptr, this._size, false);
     };
     function _toArray(values, index, ptr, size, copy) {
       // rows and columns
       var rows = size[0];
       var columns = size[1];
       // result
       var a = [];
       // vars
       var i, j;
       // initialize array
       for (i = 0; i < rows; i++) {
         a[i] = [];
         for (j = 0; j < columns; j++) {
           a[i][j] = 0;
         }
       }

       // loop columns
       for (j = 0; j < columns; j++) {
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = ptr[j];
         var k1 = ptr[j + 1];
         // loop k within [k0, k1[
         for (var k = k0; k < k1; k++) {
           // row index
           i = index[k];
           // set value (use one for pattern matrix)
           a[i][j] = values ? copy ? clone$3(values[k]) : values[k] : 1;
         }
       }
       return a;
     }

     /**
      * Get a string representation of the matrix, with optional formatting options.
      * @memberof SparseMatrix
      * @param {Object | number | Function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @returns {string} str
      */
     SparseMatrix.prototype.format = function (options) {
       // rows and columns
       var rows = this._size[0];
       var columns = this._size[1];
       // density
       var density = this.density();
       // rows & columns
       var str = 'Sparse Matrix [' + format$1(rows, options) + ' x ' + format$1(columns, options) + '] density: ' + format$1(density, options) + '\n';
       // loop columns
       for (var j = 0; j < columns; j++) {
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = this._ptr[j];
         var k1 = this._ptr[j + 1];
         // loop k within [k0, k1[
         for (var k = k0; k < k1; k++) {
           // row index
           var i = this._index[k];
           // append value
           str += '\n    (' + format$1(i, options) + ', ' + format$1(j, options) + ') ==> ' + (this._values ? format$1(this._values[k], options) : 'X');
         }
       }
       return str;
     };

     /**
      * Get a string representation of the matrix
      * @memberof SparseMatrix
      * @returns {string} str
      */
     SparseMatrix.prototype.toString = function () {
       return format$1(this.toArray());
     };

     /**
      * Get a JSON representation of the matrix
      * @memberof SparseMatrix
      * @returns {Object}
      */
     SparseMatrix.prototype.toJSON = function () {
       return {
         mathjs: 'SparseMatrix',
         values: this._values,
         index: this._index,
         ptr: this._ptr,
         size: this._size,
         datatype: this._datatype
       };
     };

     /**
      * Get the kth Matrix diagonal.
      *
      * @memberof SparseMatrix
      * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
      *
      * @returns {Matrix}                     The matrix vector with the diagonal values.
      */
     SparseMatrix.prototype.diagonal = function (k) {
       // validate k if any
       if (k) {
         // convert BigNumber to a number
         if (isBigNumber(k)) {
           k = k.toNumber();
         }
         // is must be an integer
         if (!isNumber(k) || !isInteger$1(k)) {
           throw new TypeError('The parameter k must be an integer number');
         }
       } else {
         // default value
         k = 0;
       }
       var kSuper = k > 0 ? k : 0;
       var kSub = k < 0 ? -k : 0;

       // rows & columns
       var rows = this._size[0];
       var columns = this._size[1];

       // number diagonal values
       var n = Math.min(rows - kSub, columns - kSuper);

       // diagonal arrays
       var values = [];
       var index = [];
       var ptr = [];
       // initial ptr value
       ptr[0] = 0;
       // loop columns
       for (var j = kSuper; j < columns && values.length < n; j++) {
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = this._ptr[j];
         var k1 = this._ptr[j + 1];
         // loop x within [k0, k1[
         for (var x = k0; x < k1; x++) {
           // row index
           var i = this._index[x];
           // check row
           if (i === j - kSuper + kSub) {
             // value on this column
             values.push(this._values[x]);
             // store row
             index[values.length - 1] = i - kSub;
             // exit loop
             break;
           }
         }
       }
       // close ptr
       ptr.push(values.length);
       // return matrix
       return new SparseMatrix({
         values,
         index,
         ptr,
         size: [n, 1]
       });
     };

     /**
      * Generate a matrix from a JSON object
      * @memberof SparseMatrix
      * @param {Object} json  An object structured like
      *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
      *                       where mathjs is optional
      * @returns {SparseMatrix}
      */
     SparseMatrix.fromJSON = function (json) {
       return new SparseMatrix(json);
     };

     /**
      * Create a diagonal matrix.
      *
      * @memberof SparseMatrix
      * @param {Array} size                       The matrix size.
      * @param {number | Array | Matrix } value   The values for the diagonal.
      * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
      * @param {number} [defaultValue]            The default value for non-diagonal
      * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
      *
      * @returns {SparseMatrix}
      */
     SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
       if (!isArray(size)) {
         throw new TypeError('Array expected, size parameter');
       }
       if (size.length !== 2) {
         throw new Error('Only two dimensions matrix are supported');
       }

       // map size & validate
       size = size.map(function (s) {
         // check it is a big number
         if (isBigNumber(s)) {
           // convert it
           s = s.toNumber();
         }
         // validate arguments
         if (!isNumber(s) || !isInteger$1(s) || s < 1) {
           throw new Error('Size values must be positive integers');
         }
         return s;
       });

       // validate k if any
       if (k) {
         // convert BigNumber to a number
         if (isBigNumber(k)) {
           k = k.toNumber();
         }
         // is must be an integer
         if (!isNumber(k) || !isInteger$1(k)) {
           throw new TypeError('The parameter k must be an integer number');
         }
       } else {
         // default value
         k = 0;
       }

       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       if (isString(datatype)) {
         // find signature that matches (datatype, datatype)
         eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
         // convert 0 to the same datatype
         zero = typed.convert(0, datatype);
       }
       var kSuper = k > 0 ? k : 0;
       var kSub = k < 0 ? -k : 0;

       // rows and columns
       var rows = size[0];
       var columns = size[1];

       // number of non-zero items
       var n = Math.min(rows - kSub, columns - kSuper);

       // value extraction function
       var _value;

       // check value
       if (isArray(value)) {
         // validate array
         if (value.length !== n) {
           // number of values in array must be n
           throw new Error('Invalid value array length');
         }
         // define function
         _value = function _value(i) {
           // return value @ i
           return value[i];
         };
       } else if (isMatrix(value)) {
         // matrix size
         var ms = value.size();
         // validate matrix
         if (ms.length !== 1 || ms[0] !== n) {
           // number of values in array must be n
           throw new Error('Invalid matrix length');
         }
         // define function
         _value = function _value(i) {
           // return value @ i
           return value.get([i]);
         };
       } else {
         // define function
         _value = function _value() {
           // return value
           return value;
         };
       }

       // create arrays
       var values = [];
       var index = [];
       var ptr = [];

       // loop items
       for (var j = 0; j < columns; j++) {
         // number of rows with value
         ptr.push(values.length);
         // diagonal index
         var i = j - kSuper;
         // check we need to set diagonal value
         if (i >= 0 && i < n) {
           // get value @ i
           var v = _value(i);
           // check for zero
           if (!eq(v, zero)) {
             // column
             index.push(i + kSub);
             // add value
             values.push(v);
           }
         }
       }
       // last value should be number of values
       ptr.push(values.length);
       // create SparseMatrix
       return new SparseMatrix({
         values,
         index,
         ptr,
         size: [rows, columns]
       });
     };

     /**
      * Swap rows i and j in Matrix.
      *
      * @memberof SparseMatrix
      * @param {number} i       Matrix row index 1
      * @param {number} j       Matrix row index 2
      *
      * @return {Matrix}        The matrix reference
      */
     SparseMatrix.prototype.swapRows = function (i, j) {
       // check index
       if (!isNumber(i) || !isInteger$1(i) || !isNumber(j) || !isInteger$1(j)) {
         throw new Error('Row index must be positive integers');
       }
       // check dimensions
       if (this._size.length !== 2) {
         throw new Error('Only two dimensional matrix is supported');
       }
       // validate index
       validateIndex(i, this._size[0]);
       validateIndex(j, this._size[0]);

       // swap rows
       SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
       // return current instance
       return this;
     };

     /**
      * Loop rows with data in column j.
      *
      * @param {number} j            Column
      * @param {Array} values        Matrix values
      * @param {Array} index         Matrix row indeces
      * @param {Array} ptr           Matrix column pointers
      * @param {Function} callback   Callback function invoked for every row in column j
      */
     SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
       // indeces for column j
       var k0 = ptr[j];
       var k1 = ptr[j + 1];
       // loop
       for (var k = k0; k < k1; k++) {
         // invoke callback
         callback(index[k], values[k]);
       }
     };

     /**
      * Swap rows x and y in Sparse Matrix data structures.
      *
      * @param {number} x         Matrix row index 1
      * @param {number} y         Matrix row index 2
      * @param {number} columns   Number of columns in matrix
      * @param {Array} values     Matrix values
      * @param {Array} index      Matrix row indeces
      * @param {Array} ptr        Matrix column pointers
      */
     SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
       // loop columns
       for (var j = 0; j < columns; j++) {
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = ptr[j];
         var k1 = ptr[j + 1];
         // find value index @ x
         var kx = _getValueIndex(x, k0, k1, index);
         // find value index @ x
         var ky = _getValueIndex(y, k0, k1, index);
         // check both rows exist in matrix
         if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
           // swap values (check for pattern matrix)
           if (values) {
             var v = values[kx];
             values[kx] = values[ky];
             values[ky] = v;
           }
           // next column
           continue;
         }
         // check x row exist & no y row
         if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
           // value @ x (check for pattern matrix)
           var vx = values ? values[kx] : undefined;
           // insert value @ y
           index.splice(ky, 0, y);
           if (values) {
             values.splice(ky, 0, vx);
           }
           // remove value @ x (adjust array index if needed)
           index.splice(ky <= kx ? kx + 1 : kx, 1);
           if (values) {
             values.splice(ky <= kx ? kx + 1 : kx, 1);
           }
           // next column
           continue;
         }
         // check y row exist & no x row
         if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
           // value @ y (check for pattern matrix)
           var vy = values ? values[ky] : undefined;
           // insert value @ x
           index.splice(kx, 0, x);
           if (values) {
             values.splice(kx, 0, vy);
           }
           // remove value @ y (adjust array index if needed)
           index.splice(kx <= ky ? ky + 1 : ky, 1);
           if (values) {
             values.splice(kx <= ky ? ky + 1 : ky, 1);
           }
         }
       }
     };
     return SparseMatrix;
   }, {
     isClass: true
   });

   var name$4w = 'number';
   var dependencies$4v = ['typed'];

   /**
    * Separates the radix, integer part, and fractional part of a non decimal number string
    * @param {string} input string to parse
    * @returns {object} the parts of the string or null if not a valid input
    */
   function getNonDecimalNumberParts(input) {
     var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
     if (nonDecimalWithRadixMatch) {
       var radix = {
         '0b': 2,
         '0o': 8,
         '0x': 16
       }[nonDecimalWithRadixMatch[1]];
       var integerPart = nonDecimalWithRadixMatch[2];
       var fractionalPart = nonDecimalWithRadixMatch[3];
       return {
         input,
         radix,
         integerPart,
         fractionalPart
       };
     } else {
       return null;
     }
   }

   /**
    * Makes a number from a radix, and integer part, and a fractional part
    * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
    * @returns {number} the number
    */
   function makeNumberFromNonDecimalParts(parts) {
     var n = parseInt(parts.integerPart, parts.radix);
     var f = 0;
     for (var i = 0; i < parts.fractionalPart.length; i++) {
       var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
       f += digitValue / Math.pow(parts.radix, i + 1);
     }
     var result = n + f;
     if (isNaN(result)) {
       throw new SyntaxError('String "' + parts.input + '" is no valid number');
     }
     return result;
   }
   var createNumber = /* #__PURE__ */factory(name$4w, dependencies$4v, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Create a number or convert a string, boolean, or unit to a number.
      * When value is a matrix, all elements will be converted to number.
      *
      * Syntax:
      *
      *    math.number(value)
      *    math.number(unit, valuelessUnit)
      *
      * Examples:
      *
      *    math.number(2)                         // returns number 2
      *    math.number('7.2')                     // returns number 7.2
      *    math.number(true)                      // returns number 1
      *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
      *    math.number(math.unit('52cm'), 'm')    // returns 0.52
      *
      * See also:
      *
      *    bignumber, boolean, complex, index, matrix, string, unit
      *
      * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
      * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
      * @return {number | Array | Matrix} The created number
      */
     var number = typed('number', {
       '': function _() {
         return 0;
       },
       number: function number(x) {
         return x;
       },
       string: function string(x) {
         if (x === 'NaN') return NaN;
         var nonDecimalNumberParts = getNonDecimalNumberParts(x);
         if (nonDecimalNumberParts) {
           return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
         }
         var size = 0;
         var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
         if (wordSizeSuffixMatch) {
           // x includes a size suffix like 0xffffi32, so we extract
           // the suffix and remove it from x
           size = Number(wordSizeSuffixMatch[2]);
           x = wordSizeSuffixMatch[1];
         }
         var num = Number(x);
         if (isNaN(num)) {
           throw new SyntaxError('String "' + x + '" is no valid number');
         }
         if (wordSizeSuffixMatch) {
           // x is a signed bin, oct, or hex literal
           // num is the value of string x if x is interpreted as unsigned
           if (num > 2 ** size - 1) {
             // literal is too large for size suffix
             throw new SyntaxError("String \"".concat(x, "\" is out of range"));
           }
           // check if the bit at index size - 1 is set and if so do the twos complement
           if (num >= 2 ** (size - 1)) {
             num = num - 2 ** size;
           }
         }
         return num;
       },
       BigNumber: function BigNumber(x) {
         return x.toNumber();
       },
       Fraction: function Fraction(x) {
         return x.valueOf();
       },
       Unit: typed.referToSelf(self => x => {
         var clone = x.clone();
         clone.value = self(x.value);
         return clone;
       }),
       null: function _null(x) {
         return 0;
       },
       'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {
         return unit.toNumber(valuelessUnit);
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });

     // reviver function to parse a JSON object like:
     //
     //     {"mathjs":"number","value":"2.3"}
     //
     // into a number 2.3
     number.fromJSON = function (json) {
       return parseFloat(json.value);
     };
     return number;
   });

   var name$4v = 'string';
   var dependencies$4u = ['typed'];
   var createString = /* #__PURE__ */factory(name$4v, dependencies$4u, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Create a string or convert any object into a string.
      * Elements of Arrays and Matrices are processed element wise.
      *
      * Syntax:
      *
      *    math.string(value)
      *
      * Examples:
      *
      *    math.string(4.2)               // returns string '4.2'
      *    math.string(math.complex(3, 2) // returns string '3 + 2i'
      *
      *    const u = math.unit(5, 'km')
      *    math.string(u.to('m'))         // returns string '5000 m'
      *
      *    math.string([true, false])     // returns ['true', 'false']
      *
      * See also:
      *
      *    bignumber, boolean, complex, index, matrix, number, unit
      *
      * @param {* | Array | Matrix | null} [value]  A value to convert to a string
      * @return {string | Array | Matrix} The created string
      */
     return typed(name$4v, {
       '': function _() {
         return '';
       },
       number: format$3,
       null: function _null(x) {
         return 'null';
       },
       boolean: function boolean(x) {
         return x + '';
       },
       string: function string(x) {
         return x;
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),
       any: function any(x) {
         return String(x);
       }
     });
   });

   var name$4u = 'boolean';
   var dependencies$4t = ['typed'];
   var createBoolean = /* #__PURE__ */factory(name$4u, dependencies$4t, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Create a boolean or convert a string or number to a boolean.
      * In case of a number, `true` is returned for non-zero numbers, and `false` in
      * case of zero.
      * Strings can be `'true'` or `'false'`, or can contain a number.
      * When value is a matrix, all elements will be converted to boolean.
      *
      * Syntax:
      *
      *    math.boolean(x)
      *
      * Examples:
      *
      *    math.boolean(0)     // returns false
      *    math.boolean(1)     // returns true
      *    math.boolean(-3)     // returns true
      *    math.boolean('true')     // returns true
      *    math.boolean('false')     // returns false
      *    math.boolean([1, 0, 1, 1])     // returns [true, false, true, true]
      *
      * See also:
      *
      *    bignumber, complex, index, matrix, string, unit
      *
      * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
      * @return {boolean | Array | Matrix} The boolean value
      */
     return typed(name$4u, {
       '': function _() {
         return false;
       },
       boolean: function boolean(x) {
         return x;
       },
       number: function number(x) {
         return !!x;
       },
       null: function _null(x) {
         return false;
       },
       BigNumber: function BigNumber(x) {
         return !x.isZero();
       },
       string: function string(x) {
         // try case insensitive
         var lcase = x.toLowerCase();
         if (lcase === 'true') {
           return true;
         } else if (lcase === 'false') {
           return false;
         }

         // test whether value is a valid number
         var num = Number(x);
         if (x !== '' && !isNaN(num)) {
           return !!num;
         }
         throw new Error('Cannot convert "' + x + '" to a boolean');
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4t = 'bignumber';
   var dependencies$4s = ['typed', 'BigNumber'];
   var createBignumber = /* #__PURE__ */factory(name$4t, dependencies$4s, _ref => {
     var {
       typed,
       BigNumber
     } = _ref;
     /**
      * Create a BigNumber, which can store numbers with arbitrary precision.
      * When a matrix is provided, all elements will be converted to BigNumber.
      *
      * Syntax:
      *
      *    math.bignumber(x)
      *
      * Examples:
      *
      *    0.1 + 0.2                                  // returns number 0.30000000000000004
      *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
      *
      *
      *    7.2e500                                    // returns number Infinity
      *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
      *
      * See also:
      *
      *    boolean, complex, index, matrix, string, unit
      *
      * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
      *                                                    0 by default.
      * @returns {BigNumber} The created bignumber
      */
     return typed('bignumber', {
       '': function _() {
         return new BigNumber(0);
       },
       number: function number(x) {
         // convert to string to prevent errors in case of >15 digits
         return new BigNumber(x + '');
       },
       string: function string(x) {
         var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
         if (wordSizeSuffixMatch) {
           // x has a word size suffix
           var size = wordSizeSuffixMatch[2];
           var n = BigNumber(wordSizeSuffixMatch[1]);
           var twoPowSize = new BigNumber(2).pow(Number(size));
           if (n.gt(twoPowSize.sub(1))) {
             throw new SyntaxError("String \"".concat(x, "\" is out of range"));
           }
           var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
           if (n.gte(twoPowSizeSubOne)) {
             return n.sub(twoPowSize);
           } else {
             return n;
           }
         }
         return new BigNumber(x);
       },
       BigNumber: function BigNumber(x) {
         // we assume a BigNumber is immutable
         return x;
       },
       Unit: typed.referToSelf(self => x => {
         var clone = x.clone();
         clone.value = self(x.value);
         return clone;
       }),
       Fraction: function Fraction(x) {
         return new BigNumber(x.n).div(x.d).times(x.s);
       },
       null: function _null(x) {
         return new BigNumber(0);
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4s = 'complex';
   var dependencies$4r = ['typed', 'Complex'];
   var createComplex = /* #__PURE__ */factory(name$4s, dependencies$4r, _ref => {
     var {
       typed,
       Complex
     } = _ref;
     /**
      * Create a complex value or convert a value to a complex value.
      *
      * Syntax:
      *
      *     math.complex()                           // creates a complex value with zero
      *                                              // as real and imaginary part.
      *     math.complex(re : number, im : string)   // creates a complex value with provided
      *                                              // values for real and imaginary part.
      *     math.complex(re : number)                // creates a complex value with provided
      *                                              // real value and zero imaginary part.
      *     math.complex(complex : Complex)          // clones the provided complex value.
      *     math.complex(arg : string)               // parses a string into a complex value.
      *     math.complex(array : Array)              // converts the elements of the array
      *                                              // or matrix element wise into a
      *                                              // complex value.
      *     math.complex({re: number, im: number})   // creates a complex value with provided
      *                                              // values for real an imaginary part.
      *     math.complex({r: number, phi: number})   // creates a complex value with provided
      *                                              // polar coordinates
      *
      * Examples:
      *
      *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
      *    a.re = 5                          // a = Complex 5 - 4i
      *    const i = a.im                    // Number -4
      *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
      *    const c = math.complex()          // Complex 0 + 0i
      *    const d = math.add(a, b)          // Complex 5 + 2i
      *
      * See also:
      *
      *    bignumber, boolean, index, matrix, number, string, unit
      *
      * @param {* | Array | Matrix} [args]
      *            Arguments specifying the real and imaginary part of the complex number
      * @return {Complex | Array | Matrix} Returns a complex value
      */
     return typed('complex', {
       '': function _() {
         return Complex.ZERO;
       },
       number: function number(x) {
         return new Complex(x, 0);
       },
       'number, number': function numberNumber(re, im) {
         return new Complex(re, im);
       },
       // TODO: this signature should be redundant
       'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {
         return new Complex(re.toNumber(), im.toNumber());
       },
       Fraction: function Fraction(x) {
         return new Complex(x.valueOf(), 0);
       },
       Complex: function Complex(x) {
         return x.clone();
       },
       string: function string(x) {
         return Complex(x); // for example '2 + 3i'
       },

       null: function _null(x) {
         return Complex(0);
       },
       Object: function Object(x) {
         if ('re' in x && 'im' in x) {
           return new Complex(x.re, x.im);
         }
         if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
           return new Complex(x);
         }
         throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4r = 'fraction';
   var dependencies$4q = ['typed', 'Fraction'];
   var createFraction = /* #__PURE__ */factory(name$4r, dependencies$4q, _ref => {
     var {
       typed,
       Fraction
     } = _ref;
     /**
      * Create a fraction or convert a value to a fraction.
      *
      * With one numeric argument, produces the closest rational approximation to the
      * input.
      * With two arguments, the first is the numerator and the second is the denominator,
      * and creates the corresponding fraction. Both numerator and denominator must be
      * integers.
      * With one object argument, looks for the integer numerator as the value of property
      * 'n' and the integer denominator as the value of property 'd'.
      * With a matrix argument, creates a matrix of the same shape with entries
      * converted into fractions.
      *
      * Syntax:
      *     math.fraction(value)
      *     math.fraction(numerator, denominator)
      *     math.fraction({n: numerator, d: denominator})
      *     math.fraction(matrix: Array | Matrix)
      *
      * Examples:
      *
      *     math.fraction(6.283)             // returns Fraction 6283/1000
      *     math.fraction(1, 3)              // returns Fraction 1/3
      *     math.fraction('2/3')             // returns Fraction 2/3
      *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
      *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
      *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
      *
      * See also:
      *
      *    bignumber, number, string, unit
      *
      * @param {number | string | Fraction | BigNumber | Unit | Array | Matrix} [args]
      *            Arguments specifying the value, or numerator and denominator of
      *            the fraction
      * @return {Fraction | Array | Matrix} Returns a fraction
      */
     return typed('fraction', {
       number: function number(x) {
         if (!isFinite(x) || isNaN(x)) {
           throw new Error(x + ' cannot be represented as a fraction');
         }
         return new Fraction(x);
       },
       string: function string(x) {
         return new Fraction(x);
       },
       'number, number': function numberNumber(numerator, denominator) {
         return new Fraction(numerator, denominator);
       },
       null: function _null(x) {
         return new Fraction(0);
       },
       BigNumber: function BigNumber(x) {
         return new Fraction(x.toString());
       },
       Fraction: function Fraction(x) {
         return x; // fractions are immutable
       },

       Unit: typed.referToSelf(self => x => {
         var clone = x.clone();
         clone.value = self(x.value);
         return clone;
       }),
       Object: function Object(x) {
         return new Fraction(x);
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4q = 'matrix';
   var dependencies$4p = ['typed', 'Matrix', 'DenseMatrix', 'SparseMatrix'];
   var createMatrix = /* #__PURE__ */factory(name$4q, dependencies$4p, _ref => {
     var {
       typed,
       Matrix,
       DenseMatrix,
       SparseMatrix
     } = _ref;
     /**
      * Create a Matrix. The function creates a new `math.Matrix` object from
      * an `Array`. A Matrix has utility functions to manipulate the data in the
      * matrix, like getting the size and getting or setting values in the matrix.
      * Supported storage formats are 'dense' and 'sparse'.
      *
      * Syntax:
      *
      *    math.matrix()                         // creates an empty matrix using default storage format (dense).
      *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
      *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
      *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
      *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
      *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
      *
      * Examples:
      *
      *    let m = math.matrix([[1, 2], [3, 4]])
      *    m.size()                        // Array [2, 2]
      *    m.resize([3, 2], 5)
      *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
      *    m.get([1, 0])                    // number 3
      *
      * See also:
      *
      *    bignumber, boolean, complex, index, number, string, unit, sparse
      *
      * @param {Array | Matrix} [data]    A multi dimensional array
      * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
      * @param {string} [datatype]        Type of the values
      *
      * @return {Matrix} The created matrix
      */
     return typed(name$4q, {
       '': function _() {
         return _create([]);
       },
       string: function string(format) {
         return _create([], format);
       },
       'string, string': function stringString(format, datatype) {
         return _create([], format, datatype);
       },
       Array: function Array(data) {
         return _create(data);
       },
       Matrix: function Matrix(data) {
         return _create(data, data.storage());
       },
       'Array | Matrix, string': _create,
       'Array | Matrix, string, string': _create
     });

     /**
      * Create a new Matrix with given storage format
      * @param {Array} data
      * @param {string} [format]
      * @param {string} [datatype]
      * @returns {Matrix} Returns a new Matrix
      * @private
      */
     function _create(data, format, datatype) {
       // get storage format constructor
       if (format === 'dense' || format === 'default' || format === undefined) {
         return new DenseMatrix(data, datatype);
       }
       if (format === 'sparse') {
         return new SparseMatrix(data, datatype);
       }
       throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
     }
   });

   var name$4p = 'matrixFromFunction';
   var dependencies$4o = ['typed', 'matrix', 'isZero'];
   var createMatrixFromFunction = /* #__PURE__ */factory(name$4p, dependencies$4o, _ref => {
     var {
       typed,
       matrix,
       isZero
     } = _ref;
     /**
      * Create a matrix by evaluating a generating function at each index.
      * The simplest overload returns a multi-dimensional array as long as `size` is an array.
      * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.
      *
      * Syntax:
      *
      *    math.matrixFromFunction(size, fn)
      *    math.matrixFromFunction(size, fn, format)
      *    math.matrixFromFunction(size, fn, format, datatype)
      *    math.matrixFromFunction(size, format, fn)
      *    math.matrixFromFunction(size, format, datatype, fn)
      *
      * Examples:
      *
      *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix
      *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix
      *    math.matrixFromFunction([5], i => math.random()) // a random vector
      *
      * See also:
      *
      *    matrix, zeros
      *
      * @param {Array | Matrix} size   The size of the matrix to be created
      * @param {function} fn           Callback function invoked for every entry in the matrix
      * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`
      * @param {string} [datatype]     Type of the values
      * @return {Array | Matrix} Returns the created matrix
      */
     return typed(name$4p, {
       'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {
         return _create(size, fn, format, datatype);
       },
       'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {
         return _create(size, fn, format);
       },
       'Matrix, function': function MatrixFunction(size, fn) {
         return _create(size, fn, 'dense');
       },
       'Array, function': function ArrayFunction(size, fn) {
         return _create(size, fn, 'dense').toArray();
       },
       'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {
         return _create(size, fn, format);
       },
       'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {
         return _create(size, fn, format, datatype);
       }
     });
     function _create(size, fn, format, datatype) {
       var m;
       if (datatype !== undefined) {
         m = matrix(format, datatype);
       } else {
         m = matrix(format);
       }
       m.resize(size);
       m.forEach(function (_, index) {
         var val = fn(index);
         if (isZero(val)) return;
         m.set(index, val);
       });
       return m;
     }
   });

   var name$4o = 'matrixFromRows';
   var dependencies$4n = ['typed', 'matrix', 'flatten', 'size'];
   var createMatrixFromRows = /* #__PURE__ */factory(name$4o, dependencies$4n, _ref => {
     var {
       typed,
       matrix,
       flatten,
       size
     } = _ref;
     /**
      * Create a dense matrix from vectors as individual rows.
      * If you pass column vectors, they will be transposed (but not conjugated!)
      *
      * Syntax:
      *
      *    math.matrixFromRows(...arr)
      *    math.matrixFromRows(row1, row2)
      *    math.matrixFromRows(row1, row2, row3)
      *
      * Examples:
      *
      *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])
      *    math.matrixFromRows(...vectors)
      *
      * See also:
      *
      *    matrix, matrixFromColumns, matrixFromFunction, zeros
      *
      * @param {... Array | Matrix} rows  Multiple rows
      * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
      */
     return typed(name$4o, {
       '...Array': function Array(arr) {
         return _createArray(arr);
       },
       '...Matrix': function Matrix(arr) {
         return matrix(_createArray(arr.map(m => m.toArray())));
       }

       // TODO implement this properly for SparseMatrix
     });

     function _createArray(arr) {
       if (arr.length === 0) throw new TypeError('At least one row is needed to construct a matrix.');
       var N = checkVectorTypeAndReturnLength(arr[0]);
       var result = [];
       for (var row of arr) {
         var rowLength = checkVectorTypeAndReturnLength(row);
         if (rowLength !== N) {
           throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (rowLength | 0));
         }
         result.push(flatten(row));
       }
       return result;
     }
     function checkVectorTypeAndReturnLength(vec) {
       var s = size(vec);
       if (s.length === 1) {
         // 1D vector
         return s[0];
       } else if (s.length === 2) {
         // 2D vector
         if (s[0] === 1) {
           // row vector
           return s[1];
         } else if (s[1] === 1) {
           // col vector
           return s[0];
         } else {
           throw new TypeError('At least one of the arguments is not a vector.');
         }
       } else {
         throw new TypeError('Only one- or two-dimensional vectors are supported.');
       }
     }
   });

   var name$4n = 'matrixFromColumns';
   var dependencies$4m = ['typed', 'matrix', 'flatten', 'size'];
   var createMatrixFromColumns = /* #__PURE__ */factory(name$4n, dependencies$4m, _ref => {
     var {
       typed,
       matrix,
       flatten,
       size
     } = _ref;
     /**
      * Create a dense matrix from vectors as individual columns.
      * If you pass row vectors, they will be transposed (but not conjugated!)
      *
      * Syntax:
      *
      *    math.matrixFromColumns(...arr)
      *    math.matrixFromColumns(col1, col2)
      *    math.matrixFromColumns(col1, col2, col3)
      *
      * Examples:
      *
      *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
      *    math.matrixFromColumns(...vectors)
      *
      * See also:
      *
      *    matrix, matrixFromRows, matrixFromFunction, zeros
      *
      * @param {... Array | Matrix} cols Multiple columns
      * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
      */
     return typed(name$4n, {
       '...Array': function Array(arr) {
         return _createArray(arr);
       },
       '...Matrix': function Matrix(arr) {
         return matrix(_createArray(arr.map(m => m.toArray())));
       }

       // TODO implement this properly for SparseMatrix
     });

     function _createArray(arr) {
       if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');
       var N = checkVectorTypeAndReturnLength(arr[0]);

       // create an array with empty rows
       var result = [];
       for (var i = 0; i < N; i++) {
         result[i] = [];
       }

       // loop columns
       for (var col of arr) {
         var colLength = checkVectorTypeAndReturnLength(col);
         if (colLength !== N) {
           throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));
         }
         var f = flatten(col);

         // push a value to each row
         for (var _i = 0; _i < N; _i++) {
           result[_i].push(f[_i]);
         }
       }
       return result;
     }
     function checkVectorTypeAndReturnLength(vec) {
       var s = size(vec);
       if (s.length === 1) {
         // 1D vector
         return s[0];
       } else if (s.length === 2) {
         // 2D vector
         if (s[0] === 1) {
           // row vector
           return s[1];
         } else if (s[1] === 1) {
           // col vector
           return s[0];
         } else {
           throw new TypeError('At least one of the arguments is not a vector.');
         }
       } else {
         throw new TypeError('Only one- or two-dimensional vectors are supported.');
       }
     }
   });

   var name$4m = 'splitUnit';
   var dependencies$4l = ['typed'];
   var createSplitUnit = /* #__PURE__ */factory(name$4m, dependencies$4l, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Split a unit in an array of units whose sum is equal to the original unit.
      *
      * Syntax:
      *
      *     math.splitUnit(unit: Unit, parts: Array.<Unit>)
      *
      * Example:
      *
      *     math.splitUnit(new Unit(1, 'm'), ['feet', 'inch'])
      *     // [ 3 feet, 3.3700787401575 inch ]
      *
      * See also:
      *
      *     unit
      *
      * @param {Array} [parts] An array of strings or valueless units.
      * @return {Array} An array of units.
      */
     return typed(name$4m, {
       'Unit, Array': function UnitArray(unit, parts) {
         return unit.splitUnit(parts);
       }
     });
   });

   var name$4l = 'unaryMinus';
   var dependencies$4k = ['typed'];
   var createUnaryMinus = /* #__PURE__ */factory(name$4l, dependencies$4k, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Inverse the sign of a value, apply a unary minus operation.
      *
      * For matrices, the function is evaluated element wise. Boolean values and
      * strings will be converted to a number. For complex numbers, both real and
      * complex value are inverted.
      *
      * Syntax:
      *
      *    math.unaryMinus(x)
      *
      * Examples:
      *
      *    math.unaryMinus(3.5)      // returns -3.5
      *    math.unaryMinus(-4.2)     // returns 4.2
      *
      * See also:
      *
      *    add, subtract, unaryPlus
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
      */
     return typed(name$4l, {
       number: unaryMinusNumber,
       'Complex | BigNumber | Fraction': x => x.neg(),
       Unit: typed.referToSelf(self => x => {
         var res = x.clone();
         res.value = typed.find(self, res.valueType())(x.value);
         return res;
       }),
       // deep map collection, skip zeros since unaryMinus(0) = 0
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))

       // TODO: add support for string
     });
   });

   var name$4k = 'unaryPlus';
   var dependencies$4j = ['typed', 'config', 'BigNumber'];
   var createUnaryPlus = /* #__PURE__ */factory(name$4k, dependencies$4j, _ref => {
     var {
       typed,
       config,
       BigNumber
     } = _ref;
     /**
      * Unary plus operation.
      * Boolean values and strings will be converted to a number, numeric values will be returned as is.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.unaryPlus(x)
      *
      * Examples:
      *
      *    math.unaryPlus(3.5)      // returns 3.5
      *    math.unaryPlus(1)     // returns 1
      *
      * See also:
      *
      *    unaryMinus, add, subtract
      *
      * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
      *            Input value
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
      *            Returns the input value when numeric, converts to a number when input is non-numeric.
      */
     return typed(name$4k, {
       number: unaryPlusNumber,
       Complex: function Complex(x) {
         return x; // complex numbers are immutable
       },

       BigNumber: function BigNumber(x) {
         return x; // bignumbers are immutable
       },

       Fraction: function Fraction(x) {
         return x; // fractions are immutable
       },

       Unit: function Unit(x) {
         return x.clone();
       },
       // deep map collection, skip zeros since unaryPlus(0) = 0
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),
       'boolean | string': function booleanString(x) {
         // convert to a number or bignumber
         return config.number === 'BigNumber' ? new BigNumber(+x) : +x;
       }
     });
   });

   var name$4j = 'abs';
   var dependencies$4i = ['typed'];
   var createAbs = /* #__PURE__ */factory(name$4j, dependencies$4i, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the absolute value of a number. For matrices, the function is
      * evaluated element wise.
      *
      * Syntax:
      *
      *    math.abs(x)
      *
      * Examples:
      *
      *    math.abs(3.5)                // returns number 3.5
      *    math.abs(-4.2)               // returns number 4.2
      *
      *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
      *
      * See also:
      *
      *    sign
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
      *            A number or matrix for which to get the absolute value
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
      *            Absolute value of `x`
      */
     return typed(name$4j, {
       number: absNumber,
       'Complex | BigNumber | Fraction | Unit': x => x.abs(),
       // deep map collection, skip zeros since abs(0) = 0
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$4i = 'apply';
   var dependencies$4h = ['typed', 'isInteger'];
   var createApply = /* #__PURE__ */factory(name$4i, dependencies$4h, _ref => {
     var {
       typed,
       isInteger
     } = _ref;
     /**
      * Apply a function that maps an array to a scalar
      * along a given axis of a matrix or array.
      * Returns a new matrix or array with one less dimension than the input.
      *
      * Syntax:
      *
      *     math.apply(A, dim, callback)
      *
      * Where:
      *
      * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
      *
      * Examples:
      *
      *    const A = [[1, 2], [3, 4]]
      *    const sum = math.sum
      *
      *    math.apply(A, 0, sum)             // returns [4, 6]
      *    math.apply(A, 1, sum)             // returns [3, 7]
      *
      * See also:
      *
      *    map, filter, forEach
      *
      * @param {Array | Matrix} array   The input Matrix
      * @param {number} dim             The dimension along which the callback is applied
      * @param {Function} callback      The callback function that is applied. This Function
      *                                 should take an array or 1-d matrix as an input and
      *                                 return a number.
      * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.
      */
     return typed(name$4i, {
       'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
         if (!isInteger(dim)) {
           throw new TypeError('Integer number expected for dimension');
         }
         var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
         if (dim < 0 || dim >= size.length) {
           throw new IndexError(dim, size.length);
         }
         if (isMatrix(mat)) {
           return mat.create(_apply(mat.valueOf(), dim, callback));
         } else {
           return _apply(mat, dim, callback);
         }
       }
     });
   });

   /**
    * Recursively reduce a matrix
    * @param {Array} mat
    * @param {number} dim
    * @param {Function} callback
    * @returns {Array} ret
    * @private
    */
   function _apply(mat, dim, callback) {
     var i, ret, tran;
     if (dim <= 0) {
       if (!Array.isArray(mat[0])) {
         return callback(mat);
       } else {
         tran = _switch(mat);
         ret = [];
         for (i = 0; i < tran.length; i++) {
           ret[i] = _apply(tran[i], dim - 1, callback);
         }
         return ret;
       }
     } else {
       ret = [];
       for (i = 0; i < mat.length; i++) {
         ret[i] = _apply(mat[i], dim - 1, callback);
       }
       return ret;
     }
   }

   /**
    * Transpose a matrix
    * @param {Array} mat
    * @returns {Array} ret
    * @private
    */
   function _switch(mat) {
     var I = mat.length;
     var J = mat[0].length;
     var i, j;
     var ret = [];
     for (j = 0; j < J; j++) {
       var tmp = [];
       for (i = 0; i < I; i++) {
         tmp.push(mat[i][j]);
       }
       ret.push(tmp);
     }
     return ret;
   }

   var name$4h = 'addScalar';
   var dependencies$4g = ['typed'];
   var createAddScalar = /* #__PURE__ */factory(name$4h, dependencies$4g, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Add two scalar values, `x + y`.
      * This function is meant for internal use: it is used by the public function
      * `add`
      *
      * This function does not support collections (Array or Matrix).
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
      * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
      * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
      * @private
      */
     return typed(name$4h, {
       'number, number': addNumber,
       'Complex, Complex': function ComplexComplex(x, y) {
         return x.add(y);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.plus(y);
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         return x.add(y);
       },
       'Unit, Unit': typed.referToSelf(self => (x, y) => {
         if (x.value === null || x.value === undefined) {
           throw new Error('Parameter x contains a unit with undefined value');
         }
         if (y.value === null || y.value === undefined) {
           throw new Error('Parameter y contains a unit with undefined value');
         }
         if (!x.equalBase(y)) throw new Error('Units do not match');
         var res = x.clone();
         res.value = typed.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
         res.fixPrefix = false;
         return res;
       })
     });
   });

   var name$4g = 'cbrt';
   var dependencies$4f = ['config', 'typed', 'isNegative', 'unaryMinus', 'matrix', 'Complex', 'BigNumber', 'Fraction'];
   var createCbrt = /* #__PURE__ */factory(name$4g, dependencies$4f, _ref => {
     var {
       config,
       typed,
       isNegative,
       unaryMinus,
       matrix,
       Complex,
       BigNumber,
       Fraction
     } = _ref;
     /**
      * Calculate the cubic root of a value.
      *
      * To avoid confusion with the matrix cube root, this function does not
      * apply to matrices. For a matrix, to take the cube root elementwise,
      * see the examples.
      *
      * Syntax:
      *
      *    math.cbrt(x)
      *    math.cbrt(x, allRoots)
      *
      * Examples:
      *
      *    math.cbrt(27)                  // returns 3
      *    math.cube(3)                   // returns 27
      *    math.cbrt(-64)                 // returns -4
      *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
      *    math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]
      *
      *    const x = math.complex('8i')
      *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i
      *    math.cbrt(x, true)             // returns Matrix [
      *                                    //    1.7320508075689 + i
      *                                    //   -1.7320508075689 + i
      *                                    //   -2i
      *                                    // ]
      *
      * See also:
      *
      *    square, sqrt, cube
      *
      * @param {number | BigNumber | Complex | Unit} x
      *            Value for which to calculate the cubic root.
      * @param {boolean} [allRoots]  Optional, false by default. Only applicable
      *            when `x` is a number or complex number. If true, all complex
      *            roots are returned, if false (default) the principal root is
      *            returned.
      * @return {number | BigNumber | Complex | Unit}
      *            Returns the cubic root of `x`
      */
     return typed(name$4g, {
       number: cbrtNumber,
       // note: signature 'number, boolean' is also supported,
       //       created by typed as it knows how to convert number to Complex

       Complex: _cbrtComplex,
       'Complex, boolean': _cbrtComplex,
       BigNumber: function BigNumber(x) {
         return x.cbrt();
       },
       Unit: _cbrtUnit
     });

     /**
      * Calculate the cubic root for a complex number
      * @param {Complex} x
      * @param {boolean} [allRoots]   If true, the function will return an array
      *                               with all three roots. If false or undefined,
      *                               the principal root is returned.
      * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
      * @private
      */
     function _cbrtComplex(x, allRoots) {
       // https://www.wikiwand.com/en/Cube_root#/Complex_numbers

       var arg3 = x.arg() / 3;
       var abs = x.abs();

       // principal root:
       var principal = new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3).exp());
       if (allRoots) {
         var all = [principal, new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()), new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())];
         return config.matrix === 'Array' ? all : matrix(all);
       } else {
         return principal;
       }
     }

     /**
      * Calculate the cubic root for a Unit
      * @param {Unit} x
      * @return {Unit} Returns the cubic root of x
      * @private
      */
     function _cbrtUnit(x) {
       if (x.value && isComplex(x.value)) {
         var result = x.clone();
         result.value = 1.0;
         result = result.pow(1.0 / 3); // Compute the units
         result.value = _cbrtComplex(x.value); // Compute the value
         return result;
       } else {
         var negate = isNegative(x.value);
         if (negate) {
           x.value = unaryMinus(x.value);
         }

         // TODO: create a helper function for this
         var third;
         if (isBigNumber(x.value)) {
           third = new BigNumber(1).div(3);
         } else if (isFraction(x.value)) {
           third = new Fraction(1, 3);
         } else {
           third = 1 / 3;
         }
         var _result = x.pow(third);
         if (negate) {
           _result.value = unaryMinus(_result.value);
         }
         return _result;
       }
     }
   });

   var name$4f = 'matAlgo11xS0s';
   var dependencies$4e = ['typed', 'equalScalar'];
   var createMatAlgo11xS0s = /* #__PURE__ */factory(name$4f, dependencies$4e, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
      * Callback function invoked NZ times (number of nonzero items in S).
      *
      *
      *          ┌  f(Sij, b)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  0          ; otherwise
      *
      *
      * @param {Matrix}   s                 The SparseMatrix instance (S)
      * @param {Scalar}   b                 The Scalar value
      * @param {Function} callback          The f(Aij,b) operation to invoke
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
      */
     return function matAlgo11xS0s(s, b, callback, inverse) {
       // sparse matrix arrays
       var avalues = s._values;
       var aindex = s._index;
       var aptr = s._ptr;
       var asize = s._size;
       var adt = s._datatype;

       // sparse matrix cannot be a Pattern matrix
       if (!avalues) {
         throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // convert b to the same datatype
         b = typed.convert(b, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = [];
       var cindex = [];
       var cptr = [];

       // loop columns
       for (var j = 0; j < columns; j++) {
         // initialize ptr
         cptr[j] = cindex.length;
         // values in j
         for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           var i = aindex[k];
           // invoke callback
           var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
           // check value is zero
           if (!eq(v, zero)) {
             // push index & value
             cindex.push(i);
             cvalues.push(v);
           }
         }
       }
       // update ptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return s.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$4e = 'matAlgo12xSfs';
   var dependencies$4d = ['typed', 'DenseMatrix'];
   var createMatAlgo12xSfs = /* #__PURE__ */factory(name$4e, dependencies$4d, _ref => {
     var {
       typed,
       DenseMatrix
     } = _ref;
     /**
      * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
      * Callback function invoked MxN times.
      *
      *
      *          ┌  f(Sij, b)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  f(0, b)    ; otherwise
      *
      *
      * @param {Matrix}   s                 The SparseMatrix instance (S)
      * @param {Scalar}   b                 The Scalar value
      * @param {Function} callback          The f(Aij,b) operation to invoke
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
      */
     return function matAlgo12xSfs(s, b, callback, inverse) {
       // sparse matrix arrays
       var avalues = s._values;
       var aindex = s._index;
       var aptr = s._ptr;
       var asize = s._size;
       var adt = s._datatype;

       // sparse matrix cannot be a Pattern matrix
       if (!avalues) {
         throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string') {
         // datatype
         dt = adt;
         // convert b to the same datatype
         b = typed.convert(b, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cdata = [];

       // workspaces
       var x = [];
       // marks indicating we have a value in x for a given column
       var w = [];

       // loop columns
       for (var j = 0; j < columns; j++) {
         // columns mark
         var mark = j + 1;
         // values in j
         for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           var r = aindex[k];
           // update workspace
           x[r] = avalues[k];
           w[r] = mark;
         }
         // loop rows
         for (var i = 0; i < rows; i++) {
           // initialize C on first column
           if (j === 0) {
             // create row array
             cdata[i] = [];
           }
           // check sparse matrix has a value @ i,j
           if (w[i] === mark) {
             // invoke callback, update C
             cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
           } else {
             // dense matrix value @ i, j
             cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
           }
         }
       }

       // return dense matrix
       return new DenseMatrix({
         data: cdata,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$4d = 'matAlgo14xDs';
   var dependencies$4c = ['typed'];
   var createMatAlgo14xDs = /* #__PURE__ */factory(name$4d, dependencies$4c, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
      * Callback function invoked MxN times.
      *
      * C(i,j,...z) = f(Aij..z, b)
      *
      * @param {Matrix}   a                 The DenseMatrix instance (A)
      * @param {Scalar}   b                 The Scalar value
      * @param {Function} callback          The f(Aij..z,b) operation to invoke
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
      */
     return function matAlgo14xDs(a, b, callback, inverse) {
       // a arrays
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;

       // datatype
       var dt;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string') {
         // datatype
         dt = adt;
         // convert b to the same datatype
         b = typed.convert(b, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // populate cdata, iterate through dimensions
       var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];

       // c matrix
       return a.createDenseMatrix({
         data: cdata,
         size: clone$3(asize),
         datatype: dt
       });
     };

     // recursive function
     function _iterate(f, level, s, n, av, bv, inverse) {
       // initialize array for this level
       var cv = [];
       // check we reach the last level
       if (level === s.length - 1) {
         // loop arrays in last level
         for (var i = 0; i < n; i++) {
           // invoke callback and store value
           cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
         }
       } else {
         // iterate current level
         for (var j = 0; j < n; j++) {
           // iterate next level
           cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
         }
       }
       return cv;
     }
   });

   var name$4c = 'ceil';
   var dependencies$4b = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];
   var createCeilNumber = /* #__PURE__ */factory(name$4c, ['typed', 'config', 'round'], _ref => {
     var {
       typed,
       config,
       round
     } = _ref;
     return typed(name$4c, {
       number: function number(x) {
         if (nearlyEqual$1(x, round(x), config.epsilon)) {
           return round(x);
         } else {
           return Math.ceil(x);
         }
       },
       'number, number': function numberNumber(x, n) {
         if (nearlyEqual$1(x, round(x, n), config.epsilon)) {
           return round(x, n);
         } else {
           var [number, exponent] = "".concat(x, "e").split('e');
           var result = Math.ceil(Number("".concat(number, "e").concat(Number(exponent) + n)));
           [number, exponent] = "".concat(result, "e").split('e');
           return Number("".concat(number, "e").concat(Number(exponent) - n));
         }
       }
     });
   });
   var createCeil = /* #__PURE__ */factory(name$4c, dependencies$4b, _ref2 => {
     var {
       typed,
       config,
       round,
       matrix,
       equalScalar,
       zeros,
       DenseMatrix
     } = _ref2;
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var ceilNumber = createCeilNumber({
       typed,
       config,
       round
     });
     /**
      * Round a value towards plus infinity
      * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.ceil(x)
      *    math.ceil(x, n)
      *
      * Examples:
      *
      *    math.ceil(3.2)               // returns number 4
      *    math.ceil(3.8)               // returns number 4
      *    math.ceil(-4.2)              // returns number -4
      *    math.ceil(-4.7)              // returns number -4
      *
      *    math.ceil(3.212, 2)          // returns number 3.22
      *    math.ceil(3.288, 2)          // returns number 3.29
      *    math.ceil(-4.212, 2)         // returns number -4.21
      *    math.ceil(-4.782, 2)         // returns number -4.78
      *
      *    const c = math.complex(3.24, -2.71)
      *    math.ceil(c)                 // returns Complex 4 - 2i
      *    math.ceil(c, 1)              // returns Complex 3.3 - 2.7i
      *
      *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
      *    math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]
      *
      * See also:
      *
      *    floor, fix, round
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
      * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
      */
     return typed('ceil', {
       number: ceilNumber.signatures.number,
       'number,number': ceilNumber.signatures['number,number'],
       Complex: function Complex(x) {
         return x.ceil();
       },
       'Complex, number': function ComplexNumber(x, n) {
         return x.ceil(n);
       },
       'Complex, BigNumber': function ComplexBigNumber(x, n) {
         return x.ceil(n.toNumber());
       },
       BigNumber: function BigNumber(x) {
         if (nearlyEqual(x, round(x), config.epsilon)) {
           return round(x);
         } else {
           return x.ceil();
         }
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, n) {
         if (nearlyEqual(x, round(x, n), config.epsilon)) {
           return round(x, n);
         } else {
           return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_CEIL);
         }
       },
       Fraction: function Fraction(x) {
         return x.ceil();
       },
       'Fraction, number': function FractionNumber(x, n) {
         return x.ceil(n);
       },
       'Fraction, BigNumber': function FractionBigNumber(x, n) {
         return x.ceil(n.toNumber());
       },
       'Array | Matrix': typed.referToSelf(self => x => {
         // deep map collection, skip zeros since ceil(0) = 0
         return deepMap(x, self);
       }),
       'Array, number | BigNumber': typed.referToSelf(self => (x, n) => {
         // deep map collection, skip zeros since ceil(0) = 0
         return deepMap(x, i => self(i, n));
       }),
       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo14xDs(x, y, self, false);
       }),
       'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return matAlgo14xDs(matrix(y), x, self, true).valueOf();
       }),
       'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {
         if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
         if (y.storage() === 'dense') {
           return matAlgo14xDs(y, x, self, true);
         }
         return matAlgo12xSfs(y, x, self, true);
       })
     });
   });

   var name$4b = 'cube';
   var dependencies$4a = ['typed'];
   var createCube = /* #__PURE__ */factory(name$4b, dependencies$4a, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the cube of a value, `x * x * x`.
      * To avoid confusion with `pow(M,3)`, this function does not apply to matrices.
      * If you wish to cube every entry of a matrix, see the examples.
      *
      * Syntax:
      *
      *    math.cube(x)
      *
      * Examples:
      *
      *    math.cube(2)            // returns number 8
      *    math.pow(2, 3)          // returns number 8
      *    math.cube(4)            // returns number 64
      *    4 * 4 * 4               // returns number 64
      *
      *    math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]
      *
      * See also:
      *
      *    multiply, square, pow, cbrt
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit} x  Number for which to calculate the cube
      * @return {number | BigNumber | Fraction | Complex | Unit} Cube of x
      */
     return typed(name$4b, {
       number: cubeNumber,
       Complex: function Complex(x) {
         return x.mul(x).mul(x); // Is faster than pow(x, 3)
       },

       BigNumber: function BigNumber(x) {
         return x.times(x).times(x);
       },
       Fraction: function Fraction(x) {
         return x.pow(3); // Is faster than mul()mul()mul()
       },

       Unit: function Unit(x) {
         return x.pow(3);
       }
     });
   });

   var name$4a = 'exp';
   var dependencies$49 = ['typed'];
   var createExp = /* #__PURE__ */factory(name$4a, dependencies$49, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the exponential of a value.
      * For matrices, if you want the matrix exponential of square matrix, use
      * the `expm` function; if you want to take the exponential of each element,
      * see the examples.
      *
      * Syntax:
      *
      *    math.exp(x)
      *
      * Examples:
      *
      *    math.exp(2)                  // returns number 7.3890560989306495
      *    math.pow(math.e, 2)          // returns number 7.3890560989306495
      *    math.log(math.exp(2))        // returns number 2
      *
      *    math.map([1, 2, 3], math.exp)
      *    // returns Array [
      *    //   2.718281828459045,
      *    //   7.3890560989306495,
      *    //   20.085536923187668
      *    // ]
      *
      * See also:
      *
      *    expm1, expm, log, pow
      *
      * @param {number | BigNumber | Complex} x  A number to exponentiate
      * @return {number | BigNumber | Complex} Exponential of `x`
      */
     return typed(name$4a, {
       number: expNumber,
       Complex: function Complex(x) {
         return x.exp();
       },
       BigNumber: function BigNumber(x) {
         return x.exp();
       }
     });
   });

   var name$49 = 'expm1';
   var dependencies$48 = ['typed', 'Complex'];
   var createExpm1 = /* #__PURE__ */factory(name$49, dependencies$48, _ref => {
     var {
       typed,
       Complex: _Complex
     } = _ref;
     /**
      * Calculate the value of subtracting 1 from the exponential value.
      * This function is more accurate than `math.exp(x)-1` when `x` is near 0
      * To avoid ambiguity with the matrix exponential `expm`, this function
      * does not operate on matrices; if you wish to apply it elementwise, see
      * the examples.
      *
      * Syntax:
      *
      *    math.expm1(x)
      *
      * Examples:
      *
      *    math.expm1(2)                      // returns number 6.38905609893065
      *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
      *    math.expm1(1e-8)                   // returns number 1.0000000050000001e-8
      *    math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9
      *    math.log(math.expm1(2) + 1)        // returns number 2
      *
      *    math.map([1, 2, 3], math.expm1)
      *    // returns Array [
      *    //   1.718281828459045,
      *    //   6.3890560989306495,
      *    //   19.085536923187668
      *    // ]
      *
      * See also:
      *
      *    exp, expm, log, pow
      *
      * @param {number | BigNumber | Complex} x  The number to exponentiate
      * @return {number | BigNumber | Complex} Exponential of `x`, minus one
      */
     return typed(name$49, {
       number: expm1Number,
       Complex: function Complex(x) {
         var r = Math.exp(x.re);
         return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
       },
       BigNumber: function BigNumber(x) {
         return x.exp().minus(1);
       }
     });
   });

   var name$48 = 'fix';
   var dependencies$47 = ['typed', 'Complex', 'matrix', 'ceil', 'floor', 'equalScalar', 'zeros', 'DenseMatrix'];
   var createFixNumber = /* #__PURE__ */factory(name$48, ['typed', 'ceil', 'floor'], _ref => {
     var {
       typed,
       ceil,
       floor
     } = _ref;
     return typed(name$48, {
       number: function number(x) {
         return x > 0 ? floor(x) : ceil(x);
       },
       'number, number': function numberNumber(x, n) {
         return x > 0 ? floor(x, n) : ceil(x, n);
       }
     });
   });
   var createFix = /* #__PURE__ */factory(name$48, dependencies$47, _ref2 => {
     var {
       typed,
       Complex: _Complex,
       matrix,
       ceil,
       floor,
       equalScalar,
       zeros,
       DenseMatrix
     } = _ref2;
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var fixNumber = createFixNumber({
       typed,
       ceil,
       floor
     });
     /**
      * Round a value towards zero.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.fix(x)
      *    math.fix(x,n)
      *
      * Examples:
      *
      *    math.fix(3.2)                // returns number 3
      *    math.fix(3.8)                // returns number 3
      *    math.fix(-4.2)               // returns number -4
      *    math.fix(-4.7)               // returns number -4
      *
      *    math.fix(3.12, 1)                // returns number 3.1
      *    math.fix(3.18, 1)                // returns number 3.1
      *    math.fix(-4.12, 1)               // returns number -4.1
      *    math.fix(-4.17, 1)               // returns number -4.1
      *
      *    const c = math.complex(3.22, -2.78)
      *    math.fix(c)                  // returns Complex 3 - 2i
      *    math.fix(c, 1)               // returns Complex 3.2 -2.7i
      *
      *    math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]
      *    math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]
      *
      * See also:
      *
      *    ceil, floor, round
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x    Number to be rounded
      * @param  {number | BigNumber | Array} [n=0]                             Number of decimals
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix}     Rounded value
      */
     return typed('fix', {
       number: fixNumber.signatures.number,
       'number, number | BigNumber': fixNumber.signatures['number,number'],
       Complex: function Complex(x) {
         return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
       },
       'Complex, number': function ComplexNumber(x, n) {
         return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
       },
       'Complex, BigNumber': function ComplexBigNumber(x, bn) {
         var n = bn.toNumber();
         return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
       },
       BigNumber: function BigNumber(x) {
         return x.isNegative() ? ceil(x) : floor(x);
       },
       'BigNumber, number | BigNumber': function BigNumberNumberBigNumber(x, n) {
         return x.isNegative() ? ceil(x, n) : floor(x, n);
       },
       Fraction: function Fraction(x) {
         return x.s < 0 ? x.ceil() : x.floor();
       },
       'Fraction, number | BigNumber': function FractionNumberBigNumber(x, n) {
         return x.s < 0 ? ceil(x, n) : floor(x, n);
       },
       'Array | Matrix': typed.referToSelf(self => x => {
         // deep map collection, skip zeros since fix(0) = 0
         return deepMap(x, self);
       }),
       'Array | Matrix, number | BigNumber': typed.referToSelf(self => (x, n) => {
         // deep map collection, skip zeros since fix(0) = 0
         return deepMap(x, i => self(i, n));
       }),
       'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return matAlgo14xDs(matrix(y), x, self, true).valueOf();
       }),
       'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {
         if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
         if (y.storage() === 'dense') {
           return matAlgo14xDs(y, x, self, true);
         }
         return matAlgo12xSfs(y, x, self, true);
       })
     });
   });

   var name$47 = 'floor';
   var dependencies$46 = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];
   var createFloorNumber = /* #__PURE__ */factory(name$47, ['typed', 'config', 'round'], _ref => {
     var {
       typed,
       config,
       round
     } = _ref;
     return typed(name$47, {
       number: function number(x) {
         if (nearlyEqual$1(x, round(x), config.epsilon)) {
           return round(x);
         } else {
           return Math.floor(x);
         }
       },
       'number, number': function numberNumber(x, n) {
         if (nearlyEqual$1(x, round(x, n), config.epsilon)) {
           return round(x, n);
         } else {
           var [number, exponent] = "".concat(x, "e").split('e');
           var result = Math.floor(Number("".concat(number, "e").concat(Number(exponent) + n)));
           [number, exponent] = "".concat(result, "e").split('e');
           return Number("".concat(number, "e").concat(Number(exponent) - n));
         }
       }
     });
   });
   var createFloor = /* #__PURE__ */factory(name$47, dependencies$46, _ref2 => {
     var {
       typed,
       config,
       round,
       matrix,
       equalScalar,
       zeros,
       DenseMatrix
     } = _ref2;
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var floorNumber = createFloorNumber({
       typed,
       config,
       round
     });
     /**
      * Round a value towards minus infinity.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.floor(x)
      *    math.floor(x, n)
      *
      * Examples:
      *
      *    math.floor(3.2)              // returns number 3
      *    math.floor(3.8)              // returns number 3
      *    math.floor(-4.2)             // returns number -5
      *    math.floor(-4.7)             // returns number -5
      *
      *    math.floor(3.212, 2)          // returns number 3.21
      *    math.floor(3.288, 2)          // returns number 3.28
      *    math.floor(-4.212, 2)         // returns number -4.22
      *    math.floor(-4.782, 2)         // returns number -4.79
      *
      *    const c = math.complex(3.24, -2.71)
      *    math.floor(c)                 // returns Complex 3 - 3i
      *    math.floor(c, 1)              // returns Complex 3.2 -2.8i
      *
      *    math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]
      *    math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]
      *
      *    math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]
      *
      *    // Note that floor(array, array) currently not implemented.
      *
      * See also:
      *
      *    ceil, fix, round
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
      * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
      */
     return typed('floor', {
       number: floorNumber.signatures.number,
       'number,number': floorNumber.signatures['number,number'],
       Complex: function Complex(x) {
         return x.floor();
       },
       'Complex, number': function ComplexNumber(x, n) {
         return x.floor(n);
       },
       'Complex, BigNumber': function ComplexBigNumber(x, n) {
         return x.floor(n.toNumber());
       },
       BigNumber: function BigNumber(x) {
         if (nearlyEqual(x, round(x), config.epsilon)) {
           return round(x);
         } else {
           return x.floor();
         }
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, n) {
         if (nearlyEqual(x, round(x, n), config.epsilon)) {
           return round(x, n);
         } else {
           return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_FLOOR);
         }
       },
       Fraction: function Fraction(x) {
         return x.floor();
       },
       'Fraction, number': function FractionNumber(x, n) {
         return x.floor(n);
       },
       'Fraction, BigNumber': function FractionBigNumber(x, n) {
         return x.floor(n.toNumber());
       },
       'Array | Matrix': typed.referToSelf(self => x => {
         // deep map collection, skip zeros since floor(0) = 0
         return deepMap(x, self);
       }),
       'Array, number | BigNumber': typed.referToSelf(self => (x, n) => {
         // deep map collection, skip zeros since ceil(0) = 0
         return deepMap(x, i => self(i, n));
       }),
       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo14xDs(x, y, self, false);
       }),
       'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return matAlgo14xDs(matrix(y), x, self, true).valueOf();
       }),
       'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {
         if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
         if (y.storage() === 'dense') {
           return matAlgo14xDs(y, x, self, true);
         }
         return matAlgo12xSfs(y, x, self, true);
       })
     });
   });

   var name$46 = 'matAlgo01xDSid';
   var dependencies$45 = ['typed'];
   var createMatAlgo01xDSid = /* #__PURE__ */factory(name$46, dependencies$45, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
      * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
      *
      *
      *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  Dij          ; otherwise
      *
      *
      * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
      * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
      * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
      */
     return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
       // dense matrix arrays
       var adata = denseMatrix._data;
       var asize = denseMatrix._size;
       var adt = denseMatrix._datatype;
       // sparse matrix arrays
       var bvalues = sparseMatrix._values;
       var bindex = sparseMatrix._index;
       var bptr = sparseMatrix._ptr;
       var bsize = sparseMatrix._size;
       var bdt = sparseMatrix._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // sparse matrix cannot be a Pattern matrix
       if (!bvalues) {
         throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // process data types
       var dt = typeof adt === 'string' && adt === bdt ? adt : undefined;
       // callback function
       var cf = dt ? typed.find(callback, [dt, dt]) : callback;

       // vars
       var i, j;

       // result (DenseMatrix)
       var cdata = [];
       // initialize c
       for (i = 0; i < rows; i++) {
         cdata[i] = [];
       }

       // workspace
       var x = [];
       // marks indicating we have a value in x for a given column
       var w = [];

       // loop columns in b
       for (j = 0; j < columns; j++) {
         // column mark
         var mark = j + 1;
         // values in column j
         for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = bindex[k];
           // update workspace
           x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
           // mark i as updated
           w[i] = mark;
         }
         // loop rows
         for (i = 0; i < rows; i++) {
           // check row is in workspace
           if (w[i] === mark) {
             // c[i][j] was already calculated
             cdata[i][j] = x[i];
           } else {
             // item does not exist in S
             cdata[i][j] = adata[i][j];
           }
         }
       }

       // return dense matrix
       return denseMatrix.createDenseMatrix({
         data: cdata,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$45 = 'matAlgo04xSidSid';
   var dependencies$44 = ['typed', 'equalScalar'];
   var createMatAlgo04xSidSid = /* #__PURE__ */factory(name$45, dependencies$44, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
      * Callback function invoked MAX(NNZA, NNZB) times
      *
      *
      *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
      * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
      *          └  B(i,j)       ; A(i,j) === 0
      *
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo04xSidSid(a, b, callback) {
       // sparse matrix arrays
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = avalues && bvalues ? [] : undefined;
       var cindex = [];
       var cptr = [];

       // workspace
       var xa = avalues && bvalues ? [] : undefined;
       var xb = avalues && bvalues ? [] : undefined;
       // marks indicating we have a value in x for a given column
       var wa = [];
       var wb = [];

       // vars
       var i, j, k, k0, k1;

       // loop columns
       for (j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // columns mark
         var mark = j + 1;
         // loop A(:,j)
         for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = aindex[k];
           // update c
           cindex.push(i);
           // update workspace
           wa[i] = mark;
           // check we need to process values
           if (xa) {
             xa[i] = avalues[k];
           }
         }
         // loop B(:,j)
         for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = bindex[k];
           // check row exists in A
           if (wa[i] === mark) {
             // update record in xa @ i
             if (xa) {
               // invoke callback
               var v = cf(xa[i], bvalues[k]);
               // check for zero
               if (!eq(v, zero)) {
                 // update workspace
                 xa[i] = v;
               } else {
                 // remove mark (index will be removed later)
                 wa[i] = null;
               }
             }
           } else {
             // update c
             cindex.push(i);
             // update workspace
             wb[i] = mark;
             // check we need to process values
             if (xb) {
               xb[i] = bvalues[k];
             }
           }
         }
         // check we need to process values (non pattern matrix)
         if (xa && xb) {
           // initialize first index in j
           k = cptr[j];
           // loop index in j
           while (k < cindex.length) {
             // row
             i = cindex[k];
             // check workspace has value @ i
             if (wa[i] === mark) {
               // push value (Aij != 0 || (Aij != 0 && Bij != 0))
               cvalues[k] = xa[i];
               // increment pointer
               k++;
             } else if (wb[i] === mark) {
               // push value (bij != 0)
               cvalues[k] = xb[i];
               // increment pointer
               k++;
             } else {
               // remove index @ k
               cindex.splice(k, 1);
             }
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$44 = 'matAlgo10xSids';
   var dependencies$43 = ['typed', 'DenseMatrix'];
   var createMatAlgo10xSids = /* #__PURE__ */factory(name$44, dependencies$43, _ref => {
     var {
       typed,
       DenseMatrix
     } = _ref;
     /**
      * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
      * Callback function invoked NZ times (number of nonzero items in S).
      *
      *
      *          ┌  f(Sij, b)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  b          ; otherwise
      *
      *
      * @param {Matrix}   s                 The SparseMatrix instance (S)
      * @param {Scalar}   b                 The Scalar value
      * @param {Function} callback          The f(Aij,b) operation to invoke
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
      */
     return function matAlgo10xSids(s, b, callback, inverse) {
       // sparse matrix arrays
       var avalues = s._values;
       var aindex = s._index;
       var aptr = s._ptr;
       var asize = s._size;
       var adt = s._datatype;

       // sparse matrix cannot be a Pattern matrix
       if (!avalues) {
         throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string') {
         // datatype
         dt = adt;
         // convert b to the same datatype
         b = typed.convert(b, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cdata = [];

       // workspaces
       var x = [];
       // marks indicating we have a value in x for a given column
       var w = [];

       // loop columns
       for (var j = 0; j < columns; j++) {
         // columns mark
         var mark = j + 1;
         // values in j
         for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           var r = aindex[k];
           // update workspace
           x[r] = avalues[k];
           w[r] = mark;
         }
         // loop rows
         for (var i = 0; i < rows; i++) {
           // initialize C on first column
           if (j === 0) {
             // create row array
             cdata[i] = [];
           }
           // check sparse matrix has a value @ i,j
           if (w[i] === mark) {
             // invoke callback, update C
             cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
           } else {
             // dense matrix value @ i, j
             cdata[i][j] = b;
           }
         }
       }

       // return dense matrix
       return new DenseMatrix({
         data: cdata,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$43 = 'matAlgo13xDD';
   var dependencies$42 = ['typed'];
   var createMatAlgo13xDD = /* #__PURE__ */factory(name$43, dependencies$42, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
      * Callback function invoked MxN times.
      *
      * C(i,j,...z) = f(Aij..z, Bij..z)
      *
      * @param {Matrix}   a                 The DenseMatrix instance (A)
      * @param {Matrix}   b                 The DenseMatrix instance (B)
      * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
      */
     return function matAlgo13xDD(a, b, callback) {
       // a arrays
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;
       // b arrays
       var bdata = b._data;
       var bsize = b._size;
       var bdt = b._datatype;
       // c arrays
       var csize = [];

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // validate each one of the dimension sizes
       for (var s = 0; s < asize.length; s++) {
         // must match
         if (asize[s] !== bsize[s]) {
           throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
         }
         // update dimension in c
         csize[s] = asize[s];
       }

       // datatype
       var dt;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // populate cdata, iterate through dimensions
       var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];

       // c matrix
       return a.createDenseMatrix({
         data: cdata,
         size: csize,
         datatype: dt
       });
     };

     // recursive function
     function _iterate(f, level, s, n, av, bv) {
       // initialize array for this level
       var cv = [];
       // check we reach the last level
       if (level === s.length - 1) {
         // loop arrays in last level
         for (var i = 0; i < n; i++) {
           // invoke callback and store value
           cv[i] = f(av[i], bv[i]);
         }
       } else {
         // iterate current level
         for (var j = 0; j < n; j++) {
           // iterate next level
           cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
         }
       }
       return cv;
     }
   });

   var name$42 = 'broadcast';
   var dependancies = ['concat'];
   var createBroadcast = /* #__PURE__ */factory(name$42, dependancies, _ref => {
     var {
       concat
     } = _ref;
     /**
     * Broadcasts two matrices, and return both in an array
     * It checks if it's possible with broadcasting rules
     *
     * @param {Matrix}   A      First Matrix
     * @param {Matrix}   B      Second Matrix
     *
     * @return {Matrix[]}      [ broadcastedA, broadcastedB ]
     */
     return function (A, B) {
       var N = Math.max(A._size.length, B._size.length); // max number of dims
       if (A._size.length === B._size.length) {
         if (A._size.every((dim, i) => dim === B._size[i])) {
           // If matrices have the same size return them
           return [A, B];
         }
       }
       var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right
       var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right

       // calculate the max dimensions
       var sizeMax = [];
       for (var dim = 0; dim < N; dim++) {
         sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
       }

       // check if the broadcasting rules applyes for both matrices
       checkBroadcastingRules(sizeA, sizeMax);
       checkBroadcastingRules(sizeB, sizeMax);

       // reshape A or B if needed to make them ready for concat
       var AA = A.clone();
       var BB = B.clone();
       if (AA._size.length < N) {
         AA.reshape(_padLeft(AA._size, N, 1));
       } else if (BB._size.length < N) {
         BB.reshape(_padLeft(BB._size, N, 1));
       }

       // stretches the matrices on each dimension to make them the same size
       for (var _dim = 0; _dim < N; _dim++) {
         if (AA._size[_dim] < sizeMax[_dim]) {
           AA = _stretch(AA, sizeMax[_dim], _dim);
         }
         if (BB._size[_dim] < sizeMax[_dim]) {
           BB = _stretch(BB, sizeMax[_dim], _dim);
         }
       }

       // return the array with the two broadcasted matrices
       return [AA, BB];
     };
     function _padLeft(shape, N, filler) {
       // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N
       return [...Array(N - shape.length).fill(filler), ...shape];
     }
     function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
       // stretches a matrix up to a certain size in a certain dimension
       return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
     }
   });

   var name$41 = 'matrixAlgorithmSuite';
   var dependencies$41 = ['typed', 'matrix', 'concat'];
   var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name$41, dependencies$41, _ref => {
     var {
       typed,
       matrix,
       concat
     } = _ref;
     var matAlgo13xDD = createMatAlgo13xDD({
       typed
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var broadcast = createBroadcast({
       concat
     });

     /**
      * Return a signatures object with the usual boilerplate of
      * matrix algorithms, based on a plain options object with the
      * following properties:
      *   elop: function -- the elementwise operation to use, defaults to self
      *   SS: function -- the algorithm to apply for two sparse matrices
      *   DS: function -- the algorithm to apply for a dense and a sparse matrix
      *   SD: function -- algo for a sparse and a dense; defaults to SD flipped
      *   Ss: function -- the algorithm to apply for a sparse matrix and scalar
      *   sS: function -- algo for scalar and sparse; defaults to Ss flipped
      *   scalar: string -- typed-function type for scalars, defaults to 'any'
      *
      * If Ss is not specified, no matrix-scalar signatures are generated.
      *
      * @param {object} options
      * @return {Object<string, function>} signatures
      */
     return function matrixAlgorithmSuite(options) {
       var elop = options.elop;
       var SD = options.SD || options.DS;
       var matrixSignatures;
       if (elop) {
         // First the dense ones
         matrixSignatures = {
           'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(x, y), elop),
           'Array, Array': (x, y) => matAlgo13xDD(...broadcast(matrix(x), matrix(y)), elop).valueOf(),
           'Array, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(matrix(x), y), elop),
           'DenseMatrix, Array': (x, y) => matAlgo13xDD(...broadcast(x, matrix(y)), elop)
         };
         // Now incorporate sparse matrices
         if (options.SS) {
           matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(...broadcast(x, y), elop, false);
         }
         if (options.DS) {
           matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(...broadcast(x, y), elop, false);
           matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(...broadcast(matrix(x), y), elop, false);
         }
         if (SD) {
           matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(...broadcast(y, x), elop, true);
           matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(...broadcast(matrix(y), x), elop, true);
         }
       } else {
         // No elop, use this
         // First the dense ones
         matrixSignatures = {
           'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {
             return matAlgo13xDD(...broadcast(x, y), self);
           }),
           'Array, Array': typed.referToSelf(self => (x, y) => {
             return matAlgo13xDD(...broadcast(matrix(x), matrix(y)), self).valueOf();
           }),
           'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {
             return matAlgo13xDD(...broadcast(matrix(x), y), self);
           }),
           'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {
             return matAlgo13xDD(...broadcast(x, matrix(y)), self);
           })
         };
         // Now incorporate sparse matrices
         if (options.SS) {
           matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {
             return options.SS(...broadcast(x, y), self, false);
           });
         }
         if (options.DS) {
           matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {
             return options.DS(...broadcast(x, y), self, false);
           });
           matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {
             return options.DS(...broadcast(matrix(x), y), self, false);
           });
         }
         if (SD) {
           matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {
             return SD(...broadcast(y, x), self, true);
           });
           matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {
             return SD(...broadcast(matrix(y), x), self, true);
           });
         }
       }

       // Now add the scalars
       var scalar = options.scalar || 'any';
       var Ds = options.Ds || options.Ss;
       if (Ds) {
         if (elop) {
           matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
           matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);
           matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();
           matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();
         } else {
           matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {
             return matAlgo14xDs(x, y, self, false);
           });
           matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {
             return matAlgo14xDs(y, x, self, true);
           });
           matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {
             return matAlgo14xDs(matrix(x), y, self, false).valueOf();
           });
           matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {
             return matAlgo14xDs(matrix(y), x, self, true).valueOf();
           });
         }
       }
       var sS = options.sS !== undefined ? options.sS : options.Ss;
       if (elop) {
         if (options.Ss) {
           matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);
         }
         if (sS) {
           matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);
         }
       } else {
         if (options.Ss) {
           matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {
             return options.Ss(x, y, self, false);
           });
         }
         if (sS) {
           matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {
             return sS(y, x, self, true);
           });
         }
       }
       // Also pull in the scalar signatures if the operator is a typed function
       if (elop && elop.signatures) {
         extend(matrixSignatures, elop.signatures);
       }
       return matrixSignatures;
     };
   });

   /**
    * Create a syntax error with the message:
    *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
    * @param {string} fn     Function name
    * @param {number} count  Actual argument count
    * @param {number} min    Minimum required argument count
    * @param {number} [max]  Maximum required argument count
    * @extends Error
    */
   function ArgumentsError(fn, count, min, max) {
     if (!(this instanceof ArgumentsError)) {
       throw new SyntaxError('Constructor must be called with the new operator');
     }
     this.fn = fn;
     this.count = count;
     this.min = min;
     this.max = max;
     this.message = 'Wrong number of arguments in function ' + fn + ' (' + count + ' provided, ' + min + (max !== undefined && max !== null ? '-' + max : '') + ' expected)';
     this.stack = new Error().stack;
   }
   ArgumentsError.prototype = new Error();
   ArgumentsError.prototype.constructor = Error;
   ArgumentsError.prototype.name = 'ArgumentsError';
   ArgumentsError.prototype.isArgumentsError = true;

   var name$40 = 'gcd';
   var dependencies$40 = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'DenseMatrix', 'concat'];
   var gcdTypes = 'number | BigNumber | Fraction | Matrix | Array';
   var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
   function is1d(array) {
     return !array.some(element => Array.isArray(element));
   }
   var createGcd = /* #__PURE__ */factory(name$40, dependencies$40, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       BigNumber,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo04xSidSid = createMatAlgo04xSidSid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Calculate the greatest common divisor for two or more values or arrays.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.gcd(a, b)
      *    math.gcd(a, b, c, ...)
      *
      * Examples:
      *
      *    math.gcd(8, 12)              // returns 4
      *    math.gcd(-4, 6)              // returns 2
      *    math.gcd(25, 15, -10)        // returns 5
      *
      *    math.gcd([8, -4], [12, 6])   // returns [4, 2]
      *
      * See also:
      *
      *    lcm, xgcd
      *
      * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
      * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
      */
     return typed(name$40, {
       'number, number': gcdNumber,
       'BigNumber, BigNumber': _gcdBigNumber,
       'Fraction, Fraction': (x, y) => x.gcd(y)
     }, matrixAlgorithmSuite({
       SS: matAlgo04xSidSid,
       DS: matAlgo01xDSid,
       Ss: matAlgo10xSids
     }), {
       [gcdManyTypesSignature]: typed.referToSelf(self => (a, b, args) => {
         var res = self(a, b);
         for (var i = 0; i < args.length; i++) {
           res = self(res, args[i]);
         }
         return res;
       }),
       Array: typed.referToSelf(self => array => {
         if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
           return self(...array[0]);
         }
         if (is1d(array)) {
           return self(...array);
         }
         throw new ArgumentsError('gcd() supports only 1d matrices!');
       }),
       Matrix: typed.referToSelf(self => matrix => {
         return self(matrix.toArray());
       })
     });

     /**
      * Calculate gcd for BigNumbers
      * @param {BigNumber} a
      * @param {BigNumber} b
      * @returns {BigNumber} Returns greatest common denominator of a and b
      * @private
      */
     function _gcdBigNumber(a, b) {
       if (!a.isInt() || !b.isInt()) {
         throw new Error('Parameters in function gcd must be integer numbers');
       }

       // https://en.wikipedia.org/wiki/Euclidean_algorithm
       var zero = new BigNumber(0);
       while (!b.isZero()) {
         var r = a.mod(b);
         a = b;
         b = r;
       }
       return a.lt(zero) ? a.neg() : a;
     }
   });

   var name$3$ = 'matAlgo02xDS0';
   var dependencies$3$ = ['typed', 'equalScalar'];
   var createMatAlgo02xDS0 = /* #__PURE__ */factory(name$3$, dependencies$3$, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
      * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
      *
      *
      *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  0            ; otherwise
      *
      *
      * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
      * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
      * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
      */
     return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
       // dense matrix arrays
       var adata = denseMatrix._data;
       var asize = denseMatrix._size;
       var adt = denseMatrix._datatype;
       // sparse matrix arrays
       var bvalues = sparseMatrix._values;
       var bindex = sparseMatrix._index;
       var bptr = sparseMatrix._ptr;
       var bsize = sparseMatrix._size;
       var bdt = sparseMatrix._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // sparse matrix cannot be a Pattern matrix
       if (!bvalues) {
         throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result (SparseMatrix)
       var cvalues = [];
       var cindex = [];
       var cptr = [];

       // loop columns in b
       for (var j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // values in column j
         for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
           // row
           var i = bindex[k];
           // update C(i,j)
           var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
           // check for nonzero
           if (!eq(cij, zero)) {
             // push i & v
             cindex.push(i);
             cvalues.push(cij);
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return sparseMatrix.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$3_ = 'matAlgo06xS0S0';
   var dependencies$3_ = ['typed', 'equalScalar'];
   var createMatAlgo06xS0S0 = /* #__PURE__ */factory(name$3_, dependencies$3_, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
      * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
      *
      *
      *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
      * C(i,j) = ┤
      *          └  0            ; otherwise
      *
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo06xS0S0(a, b, callback) {
       // sparse matrix arrays
       var avalues = a._values;
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bvalues = b._values;
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = avalues && bvalues ? [] : undefined;
       var cindex = [];
       var cptr = [];

       // workspaces
       var x = cvalues ? [] : undefined;
       // marks indicating we have a value in x for a given column
       var w = [];
       // marks indicating value in a given row has been updated
       var u = [];

       // loop columns
       for (var j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // columns mark
         var mark = j + 1;
         // scatter the values of A(:,j) into workspace
         scatter(a, j, w, x, u, mark, cindex, cf);
         // scatter the values of B(:,j) into workspace
         scatter(b, j, w, x, u, mark, cindex, cf);
         // check we need to process values (non pattern matrix)
         if (x) {
           // initialize first index in j
           var k = cptr[j];
           // loop index in j
           while (k < cindex.length) {
             // row
             var i = cindex[k];
             // check function was invoked on current row (Aij !=0 && Bij != 0)
             if (u[i] === mark) {
               // value @ i
               var v = x[i];
               // check for zero value
               if (!eq(v, zero)) {
                 // push value
                 cvalues.push(v);
                 // increment pointer
                 k++;
               } else {
                 // remove value @ i, do not increment pointer
                 cindex.splice(k, 1);
               }
             } else {
               // remove value @ i, do not increment pointer
               cindex.splice(k, 1);
             }
           }
         } else {
           // initialize first index in j
           var p = cptr[j];
           // loop index in j
           while (p < cindex.length) {
             // row
             var r = cindex[p];
             // check function was invoked on current row (Aij !=0 && Bij != 0)
             if (u[r] !== mark) {
               // remove value @ i, do not increment pointer
               cindex.splice(p, 1);
             } else {
               // increment pointer
               p++;
             }
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$3Z = 'lcm';
   var dependencies$3Z = ['typed', 'matrix', 'equalScalar', 'concat'];
   var createLcm = /* #__PURE__ */factory(name$3Z, dependencies$3Z, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo06xS0S0 = createMatAlgo06xS0S0({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var lcmTypes = 'number | BigNumber | Fraction | Matrix | Array';
     var lcmManySignature = {};
     lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed.referToSelf(self => (a, b, args) => {
       var res = self(a, b);
       for (var i = 0; i < args.length; i++) {
         res = self(res, args[i]);
       }
       return res;
     });

     /**
      * Calculate the least common multiple for two or more values or arrays.
      *
      * lcm is defined as:
      *
      *     lcm(a, b) = abs(a * b) / gcd(a, b)
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.lcm(a, b)
      *    math.lcm(a, b, c, ...)
      *
      * Examples:
      *
      *    math.lcm(4, 6)               // returns 12
      *    math.lcm(6, 21)              // returns 42
      *    math.lcm(6, 21, 5)           // returns 210
      *
      *    math.lcm([4, 6], [6, 21])    // returns [12, 42]
      *
      * See also:
      *
      *    gcd, xgcd
      *
      * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
      * @return {number | BigNumber | Array | Matrix}                           The least common multiple
      */
     return typed(name$3Z, {
       'number, number': lcmNumber,
       'BigNumber, BigNumber': _lcmBigNumber,
       'Fraction, Fraction': (x, y) => x.lcm(y)
     }, matrixAlgorithmSuite({
       SS: matAlgo06xS0S0,
       DS: matAlgo02xDS0,
       Ss: matAlgo11xS0s
     }), lcmManySignature);

     /**
      * Calculate lcm for two BigNumbers
      * @param {BigNumber} a
      * @param {BigNumber} b
      * @returns {BigNumber} Returns the least common multiple of a and b
      * @private
      */
     function _lcmBigNumber(a, b) {
       if (!a.isInt() || !b.isInt()) {
         throw new Error('Parameters in function lcm must be integer numbers');
       }
       if (a.isZero()) {
         return a;
       }
       if (b.isZero()) {
         return b;
       }

       // https://en.wikipedia.org/wiki/Euclidean_algorithm
       // evaluate lcm here inline to reduce overhead
       var prod = a.times(b);
       while (!b.isZero()) {
         var t = b;
         b = a.mod(t);
         a = t;
       }
       return prod.div(a).abs();
     }
   });

   var name$3Y = 'log10';
   var dependencies$3Y = ['typed', 'config', 'Complex'];
   var createLog10 = /* #__PURE__ */factory(name$3Y, dependencies$3Y, _ref => {
     var {
       typed,
       config,
       Complex: _Complex
     } = _ref;
     /**
      * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.log10(x)
      *
      * Examples:
      *
      *    math.log10(0.00001)            // returns -5
      *    math.log10(10000)              // returns 4
      *    math.log(10000) / math.log(10) // returns 4
      *    math.pow(10, 4)                // returns 10000
      *
      * See also:
      *
      *    exp, log, log1p, log2
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            Value for which to calculate the logarithm.
      * @return {number | BigNumber | Complex | Array | Matrix}
      *            Returns the 10-base logarithm of `x`
      */
     return typed(name$3Y, {
       number: function number(x) {
         if (x >= 0 || config.predictable) {
           return log10Number(x);
         } else {
           // negative value -> complex value computation
           return new _Complex(x, 0).log().div(Math.LN10);
         }
       },
       Complex: function Complex(x) {
         return new _Complex(x).log().div(Math.LN10);
       },
       BigNumber: function BigNumber(x) {
         if (!x.isNegative() || config.predictable) {
           return x.log();
         } else {
           // downgrade to number, return Complex valued result
           return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
         }
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3X = 'log2';
   var dependencies$3X = ['typed', 'config', 'Complex'];
   var createLog2 = /* #__PURE__ */factory(name$3X, dependencies$3X, _ref => {
     var {
       typed,
       config,
       Complex
     } = _ref;
     /**
      * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.log2(x)
      *
      * Examples:
      *
      *    math.log2(0.03125)           // returns -5
      *    math.log2(16)                // returns 4
      *    math.log2(16) / math.log2(2) // returns 4
      *    math.pow(2, 4)               // returns 16
      *
      * See also:
      *
      *    exp, log, log1p, log10
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            Value for which to calculate the logarithm.
      * @return {number | BigNumber | Complex | Array | Matrix}
      *            Returns the 2-base logarithm of `x`
      */
     return typed(name$3X, {
       number: function number(x) {
         if (x >= 0 || config.predictable) {
           return log2Number(x);
         } else {
           // negative value -> complex value computation
           return _log2Complex(new Complex(x, 0));
         }
       },
       Complex: _log2Complex,
       BigNumber: function BigNumber(x) {
         if (!x.isNegative() || config.predictable) {
           return x.log(2);
         } else {
           // downgrade to number, return Complex valued result
           return _log2Complex(new Complex(x.toNumber(), 0));
         }
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });

     /**
      * Calculate log2 for a complex value
      * @param {Complex} x
      * @returns {Complex}
      * @private
      */
     function _log2Complex(x) {
       var newX = Math.sqrt(x.re * x.re + x.im * x.im);
       return new Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
     }
   });

   var name$3W = 'matAlgo03xDSf';
   var dependencies$3W = ['typed'];
   var createMatAlgo03xDSf = /* #__PURE__ */factory(name$3W, dependencies$3W, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
      * Callback function invoked M*N times.
      *
      *
      *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
      * C(i,j) = ┤
      *          └  f(Dij, 0)    ; otherwise
      *
      *
      * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
      * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
      * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
      * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
      */
     return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
       // dense matrix arrays
       var adata = denseMatrix._data;
       var asize = denseMatrix._size;
       var adt = denseMatrix._datatype;
       // sparse matrix arrays
       var bvalues = sparseMatrix._values;
       var bindex = sparseMatrix._index;
       var bptr = sparseMatrix._ptr;
       var bsize = sparseMatrix._size;
       var bdt = sparseMatrix._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // sparse matrix cannot be a Pattern matrix
       if (!bvalues) {
         throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result (DenseMatrix)
       var cdata = [];

       // initialize dense matrix
       for (var z = 0; z < rows; z++) {
         // initialize row
         cdata[z] = [];
       }

       // workspace
       var x = [];
       // marks indicating we have a value in x for a given column
       var w = [];

       // loop columns in b
       for (var j = 0; j < columns; j++) {
         // column mark
         var mark = j + 1;
         // values in column j
         for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
           // row
           var i = bindex[k];
           // update workspace
           x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
           w[i] = mark;
         }
         // process workspace
         for (var y = 0; y < rows; y++) {
           // check we have a calculated value for current row
           if (w[y] === mark) {
             // use calculated value
             cdata[y][j] = x[y];
           } else {
             // calculate value
             cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
           }
         }
       }

       // return dense matrix
       return denseMatrix.createDenseMatrix({
         data: cdata,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$3V = 'matAlgo05xSfSf';
   var dependencies$3V = ['typed', 'equalScalar'];
   var createMatAlgo05xSfSf = /* #__PURE__ */factory(name$3V, dependencies$3V, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
      * Callback function invoked MAX(NNZA, NNZB) times
      *
      *
      *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
      * C(i,j) = ┤
      *          └  0            ; otherwise
      *
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo05xSfSf(a, b, callback) {
       // sparse matrix arrays
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = avalues && bvalues ? [] : undefined;
       var cindex = [];
       var cptr = [];

       // workspaces
       var xa = cvalues ? [] : undefined;
       var xb = cvalues ? [] : undefined;
       // marks indicating we have a value in x for a given column
       var wa = [];
       var wb = [];

       // vars
       var i, j, k, k1;

       // loop columns
       for (j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // columns mark
         var mark = j + 1;
         // loop values A(:,j)
         for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
           // row
           i = aindex[k];
           // push index
           cindex.push(i);
           // update workspace
           wa[i] = mark;
           // check we need to process values
           if (xa) {
             xa[i] = avalues[k];
           }
         }
         // loop values B(:,j)
         for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
           // row
           i = bindex[k];
           // check row existed in A
           if (wa[i] !== mark) {
             // push index
             cindex.push(i);
           }
           // update workspace
           wb[i] = mark;
           // check we need to process values
           if (xb) {
             xb[i] = bvalues[k];
           }
         }
         // check we need to process values (non pattern matrix)
         if (cvalues) {
           // initialize first index in j
           k = cptr[j];
           // loop index in j
           while (k < cindex.length) {
             // row
             i = cindex[k];
             // marks
             var wai = wa[i];
             var wbi = wb[i];
             // check Aij or Bij are nonzero
             if (wai === mark || wbi === mark) {
               // matrix values @ i,j
               var va = wai === mark ? xa[i] : zero;
               var vb = wbi === mark ? xb[i] : zero;
               // Cij
               var vc = cf(va, vb);
               // check for zero
               if (!eq(vc, zero)) {
                 // push value
                 cvalues.push(vc);
                 // increment pointer
                 k++;
               } else {
                 // remove value @ i, do not increment pointer
                 cindex.splice(k, 1);
               }
             }
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$3U = 'mod';
   var dependencies$3U = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];
   var createMod = /* #__PURE__ */factory(name$3U, dependencies$3U, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo05xSfSf = createMatAlgo05xSfSf({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Calculates the modulus, the remainder of an integer division.
      *
      * For matrices, the function is evaluated element wise.
      *
      * The modulus is defined as:
      *
      *     x - y * floor(x / y)
      *
      * See https://en.wikipedia.org/wiki/Modulo_operation.
      *
      * Syntax:
      *
      *    math.mod(x, y)
      *
      * Examples:
      *
      *    math.mod(8, 3)                // returns 2
      *    math.mod(11, 2)               // returns 1
      *
      *    function isOdd(x) {
      *      return math.mod(x, 2) != 0
      *    }
      *
      *    isOdd(2)                      // returns false
      *    isOdd(3)                      // returns true
      *
      * See also:
      *
      *    divide
      *
      * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
      * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
      * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
      */
     return typed(name$3U, {
       'number, number': modNumber,
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         if (y.isNeg()) {
           throw new Error('Cannot calculate mod for a negative divisor');
         }
         return y.isZero() ? x : x.mod(y);
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         if (y.compare(0) < 0) {
           throw new Error('Cannot calculate mod for a negative divisor');
         }
         // Workaround suggested in Fraction.js library to calculate correct modulo for negative dividend
         return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
       }
     }, matrixAlgorithmSuite({
       SS: matAlgo05xSfSf,
       DS: matAlgo03xDSf,
       SD: matAlgo02xDS0,
       Ss: matAlgo11xS0s,
       sS: matAlgo12xSfs
     }));
   });

   var name$3T = 'multiplyScalar';
   var dependencies$3T = ['typed'];
   var createMultiplyScalar = /* #__PURE__ */factory(name$3T, dependencies$3T, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Multiply two scalar values, `x * y`.
      * This function is meant for internal use: it is used by the public function
      * `multiply`
      *
      * This function does not support collections (Array or Matrix).
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
      * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
      * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
      * @private
      */
     return typed('multiplyScalar', {
       'number, number': multiplyNumber,
       'Complex, Complex': function ComplexComplex(x, y) {
         return x.mul(y);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.times(y);
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         return x.mul(y);
       },
       'number | Fraction | BigNumber | Complex, Unit': (x, y) => y.multiply(x),
       'Unit, number | Fraction | BigNumber | Complex | Unit': (x, y) => x.multiply(y)
     });
   });

   var name$3S = 'multiply';
   var dependencies$3S = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];
   var createMultiply = /* #__PURE__ */factory(name$3S, dependencies$3S, _ref => {
     var {
       typed,
       matrix,
       addScalar,
       multiplyScalar,
       equalScalar,
       dot
     } = _ref;
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     function _validateMatrixDimensions(size1, size2) {
       // check left operand dimensions
       switch (size1.length) {
         case 1:
           // check size2
           switch (size2.length) {
             case 1:
               // Vector x Vector
               if (size1[0] !== size2[0]) {
                 // throw error
                 throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
               }
               break;
             case 2:
               // Vector x Matrix
               if (size1[0] !== size2[0]) {
                 // throw error
                 throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
               }
               break;
             default:
               throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
           }
           break;
         case 2:
           // check size2
           switch (size2.length) {
             case 1:
               // Matrix x Vector
               if (size1[1] !== size2[0]) {
                 // throw error
                 throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
               }
               break;
             case 2:
               // Matrix x Matrix
               if (size1[1] !== size2[0]) {
                 // throw error
                 throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
               }
               break;
             default:
               throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
           }
           break;
         default:
           throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
       }
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            Dense Vector   (N)
      * @param {Matrix} b            Dense Vector   (N)
      *
      * @return {number}             Scalar value
      */
     function _multiplyVectorVector(a, b, n) {
       // check empty vector
       if (n === 0) {
         throw new Error('Cannot multiply two empty vectors');
       }
       return dot(a, b);
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            Dense Vector   (M)
      * @param {Matrix} b            Matrix         (MxN)
      *
      * @return {Matrix}             Dense Vector   (N)
      */
     function _multiplyVectorMatrix(a, b) {
       // process storage
       if (b.storage() !== 'dense') {
         throw new Error('Support for SparseMatrix not implemented');
       }
       return _multiplyVectorDenseMatrix(a, b);
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            Dense Vector   (M)
      * @param {Matrix} b            Dense Matrix   (MxN)
      *
      * @return {Matrix}             Dense Vector   (N)
      */
     function _multiplyVectorDenseMatrix(a, b) {
       // a dense
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;
       // b dense
       var bdata = b._data;
       var bsize = b._size;
       var bdt = b._datatype;
       // rows & columns
       var alength = asize[0];
       var bcolumns = bsize[1];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
       }

       // result
       var c = [];

       // loop matrix columns
       for (var j = 0; j < bcolumns; j++) {
         // sum (do not initialize it with zero)
         var sum = mf(adata[0], bdata[0][j]);
         // loop vector
         for (var i = 1; i < alength; i++) {
           // multiply & accumulate
           sum = af(sum, mf(adata[i], bdata[i][j]));
         }
         c[j] = sum;
       }

       // return matrix
       return a.createDenseMatrix({
         data: c,
         size: [bcolumns],
         datatype: dt
       });
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            Matrix         (MxN)
      * @param {Matrix} b            Dense Vector   (N)
      *
      * @return {Matrix}             Dense Vector   (M)
      */
     var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
       'DenseMatrix, any': _multiplyDenseMatrixVector,
       'SparseMatrix, any': _multiplySparseMatrixVector
     });

     /**
      * C = A * B
      *
      * @param {Matrix} a            Matrix         (MxN)
      * @param {Matrix} b            Matrix         (NxC)
      *
      * @return {Matrix}             Matrix         (MxC)
      */
     var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
       'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
       'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
       'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
       'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
     });

     /**
      * C = A * B
      *
      * @param {Matrix} a            DenseMatrix  (MxN)
      * @param {Matrix} b            Dense Vector (N)
      *
      * @return {Matrix}             Dense Vector (M)
      */
     function _multiplyDenseMatrixVector(a, b) {
       // a dense
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;
       // b dense
       var bdata = b._data;
       var bdt = b._datatype;
       // rows & columns
       var arows = asize[0];
       var acolumns = asize[1];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
       }

       // result
       var c = [];

       // loop matrix a rows
       for (var i = 0; i < arows; i++) {
         // current row
         var row = adata[i];
         // sum (do not initialize it with zero)
         var sum = mf(row[0], bdata[0]);
         // loop matrix a columns
         for (var j = 1; j < acolumns; j++) {
           // multiply & accumulate
           sum = af(sum, mf(row[j], bdata[j]));
         }
         c[i] = sum;
       }

       // return matrix
       return a.createDenseMatrix({
         data: c,
         size: [arows],
         datatype: dt
       });
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            DenseMatrix    (MxN)
      * @param {Matrix} b            DenseMatrix    (NxC)
      *
      * @return {Matrix}             DenseMatrix    (MxC)
      */
     function _multiplyDenseMatrixDenseMatrix(a, b) {
       // a dense
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;
       // b dense
       var bdata = b._data;
       var bsize = b._size;
       var bdt = b._datatype;
       // rows & columns
       var arows = asize[0];
       var acolumns = asize[1];
       var bcolumns = bsize[1];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
       }

       // result
       var c = [];

       // loop matrix a rows
       for (var i = 0; i < arows; i++) {
         // current row
         var row = adata[i];
         // initialize row array
         c[i] = [];
         // loop matrix b columns
         for (var j = 0; j < bcolumns; j++) {
           // sum (avoid initializing sum to zero)
           var sum = mf(row[0], bdata[0][j]);
           // loop matrix a columns
           for (var x = 1; x < acolumns; x++) {
             // multiply & accumulate
             sum = af(sum, mf(row[x], bdata[x][j]));
           }
           c[i][j] = sum;
         }
       }

       // return matrix
       return a.createDenseMatrix({
         data: c,
         size: [arows, bcolumns],
         datatype: dt
       });
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            DenseMatrix    (MxN)
      * @param {Matrix} b            SparseMatrix   (NxC)
      *
      * @return {Matrix}             SparseMatrix   (MxC)
      */
     function _multiplyDenseMatrixSparseMatrix(a, b) {
       // a dense
       var adata = a._data;
       var asize = a._size;
       var adt = a._datatype;
       // b sparse
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bsize = b._size;
       var bdt = b._datatype;
       // validate b matrix
       if (!bvalues) {
         throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
       }
       // rows & columns
       var arows = asize[0];
       var bcolumns = bsize[1];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;
       // equalScalar signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
       }

       // result
       var cvalues = [];
       var cindex = [];
       var cptr = [];
       // c matrix
       var c = b.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [arows, bcolumns],
         datatype: dt
       });

       // loop b columns
       for (var jb = 0; jb < bcolumns; jb++) {
         // update ptr
         cptr[jb] = cindex.length;
         // indeces in column jb
         var kb0 = bptr[jb];
         var kb1 = bptr[jb + 1];
         // do not process column jb if no data exists
         if (kb1 > kb0) {
           // last row mark processed
           var last = 0;
           // loop a rows
           for (var i = 0; i < arows; i++) {
             // column mark
             var mark = i + 1;
             // C[i, jb]
             var cij = void 0;
             // values in b column j
             for (var kb = kb0; kb < kb1; kb++) {
               // row
               var ib = bindex[kb];
               // check value has been initialized
               if (last !== mark) {
                 // first value in column jb
                 cij = mf(adata[i][ib], bvalues[kb]);
                 // update mark
                 last = mark;
               } else {
                 // accumulate value
                 cij = af(cij, mf(adata[i][ib], bvalues[kb]));
               }
             }
             // check column has been processed and value != 0
             if (last === mark && !eq(cij, zero)) {
               // push row & value
               cindex.push(i);
               cvalues.push(cij);
             }
           }
         }
       }
       // update ptr
       cptr[bcolumns] = cindex.length;

       // return sparse matrix
       return c;
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            SparseMatrix    (MxN)
      * @param {Matrix} b            Dense Vector (N)
      *
      * @return {Matrix}             SparseMatrix    (M, 1)
      */
     function _multiplySparseMatrixVector(a, b) {
       // a sparse
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var adt = a._datatype;
       // validate a matrix
       if (!avalues) {
         throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
       }
       // b dense
       var bdata = b._data;
       var bdt = b._datatype;
       // rows & columns
       var arows = a._size[0];
       var brows = b._size[0];
       // result
       var cvalues = [];
       var cindex = [];
       var cptr = [];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;
       // equalScalar signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
       }

       // workspace
       var x = [];
       // vector with marks indicating a value x[i] exists in a given column
       var w = [];

       // update ptr
       cptr[0] = 0;
       // rows in b
       for (var ib = 0; ib < brows; ib++) {
         // b[ib]
         var vbi = bdata[ib];
         // check b[ib] != 0, avoid loops
         if (!eq(vbi, zero)) {
           // A values & index in ib column
           for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
             // a row
             var ia = aindex[ka];
             // check value exists in current j
             if (!w[ia]) {
               // ia is new entry in j
               w[ia] = true;
               // add i to pattern of C
               cindex.push(ia);
               // x(ia) = A
               x[ia] = mf(vbi, avalues[ka]);
             } else {
               // i exists in C already
               x[ia] = af(x[ia], mf(vbi, avalues[ka]));
             }
           }
         }
       }
       // copy values from x to column jb of c
       for (var p1 = cindex.length, p = 0; p < p1; p++) {
         // row
         var ic = cindex[p];
         // copy value
         cvalues[p] = x[ic];
       }
       // update ptr
       cptr[1] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [arows, 1],
         datatype: dt
       });
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            SparseMatrix      (MxN)
      * @param {Matrix} b            DenseMatrix       (NxC)
      *
      * @return {Matrix}             SparseMatrix      (MxC)
      */
     function _multiplySparseMatrixDenseMatrix(a, b) {
       // a sparse
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var adt = a._datatype;
       // validate a matrix
       if (!avalues) {
         throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
       }
       // b dense
       var bdata = b._data;
       var bdt = b._datatype;
       // rows & columns
       var arows = a._size[0];
       var brows = b._size[0];
       var bcolumns = b._size[1];

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;
       // equalScalar signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
       }

       // result
       var cvalues = [];
       var cindex = [];
       var cptr = [];
       // c matrix
       var c = a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [arows, bcolumns],
         datatype: dt
       });

       // workspace
       var x = [];
       // vector with marks indicating a value x[i] exists in a given column
       var w = [];

       // loop b columns
       for (var jb = 0; jb < bcolumns; jb++) {
         // update ptr
         cptr[jb] = cindex.length;
         // mark in workspace for current column
         var mark = jb + 1;
         // rows in jb
         for (var ib = 0; ib < brows; ib++) {
           // b[ib, jb]
           var vbij = bdata[ib][jb];
           // check b[ib, jb] != 0, avoid loops
           if (!eq(vbij, zero)) {
             // A values & index in ib column
             for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
               // a row
               var ia = aindex[ka];
               // check value exists in current j
               if (w[ia] !== mark) {
                 // ia is new entry in j
                 w[ia] = mark;
                 // add i to pattern of C
                 cindex.push(ia);
                 // x(ia) = A
                 x[ia] = mf(vbij, avalues[ka]);
               } else {
                 // i exists in C already
                 x[ia] = af(x[ia], mf(vbij, avalues[ka]));
               }
             }
           }
         }
         // copy values from x to column jb of c
         for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
           // row
           var ic = cindex[p];
           // copy value
           cvalues[p] = x[ic];
         }
       }
       // update ptr
       cptr[bcolumns] = cindex.length;

       // return sparse matrix
       return c;
     }

     /**
      * C = A * B
      *
      * @param {Matrix} a            SparseMatrix      (MxN)
      * @param {Matrix} b            SparseMatrix      (NxC)
      *
      * @return {Matrix}             SparseMatrix      (MxC)
      */
     function _multiplySparseMatrixSparseMatrix(a, b) {
       // a sparse
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var adt = a._datatype;
       // b sparse
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bdt = b._datatype;

       // rows & columns
       var arows = a._size[0];
       var bcolumns = b._size[1];
       // flag indicating both matrices (a & b) contain data
       var values = avalues && bvalues;

       // datatype
       var dt;
       // addScalar signature to use
       var af = addScalar;
       // multiplyScalar signature to use
       var mf = multiplyScalar;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         // datatype
         dt = adt;
         // find signatures that matches (dt, dt)
         af = typed.find(addScalar, [dt, dt]);
         mf = typed.find(multiplyScalar, [dt, dt]);
       }

       // result
       var cvalues = values ? [] : undefined;
       var cindex = [];
       var cptr = [];
       // c matrix
       var c = a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [arows, bcolumns],
         datatype: dt
       });

       // workspace
       var x = values ? [] : undefined;
       // vector with marks indicating a value x[i] exists in a given column
       var w = [];
       // variables
       var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
       // loop b columns
       for (var jb = 0; jb < bcolumns; jb++) {
         // update ptr
         cptr[jb] = cindex.length;
         // mark in workspace for current column
         var mark = jb + 1;
         // B values & index in j
         for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
           // b row
           ib = bindex[kb];
           // check we need to process values
           if (values) {
             // loop values in a[:,ib]
             for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
               // row
               ia = aindex[ka];
               // check value exists in current j
               if (w[ia] !== mark) {
                 // ia is new entry in j
                 w[ia] = mark;
                 // add i to pattern of C
                 cindex.push(ia);
                 // x(ia) = A
                 x[ia] = mf(bvalues[kb], avalues[ka]);
               } else {
                 // i exists in C already
                 x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
               }
             }
           } else {
             // loop values in a[:,ib]
             for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
               // row
               ia = aindex[ka];
               // check value exists in current j
               if (w[ia] !== mark) {
                 // ia is new entry in j
                 w[ia] = mark;
                 // add i to pattern of C
                 cindex.push(ia);
               }
             }
           }
         }
         // check we need to process matrix values (pattern matrix)
         if (values) {
           // copy values from x to column jb of c
           for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
             // row
             var ic = cindex[p];
             // copy value
             cvalues[p] = x[ic];
           }
         }
       }
       // update ptr
       cptr[bcolumns] = cindex.length;

       // return sparse matrix
       return c;
     }

     /**
      * Multiply two or more values, `x * y`.
      * For matrices, the matrix product is calculated.
      *
      * Syntax:
      *
      *    math.multiply(x, y)
      *    math.multiply(x, y, z, ...)
      *
      * Examples:
      *
      *    math.multiply(4, 5.2)        // returns number 20.8
      *    math.multiply(2, 3, 4)       // returns number 24
      *
      *    const a = math.complex(2, 3)
      *    const b = math.complex(4, 1)
      *    math.multiply(a, b)          // returns Complex 5 + 14i
      *
      *    const c = [[1, 2], [4, 3]]
      *    const d = [[1, 2, 3], [3, -4, 7]]
      *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
      *
      *    const e = math.unit('2.1 km')
      *    math.multiply(3, e)          // returns Unit 6.3 km
      *
      * See also:
      *
      *    divide, prod, cross, dot
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
      */
     return typed(name$3S, multiplyScalar, {
       // we extend the signatures of multiplyScalar with signatures dealing with matrices

       'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {
         // check dimensions
         _validateMatrixDimensions(arraySize(x), arraySize(y));

         // use dense matrix implementation
         var m = selfMM(matrix(x), matrix(y));
         // return array or scalar
         return isMatrix(m) ? m.valueOf() : m;
       }),
       'Matrix, Matrix': function MatrixMatrix(x, y) {
         // dimensions
         var xsize = x.size();
         var ysize = y.size();

         // check dimensions
         _validateMatrixDimensions(xsize, ysize);

         // process dimensions
         if (xsize.length === 1) {
           // process y dimensions
           if (ysize.length === 1) {
             // Vector * Vector
             return _multiplyVectorVector(x, y, xsize[0]);
           }
           // Vector * Matrix
           return _multiplyVectorMatrix(x, y);
         }
         // process y dimensions
         if (ysize.length === 1) {
           // Matrix * Vector
           return _multiplyMatrixVector(x, y);
         }
         // Matrix * Matrix
         return _multiplyMatrixMatrix(x, y);
       },
       'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),
       'Array, Matrix': typed.referToSelf(self => (x, y) => {
         // use Matrix * Matrix implementation
         return self(matrix(x, y.storage()), y);
       }),
       'SparseMatrix, any': function SparseMatrixAny(x, y) {
         return matAlgo11xS0s(x, y, multiplyScalar, false);
       },
       'DenseMatrix, any': function DenseMatrixAny(x, y) {
         return matAlgo14xDs(x, y, multiplyScalar, false);
       },
       'any, SparseMatrix': function anySparseMatrix(x, y) {
         return matAlgo11xS0s(y, x, multiplyScalar, true);
       },
       'any, DenseMatrix': function anyDenseMatrix(x, y) {
         return matAlgo14xDs(y, x, multiplyScalar, true);
       },
       'Array, any': function ArrayAny(x, y) {
         // use matrix implementation
         return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();
       },
       'any, Array': function anyArray(x, y) {
         // use matrix implementation
         return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();
       },
       'any, any': multiplyScalar,
       'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {
         var result = self(x, y);
         for (var i = 0; i < rest.length; i++) {
           result = self(result, rest[i]);
         }
         return result;
       })
     });
   });

   var name$3R = 'nthRoot';
   var dependencies$3R = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'concat'];
   var createNthRoot = /* #__PURE__ */factory(name$3R, dependencies$3R, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       BigNumber: _BigNumber,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo06xS0S0 = createMatAlgo06xS0S0({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Calculate the nth root of a value.
      * The principal nth root of a positive real number A, is the positive real
      * solution of the equation
      *
      *     x^root = A
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *     math.nthRoot(a)
      *     math.nthRoot(a, root)
      *
      * Examples:
      *
      *     math.nthRoot(9, 2)    // returns 3 (since 3^2 == 9)
      *     math.sqrt(9)          // returns 3 (since 3^2 == 9)
      *     math.nthRoot(64, 3)   // returns 4 (since 4^3 == 64)
      *
      * See also:
      *
      *     sqrt, pow
      *
      * @param {number | BigNumber | Array | Matrix | Complex} a
      *              Value for which to calculate the nth root
      * @param {number | BigNumber} [root=2]    The root.
      * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
      */
     function complexErr() {
       throw new Error('Complex number not supported in function nthRoot. Use nthRoots instead.');
     }
     return typed(name$3R, {
       number: nthRootNumber,
       'number, number': nthRootNumber,
       BigNumber: x => _bigNthRoot(x, new _BigNumber(2)),
       'BigNumber, BigNumber': _bigNthRoot,
       Complex: complexErr,
       'Complex, number': complexErr,
       Array: typed.referTo('DenseMatrix,number', selfDn => x => selfDn(matrix(x), 2).valueOf()),
       DenseMatrix: typed.referTo('DenseMatrix,number', selfDn => x => selfDn(x, 2)),
       SparseMatrix: typed.referTo('SparseMatrix,number', selfSn => x => selfSn(x, 2)),
       'SparseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // density must be one (no zeros in matrix)
         if (y.density() === 1) {
           // sparse + sparse
           return matAlgo06xS0S0(x, y, self);
         } else {
           // throw exception
           throw new Error('Root must be non-zero');
         }
       }),
       'DenseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // density must be one (no zeros in matrix)
         if (y.density() === 1) {
           // dense + sparse
           return matAlgo01xDSid(x, y, self, false);
         } else {
           // throw exception
           throw new Error('Root must be non-zero');
         }
       }),
       'Array, SparseMatrix': typed.referTo('DenseMatrix,SparseMatrix', selfDS => (x, y) => selfDS(matrix(x), y)),
       'number | BigNumber, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // density must be one (no zeros in matrix)
         if (y.density() === 1) {
           // sparse - scalar
           return matAlgo11xS0s(y, x, self, true);
         } else {
           // throw exception
           throw new Error('Root must be non-zero');
         }
       })
     }, matrixAlgorithmSuite({
       scalar: 'number | BigNumber',
       SD: matAlgo02xDS0,
       Ss: matAlgo11xS0s,
       sS: false
     }));

     /**
      * Calculate the nth root of a for BigNumbers, solve x^root == a
      * https://rosettacode.org/wiki/Nth_root#JavaScript
      * @param {BigNumber} a
      * @param {BigNumber} root
      * @private
      */
     function _bigNthRoot(a, root) {
       var precision = _BigNumber.precision;
       var Big = _BigNumber.clone({
         precision: precision + 2
       });
       var zero = new _BigNumber(0);
       var one = new Big(1);
       var inv = root.isNegative();
       if (inv) {
         root = root.neg();
       }
       if (root.isZero()) {
         throw new Error('Root must be non-zero');
       }
       if (a.isNegative() && !root.abs().mod(2).equals(1)) {
         throw new Error('Root must be odd when a is negative.');
       }

       // edge cases zero and infinity
       if (a.isZero()) {
         return inv ? new Big(Infinity) : 0;
       }
       if (!a.isFinite()) {
         return inv ? zero : a;
       }
       var x = a.abs().pow(one.div(root));
       // If a < 0, we require that root is an odd integer,
       // so (-1) ^ (1/root) = -1
       x = a.isNeg() ? x.neg() : x;
       return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
     }
   });

   var name$3Q = 'sign';
   var dependencies$3Q = ['typed', 'BigNumber', 'Fraction', 'complex'];
   var createSign = /* #__PURE__ */factory(name$3Q, dependencies$3Q, _ref => {
     var {
       typed,
       BigNumber: _BigNumber,
       complex,
       Fraction: _Fraction
     } = _ref;
     /**
      * Compute the sign of a value. The sign of a value x is:
      *
      * -  1 when x > 0
      * - -1 when x < 0
      * -  0 when x == 0
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.sign(x)
      *
      * Examples:
      *
      *    math.sign(3.5)               // returns 1
      *    math.sign(-4.2)              // returns -1
      *    math.sign(0)                 // returns 0
      *
      *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
      *
      * See also:
      *
      *    abs
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
      *            The number for which to determine the sign
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
      *            The sign of `x`
      */
     return typed(name$3Q, {
       number: signNumber,
       Complex: function Complex(x) {
         return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(x.cmp(0));
       },
       Fraction: function Fraction(x) {
         return new _Fraction(x.s, 1);
       },
       // deep map collection, skip zeros since sign(0) = 0
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),
       Unit: typed.referToSelf(self => x => {
         if (!x._isDerived() && x.units[0].unit.offset !== 0) {
           throw new TypeError('sign is ambiguous for units with offset');
         }
         return typed.find(self, x.valueType())(x.value);
       })
     });
   });

   var name$3P = 'sqrt';
   var dependencies$3P = ['config', 'typed', 'Complex'];
   var createSqrt = /* #__PURE__ */factory(name$3P, dependencies$3P, _ref => {
     var {
       config,
       typed,
       Complex
     } = _ref;
     /**
      * Calculate the square root of a value.
      *
      * For matrices, if you want the matrix square root of a square matrix,
      * use the `sqrtm` function. If you wish to apply `sqrt` elementwise to
      * a matrix M, use `math.map(M, math.sqrt)`.
      *
      * Syntax:
      *
      *    math.sqrt(x)
      *
      * Examples:
      *
      *    math.sqrt(25)                // returns 5
      *    math.square(5)               // returns 25
      *    math.sqrt(-4)                // returns Complex 2i
      *
      * See also:
      *
      *    square, multiply, cube, cbrt, sqrtm
      *
      * @param {number | BigNumber | Complex | Unit} x
      *            Value for which to calculate the square root.
      * @return {number | BigNumber | Complex | Unit}
      *            Returns the square root of `x`
      */
     return typed('sqrt', {
       number: _sqrtNumber,
       Complex: function Complex(x) {
         return x.sqrt();
       },
       BigNumber: function BigNumber(x) {
         if (!x.isNegative() || config.predictable) {
           return x.sqrt();
         } else {
           // negative value -> downgrade to number to do complex value computation
           return _sqrtNumber(x.toNumber());
         }
       },
       Unit: function Unit(x) {
         // Someday will work for complex units when they are implemented
         return x.pow(0.5);
       }
     });

     /**
      * Calculate sqrt for a number
      * @param {number} x
      * @returns {number | Complex} Returns the square root of x
      * @private
      */
     function _sqrtNumber(x) {
       if (isNaN(x)) {
         return NaN;
       } else if (x >= 0 || config.predictable) {
         return Math.sqrt(x);
       } else {
         return new Complex(x, 0).sqrt();
       }
     }
   });

   var name$3O = 'square';
   var dependencies$3O = ['typed'];
   var createSquare = /* #__PURE__ */factory(name$3O, dependencies$3O, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the square of a value, `x * x`.
      * To avoid confusion with multiplying a square matrix by itself,
      * this function does not apply to matrices. If you wish to square
      * every element of a matrix, see the examples.
      *
      * Syntax:
      *
      *    math.square(x)
      *
      * Examples:
      *
      *    math.square(2)           // returns number 4
      *    math.square(3)           // returns number 9
      *    math.pow(3, 2)           // returns number 9
      *    math.multiply(3, 3)      // returns number 9
      *
      *    math.map([1, 2, 3, 4], math.square)  // returns Array [1, 4, 9, 16]
      *
      * See also:
      *
      *    multiply, cube, sqrt, pow
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit} x
      *            Number for which to calculate the square
      * @return {number | BigNumber | Fraction | Complex | Unit}
      *            Squared value
      */
     return typed(name$3O, {
       number: squareNumber,
       Complex: function Complex(x) {
         return x.mul(x);
       },
       BigNumber: function BigNumber(x) {
         return x.times(x);
       },
       Fraction: function Fraction(x) {
         return x.mul(x);
       },
       Unit: function Unit(x) {
         return x.pow(2);
       }
     });
   });

   var name$3N = 'subtract';
   var dependencies$3N = ['typed', 'matrix', 'equalScalar', 'addScalar', 'unaryMinus', 'DenseMatrix', 'concat'];
   var createSubtract = /* #__PURE__ */factory(name$3N, dependencies$3N, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       addScalar,
       unaryMinus,
       DenseMatrix,
       concat
     } = _ref;
     // TODO: split function subtract in two: subtract and subtractScalar

     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo05xSfSf = createMatAlgo05xSfSf({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Subtract two values, `x - y`.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.subtract(x, y)
      *
      * Examples:
      *
      *    math.subtract(5.3, 2)        // returns number 3.3
      *
      *    const a = math.complex(2, 3)
      *    const b = math.complex(4, 1)
      *    math.subtract(a, b)          // returns Complex -2 + 2i
      *
      *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
      *
      *    const c = math.unit('2.1 km')
      *    const d = math.unit('500m')
      *    math.subtract(c, d)          // returns Unit 1.6 km
      *
      * See also:
      *
      *    add
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
      *            Initial value
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
      *            Value to subtract from `x`
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
      *            Subtraction of `x` and `y`
      */
     return typed(name$3N, {
       'number, number': (x, y) => x - y,
       'Complex, Complex': (x, y) => x.sub(y),
       'BigNumber, BigNumber': (x, y) => x.minus(y),
       'Fraction, Fraction': (x, y) => x.sub(y),
       'Unit, Unit': typed.referToSelf(self => (x, y) => {
         if (x.value === null) {
           throw new Error('Parameter x contains a unit with undefined value');
         }
         if (y.value === null) {
           throw new Error('Parameter y contains a unit with undefined value');
         }
         if (!x.equalBase(y)) {
           throw new Error('Units do not match');
         }
         var res = x.clone();
         res.value = typed.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
         res.fixPrefix = false;
         return res;
       })
     }, matrixAlgorithmSuite({
       SS: matAlgo05xSfSf,
       DS: matAlgo01xDSid,
       SD: matAlgo03xDSf,
       Ss: matAlgo12xSfs,
       sS: matAlgo10xSids
     }));
   });

   var name$3M = 'xgcd';
   var dependencies$3M = ['typed', 'config', 'matrix', 'BigNumber'];
   var createXgcd = /* #__PURE__ */factory(name$3M, dependencies$3M, _ref => {
     var {
       typed,
       config,
       matrix,
       BigNumber
     } = _ref;
     /**
      * Calculate the extended greatest common divisor for two values.
      * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
      *
      * Syntax:
      *
      *    math.xgcd(a, b)
      *
      * Examples:
      *
      *    math.xgcd(8, 12)             // returns [4, -1, 1]
      *    math.gcd(8, 12)              // returns 4
      *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]
      *
      * See also:
      *
      *    gcd, lcm
      *
      * @param {number | BigNumber} a  An integer number
      * @param {number | BigNumber} b  An integer number
      * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
      *                              where `div = gcd(a, b)` and `a*m + b*n = div`
      */
     return typed(name$3M, {
       'number, number': function numberNumber(a, b) {
         var res = xgcdNumber(a, b);
         return config.matrix === 'Array' ? res : matrix(res);
       },
       'BigNumber, BigNumber': _xgcdBigNumber
       // TODO: implement support for Fraction
     });

     /**
      * Calculate xgcd for two BigNumbers
      * @param {BigNumber} a
      * @param {BigNumber} b
      * @return {BigNumber[]} result
      * @private
      */
     function _xgcdBigNumber(a, b) {
       // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
       var
       // used to swap two variables
       t;
       var
       // quotient
       q;
       var
       // remainder
       r;
       var zero = new BigNumber(0);
       var one = new BigNumber(1);
       var x = zero;
       var lastx = one;
       var y = one;
       var lasty = zero;
       if (!a.isInt() || !b.isInt()) {
         throw new Error('Parameters in function xgcd must be integer numbers');
       }
       while (!b.isZero()) {
         q = a.div(b).floor();
         r = a.mod(b);
         t = x;
         x = lastx.minus(q.times(x));
         lastx = t;
         t = y;
         y = lasty.minus(q.times(y));
         lasty = t;
         a = b;
         b = r;
       }
       var res;
       if (a.lt(zero)) {
         res = [a.neg(), lastx.neg(), lasty.neg()];
       } else {
         res = [a, !a.isZero() ? lastx : 0, lasty];
       }
       return config.matrix === 'Array' ? res : matrix(res);
     }
   });

   var name$3L = 'invmod';
   var dependencies$3L = ['typed', 'config', 'BigNumber', 'xgcd', 'equal', 'smaller', 'mod', 'add', 'isInteger'];
   var createInvmod = /* #__PURE__ */factory(name$3L, dependencies$3L, _ref => {
     var {
       typed,
       config,
       BigNumber,
       xgcd,
       equal,
       smaller,
       mod,
       add,
       isInteger
     } = _ref;
     /**
      * Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation `ax ≣ 1 (mod b)`
      * See https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.
      *
      * Syntax:
      *
      *    math.invmod(a, b)
      *
      * Examples:
      *
      *    math.invmod(8, 12)             // returns NaN
      *    math.invmod(7, 13)             // returns 2
      *    math.invmod(15151, 15122)      // returns 10429
      *
      * See also:
      *
      *    gcd, xgcd
      *
      * @param {number | BigNumber} a  An integer number
      * @param {number | BigNumber} b  An integer number
      * @return {number | BigNumber }  Returns an integer number
      *                              where `invmod(a,b)*a ≣ 1 (mod b)`
      */
     return typed(name$3L, {
       'number, number': invmod,
       'BigNumber, BigNumber': invmod
     });
     function invmod(a, b) {
       if (!isInteger(a) || !isInteger(b)) throw new Error('Parameters in function invmod must be integer numbers');
       a = mod(a, b);
       if (equal(b, 0)) throw new Error('Divisor must be non zero');
       var res = xgcd(a, b);
       res = res.valueOf();
       var [gcd, inv] = res;
       if (!equal(gcd, BigNumber(1))) return NaN;
       inv = mod(inv, b);
       if (smaller(inv, BigNumber(0))) inv = add(inv, b);
       return inv;
     }
   });

   var name$3K = 'matAlgo09xS0Sf';
   var dependencies$3K = ['typed', 'equalScalar'];
   var createMatAlgo09xS0Sf = /* #__PURE__ */factory(name$3K, dependencies$3K, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij).
      * Callback function invoked NZA times, number of nonzero elements in A.
      *
      *
      *          ┌  f(Aij, Bij)  ; A(i,j) !== 0
      * C(i,j) = ┤
      *          └  0            ; otherwise
      *
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo09xS0Sf(a, b, callback) {
       // sparse matrix arrays
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = avalues && bvalues ? [] : undefined;
       var cindex = [];
       var cptr = [];

       // workspaces
       var x = cvalues ? [] : undefined;
       // marks indicating we have a value in x for a given column
       var w = [];

       // vars
       var i, j, k, k0, k1;

       // loop columns
       for (j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // column mark
         var mark = j + 1;
         // check we need to process values
         if (x) {
           // loop B(:,j)
           for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
             // row
             i = bindex[k];
             // update workspace
             w[i] = mark;
             x[i] = bvalues[k];
           }
         }
         // loop A(:,j)
         for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = aindex[k];
           // check we need to process values
           if (x) {
             // b value @ i,j
             var vb = w[i] === mark ? x[i] : zero;
             // invoke f
             var vc = cf(avalues[k], vb);
             // check zero value
             if (!eq(vc, zero)) {
               // push index
               cindex.push(i);
               // push value
               cvalues.push(vc);
             }
           } else {
             // push index
             cindex.push(i);
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var name$3J = 'dotMultiply';
   var dependencies$3J = ['typed', 'matrix', 'equalScalar', 'multiplyScalar', 'concat'];
   var createDotMultiply = /* #__PURE__ */factory(name$3J, dependencies$3J, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       multiplyScalar,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Multiply two matrices element wise. The function accepts both matrices and
      * scalar values.
      *
      * Syntax:
      *
      *    math.dotMultiply(x, y)
      *
      * Examples:
      *
      *    math.dotMultiply(2, 4) // returns 8
      *
      *    a = [[9, 5], [6, 1]]
      *    b = [[3, 2], [5, 2]]
      *
      *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
      *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]
      *
      * See also:
      *
      *    multiply, divide, dotDivide
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
      */
     return typed(name$3J, matrixAlgorithmSuite({
       elop: multiplyScalar,
       SS: matAlgo09xS0Sf,
       DS: matAlgo02xDS0,
       Ss: matAlgo11xS0s
     }));
   });

   /**
    * Bitwise and for Bignumbers
    *
    * Special Cases:
    *   N &  n =  N
    *   n &  0 =  0
    *   n & -1 =  n
    *   n &  n =  n
    *   I &  I =  I
    *  -I & -I = -I
    *   I & -I =  0
    *   I &  n =  n
    *   I & -n =  I
    *  -I &  n =  0
    *  -I & -n = -I
    *
    * @param {BigNumber} x
    * @param {BigNumber} y
    * @return {BigNumber} Result of `x` & `y`, is fully precise
    * @private
    */
   function bitAndBigNumber(x, y) {
     if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
       throw new Error('Integers expected in function bitAnd');
     }
     var BigNumber = x.constructor;
     if (x.isNaN() || y.isNaN()) {
       return new BigNumber(NaN);
     }
     if (x.isZero() || y.eq(-1) || x.eq(y)) {
       return x;
     }
     if (y.isZero() || x.eq(-1)) {
       return y;
     }
     if (!x.isFinite() || !y.isFinite()) {
       if (!x.isFinite() && !y.isFinite()) {
         if (x.isNegative() === y.isNegative()) {
           return x;
         }
         return new BigNumber(0);
       }
       if (!x.isFinite()) {
         if (y.isNegative()) {
           return x;
         }
         if (x.isNegative()) {
           return new BigNumber(0);
         }
         return y;
       }
       if (!y.isFinite()) {
         if (x.isNegative()) {
           return y;
         }
         if (y.isNegative()) {
           return new BigNumber(0);
         }
         return x;
       }
     }
     return bitwise(x, y, function (a, b) {
       return a & b;
     });
   }

   /**
    * Bitwise not
    * @param {BigNumber} x
    * @return {BigNumber} Result of ~`x`, fully precise
    *
    */
   function bitNotBigNumber(x) {
     if (x.isFinite() && !x.isInteger()) {
       throw new Error('Integer expected in function bitNot');
     }
     var BigNumber = x.constructor;
     var prevPrec = BigNumber.precision;
     BigNumber.config({
       precision: 1E9
     });
     var result = x.plus(new BigNumber(1));
     result.s = -result.s || null;
     BigNumber.config({
       precision: prevPrec
     });
     return result;
   }

   /**
    * Bitwise OR for BigNumbers
    *
    * Special Cases:
    *   N |  n =  N
    *   n |  0 =  n
    *   n | -1 = -1
    *   n |  n =  n
    *   I |  I =  I
    *  -I | -I = -I
    *   I | -n = -1
    *   I | -I = -1
    *   I |  n =  I
    *  -I |  n = -I
    *  -I | -n = -n
    *
    * @param {BigNumber} x
    * @param {BigNumber} y
    * @return {BigNumber} Result of `x` | `y`, fully precise
    */
   function bitOrBigNumber(x, y) {
     if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
       throw new Error('Integers expected in function bitOr');
     }
     var BigNumber = x.constructor;
     if (x.isNaN() || y.isNaN()) {
       return new BigNumber(NaN);
     }
     var negOne = new BigNumber(-1);
     if (x.isZero() || y.eq(negOne) || x.eq(y)) {
       return y;
     }
     if (y.isZero() || x.eq(negOne)) {
       return x;
     }
     if (!x.isFinite() || !y.isFinite()) {
       if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
         return negOne;
       }
       if (x.isNegative() && y.isNegative()) {
         return x.isFinite() ? x : y;
       }
       return x.isFinite() ? y : x;
     }
     return bitwise(x, y, function (a, b) {
       return a | b;
     });
   }

   /**
    * Applies bitwise function to numbers
    * @param {BigNumber} x
    * @param {BigNumber} y
    * @param {function (a, b)} func
    * @return {BigNumber}
    */
   function bitwise(x, y, func) {
     var BigNumber = x.constructor;
     var xBits, yBits;
     var xSign = +(x.s < 0);
     var ySign = +(y.s < 0);
     if (xSign) {
       xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
       for (var i = 0; i < xBits.length; ++i) {
         xBits[i] ^= 1;
       }
     } else {
       xBits = decCoefficientToBinaryString(x);
     }
     if (ySign) {
       yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
       for (var _i = 0; _i < yBits.length; ++_i) {
         yBits[_i] ^= 1;
       }
     } else {
       yBits = decCoefficientToBinaryString(y);
     }
     var minBits, maxBits, minSign;
     if (xBits.length <= yBits.length) {
       minBits = xBits;
       maxBits = yBits;
       minSign = xSign;
     } else {
       minBits = yBits;
       maxBits = xBits;
       minSign = ySign;
     }
     var shortLen = minBits.length;
     var longLen = maxBits.length;
     var expFuncVal = func(xSign, ySign) ^ 1;
     var outVal = new BigNumber(expFuncVal ^ 1);
     var twoPower = new BigNumber(1);
     var two = new BigNumber(2);
     var prevPrec = BigNumber.precision;
     BigNumber.config({
       precision: 1E9
     });
     while (shortLen > 0) {
       if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
         outVal = outVal.plus(twoPower);
       }
       twoPower = twoPower.times(two);
     }
     while (longLen > 0) {
       if (func(minSign, maxBits[--longLen]) === expFuncVal) {
         outVal = outVal.plus(twoPower);
       }
       twoPower = twoPower.times(two);
     }
     BigNumber.config({
       precision: prevPrec
     });
     if (expFuncVal === 0) {
       outVal.s = -outVal.s;
     }
     return outVal;
   }

   /* Extracted from decimal.js, and edited to specialize. */
   function decCoefficientToBinaryString(x) {
     // Convert to string
     var a = x.d; // array with digits
     var r = a[0] + '';
     for (var i = 1; i < a.length; ++i) {
       var s = a[i] + '';
       for (var z = 7 - s.length; z--;) {
         s = '0' + s;
       }
       r += s;
     }
     var j = r.length;
     while (r.charAt(j) === '0') {
       j--;
     }
     var xe = x.e;
     var str = r.slice(0, j + 1 || 1);
     var strL = str.length;
     if (xe > 0) {
       if (++xe > strL) {
         // Append zeros.
         xe -= strL;
         while (xe--) {
           str += '0';
         }
       } else if (xe < strL) {
         str = str.slice(0, xe) + '.' + str.slice(xe);
       }
     }

     // Convert from base 10 (decimal) to base 2
     var arr = [0];
     for (var _i2 = 0; _i2 < str.length;) {
       var arrL = arr.length;
       while (arrL--) {
         arr[arrL] *= 10;
       }
       arr[0] += parseInt(str.charAt(_i2++)); // convert to int
       for (var _j = 0; _j < arr.length; ++_j) {
         if (arr[_j] > 1) {
           if (arr[_j + 1] === null || arr[_j + 1] === undefined) {
             arr[_j + 1] = 0;
           }
           arr[_j + 1] += arr[_j] >> 1;
           arr[_j] &= 1;
         }
       }
     }
     return arr.reverse();
   }

   /**
    * Bitwise XOR for BigNumbers
    *
    * Special Cases:
    *   N ^  n =  N
    *   n ^  0 =  n
    *   n ^  n =  0
    *   n ^ -1 = ~n
    *   I ^  n =  I
    *   I ^ -n = -I
    *   I ^ -I = -1
    *  -I ^  n = -I
    *  -I ^ -n =  I
    *
    * @param {BigNumber} x
    * @param {BigNumber} y
    * @return {BigNumber} Result of `x` ^ `y`, fully precise
    *
    */
   function bitXor$1(x, y) {
     if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
       throw new Error('Integers expected in function bitXor');
     }
     var BigNumber = x.constructor;
     if (x.isNaN() || y.isNaN()) {
       return new BigNumber(NaN);
     }
     if (x.isZero()) {
       return y;
     }
     if (y.isZero()) {
       return x;
     }
     if (x.eq(y)) {
       return new BigNumber(0);
     }
     var negOne = new BigNumber(-1);
     if (x.eq(negOne)) {
       return bitNotBigNumber(y);
     }
     if (y.eq(negOne)) {
       return bitNotBigNumber(x);
     }
     if (!x.isFinite() || !y.isFinite()) {
       if (!x.isFinite() && !y.isFinite()) {
         return negOne;
       }
       return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
     }
     return bitwise(x, y, function (a, b) {
       return a ^ b;
     });
   }

   /**
    * Bitwise left shift
    *
    * Special Cases:
    *  n << -n = N
    *  n <<  N = N
    *  N <<  n = N
    *  n <<  0 = n
    *  0 <<  n = 0
    *  I <<  I = N
    *  I <<  n = I
    *  n <<  I = I
    *
    * @param {BigNumber} x
    * @param {BigNumber} y
    * @return {BigNumber} Result of `x` << `y`
    *
    */
   function leftShiftBigNumber(x, y) {
     if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
       throw new Error('Integers expected in function leftShift');
     }
     var BigNumber = x.constructor;
     if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
       return new BigNumber(NaN);
     }
     if (x.isZero() || y.isZero()) {
       return x;
     }
     if (!x.isFinite() && !y.isFinite()) {
       return new BigNumber(NaN);
     }

     // Math.pow(2, y) is fully precise for y < 55, and fast
     if (y.lt(55)) {
       return x.times(Math.pow(2, y.toNumber()) + '');
     }
     return x.times(new BigNumber(2).pow(y));
   }

   /*
    * Special Cases:
    *   n >> -n =  N
    *   n >>  N =  N
    *   N >>  n =  N
    *   I >>  I =  N
    *   n >>  0 =  n
    *   I >>  n =  I
    *  -I >>  n = -I
    *  -I >>  I = -I
    *   n >>  I =  I
    *  -n >>  I = -1
    *   0 >>  n =  0
    *
    * @param {BigNumber} value
    * @param {BigNumber} value
    * @return {BigNumber} Result of `x` >> `y`
    *
    */
   function rightArithShiftBigNumber(x, y) {
     if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
       throw new Error('Integers expected in function rightArithShift');
     }
     var BigNumber = x.constructor;
     if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
       return new BigNumber(NaN);
     }
     if (x.isZero() || y.isZero()) {
       return x;
     }
     if (!y.isFinite()) {
       if (x.isNegative()) {
         return new BigNumber(-1);
       }
       if (!x.isFinite()) {
         return new BigNumber(NaN);
       }
       return new BigNumber(0);
     }

     // Math.pow(2, y) is fully precise for y < 55, and fast
     if (y.lt(55)) {
       return x.div(Math.pow(2, y.toNumber()) + '').floor();
     }
     return x.div(new BigNumber(2).pow(y)).floor();
   }

   var name$3I = 'bitAnd';
   var dependencies$3I = ['typed', 'matrix', 'equalScalar', 'concat'];
   var createBitAnd = /* #__PURE__ */factory(name$3I, dependencies$3I, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo06xS0S0 = createMatAlgo06xS0S0({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Bitwise AND two values, `x & y`.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.bitAnd(x, y)
      *
      * Examples:
      *
      *    math.bitAnd(53, 131)               // returns number 1
      *
      *    math.bitAnd([1, 12, 31], 42)       // returns Array [0, 8, 10]
      *
      * See also:
      *
      *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x First value to and
      * @param  {number | BigNumber | Array | Matrix} y Second value to and
      * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`
      */
     return typed(name$3I, {
       'number, number': bitAndNumber,
       'BigNumber, BigNumber': bitAndBigNumber
     }, matrixAlgorithmSuite({
       SS: matAlgo06xS0S0,
       DS: matAlgo02xDS0,
       Ss: matAlgo11xS0s
     }));
   });

   var name$3H = 'bitNot';
   var dependencies$3H = ['typed'];
   var createBitNot = /* #__PURE__ */factory(name$3H, dependencies$3H, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Bitwise NOT value, `~x`.
      * For matrices, the function is evaluated element wise.
      * For units, the function is evaluated on the best prefix base.
      *
      * Syntax:
      *
      *    math.bitNot(x)
      *
      * Examples:
      *
      *    math.bitNot(1)               // returns number -2
      *
      *    math.bitNot([2, -3, 4])      // returns Array [-3, 2, -5]
      *
      * See also:
      *
      *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x Value to not
      * @return {number | BigNumber | Array | Matrix} NOT of `x`
      */
     return typed(name$3H, {
       number: bitNotNumber,
       BigNumber: bitNotBigNumber,
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3G = 'bitOr';
   var dependencies$3G = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];
   var createBitOr = /* #__PURE__ */factory(name$3G, dependencies$3G, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo04xSidSid = createMatAlgo04xSidSid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Bitwise OR two values, `x | y`.
      * For matrices, the function is evaluated element wise.
      * For units, the function is evaluated on the lowest print base.
      *
      * Syntax:
      *
      *    math.bitOr(x, y)
      *
      * Examples:
      *
      *    math.bitOr(1, 2)               // returns number 3
      *
      *    math.bitOr([1, 2, 3], 4)       // returns Array [5, 6, 7]
      *
      * See also:
      *
      *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x First value to or
      * @param  {number | BigNumber | Array | Matrix} y Second value to or
      * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`
      */
     return typed(name$3G, {
       'number, number': bitOrNumber,
       'BigNumber, BigNumber': bitOrBigNumber
     }, matrixAlgorithmSuite({
       SS: matAlgo04xSidSid,
       DS: matAlgo01xDSid,
       Ss: matAlgo10xSids
     }));
   });

   var name$3F = 'matAlgo07xSSf';
   var dependencies$3F = ['typed', 'DenseMatrix'];
   var createMatAlgo07xSSf = /* #__PURE__ */factory(name$3F, dependencies$3F, _ref => {
     var {
       typed,
       DenseMatrix
     } = _ref;
     /**
      * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
      * Callback function invoked MxN times.
      *
      * C(i,j) = f(Aij, Bij)
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    DenseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo07xSSf(a, b, callback) {
       // sparse matrix arrays
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // vars
       var i, j;

       // result arrays
       var cdata = [];
       // initialize c
       for (i = 0; i < rows; i++) {
         cdata[i] = [];
       }

       // workspaces
       var xa = [];
       var xb = [];
       // marks indicating we have a value in x for a given column
       var wa = [];
       var wb = [];

       // loop columns
       for (j = 0; j < columns; j++) {
         // columns mark
         var mark = j + 1;
         // scatter the values of A(:,j) into workspace
         _scatter(a, j, wa, xa, mark);
         // scatter the values of B(:,j) into workspace
         _scatter(b, j, wb, xb, mark);
         // loop rows
         for (i = 0; i < rows; i++) {
           // matrix values @ i,j
           var va = wa[i] === mark ? xa[i] : zero;
           var vb = wb[i] === mark ? xb[i] : zero;
           // invoke callback
           cdata[i][j] = cf(va, vb);
         }
       }

       // return dense matrix
       return new DenseMatrix({
         data: cdata,
         size: [rows, columns],
         datatype: dt
       });
     };
     function _scatter(m, j, w, x, mark) {
       // a arrays
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;
       // loop values in column j
       for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
         // row
         var i = index[k];
         // update workspace
         w[i] = mark;
         x[i] = values[k];
       }
     }
   });

   var name$3E = 'bitXor';
   var dependencies$3E = ['typed', 'matrix', 'DenseMatrix', 'concat'];
   var createBitXor = /* #__PURE__ */factory(name$3E, dependencies$3E, _ref => {
     var {
       typed,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Bitwise XOR two values, `x ^ y`.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.bitXor(x, y)
      *
      * Examples:
      *
      *    math.bitXor(1, 2)               // returns number 3
      *
      *    math.bitXor([2, 3, 4], 4)       // returns Array [6, 7, 0]
      *
      * See also:
      *
      *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x First value to xor
      * @param  {number | BigNumber | Array | Matrix} y Second value to xor
      * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`
      */
     return typed(name$3E, {
       'number, number': bitXorNumber,
       'BigNumber, BigNumber': bitXor$1
     }, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });

   var name$3D = 'arg';
   var dependencies$3D = ['typed'];
   var createArg = /* #__PURE__ */factory(name$3D, dependencies$3D, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the argument of a complex value.
      * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.arg(x)
      *
      * Examples:
      *
      *    const a = math.complex(2, 2)
      *    math.arg(a) / math.pi          // returns number 0.25
      *
      *    const b = math.complex('2 + 3i')
      *    math.arg(b)                    // returns number 0.982793723247329
      *    math.atan2(3, 2)               // returns number 0.982793723247329
      *
      * See also:
      *
      *    re, im, conj, abs
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            A complex number or array with complex numbers
      * @return {number | BigNumber | Array | Matrix} The argument of x
      */
     return typed(name$3D, {
       number: function number(x) {
         return Math.atan2(0, x);
       },
       BigNumber: function BigNumber(x) {
         return x.constructor.atan2(0, x);
       },
       Complex: function Complex(x) {
         return x.arg();
       },
       // TODO: implement BigNumber support for function arg

       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3C = 'conj';
   var dependencies$3C = ['typed'];
   var createConj = /* #__PURE__ */factory(name$3C, dependencies$3C, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the complex conjugate of a complex value.
      * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.conj(x)
      *
      * Examples:
      *
      *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
      *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
      *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
      *
      * See also:
      *
      *    re, im, arg, abs
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            A complex number or array with complex numbers
      * @return {number | BigNumber | Complex | Array | Matrix}
      *            The complex conjugate of x
      */
     return typed(name$3C, {
       'number | BigNumber | Fraction': x => x,
       Complex: x => x.conjugate(),
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3B = 'im';
   var dependencies$3B = ['typed'];
   var createIm = /* #__PURE__ */factory(name$3B, dependencies$3B, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Get the imaginary part of a complex number.
      * For a complex number `a + bi`, the function returns `b`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.im(x)
      *
      * Examples:
      *
      *    const a = math.complex(2, 3)
      *    math.re(a)                     // returns number 2
      *    math.im(a)                     // returns number 3
      *
      *    math.re(math.complex('-5.2i')) // returns number -5.2
      *    math.re(math.complex(2.4))     // returns number 0
      *
      * See also:
      *
      *    re, conj, abs, arg
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            A complex number or array with complex numbers
      * @return {number | BigNumber | Array | Matrix} The imaginary part of x
      */
     return typed(name$3B, {
       number: () => 0,
       'BigNumber | Fraction': x => x.mul(0),
       Complex: x => x.im,
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3A = 're';
   var dependencies$3A = ['typed'];
   var createRe = /* #__PURE__ */factory(name$3A, dependencies$3A, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Get the real part of a complex number.
      * For a complex number `a + bi`, the function returns `a`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.re(x)
      *
      * Examples:
      *
      *    const a = math.complex(2, 3)
      *    math.re(a)                     // returns number 2
      *    math.im(a)                     // returns number 3
      *
      *    math.re(math.complex('-5.2i')) // returns number 0
      *    math.re(math.complex(2.4))     // returns number 2.4
      *
      * See also:
      *
      *    im, conj, abs, arg
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            A complex number or array with complex numbers
      * @return {number | BigNumber | Array | Matrix} The real part of x
      */
     return typed(name$3A, {
       'number | BigNumber | Fraction': x => x,
       Complex: x => x.re,
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3z = 'not';
   var dependencies$3z = ['typed'];
   var createNot = /* #__PURE__ */factory(name$3z, dependencies$3z, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Logical `not`. Flips boolean value of a given parameter.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.not(x)
      *
      * Examples:
      *
      *    math.not(2)      // returns false
      *    math.not(0)      // returns true
      *    math.not(true)   // returns false
      *
      *    a = [2, -7, 0]
      *    math.not(a)      // returns [false, false, true]
      *
      * See also:
      *
      *    and, or, xor
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
      * @return {boolean | Array | Matrix}
      *            Returns true when input is a zero or empty value.
      */
     return typed(name$3z, {
       'null | undefined': () => true,
       number: notNumber,
       Complex: function Complex(x) {
         return x.re === 0 && x.im === 0;
       },
       BigNumber: function BigNumber(x) {
         return x.isZero() || x.isNaN();
       },
       Unit: typed.referToSelf(self => x => typed.find(self, x.valueType())(x.value)),
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$3y = 'or';
   var dependencies$3y = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];
   var createOr = /* #__PURE__ */factory(name$3y, dependencies$3y, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo05xSfSf = createMatAlgo05xSfSf({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.or(x, y)
      *
      * Examples:
      *
      *    math.or(2, 4)   // returns true
      *
      *    a = [2, 5, 0]
      *    b = [0, 22, 0]
      *    c = 0
      *
      *    math.or(a, b)   // returns [true, true, false]
      *    math.or(b, c)   // returns [false, true, false]
      *
      * See also:
      *
      *    and, not, xor
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
      * @return {boolean | Array | Matrix}
      *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
      */
     return typed(name$3y, {
       'number, number': orNumber,
       'Complex, Complex': function ComplexComplex(x, y) {
         return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
       },
       'Unit, Unit': typed.referToSelf(self => (x, y) => self(x.value || 0, y.value || 0))
     }, matrixAlgorithmSuite({
       SS: matAlgo05xSfSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });

   var name$3x = 'xor';
   var dependencies$3x = ['typed', 'matrix', 'DenseMatrix', 'concat'];
   var createXor = /* #__PURE__ */factory(name$3x, dependencies$3x, _ref => {
     var {
       typed,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.xor(x, y)
      *
      * Examples:
      *
      *    math.xor(2, 4)   // returns false
      *
      *    a = [2, 0, 0]
      *    b = [2, 7, 0]
      *    c = 0
      *
      *    math.xor(a, b)   // returns [false, true, false]
      *    math.xor(a, c)   // returns [true, false, false]
      *
      * See also:
      *
      *    and, not, or
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
      * @return {boolean | Array | Matrix}
      *            Returns true when one and only one input is defined with a nonzero/nonempty value.
      */
     return typed(name$3x, {
       'number, number': xorNumber,
       'Complex, Complex': function ComplexComplex(x, y) {
         return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
       },
       'Unit, Unit': typed.referToSelf(self => (x, y) => self(x.value || 0, y.value || 0))
     }, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });

   var name$3w = 'concat';
   var dependencies$3w = ['typed', 'matrix', 'isInteger'];
   var createConcat = /* #__PURE__ */factory(name$3w, dependencies$3w, _ref => {
     var {
       typed,
       matrix,
       isInteger
     } = _ref;
     /**
      * Concatenate two or more matrices.
      *
      * Syntax:
      *
      *     math.concat(A, B, C, ...)
      *     math.concat(A, B, C, ..., dim)
      *
      * Where:
      *
      * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
      *   By default the last dimension of the matrices.
      *
      * Examples:
      *
      *    const A = [[1, 2], [5, 6]]
      *    const B = [[3, 4], [7, 8]]
      *
      *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
      *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
      *    math.concat('hello', ' ', 'world') // returns 'hello world'
      *
      * See also:
      *
      *    size, squeeze, subset, transpose
      *
      * @param {... Array | Matrix} args     Two or more matrices
      * @return {Array | Matrix} Concatenated matrix
      */
     return typed(name$3w, {
       // TODO: change signature to '...Array | Matrix, dim?' when supported
       '...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumber(args) {
         var i;
         var len = args.length;
         var dim = -1; // zero-based dimension
         var prevDim;
         var asMatrix = false;
         var matrices = []; // contains multi dimensional arrays

         for (i = 0; i < len; i++) {
           var arg = args[i];

           // test whether we need to return a Matrix (if not we return an Array)
           if (isMatrix(arg)) {
             asMatrix = true;
           }
           if (isNumber(arg) || isBigNumber(arg)) {
             if (i !== len - 1) {
               throw new Error('Dimension must be specified as last argument');
             }

             // last argument contains the dimension on which to concatenate
             prevDim = dim;
             dim = arg.valueOf(); // change BigNumber to number

             if (!isInteger(dim)) {
               throw new TypeError('Integer number expected for dimension');
             }
             if (dim < 0 || i > 0 && dim > prevDim) {
               // TODO: would be more clear when throwing a DimensionError here
               throw new IndexError(dim, prevDim + 1);
             }
           } else {
             // this is a matrix or array
             var m = clone$3(arg).valueOf();
             var size = arraySize(m);
             matrices[i] = m;
             prevDim = dim;
             dim = size.length - 1;

             // verify whether each of the matrices has the same number of dimensions
             if (i > 0 && dim !== prevDim) {
               throw new DimensionError(prevDim + 1, dim + 1);
             }
           }
         }
         if (matrices.length === 0) {
           throw new SyntaxError('At least one matrix expected');
         }
         var res = matrices.shift();
         while (matrices.length) {
           res = concat$1(res, matrices.shift(), dim);
         }
         return asMatrix ? matrix(res) : res;
       },
       '...string': function string(args) {
         return args.join('');
       }
     });
   });

   var name$3v = 'column';
   var dependencies$3v = ['typed', 'Index', 'matrix', 'range'];
   var createColumn = /* #__PURE__ */factory(name$3v, dependencies$3v, _ref => {
     var {
       typed,
       Index,
       matrix,
       range
     } = _ref;
     /**
      * Return a column from a Matrix.
      *
      * Syntax:
      *
      *     math.column(value, index)
      *
      * Example:
      *
      *     // get a column
      *     const d = [[1, 2], [3, 4]]
      *     math.column(d, 1) // returns [[2], [4]]
      *
      * See also:
      *
      *     row
      *
      * @param {Array | Matrix } value   An array or matrix
      * @param {number} column           The index of the column
      * @return {Array | Matrix}         The retrieved column
      */
     return typed(name$3v, {
       'Matrix, number': _column,
       'Array, number': function ArrayNumber(value, column) {
         return _column(matrix(clone$3(value)), column).valueOf();
       }
     });

     /**
      * Retrieve a column of a matrix
      * @param {Matrix } value  A matrix
      * @param {number} column  The index of the column
      * @return {Matrix}        The retrieved column
      */
     function _column(value, column) {
       // check dimensions
       if (value.size().length !== 2) {
         throw new Error('Only two dimensional matrix is supported');
       }
       validateIndex(column, value.size()[1]);
       var rowRange = range(0, value.size()[0]);
       var index = new Index(rowRange, column);
       var result = value.subset(index);
       return isMatrix(result) ? result : matrix([[result]]);
     }
   });

   var name$3u = 'count';
   var dependencies$3u = ['typed', 'size', 'prod'];
   var createCount = /* #__PURE__ */factory(name$3u, dependencies$3u, _ref => {
     var {
       typed,
       size,
       prod
     } = _ref;
     /**
      * Count the number of elements of a matrix, array or string.
      *
      * Syntax:
      *
      *     math.count(x)
      *
      * Examples:
      *
      *     math.count('hello world')        // returns 11
      *     const A = [[1, 2, 3], [4, 5, 6]]
      *     math.count(A)                    // returns 6
      *     math.count(math.range(1,6))      // returns 5
      *
      * See also:
      *
      *     size
      *
      * @param {string | Array | Matrix} x  A matrix or string
      * @return {number} An integer with the elements in `x`.
      */
     return typed(name$3u, {
       string: function string(x) {
         return x.length;
       },
       'Matrix | Array': function MatrixArray(x) {
         return prod(size(x));
       }
     });
   });

   var name$3t = 'cross';
   var dependencies$3t = ['typed', 'matrix', 'subtract', 'multiply'];
   var createCross = /* #__PURE__ */factory(name$3t, dependencies$3t, _ref => {
     var {
       typed,
       matrix,
       subtract,
       multiply
     } = _ref;
     /**
      * Calculate the cross product for two vectors in three dimensional space.
      * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
      * as:
      *
      *    cross(A, B) = [
      *      a2 * b3 - a3 * b2,
      *      a3 * b1 - a1 * b3,
      *      a1 * b2 - a2 * b1
      *    ]
      *
      * If one of the input vectors has a dimension greater than 1, the output
      * vector will be a 1x3 (2-dimensional) matrix.
      *
      * Syntax:
      *
      *    math.cross(x, y)
      *
      * Examples:
      *
      *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
      *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
      *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
      *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
      *
      * See also:
      *
      *    dot, multiply
      *
      * @param  {Array | Matrix} x   First vector
      * @param  {Array | Matrix} y   Second vector
      * @return {Array | Matrix}     Returns the cross product of `x` and `y`
      */
     return typed(name$3t, {
       'Matrix, Matrix': function MatrixMatrix(x, y) {
         return matrix(_cross(x.toArray(), y.toArray()));
       },
       'Matrix, Array': function MatrixArray(x, y) {
         return matrix(_cross(x.toArray(), y));
       },
       'Array, Matrix': function ArrayMatrix(x, y) {
         return matrix(_cross(x, y.toArray()));
       },
       'Array, Array': _cross
     });

     /**
      * Calculate the cross product for two arrays
      * @param {Array} x  First vector
      * @param {Array} y  Second vector
      * @returns {Array} Returns the cross product of x and y
      * @private
      */
     function _cross(x, y) {
       var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
       x = squeeze$1(x);
       y = squeeze$1(y);
       var xSize = arraySize(x);
       var ySize = arraySize(y);
       if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
         throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
       }
       var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
       if (highestDimension > 1) {
         return [product];
       } else {
         return product;
       }
     }
   });

   var name$3s = 'diag';
   var dependencies$3s = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];
   var createDiag = /* #__PURE__ */factory(name$3s, dependencies$3s, _ref => {
     var {
       typed,
       matrix,
       DenseMatrix,
       SparseMatrix
     } = _ref;
     /**
      * Create a diagonal matrix or retrieve the diagonal of a matrix
      *
      * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
      * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
      * When k is positive, the values are placed on the super diagonal.
      * When k is negative, the values are placed on the sub diagonal.
      *
      * Syntax:
      *
      *     math.diag(X)
      *     math.diag(X, format)
      *     math.diag(X, k)
      *     math.diag(X, k, format)
      *
      * Examples:
      *
      *     // create a diagonal matrix
      *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
      *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
      *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
      *
      *    // retrieve the diagonal from a matrix
      *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      *    math.diag(a)   // returns [1, 5, 9]
      *
      * See also:
      *
      *     ones, zeros, identity
      *
      * @param {Matrix | Array} x          A two dimensional matrix or a vector
      * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
      *                                    in or retrieved.
      * @param {string} [format='dense']   The matrix storage format.
      *
      * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
      */
     return typed(name$3s, {
       // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments

       Array: function Array(x) {
         return _diag(x, 0, arraySize(x), null);
       },
       'Array, number': function ArrayNumber(x, k) {
         return _diag(x, k, arraySize(x), null);
       },
       'Array, BigNumber': function ArrayBigNumber(x, k) {
         return _diag(x, k.toNumber(), arraySize(x), null);
       },
       'Array, string': function ArrayString(x, format) {
         return _diag(x, 0, arraySize(x), format);
       },
       'Array, number, string': function ArrayNumberString(x, k, format) {
         return _diag(x, k, arraySize(x), format);
       },
       'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {
         return _diag(x, k.toNumber(), arraySize(x), format);
       },
       Matrix: function Matrix(x) {
         return _diag(x, 0, x.size(), x.storage());
       },
       'Matrix, number': function MatrixNumber(x, k) {
         return _diag(x, k, x.size(), x.storage());
       },
       'Matrix, BigNumber': function MatrixBigNumber(x, k) {
         return _diag(x, k.toNumber(), x.size(), x.storage());
       },
       'Matrix, string': function MatrixString(x, format) {
         return _diag(x, 0, x.size(), format);
       },
       'Matrix, number, string': function MatrixNumberString(x, k, format) {
         return _diag(x, k, x.size(), format);
       },
       'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {
         return _diag(x, k.toNumber(), x.size(), format);
       }
     });

     /**
      * Creeate diagonal matrix from a vector or vice versa
      * @param {Array | Matrix} x
      * @param {number} k
      * @param {string} format Storage format for matrix. If null,
      *                          an Array is returned
      * @returns {Array | Matrix}
      * @private
      */
     function _diag(x, k, size, format) {
       if (!isInteger$1(k)) {
         throw new TypeError('Second parameter in function diag must be an integer');
       }
       var kSuper = k > 0 ? k : 0;
       var kSub = k < 0 ? -k : 0;

       // check dimensions
       switch (size.length) {
         case 1:
           return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
         case 2:
           return _getDiagonal(x, k, format, size, kSub, kSuper);
       }
       throw new RangeError('Matrix for function diag must be 2 dimensional');
     }
     function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
       // matrix size
       var ms = [l + kSub, l + kSuper];
       if (format && format !== 'sparse' && format !== 'dense') {
         throw new TypeError("Unknown matrix type ".concat(format, "\""));
       }

       // create diagonal matrix
       var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
       // check we need to return a matrix
       return format !== null ? m : m.valueOf();
     }
     function _getDiagonal(x, k, format, s, kSub, kSuper) {
       // check x is a Matrix
       if (isMatrix(x)) {
         // get diagonal matrix
         var dm = x.diagonal(k);
         // check we need to return a matrix
         if (format !== null) {
           // check we need to change matrix format
           if (format !== dm.storage()) {
             return matrix(dm, format);
           }
           return dm;
         }
         return dm.valueOf();
       }
       // vector size
       var n = Math.min(s[0] - kSub, s[1] - kSuper);
       // diagonal values
       var vector = [];
       // loop diagonal
       for (var i = 0; i < n; i++) {
         vector[i] = x[i + kSub][i + kSuper];
       }
       // check we need to return a matrix
       return format !== null ? matrix(vector) : vector;
     }
   });

   /**
    * Invoke a callback for functions like map and filter with a matching number of arguments
    * @param {function} callback
    * @param {any} value
    * @param {number | number[]} index
    * @param {Array} array
    * @param {string} mappingFnName   The name of the function that is invoking these callbacks, for example "map" or "filter"
    * @returns {*}
    */
   function applyCallback(callback, value, index, array, mappingFnName) {
     if (typedFunction.isTypedFunction(callback)) {
       // invoke the typed callback function with the matching number of arguments only

       var args3 = [value, index, array];
       var signature3 = typedFunction.resolve(callback, args3);
       if (signature3) {
         return tryWithArgs(signature3.implementation, args3);
       }
       var args2 = [value, index];
       var signature2 = typedFunction.resolve(callback, args2);
       if (signature2) {
         return tryWithArgs(signature2.implementation, args2);
       }
       var args1 = [value];
       var signature1 = typedFunction.resolve(callback, args1);
       if (signature1) {
         return tryWithArgs(signature1.implementation, args1);
       }

       // fallback (will throw an exception)
       return tryWithArgs(callback, args3);
     } else {
       // A regular JavaScript function
       return callback(value, index, array);
     }

     /**
      * @param {function} signature The selected signature of the typed-function
      * @param {Array} args List with arguments to apply to the selected signature
      * @returns {*} Returns the return value of the invoked signature
      * @throws {TypeError} Throws an error when no matching signature was found
      */
     function tryWithArgs(signature, args) {
       try {
         return signature.apply(signature, args);
       } catch (err) {
         var _err$data;
         // Enrich the error message so the user understands that it took place inside the callback function
         if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === 'wrongType') {
           var argsDesc = [];
           argsDesc.push("value: ".concat(typeOf$1(value)));
           if (args.length >= 2) {
             argsDesc.push("index: ".concat(typeOf$1(index)));
           }
           if (args.length >= 3) {
             argsDesc.push("array: ".concat(typeOf$1(array)));
           }
           throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(', '), ") at index ").concat(JSON.stringify(index)));
         } else {
           throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
         }
       }
     }
   }

   var name$3r = 'filter';
   var dependencies$3r = ['typed'];
   var createFilter = /* #__PURE__ */factory(name$3r, dependencies$3r, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Filter the items in an array or one dimensional matrix.
      *
      * Syntax:
      *
      *    math.filter(x, test)
      *
      * Examples:
      *
      *    function isPositive (x) {
      *      return x > 0
      *    }
      *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]
      *
      *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/) // returns ["23", "100", "55"]
      *
      * See also:
      *
      *    forEach, map, sort
      *
      * @param {Matrix | Array} x    A one dimensional matrix or array to filter
      * @param {Function | RegExp} test
      *        A function or regular expression to test items.
      *        All entries for which `test` returns true are returned.
      *        When `test` is a function, it is invoked with three parameters:
      *        the value of the element, the index of the element, and the
      *        matrix/array being traversed. The function must return a boolean.
      * @return {Matrix | Array} Returns the filtered matrix.
      */
     return typed('filter', {
       'Array, function': _filterCallback,
       'Matrix, function': function MatrixFunction(x, test) {
         return x.create(_filterCallback(x.toArray(), test));
       },
       'Array, RegExp': filterRegExp,
       'Matrix, RegExp': function MatrixRegExp(x, test) {
         return x.create(filterRegExp(x.toArray(), test));
       }
     });
   });

   /**
    * Filter values in a callback given a callback function
    * @param {Array} x
    * @param {Function} callback
    * @return {Array} Returns the filtered array
    * @private
    */
   function _filterCallback(x, callback) {
     return filter$1(x, function (value, index, array) {
       // invoke the callback function with the right number of arguments
       return applyCallback(callback, value, [index], array, 'filter');
     });
   }

   var name$3q = 'flatten';
   var dependencies$3q = ['typed', 'matrix'];
   var createFlatten = /* #__PURE__ */factory(name$3q, dependencies$3q, _ref => {
     var {
       typed,
       matrix
     } = _ref;
     /**
      * Flatten a multidimensional matrix into a single dimensional matrix.
      * A new matrix is returned, the original matrix is left untouched.
      *
      * Syntax:
      *
      *    math.flatten(x)
      *
      * Examples:
      *
      *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
      *
      * See also:
      *
      *    concat, resize, size, squeeze
      *
      * @param {Matrix | Array} x   Matrix to be flattened
      * @return {Matrix | Array} Returns the flattened matrix
      */
     return typed(name$3q, {
       Array: function Array(x) {
         return flatten$1(x);
       },
       Matrix: function Matrix(x) {
         var flat = flatten$1(x.toArray());
         // TODO: return the same matrix type as x (Dense or Sparse Matrix)
         return matrix(flat);
       }
     });
   });

   var name$3p = 'forEach';
   var dependencies$3p = ['typed'];
   var createForEach = /* #__PURE__ */factory(name$3p, dependencies$3p, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Iterate over all elements of a matrix/array, and executes the given callback function.
      *
      * Syntax:
      *
      *    math.forEach(x, callback)
      *
      * Examples:
      *
      *    math.forEach([1, 2, 3], function(value) {
      *      console.log(value)
      *    })
      *    // outputs 1, 2, 3
      *
      * See also:
      *
      *    filter, map, sort
      *
      * @param {Matrix | Array} x    The matrix to iterate on.
      * @param {Function} callback   The callback function is invoked with three
      *                              parameters: the value of the element, the index
      *                              of the element, and the Matrix/array being traversed.
      */
     return typed(name$3p, {
       'Array, function': _forEach,
       'Matrix, function': function MatrixFunction(x, callback) {
         x.forEach(callback);
       }
     });
   });

   /**
    * forEach for a multidimensional array
    * @param {Array} array
    * @param {Function} callback
    * @private
    */
   function _forEach(array, callback) {
     var recurse = function recurse(value, index) {
       if (Array.isArray(value)) {
         forEach$1(value, function (child, i) {
           // we create a copy of the index array and append the new index value
           recurse(child, index.concat(i));
         });
       } else {
         // invoke the callback function with the right number of arguments
         return applyCallback(callback, value, index, array, 'forEach');
       }
     };
     recurse(array, []);
   }

   var name$3o = 'getMatrixDataType';
   var dependencies$3o = ['typed'];
   var createGetMatrixDataType = /* #__PURE__ */factory(name$3o, dependencies$3o, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Find the data type of all elements in a matrix or array,
      * for example 'number' if all items are a number and 'Complex' if all values
      * are complex numbers.
      * If a matrix contains more than one data type, it will return 'mixed'.
      *
      * Syntax:
      *
      *    math.getMatrixDataType(x)
      *
      * Examples:
      *
      *    const x = [ [1, 2, 3], [4, 5, 6] ]
      *    const mixedX = [ [1, true], [2, 3] ]
      *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3)] ]
      *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]
      *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]
      *    const sparse = math.sparse(x)
      *    const dense = math.matrix(x)
      *    math.getMatrixDataType(x)   // returns 'number'
      *    math.getMatrixDataType(sparse)   // returns 'number'
      *    math.getMatrixDataType(dense)   // returns 'number'
      *    math.getMatrixDataType(mixedX) // returns 'mixed'
      *    math.getMatrixDataType(fractionX) // returns 'Fraction'
      *    math.getMatrixDataType(unitX) // returns 'Unit'
      *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'
      *
      * See also:
      *  SparseMatrix, DenseMatrix
      *
      * @param {...Matrix | Array} x   The Matrix with values.
      *
      * @return {string} A string representation of the matrix type
      */
     return typed(name$3o, {
       Array: function Array(x) {
         return getArrayDataType(x, typeOf$1);
       },
       Matrix: function Matrix(x) {
         return x.getDataType();
       }
     });
   });

   var name$3n = 'identity';
   var dependencies$3n = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];
   var createIdentity = /* #__PURE__ */factory(name$3n, dependencies$3n, _ref => {
     var {
       typed,
       config,
       matrix,
       BigNumber,
       DenseMatrix,
       SparseMatrix
     } = _ref;
     /**
      * Create a 2-dimensional identity matrix with size m x n or n x n.
      * The matrix has ones on the diagonal and zeros elsewhere.
      *
      * Syntax:
      *
      *    math.identity(n)
      *    math.identity(n, format)
      *    math.identity(m, n)
      *    math.identity(m, n, format)
      *    math.identity([m, n])
      *    math.identity([m, n], format)
      *
      * Examples:
      *
      *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
      *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
      *
      *    const A = [[1, 2, 3], [4, 5, 6]]
      *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
      *
      * See also:
      *
      *    diag, ones, zeros, size, range
      *
      * @param {...number | Matrix | Array} size   The size for the matrix
      * @param {string} [format]                   The Matrix storage format
      *
      * @return {Matrix | Array | number} A matrix with ones on the diagonal.
      */
     return typed(name$3n, {
       '': function _() {
         return config.matrix === 'Matrix' ? matrix([]) : [];
       },
       string: function string(format) {
         return matrix(format);
       },
       'number | BigNumber': function numberBigNumber(rows) {
         return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
       },
       'number | BigNumber, string': function numberBigNumberString(rows, format) {
         return _identity(rows, rows, format);
       },
       'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {
         return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
       },
       'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format) {
         return _identity(rows, cols, format);
       },
       Array: function Array(size) {
         return _identityVector(size);
       },
       'Array, string': function ArrayString(size, format) {
         return _identityVector(size, format);
       },
       Matrix: function Matrix(size) {
         return _identityVector(size.valueOf(), size.storage());
       },
       'Matrix, string': function MatrixString(size, format) {
         return _identityVector(size.valueOf(), format);
       }
     });
     function _identityVector(size, format) {
       switch (size.length) {
         case 0:
           return format ? matrix(format) : [];
         case 1:
           return _identity(size[0], size[0], format);
         case 2:
           return _identity(size[0], size[1], format);
         default:
           throw new Error('Vector containing two values expected');
       }
     }

     /**
      * Create an identity matrix
      * @param {number | BigNumber} rows
      * @param {number | BigNumber} cols
      * @param {string} [format]
      * @returns {Matrix}
      * @private
      */
     function _identity(rows, cols, format) {
       // BigNumber constructor with the right precision
       var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
       if (isBigNumber(rows)) rows = rows.toNumber();
       if (isBigNumber(cols)) cols = cols.toNumber();
       if (!isInteger$1(rows) || rows < 1) {
         throw new Error('Parameters in function identity must be positive integers');
       }
       if (!isInteger$1(cols) || cols < 1) {
         throw new Error('Parameters in function identity must be positive integers');
       }
       var one = Big ? new BigNumber(1) : 1;
       var defaultValue = Big ? new Big(0) : 0;
       var size = [rows, cols];

       // check we need to return a matrix
       if (format) {
         // create diagonal matrix (use optimized implementation for storage format)
         if (format === 'sparse') {
           return SparseMatrix.diagonal(size, one, 0, defaultValue);
         }
         if (format === 'dense') {
           return DenseMatrix.diagonal(size, one, 0, defaultValue);
         }
         throw new TypeError("Unknown matrix type \"".concat(format, "\""));
       }

       // create and resize array
       var res = resize$1([], size, defaultValue);
       // fill in ones on the diagonal
       var minimum = rows < cols ? rows : cols;
       // fill diagonal
       for (var d = 0; d < minimum; d++) {
         res[d][d] = one;
       }
       return res;
     }
   });

   var name$3m = 'kron';
   var dependencies$3m = ['typed', 'matrix', 'multiplyScalar'];
   var createKron = /* #__PURE__ */factory(name$3m, dependencies$3m, _ref => {
     var {
       typed,
       matrix,
       multiplyScalar
     } = _ref;
     /**
        * Calculates the kronecker product of 2 matrices or vectors.
        *
        * NOTE: If a one dimensional vector / matrix is given, it will be
        * wrapped so its two dimensions.
        * See the examples.
        *
        * Syntax:
        *
        *    math.kron(x, y)
        *
        * Examples:
        *
        *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])
        *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
        *
        *    math.kron([1,1], [2,3,4])
        *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]
        *
        * See also:
        *
        *    multiply, dot, cross
        *
        * @param  {Array | Matrix} x     First vector
        * @param  {Array | Matrix} y     Second vector
        * @return {Array | Matrix}       Returns the kronecker product of `x` and `y`
        */
     return typed(name$3m, {
       'Matrix, Matrix': function MatrixMatrix(x, y) {
         return matrix(_kron(x.toArray(), y.toArray()));
       },
       'Matrix, Array': function MatrixArray(x, y) {
         return matrix(_kron(x.toArray(), y));
       },
       'Array, Matrix': function ArrayMatrix(x, y) {
         return matrix(_kron(x, y.toArray()));
       },
       'Array, Array': _kron
     });

     /**
        * Calculate the kronecker product of two matrices / vectors
        * @param {Array} a  First vector
        * @param {Array} b  Second vector
        * @returns {Array} Returns the kronecker product of x and y
        * @private
        */
     function _kron(a, b) {
       // Deal with the dimensions of the matricies.
       if (arraySize(a).length === 1) {
         // Wrap it in a 2D Matrix
         a = [a];
       }
       if (arraySize(b).length === 1) {
         // Wrap it in a 2D Matrix
         b = [b];
       }
       if (arraySize(a).length > 2 || arraySize(b).length > 2) {
         throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' + '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');
       }
       var t = [];
       var r = [];
       return a.map(function (a) {
         return b.map(function (b) {
           r = [];
           t.push(r);
           return a.map(function (y) {
             return b.map(function (x) {
               return r.push(multiplyScalar(y, x));
             });
           });
         });
       }) && t;
     }
   });

   var name$3l = 'map';
   var dependencies$3l = ['typed'];
   var createMap = /* #__PURE__ */factory(name$3l, dependencies$3l, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Create a new matrix or array with the results of a callback function executed on
      * each entry of a given matrix/array.
      *
      * For each entry of the input, the callback is invoked with three arguments:
      * the value of the entry, the index at which that entry occurs, and the full
      * matrix/array being traversed. Note that because the matrix/array might be
      * multidimensional, the "index" argument is always an array of numbers giving
      * the index in each dimension. This is true even for vectors: the "index"
      * argument is an array of length 1, rather than simply a number.
      *
      * Syntax:
      *
      *    math.map(x, callback)
      *
      * Examples:
      *
      *    math.map([1, 2, 3], function(value) {
      *      return value * value
      *    })  // returns [1, 4, 9]
      *
      *    // The callback is normally called with three arguments:
      *    //    callback(value, index, Array)
      *    // If you want to call with only one argument, use:
      *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']
      *
      * See also:
      *
      *    filter, forEach, sort
      *
      * @param {Matrix | Array} x    The input to iterate on.
      * @param {Function} callback
      *     The function to call (as described above) on each entry of the input
      * @return {Matrix | array}
      *     Transformed map of x; always has the same type and shape as x
      */
     return typed(name$3l, {
       'Array, function': _map$1,
       'Matrix, function': function MatrixFunction(x, callback) {
         return x.map(callback);
       }
     });
   });

   /**
    * Map for a multi dimensional array
    * @param {Array} array
    * @param {Function} callback
    * @return {Array}
    * @private
    */
   function _map$1(array, callback) {
     var recurse = function recurse(value, index) {
       if (Array.isArray(value)) {
         return value.map(function (child, i) {
           // we create a copy of the index array and append the new index value
           return recurse(child, index.concat(i));
         });
       } else {
         // invoke the callback function with the right number of arguments
         return applyCallback(callback, value, index, array, 'map');
       }
     };
     return recurse(array, []);
   }

   var name$3k = 'diff';
   var dependencies$3k = ['typed', 'matrix', 'subtract', 'number'];
   var createDiff = /* #__PURE__ */factory(name$3k, dependencies$3k, _ref => {
     var {
       typed,
       matrix,
       subtract,
       number
     } = _ref;
     /**
      * Create a new matrix or array of the difference between elements of the given array
      * The optional dim parameter lets you specify the dimension to evaluate the difference of
      * If no dimension parameter is passed it is assumed as dimension 0
      *
      * Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber
      * Arrays must be 'rectangular' meaning arrays like [1, 2]
      * If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays
      *
      * Syntax:
      *
      *     math.diff(arr)
      *     math.diff(arr, dim)
      *
      * Examples:
      *
      *     const arr = [1, 2, 4, 7, 0]
      *     math.diff(arr) // returns [1, 2, 3, -7] (no dimension passed so 0 is assumed)
      *     math.diff(math.matrix(arr)) // returns Matrix [1, 2, 3, -7]
      *
      *     const arr = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [9, 8, 7, 6, 4]]
      *     math.diff(arr) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
      *     math.diff(arr, 0) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
      *     math.diff(arr, 1) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
      *     math.diff(arr, math.bignumber(1)) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
      *
      *     math.diff(arr, 2) // throws RangeError as arr is 2 dimensional not 3
      *     math.diff(arr, -1) // throws RangeError as negative dimensions are not allowed
      *
      *     // These will all produce the same result
      *     math.diff([[1, 2], [3, 4]])
      *     math.diff([math.matrix([1, 2]), math.matrix([3, 4])])
      *     math.diff([[1, 2], math.matrix([3, 4])])
      *     math.diff([math.matrix([1, 2]), [3, 4]])
      *     // They do not produce the same result as  math.diff(math.matrix([[1, 2], [3, 4]])) as this returns a matrix
      *
      * See Also:
      *
      *      sum
      *      subtract
      *      partitionSelect
      *
      * @param {Array | Matrix} arr      An array or matrix
      * @param {number | BigNumber} dim  Dimension
      * @return {Array | Matrix}         Difference between array elements in given dimension
      */
     return typed(name$3k, {
       'Array | Matrix': function ArrayMatrix(arr) {
         // No dimension specified => assume dimension 0
         if (isMatrix(arr)) {
           return matrix(_diff(arr.toArray()));
         } else {
           return _diff(arr);
         }
       },
       'Array | Matrix, number': function ArrayMatrixNumber(arr, dim) {
         if (!isInteger$1(dim)) throw new RangeError('Dimension must be a whole number');
         if (isMatrix(arr)) {
           return matrix(_recursive(arr.toArray(), dim));
         } else {
           return _recursive(arr, dim);
         }
       },
       'Array, BigNumber': typed.referTo('Array,number', selfAn => (arr, dim) => selfAn(arr, number(dim))),
       'Matrix, BigNumber': typed.referTo('Matrix,number', selfMn => (arr, dim) => selfMn(arr, number(dim)))
     });

     /**
      * Recursively find the correct dimension in the array/matrix
      * Then Apply _diff to that dimension
      *
      * @param {Array} arr      The array
      * @param {number} dim     Dimension
      * @return {Array}         resulting array
      */
     function _recursive(arr, dim) {
       if (isMatrix(arr)) {
         arr = arr.toArray(); // Makes sure arrays like [ matrix([0, 1]), matrix([1, 0]) ] are processed properly
       }

       if (!Array.isArray(arr)) {
         throw RangeError('Array/Matrix does not have that many dimensions');
       }
       if (dim > 0) {
         var result = [];
         arr.forEach(element => {
           result.push(_recursive(element, dim - 1));
         });
         return result;
       } else if (dim === 0) {
         return _diff(arr);
       } else {
         throw RangeError('Cannot have negative dimension');
       }
     }

     /**
      * Difference between elements in the array
      *
      * @param {Array} arr      An array
      * @return {Array}         resulting array
      */
     function _diff(arr) {
       var result = [];
       var size = arr.length;
       for (var i = 1; i < size; i++) {
         result.push(_ElementDiff(arr[i - 1], arr[i]));
       }
       return result;
     }

     /**
      * Difference between 2 objects
      *
      * @param {Object} obj1    First object
      * @param {Object} obj2    Second object
      * @return {Array}         resulting array
      */
     function _ElementDiff(obj1, obj2) {
       // Convert matrices to arrays
       if (isMatrix(obj1)) obj1 = obj1.toArray();
       if (isMatrix(obj2)) obj2 = obj2.toArray();
       var obj1IsArray = Array.isArray(obj1);
       var obj2IsArray = Array.isArray(obj2);
       if (obj1IsArray && obj2IsArray) {
         return _ArrayDiff(obj1, obj2);
       }
       if (!obj1IsArray && !obj2IsArray) {
         return subtract(obj2, obj1); // Difference is (second - first) NOT (first - second)
       }

       throw TypeError('Cannot calculate difference between 1 array and 1 non-array');
     }

     /**
      * Difference of elements in 2 arrays
      *
      * @param {Array} arr1     Array 1
      * @param {Array} arr2     Array 2
      * @return {Array}         resulting array
      */
     function _ArrayDiff(arr1, arr2) {
       if (arr1.length !== arr2.length) {
         throw RangeError('Not all sub-arrays have the same length');
       }
       var result = [];
       var size = arr1.length;
       for (var i = 0; i < size; i++) {
         result.push(_ElementDiff(arr1[i], arr2[i]));
       }
       return result;
     }
   });

   var name$3j = 'ones';
   var dependencies$3j = ['typed', 'config', 'matrix', 'BigNumber'];
   var createOnes = /* #__PURE__ */factory(name$3j, dependencies$3j, _ref => {
     var {
       typed,
       config,
       matrix,
       BigNumber
     } = _ref;
     /**
      * Create a matrix filled with ones. The created matrix can have one or
      * multiple dimensions.
      *
      * Syntax:
      *
      *    math.ones(m)
      *    math.ones(m, format)
      *    math.ones(m, n)
      *    math.ones(m, n, format)
      *    math.ones([m, n])
      *    math.ones([m, n], format)
      *    math.ones([m, n, p, ...])
      *    math.ones([m, n, p, ...], format)
      *
      * Examples:
      *
      *    math.ones()                    // returns []
      *    math.ones(3)                   // returns [1, 1, 1]
      *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
      *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
      *
      *    const A = [[1, 2, 3], [4, 5, 6]]
      *    math.ones(math.size(A))       // returns [[1, 1, 1], [1, 1, 1]]
      *
      * See also:
      *
      *    zeros, identity, size, range
      *
      * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
      * @param {string} [format]           The Matrix storage format
      *
      * @return {Array | Matrix | number}  A matrix filled with ones
      */
     return typed('ones', {
       '': function _() {
         return config.matrix === 'Array' ? _ones([]) : _ones([], 'default');
       },
       // math.ones(m, n, p, ..., format)
       // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
       '...number | BigNumber | string': function numberBigNumberString(size) {
         var last = size[size.length - 1];
         if (typeof last === 'string') {
           var format = size.pop();
           return _ones(size, format);
         } else if (config.matrix === 'Array') {
           return _ones(size);
         } else {
           return _ones(size, 'default');
         }
       },
       Array: _ones,
       Matrix: function Matrix(size) {
         var format = size.storage();
         return _ones(size.valueOf(), format);
       },
       'Array | Matrix, string': function ArrayMatrixString(size, format) {
         return _ones(size.valueOf(), format);
       }
     });

     /**
      * Create an Array or Matrix with ones
      * @param {Array} size
      * @param {string} [format='default']
      * @return {Array | Matrix}
      * @private
      */
     function _ones(size, format) {
       var hasBigNumbers = _normalize(size);
       var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
       _validate(size);
       if (format) {
         // return a matrix
         var m = matrix(format);
         if (size.length > 0) {
           return m.resize(size, defaultValue);
         }
         return m;
       } else {
         // return an Array
         var arr = [];
         if (size.length > 0) {
           return resize$1(arr, size, defaultValue);
         }
         return arr;
       }
     }

     // replace BigNumbers with numbers, returns true if size contained BigNumbers
     function _normalize(size) {
       var hasBigNumbers = false;
       size.forEach(function (value, index, arr) {
         if (isBigNumber(value)) {
           hasBigNumbers = true;
           arr[index] = value.toNumber();
         }
       });
       return hasBigNumbers;
     }

     // validate arguments
     function _validate(size) {
       size.forEach(function (value) {
         if (typeof value !== 'number' || !isInteger$1(value) || value < 0) {
           throw new Error('Parameters in function ones must be positive integers');
         }
       });
     }
   });

   function noBignumber() {
     throw new Error('No "bignumber" implementation available');
   }
   function noFraction() {
     throw new Error('No "fraction" implementation available');
   }
   function noMatrix() {
     throw new Error('No "matrix" implementation available');
   }

   var name$3i = 'range';
   var dependencies$3i = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq', 'add', 'isPositive'];
   var createRange = /* #__PURE__ */factory(name$3i, dependencies$3i, _ref => {
     var {
       typed,
       config,
       matrix,
       bignumber,
       smaller,
       smallerEq,
       larger,
       largerEq,
       add,
       isPositive
     } = _ref;
     /**
      * Create an array from a range.
      * By default, the range end is excluded. This can be customized by providing
      * an extra parameter `includeEnd`.
      *
      * Syntax:
      *
      *     math.range(str [, includeEnd])               // Create a range from a string,
      *                                                  // where the string contains the
      *                                                  // start, optional step, and end,
      *                                                  // separated by a colon.
      *     math.range(start, end [, includeEnd])        // Create a range with start and
      *                                                  // end and a step size of 1.
      *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
      *                                                  // and end.
      *
      * Where:
      *
      * - `str: string`
      *   A string 'start:end' or 'start:step:end'
      * - `start: {number | BigNumber | Unit}`
      *   Start of the range
      * - `end: number | BigNumber | Unit`
      *   End of the range, excluded by default, included when parameter includeEnd=true
      * - `step: number | BigNumber | Unit`
      *   Step size. Default value is 1.
      * - `includeEnd: boolean`
      *   Option to specify whether to include the end or not. False by default.
      *
      * Examples:
      *
      *     math.range(2, 6)        // [2, 3, 4, 5]
      *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
      *     math.range('2:1:6')     // [2, 3, 4, 5]
      *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
      *     math.range(math.unit(2, 'm'), math.unit(-3, 'm'), math.unit(-1, 'm')) // [2 m, 1 m, 0 m , -1 m, -2 m]
      *
      * See also:
      *
      *     ones, zeros, size, subset
      *
      * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
      * @return {Array | Matrix} range
      */
     return typed(name$3i, {
       // TODO: simplify signatures when typed-function supports default values and optional arguments

       // TODO: a number or boolean should not be converted to string here
       string: _strRange,
       'string, boolean': _strRange,
       'number, number': function numberNumber(start, end) {
         return _out(_range(start, end, 1, false));
       },
       'number, number, number': function numberNumberNumber(start, end, step) {
         return _out(_range(start, end, step, false));
       },
       'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {
         return _out(_range(start, end, 1, includeEnd));
       },
       'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {
         return _out(_range(start, end, step, includeEnd));
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {
         var BigNumber = start.constructor;
         return _out(_range(start, end, new BigNumber(1), false));
       },
       'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {
         return _out(_range(start, end, step, false));
       },
       'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {
         var BigNumber = start.constructor;
         return _out(_range(start, end, new BigNumber(1), includeEnd));
       },
       'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
         return _out(_range(start, end, step, includeEnd));
       },
       'Unit, Unit, Unit': function UnitUnitUnit(start, end, step) {
         return _out(_range(start, end, step, false));
       },
       'Unit, Unit, Unit, boolean': function UnitUnitUnitBoolean(start, end, step, includeEnd) {
         return _out(_range(start, end, step, includeEnd));
       }
     });
     function _out(arr) {
       if (config.matrix === 'Matrix') {
         return matrix ? matrix(arr) : noMatrix();
       }
       return arr;
     }
     function _strRange(str, includeEnd) {
       var r = _parse(str);
       if (!r) {
         throw new SyntaxError('String "' + str + '" is no valid range');
       }
       if (config.number === 'BigNumber') {
         if (bignumber === undefined) {
           noBignumber();
         }
         return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
       } else {
         return _out(_range(r.start, r.end, r.step, includeEnd));
       }
     }

     /**
      * Create a range with numbers or BigNumbers
      * @param {number | BigNumber | Unit} start
      * @param {number | BigNumber | Unit} end
      * @param {number | BigNumber | Unit} step
      * @param {boolean} includeEnd
      * @returns {Array} range
      * @private
      */
     function _range(start, end, step, includeEnd) {
       var array = [];
       var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
       var x = start;
       while (ongoing(x, end)) {
         array.push(x);
         x = add(x, step);
       }
       return array;
     }

     /**
      * Parse a string into a range,
      * The string contains the start, optional step, and end, separated by a colon.
      * If the string does not contain a valid range, null is returned.
      * For example str='0:2:11'.
      * @param {string} str
      * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
      * @private
      */
     function _parse(str) {
       var args = str.split(':');

       // number
       var nums = args.map(function (arg) {
         // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
         return Number(arg);
       });
       var invalid = nums.some(function (num) {
         return isNaN(num);
       });
       if (invalid) {
         return null;
       }
       switch (nums.length) {
         case 2:
           return {
             start: nums[0],
             end: nums[1],
             step: 1
           };
         case 3:
           return {
             start: nums[0],
             end: nums[2],
             step: nums[1]
           };
         default:
           return null;
       }
     }
   });

   var name$3h = 'reshape';
   var dependencies$3h = ['typed', 'isInteger', 'matrix'];
   var createReshape = /* #__PURE__ */factory(name$3h, dependencies$3h, _ref => {
     var {
       typed,
       isInteger
     } = _ref;
     /**
      * Reshape a multi dimensional array to fit the specified dimensions
      *
      * Syntax:
      *
      *     math.reshape(x, sizes)
      *
      * Examples:
      *
      *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])
      *     // returns Array  [[1, 2, 3], [4, 5, 6]]
      *
      *     math.reshape([[1, 2], [3, 4]], [1, 4])
      *     // returns Array  [[1, 2, 3, 4]]
      *
      *     math.reshape([[1, 2], [3, 4]], [4])
      *     // returns Array [1, 2, 3, 4]
      *
      *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])
      *     math.reshape(x, [2, 2, 2])
      *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
      *
      *    math.reshape([1, 2, 3, 4], [-1, 2])
      *    // returns Matrix [[1, 2], [3, 4]]
      *
      * See also:
      *
      *     size, squeeze, resize
      *
      * @param {Array | Matrix | *} x  Matrix to be reshaped
      * @param {number[]} sizes        One dimensional array with integral sizes for
      *                                each dimension. One -1 is allowed as wildcard,
      *                                which calculates this dimension automatically.
      *
      * @return {* | Array | Matrix}   A reshaped clone of matrix `x`
      *
      * @throws {TypeError}            If `sizes` does not contain solely integers
      * @throws {DimensionError}       If the product of the new dimension sizes does
      *                                not equal that of the old ones
      */
     return typed(name$3h, {
       'Matrix, Array': function MatrixArray(x, sizes) {
         return x.reshape(sizes, true);
       },
       'Array, Array': function ArrayArray(x, sizes) {
         sizes.forEach(function (size) {
           if (!isInteger(size)) {
             throw new TypeError('Invalid size for dimension: ' + size);
           }
         });
         return reshape$1(x, sizes);
       }
     });
   });

   var name$3g = 'resize';
   var dependencies$3g = ['config', 'matrix'];
   var createResize = /* #__PURE__ */factory(name$3g, dependencies$3g, _ref => {
     var {
       config,
       matrix
     } = _ref;
     /**
      * Resize a matrix
      *
      * Syntax:
      *
      *     math.resize(x, size)
      *     math.resize(x, size, defaultValue)
      *
      * Examples:
      *
      *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]
      *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]
      *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]
      *     math.resize("hello", [8], "!")    // returns string 'hello!!!'
      *
      * See also:
      *
      *     size, squeeze, subset, reshape
      *
      * @param {Array | Matrix | *} x             Matrix to be resized
      * @param {Array | Matrix} size              One dimensional array with numbers
      * @param {number | string} [defaultValue=0] Zero by default, except in
      *                                           case of a string, in that case
      *                                           defaultValue = ' '
      * @return {* | Array | Matrix} A resized clone of matrix `x`
      */
     // TODO: rework resize to a typed-function
     return function resize(x, size, defaultValue) {
       if (arguments.length !== 2 && arguments.length !== 3) {
         throw new ArgumentsError('resize', arguments.length, 2, 3);
       }
       if (isMatrix(size)) {
         size = size.valueOf(); // get Array
       }

       if (isBigNumber(size[0])) {
         // convert bignumbers to numbers
         size = size.map(function (value) {
           return !isBigNumber(value) ? value : value.toNumber();
         });
       }

       // check x is a Matrix
       if (isMatrix(x)) {
         // use optimized matrix implementation, return copy
         return x.resize(size, defaultValue, true);
       }
       if (typeof x === 'string') {
         // resize string
         return _resizeString(x, size, defaultValue);
       }

       // check result should be a matrix
       var asMatrix = Array.isArray(x) ? false : config.matrix !== 'Array';
       if (size.length === 0) {
         // output a scalar
         while (Array.isArray(x)) {
           x = x[0];
         }
         return clone$3(x);
       } else {
         // output an array/matrix
         if (!Array.isArray(x)) {
           x = [x];
         }
         x = clone$3(x);
         var res = resize$1(x, size, defaultValue);
         return asMatrix ? matrix(res) : res;
       }
     };

     /**
      * Resize a string
      * @param {string} str
      * @param {number[]} size
      * @param {string} [defaultChar=' ']
      * @private
      */
     function _resizeString(str, size, defaultChar) {
       if (defaultChar !== undefined) {
         if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {
           throw new TypeError('Single character expected as defaultValue');
         }
       } else {
         defaultChar = ' ';
       }
       if (size.length !== 1) {
         throw new DimensionError(size.length, 1);
       }
       var len = size[0];
       if (typeof len !== 'number' || !isInteger$1(len)) {
         throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$1(size) + ')');
       }
       if (str.length > len) {
         return str.substring(0, len);
       } else if (str.length < len) {
         var res = str;
         for (var i = 0, ii = len - str.length; i < ii; i++) {
           res += defaultChar;
         }
         return res;
       } else {
         return str;
       }
     }
   });

   var name$3f = 'rotate';
   var dependencies$3f = ['typed', 'multiply', 'rotationMatrix'];
   var createRotate = /* #__PURE__ */factory(name$3f, dependencies$3f, _ref => {
     var {
       typed,
       multiply,
       rotationMatrix
     } = _ref;
     /**
        * Rotate a vector of size 1x2 counter-clockwise by a given angle
        * Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis
        *
        * Syntax:
        *
        *    math.rotate(w, theta)
        *    math.rotate(w, theta, v)
        *
        * Examples:
        *
        *    math.rotate([11, 12], math.pi / 2)                           // returns [-12, 11]
        *    math.rotate(matrix([11, 12]), math.pi / 2)                   // returns [-12, 11]
        *
        *    math.rotate([1, 0, 0], unit('90deg'), [0, 0, 1])             // returns [0, 1, 0]
        *    math.rotate(matrix([1, 0, 0]), unit('90deg'), [0, 0, 1])     // returns Matrix [0, 1, 0]
        *
        *    math.rotate([1, 0], math.complex(1 + i))                     // returns [cos(1 + i) - sin(1 + i), sin(1 + i) + cos(1 + i)]
        *
        * See also:
        *
        *    matrix, rotationMatrix
        *
        * @param {Array | Matrix} w                             Vector to rotate
        * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
        * @param {Array | Matrix} [v]                           Rotation axis
        * @return {Array | Matrix}                              Multiplication of the rotation matrix and w
        */
     return typed(name$3f, {
       'Array , number | BigNumber | Complex | Unit': function ArrayNumberBigNumberComplexUnit(w, theta) {
         _validateSize(w, 2);
         var matrixRes = multiply(rotationMatrix(theta), w);
         return matrixRes.toArray();
       },
       'Matrix , number | BigNumber | Complex | Unit': function MatrixNumberBigNumberComplexUnit(w, theta) {
         _validateSize(w, 2);
         return multiply(rotationMatrix(theta), w);
       },
       'Array, number | BigNumber | Complex | Unit, Array | Matrix': function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
         _validateSize(w, 3);
         var matrixRes = multiply(rotationMatrix(theta, v), w);
         return matrixRes;
       },
       'Matrix, number | BigNumber | Complex | Unit, Array | Matrix': function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
         _validateSize(w, 3);
         return multiply(rotationMatrix(theta, v), w);
       }
     });
     function _validateSize(v, expectedSize) {
       var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
       if (actualSize.length > 2) {
         throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
       }
       if (actualSize.length === 2 && actualSize[1] !== 1) {
         throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
       }
       if (actualSize[0] !== expectedSize) {
         throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
       }
     }
   });

   var name$3e = 'rotationMatrix';
   var dependencies$3e = ['typed', 'config', 'multiplyScalar', 'addScalar', 'unaryMinus', 'norm', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix', 'cos', 'sin'];
   var createRotationMatrix = /* #__PURE__ */factory(name$3e, dependencies$3e, _ref => {
     var {
       typed,
       config,
       multiplyScalar,
       addScalar,
       unaryMinus,
       norm,
       BigNumber,
       matrix,
       DenseMatrix,
       SparseMatrix,
       cos,
       sin
     } = _ref;
     /**
      * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
      * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).
      *
      * Syntax:
      *
      *    math.rotationMatrix(theta)
      *    math.rotationMatrix(theta, format)
      *    math.rotationMatrix(theta, [v])
      *    math.rotationMatrix(theta, [v], format)
      *
      * Examples:
      *
      *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]
      *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]
      *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]
      *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]
      *
      *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]
      *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])
      *
      *
      * See also:
      *
      *    matrix, cos, sin
      *
      *
      * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
      * @param {Array | Matrix} [v]                           Rotation axis
      * @param {string} [format]                              Result Matrix storage format
      * @return {Array | Matrix}                              Rotation matrix
      */

     return typed(name$3e, {
       '': function _() {
         return config.matrix === 'Matrix' ? matrix([]) : [];
       },
       string: function string(format) {
         return matrix(format);
       },
       'number | BigNumber | Complex | Unit': function numberBigNumberComplexUnit(theta) {
         return _rotationMatrix2x2(theta, config.matrix === 'Matrix' ? 'dense' : undefined);
       },
       'number | BigNumber | Complex | Unit, string': function numberBigNumberComplexUnitString(theta, format) {
         return _rotationMatrix2x2(theta, format);
       },
       'number | BigNumber | Complex | Unit, Array': function numberBigNumberComplexUnitArray(theta, v) {
         var matrixV = matrix(v);
         _validateVector(matrixV);
         return _rotationMatrix3x3(theta, matrixV, undefined);
       },
       'number | BigNumber | Complex | Unit, Matrix': function numberBigNumberComplexUnitMatrix(theta, v) {
         _validateVector(v);
         var storageType = v.storage() || (config.matrix === 'Matrix' ? 'dense' : undefined);
         return _rotationMatrix3x3(theta, v, storageType);
       },
       'number | BigNumber | Complex | Unit, Array, string': function numberBigNumberComplexUnitArrayString(theta, v, format) {
         var matrixV = matrix(v);
         _validateVector(matrixV);
         return _rotationMatrix3x3(theta, matrixV, format);
       },
       'number | BigNumber | Complex | Unit, Matrix, string': function numberBigNumberComplexUnitMatrixString(theta, v, format) {
         _validateVector(v);
         return _rotationMatrix3x3(theta, v, format);
       }
     });

     /**
      * Returns 2x2 matrix of 2D rotation of angle theta
      *
      * @param {number | BigNumber | Complex | Unit} theta  The rotation angle
      * @param {string} format                              The result Matrix storage format
      * @returns {Matrix}
      * @private
      */
     function _rotationMatrix2x2(theta, format) {
       var Big = isBigNumber(theta);
       var minusOne = Big ? new BigNumber(-1) : -1;
       var cosTheta = cos(theta);
       var sinTheta = sin(theta);
       var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
       return _convertToFormat(data, format);
     }
     function _validateVector(v) {
       var size = v.size();
       if (size.length < 1 || size[0] !== 3) {
         throw new RangeError('Vector must be of dimensions 1x3');
       }
     }
     function _mul(array) {
       return array.reduce((p, curr) => multiplyScalar(p, curr));
     }
     function _convertToFormat(data, format) {
       if (format) {
         if (format === 'sparse') {
           return new SparseMatrix(data);
         }
         if (format === 'dense') {
           return new DenseMatrix(data);
         }
         throw new TypeError("Unknown matrix type \"".concat(format, "\""));
       }
       return data;
     }

     /**
      * Returns a 3x3 matrix of rotation of angle theta around vector v
      *
      * @param {number | BigNumber | Complex | Unit} theta The rotation angle
      * @param {Matrix} v                                  The rotation axis vector
      * @param {string} format                             The storage format of the resulting matrix
      * @returns {Matrix}
      * @private
      */
     function _rotationMatrix3x3(theta, v, format) {
       var normV = norm(v);
       if (normV === 0) {
         throw new RangeError('Rotation around zero vector');
       }
       var Big = isBigNumber(theta) ? BigNumber : null;
       var one = Big ? new Big(1) : 1;
       var minusOne = Big ? new Big(-1) : -1;
       var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
       var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
       var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
       var c = cos(theta);
       var oneMinusC = addScalar(one, unaryMinus(c));
       var s = sin(theta);
       var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
       var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
       var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
       var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
       var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
       var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
       var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
       var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
       var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
       var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
       return _convertToFormat(data, format);
     }
   });

   var name$3d = 'row';
   var dependencies$3d = ['typed', 'Index', 'matrix', 'range'];
   var createRow = /* #__PURE__ */factory(name$3d, dependencies$3d, _ref => {
     var {
       typed,
       Index,
       matrix,
       range
     } = _ref;
     /**
      * Return a row from a Matrix.
      *
      * Syntax:
      *
      *     math.row(value, index)
      *
      * Example:
      *
      *     // get a row
      *     const d = [[1, 2], [3, 4]]
      *     math.row(d, 1) // returns [[3, 4]]
      *
      * See also:
      *
      *     column
      *
      * @param {Array | Matrix } value   An array or matrix
      * @param {number} row              The index of the row
      * @return {Array | Matrix}         The retrieved row
      */
     return typed(name$3d, {
       'Matrix, number': _row,
       'Array, number': function ArrayNumber(value, row) {
         return _row(matrix(clone$3(value)), row).valueOf();
       }
     });

     /**
      * Retrieve a row of a matrix
      * @param {Matrix } value  A matrix
      * @param {number} row     The index of the row
      * @return {Matrix}        The retrieved row
      */
     function _row(value, row) {
       // check dimensions
       if (value.size().length !== 2) {
         throw new Error('Only two dimensional matrix is supported');
       }
       validateIndex(row, value.size()[0]);
       var columnRange = range(0, value.size()[1]);
       var index = new Index(row, columnRange);
       var result = value.subset(index);
       return isMatrix(result) ? result : matrix([[result]]);
     }
   });

   var name$3c = 'size';
   var dependencies$3c = ['typed', 'config', '?matrix'];
   var createSize = /* #__PURE__ */factory(name$3c, dependencies$3c, _ref => {
     var {
       typed,
       config,
       matrix
     } = _ref;
     /**
      * Calculate the size of a matrix or scalar.
      *
      * Syntax:
      *
      *     math.size(x)
      *
      * Examples:
      *
      *     math.size(2.3)                  // returns []
      *     math.size('hello world')        // returns [11]
      *
      *     const A = [[1, 2, 3], [4, 5, 6]]
      *     math.size(A)                    // returns [2, 3]
      *     math.size(math.range(1,6))      // returns [5]
      *
      * See also:
      *
      *     count, resize, squeeze, subset
      *
      * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
      * @return {Array | Matrix} A vector with size of `x`.
      */
     return typed(name$3c, {
       Matrix: function Matrix(x) {
         return x.create(x.size());
       },
       Array: arraySize,
       string: function string(x) {
         return config.matrix === 'Array' ? [x.length] : matrix([x.length]);
       },
       'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {
         // scalar
         return config.matrix === 'Array' ? [] : matrix ? matrix([]) : noMatrix();
       }
     });
   });

   var name$3b = 'squeeze';
   var dependencies$3b = ['typed', 'matrix'];
   var createSqueeze = /* #__PURE__ */factory(name$3b, dependencies$3b, _ref => {
     var {
       typed,
       matrix
     } = _ref;
     /**
      * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
      *
      * Syntax:
      *
      *     math.squeeze(x)
      *
      * Examples:
      *
      *     math.squeeze([3])           // returns 3
      *     math.squeeze([[3]])         // returns 3
      *
      *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)
      *     math.squeeze(A)             // returns [0, 0, 0] (size 3)
      *
      *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)
      *     math.squeeze(B)             // returns [0, 0, 0] (size 3)
      *
      *     // only inner and outer dimensions are removed
      *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
      *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
      *
      * See also:
      *
      *     subset
      *
      * @param {Matrix | Array} x      Matrix to be squeezed
      * @return {Matrix | Array} Squeezed matrix
      */
     return typed(name$3b, {
       Array: function Array(x) {
         return squeeze$1(clone$3(x));
       },
       Matrix: function Matrix(x) {
         var res = squeeze$1(x.toArray());
         // FIXME: return the same type of matrix as the input
         return Array.isArray(res) ? matrix(res) : res;
       },
       any: function any(x) {
         // scalar
         return clone$3(x);
       }
     });
   });

   var name$3a = 'subset';
   var dependencies$3a = ['typed', 'matrix', 'zeros', 'add'];
   var createSubset = /* #__PURE__ */factory(name$3a, dependencies$3a, _ref => {
     var {
       typed,
       matrix,
       zeros,
       add
     } = _ref;
     /**
      * Get or set a subset of a matrix or string.
      *
      * Syntax:
      *     math.subset(value, index)                                // retrieve a subset
      *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
      *
      * Examples:
      *
      *     // get a subset
      *     const d = [[1, 2], [3, 4]]
      *     math.subset(d, math.index(1, 0))             // returns 3
      *     math.subset(d, math.index([0, 1], 1))        // returns [[2], [4]]
      *     math.subset(d, math.index([false, true], 0)) // returns [[3]]
      *
      *     // replace a subset
      *     const e = []
      *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 0, 6]]
      *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 0, 6], [0, 7, 0]]
      *     math.subset(g, math.index([false, true], 1), 8)          // returns [[5, 0, 6], [0, 8, 0]]
      *
      *     // get submatrix using ranges
      *     const M = [
      *       [1,2,3],
      *       [4,5,6],
      *       [7,8,9]
      *     ]
      *     math.subset(M, math.index(math.range(0,2), math.range(0,3))) // [[1, 2, 3], [4, 5, 6]]
      *
      * See also:
      *
      *     size, resize, squeeze, index
      *
      * @param {Array | Matrix | string} matrix  An array, matrix, or string
      * @param {Index} index
      *    For each dimension of the target, specifies an index or a list of
      *    indices to fetch or set. `subset` uses the cartesian product of
      *    the indices specified in each dimension.
      * @param {*} [replacement]                 An array, matrix, or scalar.
      *                                          If provided, the subset is replaced with replacement.
      *                                          If not provided, the subset is returned
      * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
      *                                          the matrix is resized. If not provided,
      *                                          math.matrix elements will be left undefined.
      * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
      */

     return typed(name$3a, {
       // get subset
       'Matrix, Index': function MatrixIndex(value, index) {
         if (isEmptyIndex(index)) {
           return matrix();
         }
         validateIndexSourceSize(value, index);
         return value.subset(index);
       },
       'Array, Index': typed.referTo('Matrix, Index', function (subsetRef) {
         return function (value, index) {
           var subsetResult = subsetRef(matrix(value), index);
           return index.isScalar() ? subsetResult : subsetResult.valueOf();
         };
       }),
       'Object, Index': _getObjectProperty,
       'string, Index': _getSubstring,
       // set subset
       'Matrix, Index, any, any': function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
         if (isEmptyIndex(index)) {
           return value;
         }
         validateIndexSourceSize(value, index);
         return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);
       },
       'Array, Index, any, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {
         return function (value, index, replacement, defaultValue) {
           var subsetResult = subsetRef(matrix(value), index, replacement, defaultValue);
           return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
         };
       }),
       'Array, Index, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {
         return function (value, index, replacement) {
           return subsetRef(matrix(value), index, replacement, undefined).valueOf();
         };
       }),
       'Matrix, Index, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {
         return function (value, index, replacement) {
           return subsetRef(value, index, replacement, undefined);
         };
       }),
       'string, Index, string': _setSubstring,
       'string, Index, string, string': _setSubstring,
       'Object, Index, any': _setObjectProperty
     });

     /**
      * Broadcasts a replacment value to be the same size as index
      * @param {number | BigNumber | Array | Matrix} replacement Replacement value to try to broadcast
      * @param {*} index Index value
      * @returns broadcasted replacement that matches the size of index
      */

     function _broadcastReplacement(replacement, index) {
       if (typeof replacement === 'string') {
         throw new Error('can\'t boradcast a string');
       }
       if (index._isScalar) {
         return replacement;
       }
       var indexSize = index.size();
       if (indexSize.every(d => d > 0)) {
         try {
           return add(replacement, zeros(indexSize));
         } catch (error) {
           return replacement;
         }
       } else {
         return replacement;
       }
     }
   });

   /**
    * Retrieve a subset of a string
    * @param {string} str            string from which to get a substring
    * @param {Index} index           An index or list of indices (character positions)
    * @returns {string} substring
    * @private
    */
   function _getSubstring(str, index) {
     if (!isIndex(index)) {
       // TODO: better error message
       throw new TypeError('Index expected');
     }
     if (isEmptyIndex(index)) {
       return '';
     }
     validateIndexSourceSize(Array.from(str), index);
     if (index.size().length !== 1) {
       throw new DimensionError(index.size().length, 1);
     }

     // validate whether the range is out of range
     var strLen = str.length;
     validateIndex(index.min()[0], strLen);
     validateIndex(index.max()[0], strLen);
     var range = index.dimension(0);
     var substr = '';
     range.forEach(function (v) {
       substr += str.charAt(v);
     });
     return substr;
   }

   /**
    * Replace a substring in a string
    * @param {string} str            string to be replaced
    * @param {Index} index           An index or list of indices (character positions)
    * @param {string} replacement    Replacement string
    * @param {string} [defaultValue] Default value to be used when resizing
    *                                the string. is ' ' by default
    * @returns {string} result
    * @private
    */
   function _setSubstring(str, index, replacement, defaultValue) {
     if (!index || index.isIndex !== true) {
       // TODO: better error message
       throw new TypeError('Index expected');
     }
     if (isEmptyIndex(index)) {
       return str;
     }
     validateIndexSourceSize(Array.from(str), index);
     if (index.size().length !== 1) {
       throw new DimensionError(index.size().length, 1);
     }
     if (defaultValue !== undefined) {
       if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {
         throw new TypeError('Single character expected as defaultValue');
       }
     } else {
       defaultValue = ' ';
     }
     var range = index.dimension(0);
     var len = range.size()[0];
     if (len !== replacement.length) {
       throw new DimensionError(range.size()[0], replacement.length);
     }

     // validate whether the range is out of range
     var strLen = str.length;
     validateIndex(index.min()[0]);
     validateIndex(index.max()[0]);

     // copy the string into an array with characters
     var chars = [];
     for (var i = 0; i < strLen; i++) {
       chars[i] = str.charAt(i);
     }
     range.forEach(function (v, i) {
       chars[v] = replacement.charAt(i[0]);
     });

     // initialize undefined characters with a space
     if (chars.length > strLen) {
       for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
         if (!chars[_i]) {
           chars[_i] = defaultValue;
         }
       }
     }
     return chars.join('');
   }

   /**
    * Retrieve a property from an object
    * @param {Object} object
    * @param {Index} index
    * @return {*} Returns the value of the property
    * @private
    */
   function _getObjectProperty(object, index) {
     if (isEmptyIndex(index)) {
       return undefined;
     }
     if (index.size().length !== 1) {
       throw new DimensionError(index.size(), 1);
     }
     var key = index.dimension(0);
     if (typeof key !== 'string') {
       throw new TypeError('String expected as index to retrieve an object property');
     }
     return getSafeProperty(object, key);
   }

   /**
    * Set a property on an object
    * @param {Object} object
    * @param {Index} index
    * @param {*} replacement
    * @return {*} Returns the updated object
    * @private
    */
   function _setObjectProperty(object, index, replacement) {
     if (isEmptyIndex(index)) {
       return object;
     }
     if (index.size().length !== 1) {
       throw new DimensionError(index.size(), 1);
     }
     var key = index.dimension(0);
     if (typeof key !== 'string') {
       throw new TypeError('String expected as index to retrieve an object property');
     }

     // clone the object, and apply the property to the clone
     var updated = clone$3(object);
     setSafeProperty(updated, key, replacement);
     return updated;
   }

   var name$39 = 'transpose';
   var dependencies$39 = ['typed', 'matrix'];
   var createTranspose = /* #__PURE__ */factory(name$39, dependencies$39, _ref => {
     var {
       typed,
       matrix
     } = _ref;
     /**
      * Transpose a matrix. All values of the matrix are reflected over its
      * main diagonal. Only applicable to two dimensional matrices containing
      * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
      * vectors and scalars return the input unchanged.
      *
      * Syntax:
      *
      *     math.transpose(x)
      *
      * Examples:
      *
      *     const A = [[1, 2, 3], [4, 5, 6]]
      *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
      *
      * See also:
      *
      *     diag, inv, subset, squeeze
      *
      * @param {Array | Matrix} x  Matrix to be transposed
      * @return {Array | Matrix}   The transposed matrix
      */
     return typed(name$39, {
       Array: x => transposeMatrix(matrix(x)).valueOf(),
       Matrix: transposeMatrix,
       any: clone$3 // scalars
     });

     function transposeMatrix(x) {
       // matrix size
       var size = x.size();

       // result
       var c;

       // process dimensions
       switch (size.length) {
         case 1:
           // vector
           c = x.clone();
           break;
         case 2:
           {
             // rows and columns
             var rows = size[0];
             var columns = size[1];

             // check columns
             if (columns === 0) {
               // throw exception
               throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format$1(size) + ')');
             }

             // process storage format
             switch (x.storage()) {
               case 'dense':
                 c = _denseTranspose(x, rows, columns);
                 break;
               case 'sparse':
                 c = _sparseTranspose(x, rows, columns);
                 break;
             }
           }
           break;
         default:
           // multi dimensional
           throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format$1(size) + ')');
       }
       return c;
     }
     function _denseTranspose(m, rows, columns) {
       // matrix array
       var data = m._data;
       // transposed matrix data
       var transposed = [];
       var transposedRow;
       // loop columns
       for (var j = 0; j < columns; j++) {
         // initialize row
         transposedRow = transposed[j] = [];
         // loop rows
         for (var i = 0; i < rows; i++) {
           // set data
           transposedRow[i] = clone$3(data[i][j]);
         }
       }
       // return matrix
       return m.createDenseMatrix({
         data: transposed,
         size: [columns, rows],
         datatype: m._datatype
       });
     }
     function _sparseTranspose(m, rows, columns) {
       // matrix arrays
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;
       // result matrices
       var cvalues = values ? [] : undefined;
       var cindex = [];
       var cptr = [];
       // row counts
       var w = [];
       for (var x = 0; x < rows; x++) {
         w[x] = 0;
       }
       // vars
       var p, l, j;
       // loop values in matrix
       for (p = 0, l = index.length; p < l; p++) {
         // number of values in row
         w[index[p]]++;
       }
       // cumulative sum
       var sum = 0;
       // initialize cptr with the cummulative sum of row counts
       for (var i = 0; i < rows; i++) {
         // update cptr
         cptr.push(sum);
         // update sum
         sum += w[i];
         // update w
         w[i] = cptr[i];
       }
       // update cptr
       cptr.push(sum);
       // loop columns
       for (j = 0; j < columns; j++) {
         // values & index in column
         for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
           // C values & index
           var q = w[index[k]]++;
           // C[j, i] = A[i, j]
           cindex[q] = j;
           // check we need to process values (pattern matrix)
           if (values) {
             cvalues[q] = clone$3(values[k]);
           }
         }
       }
       // return matrix
       return m.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [columns, rows],
         datatype: m._datatype
       });
     }
   });

   var name$38 = 'ctranspose';
   var dependencies$38 = ['typed', 'transpose', 'conj'];
   var createCtranspose = /* #__PURE__ */factory(name$38, dependencies$38, _ref => {
     var {
       typed,
       transpose,
       conj
     } = _ref;
     /**
      * Transpose and complex conjugate a matrix. All values of the matrix are
      * reflected over its main diagonal and then the complex conjugate is
      * taken. This is equivalent to complex conjugation for scalars and
      * vectors.
      *
      * Syntax:
      *
      *     math.ctranspose(x)
      *
      * Examples:
      *
      *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
      *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
      *
      * See also:
      *
      *     transpose, diag, inv, subset, squeeze
      *
      * @param {Array | Matrix} x  Matrix to be ctransposed
      * @return {Array | Matrix}   The ctransposed matrix
      */
     return typed(name$38, {
       any: function any(x) {
         return conj(transpose(x));
       }
     });
   });

   var name$37 = 'zeros';
   var dependencies$37 = ['typed', 'config', 'matrix', 'BigNumber'];
   var createZeros = /* #__PURE__ */factory(name$37, dependencies$37, _ref => {
     var {
       typed,
       config,
       matrix,
       BigNumber
     } = _ref;
     /**
      * Create a matrix filled with zeros. The created matrix can have one or
      * multiple dimensions.
      *
      * Syntax:
      *
      *    math.zeros(m)
      *    math.zeros(m, format)
      *    math.zeros(m, n)
      *    math.zeros(m, n, format)
      *    math.zeros([m, n])
      *    math.zeros([m, n], format)
      *
      * Examples:
      *
      *    math.zeros()                   // returns []
      *    math.zeros(3)                  // returns [0, 0, 0]
      *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
      *    math.zeros(3, 'dense')         // returns [0, 0, 0]
      *
      *    const A = [[1, 2, 3], [4, 5, 6]]
      *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
      *
      * See also:
      *
      *    ones, identity, size, range
      *
      * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
      * @param {string} [format]           The Matrix storage format
      *
      * @return {Array | Matrix}           A matrix filled with zeros
      */
     return typed(name$37, {
       '': function _() {
         return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
       },
       // math.zeros(m, n, p, ..., format)
       // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
       '...number | BigNumber | string': function numberBigNumberString(size) {
         var last = size[size.length - 1];
         if (typeof last === 'string') {
           var format = size.pop();
           return _zeros(size, format);
         } else if (config.matrix === 'Array') {
           return _zeros(size);
         } else {
           return _zeros(size, 'default');
         }
       },
       Array: _zeros,
       Matrix: function Matrix(size) {
         var format = size.storage();
         return _zeros(size.valueOf(), format);
       },
       'Array | Matrix, string': function ArrayMatrixString(size, format) {
         return _zeros(size.valueOf(), format);
       }
     });

     /**
      * Create an Array or Matrix with zeros
      * @param {Array} size
      * @param {string} [format='default']
      * @return {Array | Matrix}
      * @private
      */
     function _zeros(size, format) {
       var hasBigNumbers = _normalize(size);
       var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
       _validate(size);
       if (format) {
         // return a matrix
         var m = matrix(format);
         if (size.length > 0) {
           return m.resize(size, defaultValue);
         }
         return m;
       } else {
         // return an Array
         var arr = [];
         if (size.length > 0) {
           return resize$1(arr, size, defaultValue);
         }
         return arr;
       }
     }

     // replace BigNumbers with numbers, returns true if size contained BigNumbers
     function _normalize(size) {
       var hasBigNumbers = false;
       size.forEach(function (value, index, arr) {
         if (isBigNumber(value)) {
           hasBigNumbers = true;
           arr[index] = value.toNumber();
         }
       });
       return hasBigNumbers;
     }

     // validate arguments
     function _validate(size) {
       size.forEach(function (value) {
         if (typeof value !== 'number' || !isInteger$1(value) || value < 0) {
           throw new Error('Parameters in function zeros must be positive integers');
         }
       });
     }
   });

   // TODO: zeros contains almost the same code as ones. Reuse this?

   var name$36 = 'fft';
   var dependencies$36 = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];
   var createFft = /* #__PURE__ */factory(name$36, dependencies$36, _ref => {
     var {
       typed,
       matrix,
       addScalar,
       multiplyScalar,
       divideScalar,
       exp,
       tau,
       i: I,
       dotDivide,
       conj,
       pow,
       ceil,
       log2
     } = _ref;
     /**
      * Calculate N-dimensional fourier transform
      *
      * Syntax:
      *
      *     math.fft(arr)
      *
      * Examples:
      *
      *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]
      *
      *
      * See Also:
      *
      *      ifft
      *
      * @param {Array | Matrix} arr    An array or matrix
      * @return {Array | Matrix}       N-dimensional fourier transformation of the array
      */
     return typed(name$36, {
       Array: _ndFft,
       Matrix: function Matrix(matrix) {
         return matrix.create(_ndFft(matrix.toArray()));
       }
     });

     /**
      * Perform an N-dimensional Fourier transform
      *
      * @param {Array} arr      The array
      * @return {Array}         resulting array
      */
     function _ndFft(arr) {
       var size = arraySize(arr);
       if (size.length === 1) return _fft(arr, size[0]);
       // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0
       return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);
     }

     /**
      * Perform an 1-dimensional Fourier transform
      *
      * @param {Array} arr      The array
      * @param {number} dim     dimension of the array to perform on
      * @return {Array}         resulting array
      */
     function _1dFft(arr, dim) {
       var size = arraySize(arr);
       if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));
       if (size.length === 1) return _fft(arr);
       function _transpose(arr) {
         // Swap first 2 dimensions
         var size = arraySize(arr);
         return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));
       }
       return _transpose(_1dFft(_transpose(arr), 1));
     }
     /**
      * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform
      *
      * @param {Array} arr      The array
      * @return {Array}         resulting array
      */
     function _czt(arr) {
       var n = arr.length;
       var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));
       var chirp = [];
       for (var i = 1 - n; i < n; i++) {
         chirp.push(pow(w, divideScalar(pow(i, 2), 2)));
       }
       var N2 = pow(2, ceil(log2(n + n - 1)));
       var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];
       var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];
       var fftXp = _fft(xp);
       var fftIchirp = _fft(ichirp);
       var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));
       var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
       var ret = [];
       for (var _i = n - 1; _i < n + n - 1; _i++) {
         ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));
       }
       return ret;
     }
     /**
      * Perform an 1-dimensional Fourier transform
      *
      * @param {Array} arr      The array
      * @return {Array}         resulting array
      */
     function _fft(arr) {
       var len = arr.length;
       if (len === 1) return [arr[0]];
       if (len % 2 === 0) {
         var ret = [..._fft(arr.filter((_, i) => i % 2 === 0)), ..._fft(arr.filter((_, i) => i % 2 === 1))];
         for (var k = 0; k < len / 2; k++) {
           var p = ret[k];
           var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));
           ret[k] = addScalar(p, q);
           ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));
         }
         return ret;
       } else {
         // use chirp-z transform for non-power-of-2 FFT
         return _czt(arr);
       }
       // throw new Error('Can only calculate FFT of power-of-two size')
     }
   });

   var name$35 = 'ifft';
   var dependencies$35 = ['typed', 'fft', 'dotDivide', 'conj'];
   var createIfft = /* #__PURE__ */factory(name$35, dependencies$35, _ref => {
     var {
       typed,
       fft,
       dotDivide,
       conj
     } = _ref;
     /**
      * Calculate N-dimensional inverse fourier transform
      *
      * Syntax:
      *
      *     math.ifft(arr)
      *
      * Examples:
      *
      *    math.ifft([[2, 2], [0, 0]]) // returns [[{re:1, im:0}, {re:0, im:0}], [{re:1, im:0}, {re:0, im:0}]]
      *
      * See Also:
      *
      *      fft
      *
      * @param {Array | Matrix} arr    An array or matrix
      * @return {Array | Matrix}       N-dimensional fourier transformation of the array
      */
     return typed(name$35, {
       'Array | Matrix': function ArrayMatrix(arr) {
         var size = isMatrix(arr) ? arr.size() : arraySize(arr);
         return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));
       }
     });
   });

   function _typeof(o) {
     "@babel/helpers - typeof";

     return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
       return typeof o;
     } : function (o) {
       return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
     }, _typeof(o);
   }

   function _toPrimitive(input, hint) {
     if (_typeof(input) !== "object" || input === null) return input;
     var prim = input[Symbol.toPrimitive];
     if (prim !== undefined) {
       var res = prim.call(input, hint || "default");
       if (_typeof(res) !== "object") return res;
       throw new TypeError("@@toPrimitive must return a primitive value.");
     }
     return (hint === "string" ? String : Number)(input);
   }

   function _toPropertyKey(arg) {
     var key = _toPrimitive(arg, "string");
     return _typeof(key) === "symbol" ? key : String(key);
   }

   function _defineProperty(obj, key, value) {
     key = _toPropertyKey(key);
     if (key in obj) {
       Object.defineProperty(obj, key, {
         value: value,
         enumerable: true,
         configurable: true,
         writable: true
       });
     } else {
       obj[key] = value;
     }
     return obj;
   }

   function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
   function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
   var name$34 = 'solveODE';
   var dependencies$34 = ['typed', 'add', 'subtract', 'multiply', 'divide', 'max', 'map', 'abs', 'isPositive', 'isNegative', 'larger', 'smaller', 'matrix', 'bignumber', 'unaryMinus'];
   var createSolveODE = /* #__PURE__ */factory(name$34, dependencies$34, _ref => {
     var {
       typed,
       add,
       subtract,
       multiply,
       divide,
       max,
       map,
       abs,
       isPositive,
       isNegative,
       larger,
       smaller,
       matrix,
       bignumber,
       unaryMinus
     } = _ref;
     /**
        * Numerical Integration of Ordinary Differential Equations
        *
        * Two variable step methods are provided:
        * - "RK23": Bogacki–Shampine method
        * - "RK45": Dormand-Prince method RK5(4)7M (default)
        *
        * The arguments are expected as follows.
        *
        * - `func` should be the forcing function `f(t, y)`
        * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`
        * - `y0` the initial state values, should be a scalar or a flat array
        * - `options` should be an object with the following information:
        *   - `method` ('RK45'): ['RK23', 'RK45']
        *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value
        *   - `firstStep`: Initial step size
        *   - `minStep`: minimum step size of the method
        *   - `maxStep`: maximum step size of the method
        *   - `minDelta` (0.2): minimum ratio of change for the step
        *   - `maxDelta` (5): maximum ratio of change for the step
        *   - `maxIter` (1e4): maximum number of iterations
        *
        * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:
        * - `t` an array of size `[n]`
        * - `y` the states array can be in two ways
        *   - **if `y0` is a scalar:** returns an array-like of size `[n]`
        *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`
        *
        * Syntax:
        *
        *     math.solveODE(func, tspan, y0)
        *     math.solveODE(func, tspan, y0, options)
        *
        * Examples:
        *
        *     function func(t, y) {return y}
        *     const tspan = [0, 4]
        *     const y0 = 1
        *     math.solveODE(func, tspan, y0)
        *     math.solveODE(func, tspan, [1, 2])
        *     math.solveODE(func, tspan, y0, { method:"RK23", maxStep:0.1 })
        *
        * See also:
        *
        *     derivative, simplifyCore
        *
        * @param {function} func The forcing function f(t,y)
        * @param {Array | Matrix} tspan The time span
        * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value
        * @param {Object} [options] Optional configuration options
        * @return {Object} Return an object with t and y values as arrays
        */

     function _rk(butcherTableau) {
       // generates an adaptive runge kutta method from it's butcher tableau

       return function (f, tspan, y0, options) {
         // adaptive runge kutta methods
         var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
         if (wrongTSpan) {
           throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
         }
         var t0 = tspan[0]; // initial time
         var tf = tspan[1]; // final time
         var isForwards = larger(tf, t0);
         var firstStep = options.firstStep;
         if (firstStep !== undefined && !isPositive(firstStep)) {
           throw new Error('"firstStep" must be positive');
         }
         var maxStep = options.maxStep;
         if (maxStep !== undefined && !isPositive(maxStep)) {
           throw new Error('"maxStep" must be positive');
         }
         var minStep = options.minStep;
         if (minStep && isNegative(minStep)) {
           throw new Error('"minStep" must be positive or zero');
         }
         var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(x => x !== undefined);
         if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
           throw new Error('Inconsistent type of "t" dependant variables');
         }
         var steps = 1; // divide time in this number of steps
         var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)
         var minDelta = options.minDelta ? options.minDelta : 0.2;
         var maxDelta = options.maxDelta ? options.maxDelta : 5;
         var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong
         var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
         var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
         var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size
         var t = [t0]; // start the time array
         var y = [y0]; // start the solution array

         var deltaB = subtract(b, bp); // b - bp

         var n = 0;
         var iter = 0;
         var ongoing = _createOngoing(isForwards);
         var trimStep = _createTrimStep(isForwards);
         // iterate unitil it reaches either the final time or maximum iterations
         while (ongoing(t[n], tf)) {
           var k = [];

           // trim the time step so that it doesn't overshoot
           h = trimStep(t[n], tf, h);

           // calculate the first value of k
           k.push(f(t[n], y[n]));

           // calculate the rest of the values of k
           for (var i = 1; i < c.length; ++i) {
             k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));
           }

           // estimate the error by comparing solutions of different orders
           var TE = max(abs(map(multiply(deltaB, k), X => isUnit(X) ? X.value : X)));
           if (TE < tol && tol / TE > 1 / 4) {
             // push solution if within tol
             t.push(add(t[n], h));
             y.push(add(y[n], multiply(h, b, k)));
             n++;
           }

           // estimate the delta value that will affect the step size
           var delta = 0.84 * (tol / TE) ** (1 / 5);
           if (smaller(delta, minDelta)) {
             delta = minDelta;
           } else if (larger(delta, maxDelta)) {
             delta = maxDelta;
           }
           delta = hasBigNumbers ? bignumber(delta) : delta;
           h = multiply(h, delta);
           if (maxStep && larger(abs(h), maxStep)) {
             h = isForwards ? maxStep : unaryMinus(maxStep);
           } else if (minStep && smaller(abs(h), minStep)) {
             h = isForwards ? minStep : unaryMinus(minStep);
           }
           iter++;
           if (iter > maxIter) {
             throw new Error('Maximum number of iterations reached, try changing options');
           }
         }
         return {
           t,
           y
         };
       };
     }
     function _rk23(f, tspan, y0, options) {
       // Bogacki–Shampine method

       // Define the butcher table
       var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
       var c = [null, 1 / 2, 3 / 4, 1];
       var b = [2 / 9, 1 / 3, 4 / 9, 0];
       var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
       var butcherTableau = {
         a,
         c,
         b,
         bp
       };

       // Solve an adaptive step size rk method
       return _rk(butcherTableau)(f, tspan, y0, options);
     }
     function _rk45(f, tspan, y0, options) {
       // Dormand Prince method

       // Define the butcher tableau
       var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
       var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
       var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
       var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
       var butcherTableau = {
         a,
         c,
         b,
         bp
       };

       // Solve an adaptive step size rk method
       return _rk(butcherTableau)(f, tspan, y0, options);
     }
     function _solveODE(f, tspan, y0, opt) {
       var method = opt.method ? opt.method : 'RK45';
       var methods = {
         RK23: _rk23,
         RK45: _rk45
       };
       if (method.toUpperCase() in methods) {
         var methodOptions = _objectSpread$2({}, opt); // clone the options object
         delete methodOptions.method; // delete the method as it won't be needed
         return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
       } else {
         // throw an error indicating there is no such method
         var methodsWithQuotes = Object.keys(methods).map(x => "\"".concat(x, "\""));
         // generates a string of methods like: "BDF", "RK23" and "RK45"
         var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(', '), " and ").concat(methodsWithQuotes.slice(-1));
         throw new Error("Unavailable method \"".concat(method, "\". Available methods are ").concat(availableMethodsString));
       }
     }
     function _createOngoing(isForwards) {
       // returns the correct function to test if it's still iterating
       return isForwards ? smaller : larger;
     }
     function _createTrimStep(isForwards) {
       var outOfBounds = isForwards ? larger : smaller;
       return function (t, tf, h) {
         var next = add(t, h);
         return outOfBounds(next, tf) ? subtract(tf, t) : h;
       };
     }
     function isNumOrBig(x) {
       // checks if it's a number or bignumber
       return isBigNumber(x) || isNumber(x);
     }
     function _matrixSolveODE(f, T, y0, options) {
       // receives matrices and returns matrices
       var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
       return {
         t: matrix(sol.t),
         y: matrix(sol.y)
       };
     }
     return typed('solveODE', {
       'function, Array, Array, Object': _solveODE,
       'function, Matrix, Matrix, Object': _matrixSolveODE,
       'function, Array, Array': (f, T, y0) => _solveODE(f, T, y0, {}),
       'function, Matrix, Matrix': (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
       'function, Array, number | BigNumber | Unit': (f, T, y0) => {
         var sol = _solveODE(f, T, [y0], {});
         return {
           t: sol.t,
           y: sol.y.map(Y => Y[0])
         };
       },
       'function, Matrix, number | BigNumber | Unit': (f, T, y0) => {
         var sol = _solveODE(f, T.toArray(), [y0], {});
         return {
           t: matrix(sol.t),
           y: matrix(sol.y.map(Y => Y[0]))
         };
       },
       'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options) => {
         var sol = _solveODE(f, T, [y0], options);
         return {
           t: sol.t,
           y: sol.y.map(Y => Y[0])
         };
       },
       'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options) => {
         var sol = _solveODE(f, T.toArray(), [y0], options);
         return {
           t: matrix(sol.t),
           y: matrix(sol.y.map(Y => Y[0]))
         };
       }
     });
   });

   /* eslint-disable no-loss-of-precision */

   var name$33 = 'erf';
   var dependencies$33 = ['typed'];
   var createErf = /* #__PURE__ */factory(name$33, dependencies$33, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the erf function of a value using a rational Chebyshev
      * approximations for different intervals of x.
      *
      * This is a translation of W. J. Cody's Fortran implementation from 1987
      * ( https://www.netlib.org/specfun/erf ). See the AMS publication
      * "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
      * for an explanation of this process.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.erf(x)
      *
      * Examples:
      *
      *    math.erf(0.2)    // returns 0.22270258921047847
      *    math.erf(-0.5)   // returns -0.5204998778130465
      *    math.erf(4)      // returns 0.9999999845827421
      *
      * See also:
      *    zeta
      *
      * @param {number | Array | Matrix} x   A real number
      * @return {number | Array | Matrix}    The erf of `x`
      */
     return typed('name', {
       number: function number(x) {
         var y = Math.abs(x);
         if (y >= MAX_NUM) {
           return sign$2(x);
         }
         if (y <= THRESH) {
           return sign$2(x) * erf1(y);
         }
         if (y <= 4.0) {
           return sign$2(x) * (1 - erfc2(y));
         }
         return sign$2(x) * (1 - erfc3(y));
       },
       'Array | Matrix': typed.referToSelf(self => n => deepMap(n, self))

       // TODO: For complex numbers, use the approximation for the Faddeeva function
       //  from "More Efficient Computation of the Complex Error Function" (AMS)
     });

     /**
      * Approximates the error function erf() for x <= 0.46875 using this function:
      *               n
      * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))
      *              j=0
      */
     function erf1(y) {
       var ysq = y * y;
       var xnum = P[0][4] * ysq;
       var xden = ysq;
       var i;
       for (i = 0; i < 3; i += 1) {
         xnum = (xnum + P[0][i]) * ysq;
         xden = (xden + Q[0][i]) * ysq;
       }
       return y * (xnum + P[0][3]) / (xden + Q[0][3]);
     }

     /**
      * Approximates the complement of the error function erfc() for
      * 0.46875 <= x <= 4.0 using this function:
      *                       n
      * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)
      *                      j=0
      */
     function erfc2(y) {
       var xnum = P[1][8] * y;
       var xden = y;
       var i;
       for (i = 0; i < 7; i += 1) {
         xnum = (xnum + P[1][i]) * y;
         xden = (xden + Q[1][i]) * y;
       }
       var result = (xnum + P[1][7]) / (xden + Q[1][7]);
       var ysq = parseInt(y * 16) / 16;
       var del = (y - ysq) * (y + ysq);
       return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
     }

     /**
      * Approximates the complement of the error function erfc() for x > 4.0 using
      * this function:
      *
      * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +
      *               n
      *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]
      *              j=0
      */
     function erfc3(y) {
       var ysq = 1 / (y * y);
       var xnum = P[2][5] * ysq;
       var xden = ysq;
       var i;
       for (i = 0; i < 4; i += 1) {
         xnum = (xnum + P[2][i]) * ysq;
         xden = (xden + Q[2][i]) * ysq;
       }
       var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
       result = (SQRPI - result) / y;
       ysq = parseInt(y * 16) / 16;
       var del = (y - ysq) * (y + ysq);
       return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
     }
   });

   /**
    * Upper bound for the first approximation interval, 0 <= x <= THRESH
    * @constant
    */
   var THRESH = 0.46875;

   /**
    * Constant used by W. J. Cody's Fortran77 implementation to denote sqrt(pi)
    * @constant
    */
   var SQRPI = 5.6418958354775628695e-1;

   /**
    * Coefficients for each term of the numerator sum (p_j) for each approximation
    * interval (see W. J. Cody's paper for more details)
    * @constant
    */
   var P = [[3.16112374387056560e00, 1.13864154151050156e02, 3.77485237685302021e02, 3.20937758913846947e03, 1.85777706184603153e-1], [5.64188496988670089e-1, 8.88314979438837594e00, 6.61191906371416295e01, 2.98635138197400131e02, 8.81952221241769090e02, 1.71204761263407058e03, 2.05107837782607147e03, 1.23033935479799725e03, 2.15311535474403846e-8], [3.05326634961232344e-1, 3.60344899949804439e-1, 1.25781726111229246e-1, 1.60837851487422766e-2, 6.58749161529837803e-4, 1.63153871373020978e-2]];

   /**
    * Coefficients for each term of the denominator sum (q_j) for each approximation
    * interval (see W. J. Cody's paper for more details)
    * @constant
    */
   var Q = [[2.36012909523441209e01, 2.44024637934444173e02, 1.28261652607737228e03, 2.84423683343917062e03], [1.57449261107098347e01, 1.17693950891312499e02, 5.37181101862009858e02, 1.62138957456669019e03, 3.29079923573345963e03, 4.36261909014324716e03, 3.43936767414372164e03, 1.23033935480374942e03], [2.56852019228982242e00, 1.87295284992346047e00, 5.27905102951428412e-1, 6.05183413124413191e-2, 2.33520497626869185e-3]];

   /**
    * Maximum/minimum safe numbers to input to erf() (in ES6+, this number is
    * Number.[MAX|MIN]_SAFE_INTEGER). erf() for all numbers beyond this limit will
    * return 1
    */
   var MAX_NUM = Math.pow(2, 53);

   var name$32 = 'zeta';
   var dependencies$32 = ['typed', 'config', 'multiply', 'pow', 'divide', 'factorial', 'equal', 'smallerEq', 'isNegative', 'gamma', 'sin', 'subtract', 'add', '?Complex', '?BigNumber', 'pi'];
   var createZeta = /* #__PURE__ */factory(name$32, dependencies$32, _ref => {
     var {
       typed,
       config,
       multiply,
       pow,
       divide,
       factorial,
       equal,
       smallerEq,
       isNegative,
       gamma,
       sin,
       subtract,
       add,
       Complex,
       BigNumber: _BigNumber,
       pi
     } = _ref;
     /**
      * Compute the Riemann Zeta function of a value using an infinite series for
      * all of the complex plane using Riemann's Functional equation.
      *
      * Based off the paper by Xavier Gourdon and Pascal Sebah
      * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )
      *
      * Implementation and slight modification by Anik Patel
      *
      * Note: the implementation is accurate up to about 6 digits.
      *
      * Syntax:
      *
      *    math.zeta(n)
      *
      * Examples:
      *
      *    math.zeta(5)       // returns 1.0369277551433895
      *    math.zeta(-0.5)    // returns -0.2078862249773449
      *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i
      *
      * See also:
      *    erf
      *
      * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function
      * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`
      */
     return typed(name$32, {
       number: s => zetaNumeric(s, value => value, () => 20),
       BigNumber: s => zetaNumeric(s, value => new _BigNumber(value), () => {
         // epsilon is for example 1e-12. Extract the positive exponent 12 from that
         return Math.abs(Math.log10(config.epsilon));
       }),
       Complex: zetaComplex
     });

     /**
      * @param {number | BigNumber} s
      * @param {(value: number) => number | BigNumber} createValue
      * @param {(value: number | BigNumber | Complex) => number} determineDigits
      * @returns {number | BigNumber}
      */
     function zetaNumeric(s, createValue, determineDigits) {
       if (equal(s, 0)) {
         return createValue(-0.5);
       }
       if (equal(s, 1)) {
         return createValue(NaN);
       }
       if (!isFinite(s)) {
         return isNegative(s) ? createValue(NaN) : createValue(1);
       }
       return zeta(s, createValue, determineDigits, s => s);
     }

     /**
      * @param {Complex} s
      * @returns {Complex}
      */
     function zetaComplex(s) {
       if (s.re === 0 && s.im === 0) {
         return new Complex(-0.5);
       }
       if (s.re === 1) {
         return new Complex(NaN, NaN);
       }
       if (s.re === Infinity && s.im === 0) {
         return new Complex(1);
       }
       if (s.im === Infinity || s.re === -Infinity) {
         return new Complex(NaN, NaN);
       }
       return zeta(s, value => value, s => Math.round(1.3 * 15 + 0.9 * Math.abs(s.im)), s => s.re);
     }

     /**
      * @param {number | BigNumber | Complex} s
      * @param {(value: number) => number | BigNumber | Complex} createValue
      * @param {(value: number | BigNumber | Complex) => number} determineDigits
      * @param {(value: number | BigNumber | Complex) => number} getRe
      * @returns {*|number}
      */
     function zeta(s, createValue, determineDigits, getRe) {
       var n = determineDigits(s);
       if (getRe(s) > -(n - 1) / 2) {
         return f(s, createValue(n), createValue);
       } else {
         // Function Equation for reflection to x < 1
         var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));
         c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));
         c = multiply(c, gamma(subtract(1, s)));
         return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));
       }
     }

     /**
      * Calculate a portion of the sum
      * @param {number | BigNumber} k   a positive integer
      * @param {number | BigNumber} n   a positive integer
      * @return {number}    the portion of the sum
      **/
     function d(k, n) {
       var S = k;
       for (var j = k; smallerEq(j, n); j = add(j, 1)) {
         var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));
         S = add(S, factor);
       }
       return multiply(n, S);
     }

     /**
      * Calculate the positive Riemann Zeta function
      * @param {number} s   a real or complex number with s.re > 1
      * @param {number} n   a positive integer
      * @param {(number) => number | BigNumber | Complex} createValue
      * @return {number}    Riemann Zeta of s
      **/
     function f(s, n, createValue) {
       var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));
       var S = createValue(0);
       for (var k = createValue(1); smallerEq(k, n); k = add(k, 1)) {
         S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));
       }
       return multiply(c, S);
     }
   });

   var name$31 = 'mode';
   var dependencies$31 = ['typed', 'isNaN', 'isNumeric'];
   var createMode = /* #__PURE__ */factory(name$31, dependencies$31, _ref => {
     var {
       typed,
       isNaN,
       isNumeric
     } = _ref;
     /**
     * Computes the mode of a set of numbers or a list with values(numbers or characters).
     * If there are multiple modes, it returns a list of those values.
     *
     * Syntax:
     *
     *     math.mode(a, b, c, ...)
     *     math.mode(A)
     *
     * Examples:
     *
     *     math.mode(2, 1, 4, 3, 1)                            // returns [1]
     *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]
     *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
     *     math.mode('a','a','b','c')                           // returns ["a"]
     *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
     *
     * See also:
     *
     *     median,
     *     mean
     *
     * @param {... *} args  A single matrix
     * @return {*} The mode of all values
     */
     return typed(name$31, {
       'Array | Matrix': _mode,
       '...': function _(args) {
         return _mode(args);
       }
     });

     /**
      * Calculates the mode in an 1-dimensional array
      * @param {Array} values
      * @return {Array} mode
      * @private
      */
     function _mode(values) {
       values = flatten$1(values.valueOf());
       var num = values.length;
       if (num === 0) {
         throw new Error('Cannot calculate mode of an empty array');
       }
       var count = {};
       var mode = [];
       var max = 0;
       for (var i = 0; i < values.length; i++) {
         var value = values[i];
         if (isNumeric(value) && isNaN(value)) {
           throw new Error('Cannot calculate mode of an array containing NaN values');
         }
         if (!(value in count)) {
           count[value] = 0;
         }
         count[value]++;
         if (count[value] === max) {
           mode.push(value);
         } else if (count[value] > max) {
           max = count[value];
           mode = [value];
         }
       }
       return mode;
     }
   });

   /**
    * Improve error messages for statistics functions. Errors are typically
    * thrown in an internally used function like larger, causing the error
    * not to mention the function (like max) which is actually used by the user.
    *
    * @param {Error} err
    * @param {String} fnName
    * @param {*} [value]
    * @return {Error}
    */
   function improveErrorMessage(err, fnName, value) {
     // TODO: add information with the index (also needs transform in expression parser)
     var details;
     if (String(err).indexOf('Unexpected type') !== -1) {
       details = arguments.length > 2 ? ' (type: ' + typeOf$1(value) + ', value: ' + JSON.stringify(value) + ')' : ' (type: ' + err.data.actual + ')';
       return new TypeError('Cannot calculate ' + fnName + ', unexpected type of argument' + details);
     }
     if (String(err).indexOf('complex numbers') !== -1) {
       details = arguments.length > 2 ? ' (type: ' + typeOf$1(value) + ', value: ' + JSON.stringify(value) + ')' : '';
       return new TypeError('Cannot calculate ' + fnName + ', no ordering relation is defined for complex numbers' + details);
     }
     return err;
   }

   var name$30 = 'prod';
   var dependencies$30 = ['typed', 'config', 'multiplyScalar', 'numeric'];
   var createProd = /* #__PURE__ */factory(name$30, dependencies$30, _ref => {
     var {
       typed,
       config,
       multiplyScalar,
       numeric
     } = _ref;
     /**
      * Compute the product of a matrix or a list with values.
      * In case of a multidimensional array or matrix, the sum of all
      * elements will be calculated.
      *
      * Syntax:
      *
      *     math.prod(a, b, c, ...)
      *     math.prod(A)
      *
      * Examples:
      *
      *     math.multiply(2, 3)           // returns 6
      *     math.prod(2, 3)               // returns 6
      *     math.prod(2, 3, 4)            // returns 24
      *     math.prod([2, 3, 4])          // returns 24
      *     math.prod([[2, 5], [4, 3]])   // returns 120
      *
      * See also:
      *
      *    mean, median, min, max, sum, std, variance
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The product of all values
      */
     return typed(name$30, {
       // prod([a, b, c, d, ...])
       'Array | Matrix': _prod,
       // prod([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
         // TODO: implement prod(A, dim)
         throw new Error('prod(A, dim) is not yet supported');
         // return reduce(arguments[0], arguments[1], math.prod)
       },

       // prod(a, b, c, d, ...)
       '...': function _(args) {
         return _prod(args);
       }
     });

     /**
      * Recursively calculate the product of an n-dimensional array
      * @param {Array} array
      * @return {number} prod
      * @private
      */
     function _prod(array) {
       var prod;
       deepForEach(array, function (value) {
         try {
           prod = prod === undefined ? value : multiplyScalar(prod, value);
         } catch (err) {
           throw improveErrorMessage(err, 'prod', value);
         }
       });

       // make sure returning numeric value: parse a string into a numeric value
       if (typeof prod === 'string') {
         prod = numeric(prod, config.number);
       }
       if (prod === undefined) {
         throw new Error('Cannot calculate prod of an empty array');
       }
       return prod;
     }
   });

   var name$2$ = 'format';
   var dependencies$2$ = ['typed'];
   var createFormat = /* #__PURE__ */factory(name$2$, dependencies$2$, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Format a value of any type into a string.
      *
      * Syntax:
      *
      *    math.format(value)
      *    math.format(value, options)
      *    math.format(value, precision)
      *    math.format(value, callback)
      *
      * Where:
      *
      *  - `value: *`
      *    The value to be formatted
      *  - `options: Object`
      *    An object with formatting options. Available options:
      *    - `notation: string`
      *      Number notation. Choose from:
      *      - `'fixed'`
      *        Always use regular number notation.
      *        For example `'123.40'` and `'14000000'`
      *      - `'exponential'`
      *        Always use exponential notation.
      *        For example `'1.234e+2'` and `'1.4e+7'`
      *      - `'engineering'`
      *        Always use engineering notation: always have exponential notation,
      *        and select the exponent to be a multiple of `3`.
      *        For example `'123.4e+0'` and `'14.0e+6'`
      *      - `'auto'` (default)
      *        Regular number notation for numbers having an absolute value between
      *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
      *        Lower bound is included, upper bound is excluded.
      *        For example `'123.4'` and `'1.4e7'`.
      *      - `'bin'`, `'oct'`, or `'hex'`
      *        Format the number using binary, octal, or hexadecimal notation.
      *        For example `'0b1101'` and `'0x10fe'`.
      *    - `wordSize: number`
      *      The word size in bits to use for formatting in binary, octal, or
      *      hexadecimal notation. To be used only with `'bin'`, `'oct'`, or `'hex'`
      *      values for `notation` option. When this option is defined the value
      *      is formatted as a signed twos complement integer of the given word
      *      size and the size suffix is appended to the output.
      *      For example `format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'`.
      *      Default value is undefined.
      *    - `precision: number`
      *      Limit the number of digits of the formatted value.
      *      For regular numbers, must be a number between `0` and `16`.
      *      For bignumbers, the maximum depends on the configured precision,
      *      see function `config()`.
      *      In case of notations `'exponential'`, `'engineering'`, and `'auto'`,
      *      `precision` defines the total number of significant digits returned.
      *      In case of notation `'fixed'`, `precision` defines the number of
      *      significant digits after the decimal point.
      *      `precision` is undefined by default.
      *    - `lowerExp: number`
      *      Exponent determining the lower boundary for formatting a value with
      *      an exponent when `notation='auto'`. Default value is `-3`.
      *    - `upperExp: number`
      *      Exponent determining the upper boundary for formatting a value with
      *      an exponent when `notation='auto'`. Default value is `5`.
      *    - `fraction: string`. Available values: `'ratio'` (default) or `'decimal'`.
      *      For example `format(fraction(1, 3))` will output `'1/3'` when `'ratio'`
      *      is configured, and will output `'0.(3)'` when `'decimal'` is configured.
      *    - `truncate: number`. Specifies the maximum allowed length of the
      *      returned string. If it had been longer, the excess characters
      *      are deleted and replaced with `'...'`.
      * - `callback: function`
      *   A custom formatting function, invoked for all numeric elements in `value`,
      *   for example all elements of a matrix, or the real and imaginary
      *   parts of a complex number. This callback can be used to override the
      *   built-in numeric notation with any type of formatting. Function `callback`
      *   is called with `value` as parameter and must return a string.
      *
      * When `value` is an Object:
      *
      * - When the object contains a property `format` being a function, this function
      *   is invoked as `value.format(options)` and the result is returned.
      * - When the object has its own `toString` method, this method is invoked
      *   and the result is returned.
      * - In other cases the function will loop over all object properties and
      *   return JSON object notation like '{"a": 2, "b": 3}'.
      *
      * When value is a function:
      *
      * - When the function has a property `syntax`, it returns this
      *   syntax description.
      * - In other cases, a string `'function'` is returned.
      *
      * Examples:
      *
      *    math.format(6.4)                                        // returns '6.4'
      *    math.format(1240000)                                    // returns '1.24e+6'
      *    math.format(1/3)                                        // returns '0.3333333333333333'
      *    math.format(1/3, 3)                                     // returns '0.333'
      *    math.format(21385, 2)                                   // returns '21000'
      *    math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'
      *    math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'
      *    math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'
      *    math.format(12400, {notation: 'engineering'})           // returns '12.4e+3'
      *    math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'
      *
      *    function formatCurrency(value) {
      *      // return currency notation with two digits:
      *      return '$' + value.toFixed(2)
      *
      *      // you could also use math.format inside the callback:
      *      // return '$' + math.format(value, {notation: 'fixed', precision: 2})
      *    }
      *    math.format([2.1, 3, 0.016], formatCurrency)            // returns '[$2.10, $3.00, $0.02]'
      *
      * See also:
      *
      *    print
      *
      * @param {*} value                               Value to be stringified
      * @param {Object | Function | number} [options]  Formatting options
      * @return {string} The formatted value
      */
     return typed(name$2$, {
       any: format$1,
       'any, Object | function | number': format$1
     });
   });

   var name$2_ = 'bin';
   var dependencies$2_ = ['typed', 'format'];

   /**
    * Format a number as binary.
    *
    * Syntax:
    *
    *    math.bin(value)
    *
    * Examples:
    *
    *    //the following outputs "0b10"
    *    math.bin(2)
    *
    * See also:
    *
    *    oct
    *    hex
    *
    * @param {number} value    Value to be stringified
    * @param {number} wordSize Optional word size (see `format`)
    * @return {string}         The formatted value
    */
   var createBin = factory(name$2_, dependencies$2_, _ref => {
     var {
       typed,
       format
     } = _ref;
     return typed(name$2_, {
       'number | BigNumber': function numberBigNumber(n) {
         return format(n, {
           notation: 'bin'
         });
       },
       'number | BigNumber, number': function numberBigNumberNumber(n, wordSize) {
         return format(n, {
           notation: 'bin',
           wordSize
         });
       }
     });
   });

   var name$2Z = 'oct';
   var dependencies$2Z = ['typed', 'format'];

   /**
    * Format a number as octal.
    *
    * Syntax:
    *
    *    math.oct(value)
    *
    * Examples:
    *
    *    //the following outputs "0o70"
    *    math.oct(56)
    *
    * See also:
    *
    *    bin
    *    hex
    *
    * @param {number} value    Value to be stringified
    * @param {number} wordSize Optional word size (see `format`)
    * @return {string}         The formatted value
    */

   var createOct = factory(name$2Z, dependencies$2Z, _ref => {
     var {
       typed,
       format
     } = _ref;
     return typed(name$2Z, {
       'number | BigNumber': function numberBigNumber(n) {
         return format(n, {
           notation: 'oct'
         });
       },
       'number | BigNumber, number': function numberBigNumberNumber(n, wordSize) {
         return format(n, {
           notation: 'oct',
           wordSize
         });
       }
     });
   });

   var name$2Y = 'hex';
   var dependencies$2Y = ['typed', 'format'];

   /**
    * Format a number as hexadecimal.
    *
    * Syntax:
    *
    *    math.hex(value)
    *
    * Examples:
    *
    *    math.hex(240) // returns "0xF0"
    *
    * See also:
    *
    *    oct
    *    bin
    *
    * @param {number} value    Value to be stringified
    * @param {number} wordSize Optional word size (see `format`)
    * @return {string}         The formatted value
    */
   var createHex = factory(name$2Y, dependencies$2Y, _ref => {
     var {
       typed,
       format
     } = _ref;
     return typed(name$2Y, {
       'number | BigNumber': function numberBigNumber(n) {
         return format(n, {
           notation: 'hex'
         });
       },
       'number | BigNumber, number': function numberBigNumberNumber(n, wordSize) {
         return format(n, {
           notation: 'hex',
           wordSize
         });
       }
     });
   });

   var name$2X = 'print';
   var dependencies$2X = ['typed'];
   var createPrint = /* #__PURE__ */factory(name$2X, dependencies$2X, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Interpolate values into a string template.
      *
      * Syntax:
      *
      *     math.print(template, values)
      *     math.print(template, values, precision)
      *     math.print(template, values, options)
      *
      * Example usage:
      *
      *     // the following outputs: 'Lucy is 5 years old'
      *     math.print('Lucy is $age years old', {age: 5})
      *
      *     // the following outputs: 'The value of pi is 3.141592654'
      *     math.print('The value of pi is $pi', {pi: math.pi}, 10)
      *
      *     // the following outputs: 'hello Mary! The date is 2013-03-23'
      *     math.print('Hello $user.name! The date is $date', {
      *       user: {
      *         name: 'Mary',
      *       },
      *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
      *     })
      *
      *     // the following outputs: 'My favorite fruits are apples and bananas !'
      *     math.print('My favorite fruits are $0 and $1 !', [
      *       'apples',
      *       'bananas'
      *     ])
      *
      * See also:
      *
      *     format
      *
      * @param {string} template           A string containing variable placeholders.
      * @param {Object | Array | Matrix}   values An object or array containing variables
      *                                    which will be filled in in the template.
      * @param {number | Object} [options] Formatting options,
      *                                    or the number of digits to format numbers.
      *                                    See function math.format for a description
      *                                    of all options.
      * @return {string} Interpolated string
      */
     return typed(name$2X, {
       // note: Matrix will be converted automatically to an Array
       'string, Object | Array': _print,
       'string, Object | Array, number | Object': _print
     });
   });

   /**
    * Interpolate values into a string template.
    * @param {string} template
    * @param {Object} values
    * @param {number | Object} [options]
    * @returns {string} Interpolated string
    * @private
    */
   function _print(template, values, options) {
     return template.replace(/\$([\w.]+)/g, function (original, key) {
       var keys = key.split('.');
       var value = values[keys.shift()];
       while (keys.length && value !== undefined) {
         var k = keys.shift();
         value = k ? value[k] : value + '.';
       }
       if (value !== undefined) {
         if (!isString(value)) {
           return format$1(value, options);
         } else {
           return value;
         }
       }
       return original;
     });
   }

   var name$2W = 'to';
   var dependencies$2W = ['typed', 'matrix', 'concat'];
   var createTo = /* #__PURE__ */factory(name$2W, dependencies$2W, _ref => {
     var {
       typed,
       matrix,
       concat
     } = _ref;
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Change the unit of a value.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.to(x, unit)
      *
      * Examples:
      *
      *    math.to(math.unit('2 inch'), 'cm')             // returns Unit 5.08 cm
      *    math.to(math.unit('2 inch'), math.unit('cm'))  // returns Unit 5.08 cm
      *    math.to(math.unit(16, 'bytes'), 'bits')        // returns Unit 128 bits
      *
      * See also:
      *
      *    unit
      *
      * @param {Unit | Array | Matrix} x     The unit to be converted.
      * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
      *                                      or a unit without value.
      * @return {Unit | Array | Matrix} value with changed, fixed unit.
      */
     return typed(name$2W, {
       'Unit, Unit | string': (x, unit) => x.to(unit)
     }, matrixAlgorithmSuite({
       Ds: true
     }));
   });

   var name$2V = 'isPrime';
   var dependencies$2V = ['typed'];
   var createIsPrime = /* #__PURE__ */factory(name$2V, dependencies$2V, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Test whether a value is prime: has no divisors other than itself and one.
      * The function supports type `number`, `bignumber`.
      *
      * The function is evaluated element-wise in case of Array or Matrix input.
      *
      * Syntax:
      *
      *     math.isPrime(x)
      *
      * Examples:
      *
      *    math.isPrime(3)                     // returns true
      *    math.isPrime(-2)                    // returns false
      *    math.isPrime(0)                     // returns false
      *    math.isPrime(-0)                    // returns false
      *    math.isPrime(0.5)                   // returns false
      *    math.isPrime('2')                   // returns true
      *    math.isPrime([2, 17, 100])           // returns [true, true, false]
      *
      * See also:
      *
      *    isNumeric, isZero, isNegative, isInteger
      *
      * @param {number | BigNumber | Array | Matrix} x  Value to be tested
      * @return {boolean}  Returns true when `x` is larger than zero.
      *                    Throws an error in case of an unknown data type.
      */
     return typed(name$2V, {
       number: function number(x) {
         if (x * 0 !== 0) {
           return false;
         }
         if (x <= 3) {
           return x > 1;
         }
         if (x % 2 === 0 || x % 3 === 0) {
           return false;
         }
         for (var i = 5; i * i <= x; i += 6) {
           if (x % i === 0 || x % (i + 2) === 0) {
             return false;
           }
         }
         return true;
       },
       BigNumber: function BigNumber(n) {
         if (n.toNumber() * 0 !== 0) {
           return false;
         }
         if (n.lte(3)) return n.gt(1);
         if (n.mod(2).eq(0) || n.mod(3).eq(0)) return false;
         if (n.lt(Math.pow(2, 32))) {
           var x = n.toNumber();
           for (var i = 5; i * i <= x; i += 6) {
             if (x % i === 0 || x % (i + 2) === 0) {
               return false;
             }
           }
           return true;
         }
         function modPow(base, exponent, modulus) {
           // exponent can be huge, use non-recursive variant
           var accumulator = 1;
           while (!exponent.eq(0)) {
             if (exponent.mod(2).eq(0)) {
               exponent = exponent.div(2);
               base = base.mul(base).mod(modulus);
             } else {
               exponent = exponent.sub(1);
               accumulator = base.mul(accumulator).mod(modulus);
             }
           }
           return accumulator;
         }

         // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants
         var Decimal = n.constructor.clone({
           precision: n.toFixed(0).length * 2
         });
         n = new Decimal(n);
         var r = 0;
         var d = n.sub(1);
         while (d.mod(2).eq(0)) {
           d = d.div(2);
           r += 1;
         }
         var bases = null;
         // https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases
         if (n.lt('3317044064679887385961981')) {
           bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter(x => x < n);
         } else {
           var max = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
           bases = [];
           for (var _i = 2; _i <= max; _i += 1) {
             bases.push(max);
           }
         }
         for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
           var a = bases[_i2];
           var adn = modPow(n.sub(n).add(a), d, n);
           if (!adn.eq(1)) {
             for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
               if (_i3 === r - 1) {
                 return false;
               }
             }
           }
         }
         return true;
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$2U = 'numeric';
   var dependencies$2U = ['number', '?bignumber', '?fraction'];
   var createNumeric = /* #__PURE__ */factory(name$2U, dependencies$2U, _ref => {
     var {
       number: _number,
       bignumber,
       fraction
     } = _ref;
     var validInputTypes = {
       string: true,
       number: true,
       BigNumber: true,
       Fraction: true
     };

     // Load the conversion functions for each output type
     var validOutputTypes = {
       number: x => _number(x),
       BigNumber: bignumber ? x => bignumber(x) : noBignumber,
       Fraction: fraction ? x => fraction(x) : noFraction
     };

     /**
      * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
      *
      * Syntax:
      *
      *    math.numeric(x)
      *
      * Examples:
      *
      *    math.numeric('4')                           // returns 4
      *    math.numeric('4', 'number')                 // returns 4
      *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
      *    math.numeric('4', 'Fraction')               // returns Fraction 4
      *    math.numeric(4, 'Fraction')                 // returns Fraction 4
      *    math.numeric(math.fraction(2, 5), 'number') // returns 0.4
      *
      * See also:
      *
      *    number, fraction, bignumber, string, format
      *
      * @param {string | number | BigNumber | Fraction } value
      *              A numeric value or a string containing a numeric value
      * @param {string} outputType
      *              Desired numeric output type.
      *              Available values: 'number', 'BigNumber', or 'Fraction'
      * @return {number | BigNumber | Fraction}
      *              Returns an instance of the numeric in the requested type
      */
     return function numeric(value) {
       var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'number';
       var check = arguments.length > 2 ? arguments[2] : undefined;
       if (check !== undefined) {
         throw new SyntaxError('numeric() takes one or two arguments');
       }
       var inputType = typeOf$1(value);
       if (!(inputType in validInputTypes)) {
         throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
       }
       if (!(outputType in validOutputTypes)) {
         throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
       }
       if (outputType === inputType) {
         return value;
       } else {
         return validOutputTypes[outputType](value);
       }
     };
   });

   var name$2T = 'divideScalar';
   var dependencies$2T = ['typed', 'numeric'];
   var createDivideScalar = /* #__PURE__ */factory(name$2T, dependencies$2T, _ref => {
     var {
       typed,
       numeric
     } = _ref;
     /**
      * Divide two scalar values, `x / y`.
      * This function is meant for internal use: it is used by the public functions
      * `divide` and `inv`.
      *
      * This function does not support collections (Array or Matrix).
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
      * @param  {number | BigNumber | Fraction | Complex} y          Denominator
      * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
      * @private
      */
     return typed(name$2T, {
       'number, number': function numberNumber(x, y) {
         return x / y;
       },
       'Complex, Complex': function ComplexComplex(x, y) {
         return x.div(y);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.div(y);
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         return x.div(y);
       },
       'Unit, number | Complex | Fraction | BigNumber | Unit': (x, y) => x.divide(y),
       'number | Fraction | Complex | BigNumber, Unit': (x, y) => y.divideInto(x)
     });
   });

   var name$2S = 'pow';
   var dependencies$2S = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];
   var createPow = /* #__PURE__ */factory(name$2S, dependencies$2S, _ref => {
     var {
       typed,
       config,
       identity,
       multiply,
       matrix,
       inv,
       number,
       fraction,
       Complex
     } = _ref;
     /**
      * Calculates the power of x to y, `x ^ y`.
      *
      * Matrix exponentiation is supported for square matrices `x` and integers `y`:
      * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
      * negative, `x` must be invertible, and then this function returns
      * inv(x)^(-y).
      *
      * For cubic roots of negative numbers, the function returns the principal
      * root by default. In order to let the function return the real root,
      * math.js can be configured with `math.config({predictable: true})`.
      * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
      *
      * Syntax:
      *
      *    math.pow(x, y)
      *
      * Examples:
      *
      *    math.pow(2, 3)               // returns number 8
      *
      *    const a = math.complex(2, 3)
      *    math.pow(a, 2)                // returns Complex -5 + 12i
      *
      *    const b = [[1, 2], [4, 3]]
      *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
      *
      *    const c = [[1, 2], [4, 3]]
      *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
      *
      * See also:
      *
      *    multiply, sqrt, cbrt, nthRoot
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
      * @param  {number | BigNumber | Complex} y                          The exponent
      * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
      */
     return typed(name$2S, {
       'number, number': _pow,
       'Complex, Complex': function ComplexComplex(x, y) {
         return x.pow(y);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         if (y.isInteger() || x >= 0 || config.predictable) {
           return x.pow(y);
         } else {
           return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
         }
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         var result = x.pow(y);
         if (result != null) {
           return result;
         }
         if (config.predictable) {
           throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
         } else {
           return _pow(x.valueOf(), y.valueOf());
         }
       },
       'Array, number': _powArray,
       'Array, BigNumber': function ArrayBigNumber(x, y) {
         return _powArray(x, y.toNumber());
       },
       'Matrix, number': _powMatrix,
       'Matrix, BigNumber': function MatrixBigNumber(x, y) {
         return _powMatrix(x, y.toNumber());
       },
       'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {
         return x.pow(y);
       }
     });

     /**
      * Calculates the power of x to y, x^y, for two numbers.
      * @param {number} x
      * @param {number} y
      * @return {number | Complex} res
      * @private
      */
     function _pow(x, y) {
       // Alternatively could define a 'realmode' config option or something, but
       // 'predictable' will work for now
       if (config.predictable && !isInteger$1(y) && x < 0) {
         // Check to see if y can be represented as a fraction
         try {
           var yFrac = fraction(y);
           var yNum = number(yFrac);
           if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
             if (yFrac.d % 2 === 1) {
               return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
             }
           }
         } catch (ex) {
           // fraction() throws an error if y is Infinity, etc.
         }

         // Unable to express y as a fraction, so continue on
       }

       // **for predictable mode** x^Infinity === NaN if x < -1
       // N.B. this behavour is different from `Math.pow` which gives
       // (-2)^Infinity === Infinity
       if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
         return NaN;
       }
       if (isInteger$1(y) || x >= 0 || config.predictable) {
         return powNumber(x, y);
       } else {
         // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow

         // x^Infinity === 0 if -1 < x < 1
         // A real number 0 is returned instead of complex(0)
         if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
           return 0;
         }
         return new Complex(x, 0).pow(y, 0);
       }
     }

     /**
      * Calculate the power of a 2d array
      * @param {Array} x     must be a 2 dimensional, square matrix
      * @param {number} y    a integer value (positive if `x` is not invertible)
      * @returns {Array}
      * @private
      */
     function _powArray(x, y) {
       if (!isInteger$1(y)) {
         throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
       }
       // verify that A is a 2 dimensional square matrix
       var s = arraySize(x);
       if (s.length !== 2) {
         throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
       }
       if (s[0] !== s[1]) {
         throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
       }
       if (y < 0) {
         try {
           return _powArray(inv(x), -y);
         } catch (error) {
           if (error.message === 'Cannot calculate inverse, determinant is zero') {
             throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
           }
           throw error;
         }
       }
       var res = identity(s[0]).valueOf();
       var px = x;
       while (y >= 1) {
         if ((y & 1) === 1) {
           res = multiply(px, res);
         }
         y >>= 1;
         px = multiply(px, px);
       }
       return res;
     }

     /**
      * Calculate the power of a 2d matrix
      * @param {Matrix} x     must be a 2 dimensional, square matrix
      * @param {number} y    a positive, integer value
      * @returns {Matrix}
      * @private
      */
     function _powMatrix(x, y) {
       return matrix(_powArray(x.valueOf(), y));
     }
   });

   var NO_INT = 'Number of decimals in function round must be an integer';
   var name$2R = 'round';
   var dependencies$2R = ['typed', 'matrix', 'equalScalar', 'zeros', 'BigNumber', 'DenseMatrix'];
   var createRound = /* #__PURE__ */factory(name$2R, dependencies$2R, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       zeros,
       BigNumber,
       DenseMatrix
     } = _ref;
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });

     /**
      * Round a value towards the nearest rounded value.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.round(x)
      *    math.round(x, n)
      *
      * Examples:
      *
      *    math.round(3.22)             // returns number 3
      *    math.round(3.82)             // returns number 4
      *    math.round(-4.2)             // returns number -4
      *    math.round(-4.7)             // returns number -5
      *    math.round(3.22, 1)          // returns number 3.2
      *    math.round(3.88, 1)          // returns number 3.9
      *    math.round(-4.21, 1)         // returns number -4.2
      *    math.round(-4.71, 1)         // returns number -4.7
      *    math.round(math.pi, 3)       // returns number 3.142
      *    math.round(123.45678, 2)     // returns number 123.46
      *
      *    const c = math.complex(3.2, -2.7)
      *    math.round(c)                // returns Complex 3 - 3i
      *
      *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]
      *
      * See also:
      *
      *    ceil, fix, floor
      *
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
      * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
      * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
      */
     return typed(name$2R, {
       number: roundNumber,
       'number, number': roundNumber,
       'number, BigNumber': function numberBigNumber(x, n) {
         if (!n.isInteger()) {
           throw new TypeError(NO_INT);
         }
         return new BigNumber(x).toDecimalPlaces(n.toNumber());
       },
       Complex: function Complex(x) {
         return x.round();
       },
       'Complex, number': function ComplexNumber(x, n) {
         if (n % 1) {
           throw new TypeError(NO_INT);
         }
         return x.round(n);
       },
       'Complex, BigNumber': function ComplexBigNumber(x, n) {
         if (!n.isInteger()) {
           throw new TypeError(NO_INT);
         }
         var _n = n.toNumber();
         return x.round(_n);
       },
       BigNumber: function BigNumber(x) {
         return x.toDecimalPlaces(0);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, n) {
         if (!n.isInteger()) {
           throw new TypeError(NO_INT);
         }
         return x.toDecimalPlaces(n.toNumber());
       },
       Fraction: function Fraction(x) {
         return x.round();
       },
       'Fraction, number': function FractionNumber(x, n) {
         if (n % 1) {
           throw new TypeError(NO_INT);
         }
         return x.round(n);
       },
       'Fraction, BigNumber': function FractionBigNumber(x, n) {
         if (!n.isInteger()) {
           throw new TypeError(NO_INT);
         }
         return x.round(n.toNumber());
       },
       // deep map collection, skip zeros since round(0) = 0
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),
       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         return matAlgo14xDs(x, y, self, false);
       }),
       'Array, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return matAlgo14xDs(matrix(x), y, self, false).valueOf();
       }),
       'number | Complex | BigNumber | Fraction, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar is zero
         if (equalScalar(x, 0)) {
           // do not execute algorithm, result will be a zero matrix
           return zeros(y.size(), y.storage());
         }
         return matAlgo12xSfs(y, x, self, true);
       }),
       'number | Complex | BigNumber | Fraction, DenseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar is zero
         if (equalScalar(x, 0)) {
           // do not execute algorithm, result will be a zero matrix
           return zeros(y.size(), y.storage());
         }
         return matAlgo14xDs(y, x, self, true);
       }),
       'number | Complex | BigNumber | Fraction, Array': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return matAlgo14xDs(matrix(y), x, self, true).valueOf();
       })
     });
   });

   var name$2Q = 'log';
   var dependencies$2Q = ['config', 'typed', 'divideScalar', 'Complex'];
   var createLog = /* #__PURE__ */factory(name$2Q, dependencies$2Q, _ref => {
     var {
       typed,
       config,
       divideScalar,
       Complex
     } = _ref;
     /**
      * Calculate the logarithm of a value.
      *
      * To avoid confusion with the matrix logarithm, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.log(x)
      *    math.log(x, base)
      *
      * Examples:
      *
      *    math.log(3.5)                  // returns 1.252762968495368
      *    math.exp(math.log(2.4))        // returns 2.4
      *
      *    math.pow(10, 4)                // returns 10000
      *    math.log(10000, 10)            // returns 4
      *    math.log(10000) / math.log(10) // returns 4
      *
      *    math.log(1024, 2)              // returns 10
      *    math.pow(2, 10)                // returns 1024
      *
      * See also:
      *
      *    exp, log2, log10, log1p
      *
      * @param {number | BigNumber | Complex} x
      *            Value for which to calculate the logarithm.
      * @param {number | BigNumber | Complex} [base=e]
      *            Optional base for the logarithm. If not provided, the natural
      *            logarithm of `x` is calculated.
      * @return {number | BigNumber | Complex}
      *            Returns the logarithm of `x`
      */
     return typed(name$2Q, {
       number: function number(x) {
         if (x >= 0 || config.predictable) {
           return logNumber(x);
         } else {
           // negative value -> complex value computation
           return new Complex(x, 0).log();
         }
       },
       Complex: function Complex(x) {
         return x.log();
       },
       BigNumber: function BigNumber(x) {
         if (!x.isNegative() || config.predictable) {
           return x.ln();
         } else {
           // downgrade to number, return Complex valued result
           return new Complex(x.toNumber(), 0).log();
         }
       },
       'any, any': typed.referToSelf(self => (x, base) => {
         // calculate logarithm for a specified base, log(x, base)
         return divideScalar(self(x), self(base));
       })
     });
   });

   var name$2P = 'log1p';
   var dependencies$2P = ['typed', 'config', 'divideScalar', 'log', 'Complex'];
   var createLog1p = /* #__PURE__ */factory(name$2P, dependencies$2P, _ref => {
     var {
       typed,
       config,
       divideScalar,
       log,
       Complex
     } = _ref;
     /**
      * Calculate the logarithm of a `value+1`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.log1p(x)
      *    math.log1p(x, base)
      *
      * Examples:
      *
      *    math.log1p(2.5)                 // returns 1.252762968495368
      *    math.exp(math.log1p(1.4))       // returns 2.4
      *
      *    math.pow(10, 4)                 // returns 10000
      *    math.log1p(9999, 10)            // returns 4
      *    math.log1p(9999) / math.log(10) // returns 4
      *
      * See also:
      *
      *    exp, log, log2, log10
      *
      * @param {number | BigNumber | Complex | Array | Matrix} x
      *            Value for which to calculate the logarithm of `x+1`.
      * @param {number | BigNumber | Complex} [base=e]
      *            Optional base for the logarithm. If not provided, the natural
      *            logarithm of `x+1` is calculated.
      * @return {number | BigNumber | Complex | Array | Matrix}
      *            Returns the logarithm of `x+1`
      */
     return typed(name$2P, {
       number: function number(x) {
         if (x >= -1 || config.predictable) {
           return log1p$1(x);
         } else {
           // negative value -> complex value computation
           return _log1pComplex(new Complex(x, 0));
         }
       },
       Complex: _log1pComplex,
       BigNumber: function BigNumber(x) {
         var y = x.plus(1);
         if (!y.isNegative() || config.predictable) {
           return y.ln();
         } else {
           // downgrade to number, return Complex valued result
           return _log1pComplex(new Complex(x.toNumber(), 0));
         }
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),
       'any, any': typed.referToSelf(self => (x, base) => {
         // calculate logarithm for a specified base, log1p(x, base)
         return divideScalar(self(x), log(base));
       })
     });

     /**
      * Calculate the natural logarithm of a complex number + 1
      * @param {Complex} x
      * @returns {Complex}
      * @private
      */
     function _log1pComplex(x) {
       var xRe1p = x.re + 1;
       return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
     }
   });

   var name$2O = 'nthRoots';
   var dependencies$2O = ['config', 'typed', 'divideScalar', 'Complex'];
   var createNthRoots = /* #__PURE__ */factory(name$2O, dependencies$2O, _ref => {
     var {
       typed,
       config,
       divideScalar,
       Complex
     } = _ref;
     /**
      * Each function here returns a real multiple of i as a Complex value.
      * @param  {number} val
      * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3
      */
     // This is used to fix float artifacts for zero-valued components.
     var _calculateExactResult = [function realPos(val) {
       return new Complex(val, 0);
     }, function imagPos(val) {
       return new Complex(0, val);
     }, function realNeg(val) {
       return new Complex(-val, 0);
     }, function imagNeg(val) {
       return new Complex(0, -val);
     }];

     /**
      * Calculate the nth root of a Complex Number a using De Movire's Theorem.
      * @param  {Complex} a
      * @param  {number} root
      * @return {Array} array of n Complex Roots
      */
     function _nthComplexRoots(a, root) {
       if (root < 0) throw new Error('Root must be greater than zero');
       if (root === 0) throw new Error('Root must be non-zero');
       if (root % 1 !== 0) throw new Error('Root must be an integer');
       if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];
       var aIsNumeric = typeof a === 'number';
       var offset;
       // determine the offset (argument of a)/(pi/2)
       if (aIsNumeric || a.re === 0 || a.im === 0) {
         if (aIsNumeric) {
           offset = 2 * +(a < 0); // numeric value on the real axis
         } else if (a.im === 0) {
           offset = 2 * +(a.re < 0); // complex value on the real axis
         } else {
           offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis
         }
       }

       var arg = a.arg();
       var abs = a.abs();
       var roots = [];
       var r = Math.pow(abs, 1 / root);
       for (var k = 0; k < root; k++) {
         var halfPiFactor = (offset + 4 * k) / root;
         /**
          * If (offset + 4*k)/root is an integral multiple of pi/2
          * then we can produce a more exact result.
          */
         if (halfPiFactor === Math.round(halfPiFactor)) {
           roots.push(_calculateExactResult[halfPiFactor % 4](r));
           continue;
         }
         roots.push(new Complex({
           r,
           phi: (arg + 2 * Math.PI * k) / root
         }));
       }
       return roots;
     }

     /**
      * Calculate the nth roots of a value.
      * An nth root of a positive real number A,
      * is a positive real solution of the equation "x^root = A".
      * This function returns an array of complex values.
      *
      * Syntax:
      *
      *    math.nthRoots(x)
      *    math.nthRoots(x, root)
      *
      * Examples:
      *
      *    math.nthRoots(1)
      *    // returns [
      *    //   {re: 1, im: 0},
      *    //   {re: -1, im: 0}
      *    // ]
      *    math.nthRoots(1, 3)
      *    // returns [
      *    //   { re: 1, im: 0 },
      *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },
      *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }
      *    // ]
      *
      * See also:
      *
      *    nthRoot, pow, sqrt
      *
      * @param {number | BigNumber | Fraction | Complex} x Number to be rounded
      * @param {number} [root=2] Optional root, default value is 2
      * @return {number | BigNumber | Fraction | Complex} Returns the nth roots
      */
     return typed(name$2O, {
       Complex: function Complex(x) {
         return _nthComplexRoots(x, 2);
       },
       'Complex, number': _nthComplexRoots
     });
   });

   var name$2N = 'dotPow';
   var dependencies$2N = ['typed', 'equalScalar', 'matrix', 'pow', 'DenseMatrix', 'concat'];
   var createDotPow = /* #__PURE__ */factory(name$2N, dependencies$2N, _ref => {
     var {
       typed,
       equalScalar,
       matrix,
       pow,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var powScalarSignatures = {};
     for (var signature in pow.signatures) {
       if (Object.prototype.hasOwnProperty.call(pow.signatures, signature)) {
         if (!signature.includes('Matrix') && !signature.includes('Array')) {
           powScalarSignatures[signature] = pow.signatures[signature];
         }
       }
     }
     var powScalar = typed(powScalarSignatures);

     /**
      * Calculates the power of x to y element wise.
      *
      * Syntax:
      *
      *    math.dotPow(x, y)
      *
      * Examples:
      *
      *    math.dotPow(2, 3)            // returns number 8
      *
      *    const a = [[1, 2], [4, 3]]
      *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
      *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]
      *
      * See also:
      *
      *    pow, sqrt, multiply
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
      * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
      */
     return typed(name$2N, matrixAlgorithmSuite({
       elop: powScalar,
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo11xS0s,
       sS: matAlgo12xSfs
     }));
   });

   var name$2M = 'dotDivide';
   var dependencies$2M = ['typed', 'matrix', 'equalScalar', 'divideScalar', 'DenseMatrix', 'concat'];
   var createDotDivide = /* #__PURE__ */factory(name$2M, dependencies$2M, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       divideScalar,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Divide two matrices element wise. The function accepts both matrices and
      * scalar values.
      *
      * Syntax:
      *
      *    math.dotDivide(x, y)
      *
      * Examples:
      *
      *    math.dotDivide(2, 4)   // returns 0.5
      *
      *    a = [[9, 5], [6, 1]]
      *    b = [[3, 2], [5, 2]]
      *
      *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
      *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]
      *
      * See also:
      *
      *    divide, multiply, dotMultiply
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
      */
     return typed(name$2M, matrixAlgorithmSuite({
       elop: divideScalar,
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       SD: matAlgo02xDS0,
       Ss: matAlgo11xS0s,
       sS: matAlgo12xSfs
     }));
   });

   function createSolveValidation(_ref) {
     var {
       DenseMatrix
     } = _ref;
     /**
      * Validates matrix and column vector b for backward/forward substitution algorithms.
      *
      * @param {Matrix} m            An N x N matrix
      * @param {Array | Matrix} b    A column vector
      * @param {Boolean} copy        Return a copy of vector b
      *
      * @return {DenseMatrix}        Dense column vector b
      */
     return function solveValidation(m, b, copy) {
       var mSize = m.size();
       if (mSize.length !== 2) {
         throw new RangeError('Matrix must be two dimensional (size: ' + format$1(mSize) + ')');
       }
       var rows = mSize[0];
       var columns = mSize[1];
       if (rows !== columns) {
         throw new RangeError('Matrix must be square (size: ' + format$1(mSize) + ')');
       }
       var data = [];
       if (isMatrix(b)) {
         var bSize = b.size();
         var bdata = b._data;

         // 1-dim vector
         if (bSize.length === 1) {
           if (bSize[0] !== rows) {
             throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
           }
           for (var i = 0; i < rows; i++) {
             data[i] = [bdata[i]];
           }
           return new DenseMatrix({
             data,
             size: [rows, 1],
             datatype: b._datatype
           });
         }

         // 2-dim column
         if (bSize.length === 2) {
           if (bSize[0] !== rows || bSize[1] !== 1) {
             throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
           }
           if (isDenseMatrix(b)) {
             if (copy) {
               data = [];
               for (var _i = 0; _i < rows; _i++) {
                 data[_i] = [bdata[_i][0]];
               }
               return new DenseMatrix({
                 data,
                 size: [rows, 1],
                 datatype: b._datatype
               });
             }
             return b;
           }
           if (isSparseMatrix(b)) {
             for (var _i2 = 0; _i2 < rows; _i2++) {
               data[_i2] = [0];
             }
             var values = b._values;
             var index = b._index;
             var ptr = b._ptr;
             for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
               var _i3 = index[k];
               data[_i3][0] = values[k];
             }
             return new DenseMatrix({
               data,
               size: [rows, 1],
               datatype: b._datatype
             });
           }
         }
         throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
       }
       if (isArray(b)) {
         var bsize = arraySize(b);
         if (bsize.length === 1) {
           if (bsize[0] !== rows) {
             throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
           }
           for (var _i4 = 0; _i4 < rows; _i4++) {
             data[_i4] = [b[_i4]];
           }
           return new DenseMatrix({
             data,
             size: [rows, 1]
           });
         }
         if (bsize.length === 2) {
           if (bsize[0] !== rows || bsize[1] !== 1) {
             throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
           }
           for (var _i5 = 0; _i5 < rows; _i5++) {
             data[_i5] = [b[_i5][0]];
           }
           return new DenseMatrix({
             data,
             size: [rows, 1]
           });
         }
         throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
       }
     };
   }

   var name$2L = 'lsolve';
   var dependencies$2L = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
   var createLsolve = /* #__PURE__ */factory(name$2L, dependencies$2L, _ref => {
     var {
       typed,
       matrix,
       divideScalar,
       multiplyScalar,
       subtract,
       equalScalar,
       DenseMatrix
     } = _ref;
     var solveValidation = createSolveValidation({
       DenseMatrix
     });

     /**
      * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.
      *
      * `L * x = b`
      *
      * Syntax:
      *
      *    math.lsolve(L, b)
      *
      * Examples:
      *
      *    const a = [[-2, 3], [2, 1]]
      *    const b = [11, 9]
      *    const x = lsolve(a, b)  // [[-5.5], [20]]
      *
      * See also:
      *
      *    lsolveAll, lup, slu, usolve, lusolve
      *
      * @param {Matrix, Array} L       A N x N matrix or array (L)
      * @param {Matrix, Array} b       A column vector with the b values
      *
      * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
      */
     return typed(name$2L, {
       'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
         return _sparseForwardSubstitution(m, b);
       },
       'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
         return _denseForwardSubstitution(m, b);
       },
       'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
         var m = matrix(a);
         var r = _denseForwardSubstitution(m, b);
         return r.valueOf();
       }
     });
     function _denseForwardSubstitution(m, b) {
       // validate matrix and vector, return copy of column vector b
       b = solveValidation(m, b, true);
       var bdata = b._data;
       var rows = m._size[0];
       var columns = m._size[1];

       // result
       var x = [];
       var mdata = m._data;

       // loop columns
       for (var j = 0; j < columns; j++) {
         var bj = bdata[j][0] || 0;
         var xj = void 0;
         if (!equalScalar(bj, 0)) {
           // non-degenerate row, find solution

           var vjj = mdata[j][j];
           if (equalScalar(vjj, 0)) {
             throw new Error('Linear system cannot be solved since matrix is singular');
           }
           xj = divideScalar(bj, vjj);

           // loop rows
           for (var i = j + 1; i < rows; i++) {
             bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
           }
         } else {
           // degenerate row, we can choose any value
           xj = 0;
         }
         x[j] = [xj];
       }
       return new DenseMatrix({
         data: x,
         size: [rows, 1]
       });
     }
     function _sparseForwardSubstitution(m, b) {
       // validate matrix and vector, return copy of column vector b
       b = solveValidation(m, b, true);
       var bdata = b._data;
       var rows = m._size[0];
       var columns = m._size[1];
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;

       // result
       var x = [];

       // loop columns
       for (var j = 0; j < columns; j++) {
         var bj = bdata[j][0] || 0;
         if (!equalScalar(bj, 0)) {
           // non-degenerate row, find solution

           var vjj = 0;
           // matrix values & indices (column j)
           var jValues = [];
           var jIndices = [];

           // first and last index in the column
           var firstIndex = ptr[j];
           var lastIndex = ptr[j + 1];

           // values in column, find value at [j, j]
           for (var k = firstIndex; k < lastIndex; k++) {
             var i = index[k];

             // check row (rows are not sorted!)
             if (i === j) {
               vjj = values[k];
             } else if (i > j) {
               // store lower triangular
               jValues.push(values[k]);
               jIndices.push(i);
             }
           }

           // at this point we must have a value in vjj
           if (equalScalar(vjj, 0)) {
             throw new Error('Linear system cannot be solved since matrix is singular');
           }
           var xj = divideScalar(bj, vjj);
           for (var _k = 0, l = jIndices.length; _k < l; _k++) {
             var _i = jIndices[_k];
             bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
           }
           x[j] = [xj];
         } else {
           // degenerate row, we can choose any value
           x[j] = [0];
         }
       }
       return new DenseMatrix({
         data: x,
         size: [rows, 1]
       });
     }
   });

   var name$2K = 'usolve';
   var dependencies$2K = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
   var createUsolve = /* #__PURE__ */factory(name$2K, dependencies$2K, _ref => {
     var {
       typed,
       matrix,
       divideScalar,
       multiplyScalar,
       subtract,
       equalScalar,
       DenseMatrix
     } = _ref;
     var solveValidation = createSolveValidation({
       DenseMatrix
     });

     /**
      * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
      *
      * `U * x = b`
      *
      * Syntax:
      *
      *    math.usolve(U, b)
      *
      * Examples:
      *
      *    const a = [[-2, 3], [2, 1]]
      *    const b = [11, 9]
      *    const x = usolve(a, b)  // [[8], [9]]
      *
      * See also:
      *
      *    usolveAll, lup, slu, usolve, lusolve
      *
      * @param {Matrix, Array} U       A N x N matrix or array (U)
      * @param {Matrix, Array} b       A column vector with the b values
      *
      * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
      */
     return typed(name$2K, {
       'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
         return _sparseBackwardSubstitution(m, b);
       },
       'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
         return _denseBackwardSubstitution(m, b);
       },
       'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
         var m = matrix(a);
         var r = _denseBackwardSubstitution(m, b);
         return r.valueOf();
       }
     });
     function _denseBackwardSubstitution(m, b) {
       // make b into a column vector
       b = solveValidation(m, b, true);
       var bdata = b._data;
       var rows = m._size[0];
       var columns = m._size[1];

       // result
       var x = [];
       var mdata = m._data;
       // loop columns backwards
       for (var j = columns - 1; j >= 0; j--) {
         // b[j]
         var bj = bdata[j][0] || 0;
         // x[j]
         var xj = void 0;
         if (!equalScalar(bj, 0)) {
           // value at [j, j]
           var vjj = mdata[j][j];
           if (equalScalar(vjj, 0)) {
             // system cannot be solved
             throw new Error('Linear system cannot be solved since matrix is singular');
           }
           xj = divideScalar(bj, vjj);

           // loop rows
           for (var i = j - 1; i >= 0; i--) {
             // update copy of b
             bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
           }
         } else {
           // zero value at j
           xj = 0;
         }
         // update x
         x[j] = [xj];
       }
       return new DenseMatrix({
         data: x,
         size: [rows, 1]
       });
     }
     function _sparseBackwardSubstitution(m, b) {
       // make b into a column vector
       b = solveValidation(m, b, true);
       var bdata = b._data;
       var rows = m._size[0];
       var columns = m._size[1];
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;

       // result
       var x = [];

       // loop columns backwards
       for (var j = columns - 1; j >= 0; j--) {
         var bj = bdata[j][0] || 0;
         if (!equalScalar(bj, 0)) {
           // non-degenerate row, find solution

           var vjj = 0;

           // upper triangular matrix values & index (column j)
           var jValues = [];
           var jIndices = [];

           // first & last indeces in column
           var firstIndex = ptr[j];
           var lastIndex = ptr[j + 1];

           // values in column, find value at [j, j], loop backwards
           for (var k = lastIndex - 1; k >= firstIndex; k--) {
             var i = index[k];

             // check row (rows are not sorted!)
             if (i === j) {
               vjj = values[k];
             } else if (i < j) {
               // store upper triangular
               jValues.push(values[k]);
               jIndices.push(i);
             }
           }

           // at this point we must have a value in vjj
           if (equalScalar(vjj, 0)) {
             throw new Error('Linear system cannot be solved since matrix is singular');
           }
           var xj = divideScalar(bj, vjj);
           for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
             var _i = jIndices[_k];
             bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
           }
           x[j] = [xj];
         } else {
           // degenerate row, we can choose any value
           x[j] = [0];
         }
       }
       return new DenseMatrix({
         data: x,
         size: [rows, 1]
       });
     }
   });

   var name$2J = 'lsolveAll';
   var dependencies$2J = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
   var createLsolveAll = /* #__PURE__ */factory(name$2J, dependencies$2J, _ref => {
     var {
       typed,
       matrix,
       divideScalar,
       multiplyScalar,
       subtract,
       equalScalar,
       DenseMatrix
     } = _ref;
     var solveValidation = createSolveValidation({
       DenseMatrix
     });

     /**
      * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
      *
      * `L * x = b`
      *
      * Syntax:
      *
      *    math.lsolveAll(L, b)
      *
      * Examples:
      *
      *    const a = [[-2, 3], [2, 1]]
      *    const b = [11, 9]
      *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]
      *
      * See also:
      *
      *    lsolve, lup, slu, usolve, lusolve
      *
      * @param {Matrix, Array} L       A N x N matrix or array (L)
      * @param {Matrix, Array} b       A column vector with the b values
      *
      * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
      */
     return typed(name$2J, {
       'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
         return _sparseForwardSubstitution(m, b);
       },
       'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
         return _denseForwardSubstitution(m, b);
       },
       'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
         var m = matrix(a);
         var R = _denseForwardSubstitution(m, b);
         return R.map(r => r.valueOf());
       }
     });
     function _denseForwardSubstitution(m, b_) {
       // the algorithm is derived from
       // https://www.overleaf.com/read/csvgqdxggyjv

       // array of right-hand sides
       var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
       var M = m._data;
       var rows = m._size[0];
       var columns = m._size[1];

       // loop columns
       for (var i = 0; i < columns; i++) {
         var L = B.length;

         // loop right-hand sides
         for (var k = 0; k < L; k++) {
           var b = B[k];
           if (!equalScalar(M[i][i], 0)) {
             // non-singular row

             b[i] = divideScalar(b[i], M[i][i]);
             for (var j = i + 1; j < columns; j++) {
               // b[j] -= b[i] * M[j,i]
               b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
             }
           } else if (!equalScalar(b[i], 0)) {
             // singular row, nonzero RHS

             if (k === 0) {
               // There is no valid solution
               return [];
             } else {
               // This RHS is invalid but other solutions may still exist
               B.splice(k, 1);
               k -= 1;
               L -= 1;
             }
           } else if (k === 0) {
             // singular row, RHS is zero

             var bNew = [...b];
             bNew[i] = 1;
             for (var _j = i + 1; _j < columns; _j++) {
               bNew[_j] = subtract(bNew[_j], M[_j][i]);
             }
             B.push(bNew);
           }
         }
       }
       return B.map(x => new DenseMatrix({
         data: x.map(e => [e]),
         size: [rows, 1]
       }));
     }
     function _sparseForwardSubstitution(m, b_) {
       // array of right-hand sides
       var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
       var rows = m._size[0];
       var columns = m._size[1];
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;

       // loop columns
       for (var i = 0; i < columns; i++) {
         var L = B.length;

         // loop right-hand sides
         for (var k = 0; k < L; k++) {
           var b = B[k];

           // values & indices (column i)
           var iValues = [];
           var iIndices = [];

           // first & last indeces in column
           var firstIndex = ptr[i];
           var lastIndex = ptr[i + 1];

           // find the value at [i, i]
           var Mii = 0;
           for (var j = firstIndex; j < lastIndex; j++) {
             var J = index[j];
             // check row
             if (J === i) {
               Mii = values[j];
             } else if (J > i) {
               // store lower triangular
               iValues.push(values[j]);
               iIndices.push(J);
             }
           }
           if (!equalScalar(Mii, 0)) {
             // non-singular row

             b[i] = divideScalar(b[i], Mii);
             for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
               var _J = iIndices[_j2];
               b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
             }
           } else if (!equalScalar(b[i], 0)) {
             // singular row, nonzero RHS

             if (k === 0) {
               // There is no valid solution
               return [];
             } else {
               // This RHS is invalid but other solutions may still exist
               B.splice(k, 1);
               k -= 1;
               L -= 1;
             }
           } else if (k === 0) {
             // singular row, RHS is zero

             var bNew = [...b];
             bNew[i] = 1;
             for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
               var _J2 = iIndices[_j3];
               bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
             }
             B.push(bNew);
           }
         }
       }
       return B.map(x => new DenseMatrix({
         data: x.map(e => [e]),
         size: [rows, 1]
       }));
     }
   });

   var name$2I = 'usolveAll';
   var dependencies$2I = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
   var createUsolveAll = /* #__PURE__ */factory(name$2I, dependencies$2I, _ref => {
     var {
       typed,
       matrix,
       divideScalar,
       multiplyScalar,
       subtract,
       equalScalar,
       DenseMatrix
     } = _ref;
     var solveValidation = createSolveValidation({
       DenseMatrix
     });

     /**
      * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
      *
      * `U * x = b`
      *
      * Syntax:
      *
      *    math.usolveAll(U, b)
      *
      * Examples:
      *
      *    const a = [[-2, 3], [2, 1]]
      *    const b = [11, 9]
      *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
      *
      * See also:
      *
      *    usolve, lup, slu, usolve, lusolve
      *
      * @param {Matrix, Array} U       A N x N matrix or array (U)
      * @param {Matrix, Array} b       A column vector with the b values
      *
      * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
      */
     return typed(name$2I, {
       'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
         return _sparseBackwardSubstitution(m, b);
       },
       'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
         return _denseBackwardSubstitution(m, b);
       },
       'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
         var m = matrix(a);
         var R = _denseBackwardSubstitution(m, b);
         return R.map(r => r.valueOf());
       }
     });
     function _denseBackwardSubstitution(m, b_) {
       // the algorithm is derived from
       // https://www.overleaf.com/read/csvgqdxggyjv

       // array of right-hand sides
       var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
       var M = m._data;
       var rows = m._size[0];
       var columns = m._size[1];

       // loop columns backwards
       for (var i = columns - 1; i >= 0; i--) {
         var L = B.length;

         // loop right-hand sides
         for (var k = 0; k < L; k++) {
           var b = B[k];
           if (!equalScalar(M[i][i], 0)) {
             // non-singular row

             b[i] = divideScalar(b[i], M[i][i]);
             for (var j = i - 1; j >= 0; j--) {
               // b[j] -= b[i] * M[j,i]
               b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
             }
           } else if (!equalScalar(b[i], 0)) {
             // singular row, nonzero RHS

             if (k === 0) {
               // There is no valid solution
               return [];
             } else {
               // This RHS is invalid but other solutions may still exist
               B.splice(k, 1);
               k -= 1;
               L -= 1;
             }
           } else if (k === 0) {
             // singular row, RHS is zero

             var bNew = [...b];
             bNew[i] = 1;
             for (var _j = i - 1; _j >= 0; _j--) {
               bNew[_j] = subtract(bNew[_j], M[_j][i]);
             }
             B.push(bNew);
           }
         }
       }
       return B.map(x => new DenseMatrix({
         data: x.map(e => [e]),
         size: [rows, 1]
       }));
     }
     function _sparseBackwardSubstitution(m, b_) {
       // array of right-hand sides
       var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
       var rows = m._size[0];
       var columns = m._size[1];
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;

       // loop columns backwards
       for (var i = columns - 1; i >= 0; i--) {
         var L = B.length;

         // loop right-hand sides
         for (var k = 0; k < L; k++) {
           var b = B[k];

           // values & indices (column i)
           var iValues = [];
           var iIndices = [];

           // first & last indeces in column
           var firstIndex = ptr[i];
           var lastIndex = ptr[i + 1];

           // find the value at [i, i]
           var Mii = 0;
           for (var j = lastIndex - 1; j >= firstIndex; j--) {
             var J = index[j];
             // check row
             if (J === i) {
               Mii = values[j];
             } else if (J < i) {
               // store upper triangular
               iValues.push(values[j]);
               iIndices.push(J);
             }
           }
           if (!equalScalar(Mii, 0)) {
             // non-singular row

             b[i] = divideScalar(b[i], Mii);

             // loop upper triangular
             for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
               var _J = iIndices[_j2];
               b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
             }
           } else if (!equalScalar(b[i], 0)) {
             // singular row, nonzero RHS

             if (k === 0) {
               // There is no valid solution
               return [];
             } else {
               // This RHS is invalid but other solutions may still exist
               B.splice(k, 1);
               k -= 1;
               L -= 1;
             }
           } else if (k === 0) {
             // singular row, RHS is zero

             var bNew = [...b];
             bNew[i] = 1;

             // loop upper triangular
             for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
               var _J2 = iIndices[_j3];
               bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
             }
             B.push(bNew);
           }
         }
       }
       return B.map(x => new DenseMatrix({
         data: x.map(e => [e]),
         size: [rows, 1]
       }));
     }
   });

   var name$2H = 'matAlgo08xS0Sid';
   var dependencies$2H = ['typed', 'equalScalar'];
   var createMatAlgo08xS0Sid = /* #__PURE__ */factory(name$2H, dependencies$2H, _ref => {
     var {
       typed,
       equalScalar
     } = _ref;
     /**
      * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
      * Callback function invoked MAX(NNZA, NNZB) times
      *
      *
      *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
      * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
      *          └  0            ; otherwise
      *
      *
      * @param {Matrix}   a                 The SparseMatrix instance (A)
      * @param {Matrix}   b                 The SparseMatrix instance (B)
      * @param {Function} callback          The f(Aij,Bij) operation to invoke
      *
      * @return {Matrix}                    SparseMatrix (C)
      *
      * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
      */
     return function matAlgo08xS0Sid(a, b, callback) {
       // sparse matrix arrays
       var avalues = a._values;
       var aindex = a._index;
       var aptr = a._ptr;
       var asize = a._size;
       var adt = a._datatype;
       // sparse matrix arrays
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       var bsize = b._size;
       var bdt = b._datatype;

       // validate dimensions
       if (asize.length !== bsize.length) {
         throw new DimensionError(asize.length, bsize.length);
       }

       // check rows & columns
       if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
         throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
       }

       // sparse matrix cannot be a Pattern matrix
       if (!avalues || !bvalues) {
         throw new Error('Cannot perform operation on Pattern Sparse Matrices');
       }

       // rows & columns
       var rows = asize[0];
       var columns = asize[1];

       // datatype
       var dt;
       // equal signature to use
       var eq = equalScalar;
       // zero value
       var zero = 0;
       // callback signature to use
       var cf = callback;

       // process data types
       if (typeof adt === 'string' && adt === bdt) {
         // datatype
         dt = adt;
         // find signature that matches (dt, dt)
         eq = typed.find(equalScalar, [dt, dt]);
         // convert 0 to the same datatype
         zero = typed.convert(0, dt);
         // callback
         cf = typed.find(callback, [dt, dt]);
       }

       // result arrays
       var cvalues = [];
       var cindex = [];
       var cptr = [];

       // workspace
       var x = [];
       // marks indicating we have a value in x for a given column
       var w = [];

       // vars
       var k, k0, k1, i;

       // loop columns
       for (var j = 0; j < columns; j++) {
         // update cptr
         cptr[j] = cindex.length;
         // columns mark
         var mark = j + 1;
         // loop values in a
         for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = aindex[k];
           // mark workspace
           w[i] = mark;
           // set value
           x[i] = avalues[k];
           // add index
           cindex.push(i);
         }
         // loop values in b
         for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
           // row
           i = bindex[k];
           // check value exists in workspace
           if (w[i] === mark) {
             // evaluate callback
             x[i] = cf(x[i], bvalues[k]);
           }
         }
         // initialize first index in j
         k = cptr[j];
         // loop index in j
         while (k < cindex.length) {
           // row
           i = cindex[k];
           // value @ i
           var v = x[i];
           // check for zero value
           if (!eq(v, zero)) {
             // push value
             cvalues.push(v);
             // increment pointer
             k++;
           } else {
             // remove value @ i, do not increment pointer
             cindex.splice(k, 1);
           }
         }
       }
       // update cptr
       cptr[columns] = cindex.length;

       // return sparse matrix
       return a.createSparseMatrix({
         values: cvalues,
         index: cindex,
         ptr: cptr,
         size: [rows, columns],
         datatype: dt
       });
     };
   });

   var createUseMatrixForArrayScalar = /* #__PURE__ */factory('useMatrixForArrayScalar', ['typed', 'matrix'], _ref => {
     var {
       typed,
       matrix
     } = _ref;
     return {
       'Array, number': typed.referTo('DenseMatrix, number', selfDn => (x, y) => selfDn(matrix(x), y).valueOf()),
       'Array, BigNumber': typed.referTo('DenseMatrix, BigNumber', selfDB => (x, y) => selfDB(matrix(x), y).valueOf()),
       'number, Array': typed.referTo('number, DenseMatrix', selfnD => (x, y) => selfnD(x, matrix(y)).valueOf()),
       'BigNumber, Array': typed.referTo('BigNumber, DenseMatrix', selfBD => (x, y) => selfBD(x, matrix(y)).valueOf())
     };
   });

   var name$2G = 'leftShift';
   var dependencies$2G = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix', 'concat'];
   var createLeftShift = /* #__PURE__ */factory(name$2G, dependencies$2G, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       zeros,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
       typed,
       matrix
     });

     /**
      * Bitwise left logical shift of a value x by y number of bits, `x << y`.
      * For matrices, the function is evaluated element wise.
      * For units, the function is evaluated on the best prefix base.
      *
      * Syntax:
      *
      *    math.leftShift(x, y)
      *
      * Examples:
      *
      *    math.leftShift(1, 2)               // returns number 4
      *
      *    math.leftShift([1, 2, 4], 4)       // returns Array [16, 32, 64]
      *
      * See also:
      *
      *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
      * @param  {number | BigNumber} y Amount of shifts
      * @return {number | BigNumber | Array | Matrix} `x` shifted left `y` times
      */
     return typed(name$2G, {
       'number, number': leftShiftNumber,
       'BigNumber, BigNumber': leftShiftBigNumber,
       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo14xDs(x, y, self, false);
       }),
       'number | BigNumber, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo10xSids(y, x, self, true);
       }),
       'number | BigNumber, DenseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo14xDs(y, x, self, true);
       })
     }, useMatrixForArrayScalar, matrixAlgorithmSuite({
       SS: matAlgo08xS0Sid,
       DS: matAlgo01xDSid,
       SD: matAlgo02xDS0
     }));
   });

   var name$2F = 'rightArithShift';
   var dependencies$2F = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix', 'concat'];
   var createRightArithShift = /* #__PURE__ */factory(name$2F, dependencies$2F, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       zeros,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
       typed,
       matrix
     });

     /**
      * Bitwise right arithmetic shift of a value x by y number of bits, `x >> y`.
      * For matrices, the function is evaluated element wise.
      * For units, the function is evaluated on the best prefix base.
      *
      * Syntax:
      *
      *    math.rightArithShift(x, y)
      *
      * Examples:
      *
      *    math.rightArithShift(4, 2)               // returns number 1
      *
      *    math.rightArithShift([16, -32, 64], 4)   // returns Array [1, -2, 4]
      *
      * See also:
      *
      *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
      *
      * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
      * @param  {number | BigNumber} y Amount of shifts
      * @return {number | BigNumber | Array | Matrix} `x` zero-filled shifted right `y` times
      */
     return typed(name$2F, {
       'number, number': rightArithShiftNumber,
       'BigNumber, BigNumber': rightArithShiftBigNumber,
       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo14xDs(x, y, self, false);
       }),
       'number | BigNumber, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo10xSids(y, x, self, true);
       }),
       'number | BigNumber, DenseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo14xDs(y, x, self, true);
       })
     }, useMatrixForArrayScalar, matrixAlgorithmSuite({
       SS: matAlgo08xS0Sid,
       DS: matAlgo01xDSid,
       SD: matAlgo02xDS0
     }));
   });

   var name$2E = 'rightLogShift';
   var dependencies$2E = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix', 'concat'];
   var createRightLogShift = /* #__PURE__ */factory(name$2E, dependencies$2E, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       zeros,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
       typed,
       matrix
     });

     /**
      * Bitwise right logical shift of value x by y number of bits, `x >>> y`.
      * For matrices, the function is evaluated element wise.
      * For units, the function is evaluated on the best prefix base.
      *
      * Syntax:
      *
      *    math.rightLogShift(x, y)
      *
      * Examples:
      *
      *    math.rightLogShift(4, 2)               // returns number 1
      *
      *    math.rightLogShift([16, 32, 64], 4)    // returns Array [1, 2, 4]
      *
      * See also:
      *
      *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
      *
      * @param  {number | Array | Matrix} x Value to be shifted
      * @param  {number} y Amount of shifts
      * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
      */

     return typed(name$2E, {
       'number, number': rightLogShiftNumber,
       // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift

       'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(y, 0)) {
           return x.clone();
         }
         return matAlgo14xDs(x, y, self, false);
       }),
       'number | BigNumber, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo10xSids(y, x, self, true);
       }),
       'number | BigNumber, DenseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (equalScalar(x, 0)) {
           return zeros(y.size(), y.storage());
         }
         return matAlgo14xDs(y, x, self, true);
       })
     }, useMatrixForArrayScalar, matrixAlgorithmSuite({
       SS: matAlgo08xS0Sid,
       DS: matAlgo01xDSid,
       SD: matAlgo02xDS0
     }));
   });

   var name$2D = 'and';
   var dependencies$2D = ['typed', 'matrix', 'equalScalar', 'zeros', 'not', 'concat'];
   var createAnd = /* #__PURE__ */factory(name$2D, dependencies$2D, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       zeros,
       not,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo06xS0S0 = createMatAlgo06xS0S0({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.and(x, y)
      *
      * Examples:
      *
      *    math.and(2, 4)   // returns true
      *
      *    a = [2, 0, 0]
      *    b = [3, 7, 0]
      *    c = 0
      *
      *    math.and(a, b)   // returns [true, false, false]
      *    math.and(a, c)   // returns [false, false, false]
      *
      * See also:
      *
      *    not, or, xor
      *
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
      * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
      * @return {boolean | Array | Matrix}
      *            Returns true when both inputs are defined with a nonzero/nonempty value.
      */
     return typed(name$2D, {
       'number, number': andNumber,
       'Complex, Complex': function ComplexComplex(x, y) {
         return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
       },
       'Unit, Unit': typed.referToSelf(self => (x, y) => self(x.value || 0, y.value || 0)),
       'SparseMatrix, any': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (not(y)) {
           // return zero matrix
           return zeros(x.size(), x.storage());
         }
         return matAlgo11xS0s(x, y, self, false);
       }),
       'DenseMatrix, any': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (not(y)) {
           // return zero matrix
           return zeros(x.size(), x.storage());
         }
         return matAlgo14xDs(x, y, self, false);
       }),
       'any, SparseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (not(x)) {
           // return zero matrix
           return zeros(x.size(), x.storage());
         }
         return matAlgo11xS0s(y, x, self, true);
       }),
       'any, DenseMatrix': typed.referToSelf(self => (x, y) => {
         // check scalar
         if (not(x)) {
           // return zero matrix
           return zeros(x.size(), x.storage());
         }
         return matAlgo14xDs(y, x, self, true);
       }),
       'Array, any': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return self(matrix(x), y).valueOf();
       }),
       'any, Array': typed.referToSelf(self => (x, y) => {
         // use matrix implementation
         return self(x, matrix(y)).valueOf();
       })
     }, matrixAlgorithmSuite({
       SS: matAlgo06xS0S0,
       DS: matAlgo02xDS0
     }));
   });

   var name$2C = 'compare';
   var dependencies$2C = ['typed', 'config', 'matrix', 'equalScalar', 'BigNumber', 'Fraction', 'DenseMatrix', 'concat'];
   var createCompare = /* #__PURE__ */factory(name$2C, dependencies$2C, _ref => {
     var {
       typed,
       config,
       equalScalar,
       matrix,
       BigNumber,
       Fraction,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo05xSfSf = createMatAlgo05xSfSf({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
      *
      * x and y are considered equal when the relative difference between x and y
      * is smaller than the configured epsilon. The function cannot be used to
      * compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.compare(x, y)
      *
      * Examples:
      *
      *    math.compare(6, 1)           // returns 1
      *    math.compare(2, 3)           // returns -1
      *    math.compare(7, 7)           // returns 0
      *    math.compare('10', '2')      // returns 1
      *    math.compare('1000', '1e3')  // returns 0
      *
      *    const a = math.unit('5 cm')
      *    const b = math.unit('40 mm')
      *    math.compare(a, b)           // returns 1
      *
      *    math.compare(2, [1, 2, 3])   // returns [1, 0, -1]
      *
      * See also:
      *
      *    equal, unequal, smaller, smallerEq, larger, largerEq, compareNatural, compareText
      *
      * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} y Second value to compare
      * @return {number | BigNumber | Fraction | Array | Matrix} Returns the result of the comparison:
      *                                                          1 when x > y, -1 when x < y, and 0 when x == y.
      */
     return typed(name$2C, createCompareNumber({
       typed,
       config
     }), {
       'boolean, boolean': function booleanBoolean(x, y) {
         return x === y ? 0 : x > y ? 1 : -1;
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return nearlyEqual(x, y, config.epsilon) ? new BigNumber(0) : new BigNumber(x.cmp(y));
       },
       'Fraction, Fraction': function FractionFraction(x, y) {
         return new Fraction(x.compare(y));
       },
       'Complex, Complex': function ComplexComplex() {
         throw new TypeError('No ordering relation is defined for complex numbers');
       }
     }, compareUnits, matrixAlgorithmSuite({
       SS: matAlgo05xSfSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createCompareNumber = /* #__PURE__ */factory(name$2C, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$2C, {
       'number, number': function numberNumber(x, y) {
         return nearlyEqual$1(x, y, config.epsilon) ? 0 : x > y ? 1 : -1;
       }
     });
   });

   /*
    * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
    * Author: Jim Palmer (based on chunking idea from Dave Koelle)
    */

   /*jshint unused:false */
   var naturalSort = function naturalSort (a, b) {
   	var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
   		sre = /(^[ ]*|[ ]*$)/g,
   		dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
   		hre = /^0x[0-9a-f]+$/i,
   		ore = /^0/,
   		i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
   		// convert all to strings strip whitespace
   		x = i(a).replace(sre, '') || '',
   		y = i(b).replace(sre, '') || '',
   		// chunk/tokenize
   		xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
   		yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
   		// numeric, hex or date detection
   		xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
   		yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
   		oFxNcL, oFyNcL;
   	// first try and sort Hex codes or Dates
   	if (yD) {
   		if ( xD < yD ) { return -1; }
   		else if ( xD > yD ) { return 1; }
   	}
   	// natural sorting through split numeric strings and default strings
   	for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
   		// find floats not starting with '0', string or 0 if not defined (Clint Priest)
   		oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
   		oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
   		// handle numeric vs string comparison - number < string - (Kyle Adams)
   		if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
   		// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
   		else if (typeof oFxNcL !== typeof oFyNcL) {
   			oFxNcL += '';
   			oFyNcL += '';
   		}
   		if (oFxNcL < oFyNcL) { return -1; }
   		if (oFxNcL > oFyNcL) { return 1; }
   	}
   	return 0;
   };

   var naturalSort$1 = /*@__PURE__*/getDefaultExportFromCjs(naturalSort);

   var name$2B = 'compareNatural';
   var dependencies$2B = ['typed', 'compare'];
   var createCompareNatural = /* #__PURE__ */factory(name$2B, dependencies$2B, _ref => {
     var {
       typed,
       compare
     } = _ref;
     var compareBooleans = compare.signatures['boolean,boolean'];

     /**
      * Compare two values of any type in a deterministic, natural way.
      *
      * For numeric values, the function works the same as `math.compare`.
      * For types of values that can't be compared mathematically,
      * the function compares in a natural way.
      *
      * For numeric values, x and y are considered equal when the relative
      * difference between x and y is smaller than the configured epsilon.
      * The function cannot be used to compare values smaller than
      * approximately 2.22e-16.
      *
      * For Complex numbers, first the real parts are compared. If equal,
      * the imaginary parts are compared.
      *
      * Strings are compared with a natural sorting algorithm, which
      * orders strings in a "logic" way following some heuristics.
      * This differs from the function `compare`, which converts the string
      * into a numeric value and compares that. The function `compareText`
      * on the other hand compares text lexically.
      *
      * Arrays and Matrices are compared value by value until there is an
      * unequal pair of values encountered. Objects are compared by sorted
      * keys until the keys or their values are unequal.
      *
      * Syntax:
      *
      *    math.compareNatural(x, y)
      *
      * Examples:
      *
      *    math.compareNatural(6, 1)              // returns 1
      *    math.compareNatural(2, 3)              // returns -1
      *    math.compareNatural(7, 7)              // returns 0
      *
      *    math.compareNatural('10', '2')         // returns 1
      *    math.compareText('10', '2')            // returns -1
      *    math.compare('10', '2')                // returns 1
      *
      *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1
      *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1
      *    math.compare('Answer: 10', 'Answer: 2')
      *        // Error: Cannot convert "Answer: 10" to a number
      *
      *    const a = math.unit('5 cm')
      *    const b = math.unit('40 mm')
      *    math.compareNatural(a, b)              // returns 1
      *
      *    const c = math.complex('2 + 3i')
      *    const d = math.complex('2 + 4i')
      *    math.compareNatural(c, d)              // returns -1
      *
      *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1
      *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1
      *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1
      *    math.compareNatural([1, 2], [1, 2])       // returns 0
      *
      *    math.compareNatural({a: 2}, {a: 4})       // returns -1
      *
      * See also:
      *
      *    compare, compareText
      *
      * @param  {*} x First value to compare
      * @param  {*} y Second value to compare
      * @return {number} Returns the result of the comparison:
      *                  1 when x > y, -1 when x < y, and 0 when x == y.
      */
     return typed(name$2B, {
       'any, any': _compareNatural
     }); // just to check # args

     function _compareNatural(x, y) {
       var typeX = typeOf$1(x);
       var typeY = typeOf$1(y);
       var c;

       // numeric types
       if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {
         c = compare(x, y);
         if (c.toString() !== '0') {
           // c can be number, BigNumber, or Fraction
           return c > 0 ? 1 : -1; // return a number
         } else {
           return naturalSort$1(typeX, typeY);
         }
       }

       // matrix types
       var matTypes = ['Array', 'DenseMatrix', 'SparseMatrix'];
       if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
         c = compareMatricesAndArrays(_compareNatural, x, y);
         if (c !== 0) {
           return c;
         } else {
           return naturalSort$1(typeX, typeY);
         }
       }

       // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'
       if (typeX !== typeY) {
         return naturalSort$1(typeX, typeY);
       }
       if (typeX === 'Complex') {
         return compareComplexNumbers(x, y);
       }
       if (typeX === 'Unit') {
         if (x.equalBase(y)) {
           return _compareNatural(x.value, y.value);
         }

         // compare by units
         return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
       }
       if (typeX === 'boolean') {
         return compareBooleans(x, y);
       }
       if (typeX === 'string') {
         return naturalSort$1(x, y);
       }
       if (typeX === 'Object') {
         return compareObjects(_compareNatural, x, y);
       }
       if (typeX === 'null') {
         return 0;
       }
       if (typeX === 'undefined') {
         return 0;
       }

       // this should not occur...
       throw new TypeError('Unsupported type of value "' + typeX + '"');
     }

     /**
      * Compare mixed matrix/array types, by converting to same-shaped array.
      * This comparator is non-deterministic regarding input types.
      * @param {Array | SparseMatrix | DenseMatrix | *} x
      * @param {Array | SparseMatrix | DenseMatrix | *} y
      * @returns {number} Returns the comparison result: -1, 0, or 1
      */
     function compareMatricesAndArrays(compareNatural, x, y) {
       if (isSparseMatrix(x) && isSparseMatrix(y)) {
         return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
       }
       if (isSparseMatrix(x)) {
         // note: convert to array is expensive
         return compareMatricesAndArrays(compareNatural, x.toArray(), y);
       }
       if (isSparseMatrix(y)) {
         // note: convert to array is expensive
         return compareMatricesAndArrays(compareNatural, x, y.toArray());
       }

       // convert DenseArray into Array
       if (isDenseMatrix(x)) {
         return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
       }
       if (isDenseMatrix(y)) {
         return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
       }

       // convert scalars to array
       if (!Array.isArray(x)) {
         return compareMatricesAndArrays(compareNatural, [x], y);
       }
       if (!Array.isArray(y)) {
         return compareMatricesAndArrays(compareNatural, x, [y]);
       }
       return compareArrays(compareNatural, x, y);
     }

     /**
      * Compare two Arrays
      *
      * - First, compares value by value
      * - Next, if all corresponding values are equal,
      *   look at the length: longest array will be considered largest
      *
      * @param {Array} x
      * @param {Array} y
      * @returns {number} Returns the comparison result: -1, 0, or 1
      */
     function compareArrays(compareNatural, x, y) {
       // compare each value
       for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
         var v = compareNatural(x[i], y[i]);
         if (v !== 0) {
           return v;
         }
       }

       // compare the size of the arrays
       if (x.length > y.length) {
         return 1;
       }
       if (x.length < y.length) {
         return -1;
       }

       // both Arrays have equal size and content
       return 0;
     }

     /**
      * Compare two objects
      *
      * - First, compare sorted property names
      * - Next, compare the property values
      *
      * @param {Object} x
      * @param {Object} y
      * @returns {number} Returns the comparison result: -1, 0, or 1
      */
     function compareObjects(compareNatural, x, y) {
       var keysX = Object.keys(x);
       var keysY = Object.keys(y);

       // compare keys
       keysX.sort(naturalSort$1);
       keysY.sort(naturalSort$1);
       var c = compareArrays(compareNatural, keysX, keysY);
       if (c !== 0) {
         return c;
       }

       // compare values
       for (var i = 0; i < keysX.length; i++) {
         var v = compareNatural(x[keysX[i]], y[keysY[i]]);
         if (v !== 0) {
           return v;
         }
       }
       return 0;
     }
   });

   /**
    * Compare two complex numbers, `x` and `y`:
    *
    * - First, compare the real values of `x` and `y`
    * - If equal, compare the imaginary values of `x` and `y`
    *
    * @params {Complex} x
    * @params {Complex} y
    * @returns {number} Returns the comparison result: -1, 0, or 1
    */
   function compareComplexNumbers(x, y) {
     if (x.re > y.re) {
       return 1;
     }
     if (x.re < y.re) {
       return -1;
     }
     if (x.im > y.im) {
       return 1;
     }
     if (x.im < y.im) {
       return -1;
     }
     return 0;
   }

   var name$2A = 'compareText';
   var dependencies$2A = ['typed', 'matrix', 'concat'];
   compareText$1.signature = 'any, any';
   var createCompareText = /* #__PURE__ */factory(name$2A, dependencies$2A, _ref => {
     var {
       typed,
       matrix,
       concat
     } = _ref;
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Compare two strings lexically. Comparison is case sensitive.
      * Returns 1 when x > y, -1 when x < y, and 0 when x == y.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.compareText(x, y)
      *
      * Examples:
      *
      *    math.compareText('B', 'A')     // returns 1
      *    math.compareText('2', '10')    // returns 1
      *    math.compare('2', '10')        // returns -1
      *    math.compareNatural('2', '10') // returns -1
      *
      *    math.compareText('B', ['A', 'B', 'C']) // returns [1, 0, -1]
      *
      * See also:
      *
      *    equal, equalText, compare, compareNatural
      *
      * @param  {string | Array | DenseMatrix} x First string to compare
      * @param  {string | Array | DenseMatrix} y Second string to compare
      * @return {number | Array | DenseMatrix} Returns the result of the comparison:
      *                                        1 when x > y, -1 when x < y, and 0 when x == y.
      */
     return typed(name$2A, compareText$1, matrixAlgorithmSuite({
       elop: compareText$1,
       Ds: true
     }));
   });

   var name$2z = 'equal';
   var dependencies$2z = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];
   var createEqual = /* #__PURE__ */factory(name$2z, dependencies$2z, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Test whether two values are equal.
      *
      * The function tests whether the relative difference between x and y is
      * smaller than the configured epsilon. The function cannot be used to
      * compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
      *
      * Values `null` and `undefined` are compared strictly, thus `null` is only
      * equal to `null` and nothing else, and `undefined` is only equal to
      * `undefined` and nothing else. Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.equal(x, y)
      *
      * Examples:
      *
      *    math.equal(2 + 2, 3)         // returns false
      *    math.equal(2 + 2, 4)         // returns true
      *
      *    const a = math.unit('50 cm')
      *    const b = math.unit('5 m')
      *    math.equal(a, b)             // returns true
      *
      *    const c = [2, 5, 1]
      *    const d = [2, 7, 1]
      *
      *    math.equal(c, d)             // returns [true, false, true]
      *    math.deepEqual(c, d)         // returns false
      *
      *    math.equal("1000", "1e3")    // returns true
      *    math.equal(0, null)          // returns false
      *
      * See also:
      *
      *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
      *
      * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
      */
     return typed(name$2z, createEqualNumber({
       typed,
       equalScalar
     }), matrixAlgorithmSuite({
       elop: equalScalar,
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createEqualNumber = factory(name$2z, ['typed', 'equalScalar'], _ref2 => {
     var {
       typed,
       equalScalar
     } = _ref2;
     return typed(name$2z, {
       'any, any': function anyAny(x, y) {
         // strict equality for null and undefined?
         if (x === null) {
           return y === null;
         }
         if (y === null) {
           return x === null;
         }
         if (x === undefined) {
           return y === undefined;
         }
         if (y === undefined) {
           return x === undefined;
         }
         return equalScalar(x, y);
       }
     });
   });

   var name$2y = 'equalText';
   var dependencies$2y = ['typed', 'compareText', 'isZero'];
   var createEqualText = /* #__PURE__ */factory(name$2y, dependencies$2y, _ref => {
     var {
       typed,
       compareText,
       isZero
     } = _ref;
     /**
      * Check equality of two strings. Comparison is case sensitive.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.equalText(x, y)
      *
      * Examples:
      *
      *    math.equalText('Hello', 'Hello')     // returns true
      *    math.equalText('a', 'A')             // returns false
      *    math.equal('2e3', '2000')            // returns true
      *    math.equalText('2e3', '2000')        // returns false
      *
      *    math.equalText('B', ['A', 'B', 'C']) // returns [false, true, false]
      *
      * See also:
      *
      *    equal, compareText, compare, compareNatural
      *
      * @param  {string | Array | DenseMatrix} x First string to compare
      * @param  {string | Array | DenseMatrix} y Second string to compare
      * @return {number | Array | DenseMatrix} Returns true if the values are equal, and false if not.
      */
     return typed(name$2y, {
       'any, any': function anyAny(x, y) {
         return isZero(compareText(x, y));
       }
     });
   });

   var name$2x = 'smaller';
   var dependencies$2x = ['typed', 'config', 'matrix', 'DenseMatrix', 'concat'];
   var createSmaller = /* #__PURE__ */factory(name$2x, dependencies$2x, _ref => {
     var {
       typed,
       config,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Test whether value x is smaller than y.
      *
      * The function returns true when x is smaller than y and the relative
      * difference between x and y is smaller than the configured epsilon. The
      * function cannot be used to compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.smaller(x, y)
      *
      * Examples:
      *
      *    math.smaller(2, 3)            // returns true
      *    math.smaller(5, 2 * 2)        // returns false
      *
      *    const a = math.unit('5 cm')
      *    const b = math.unit('2 inch')
      *    math.smaller(a, b)            // returns true
      *
      * See also:
      *
      *    equal, unequal, smallerEq, smaller, smallerEq, compare
      *
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
      */
     return typed(name$2x, createSmallerNumber({
       typed,
       config
     }), {
       'boolean, boolean': (x, y) => x < y,
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.lt(y) && !nearlyEqual(x, y, config.epsilon);
       },
       'Fraction, Fraction': (x, y) => x.compare(y) === -1,
       'Complex, Complex': function ComplexComplex(x, y) {
         throw new TypeError('No ordering relation is defined for complex numbers');
       }
     }, compareUnits, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createSmallerNumber = /* #__PURE__ */factory(name$2x, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$2x, {
       'number, number': function numberNumber(x, y) {
         return x < y && !nearlyEqual$1(x, y, config.epsilon);
       }
     });
   });

   var name$2w = 'smallerEq';
   var dependencies$2w = ['typed', 'config', 'matrix', 'DenseMatrix', 'concat'];
   var createSmallerEq = /* #__PURE__ */factory(name$2w, dependencies$2w, _ref => {
     var {
       typed,
       config,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Test whether value x is smaller or equal to y.
      *
      * The function returns true when x is smaller than y or the relative
      * difference between x and y is smaller than the configured epsilon. The
      * function cannot be used to compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.smallerEq(x, y)
      *
      * Examples:
      *
      *    math.smaller(1 + 2, 3)        // returns false
      *    math.smallerEq(1 + 2, 3)      // returns true
      *
      * See also:
      *
      *    equal, unequal, smaller, larger, largerEq, compare
      *
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
      */
     return typed(name$2w, createSmallerEqNumber({
       typed,
       config
     }), {
       'boolean, boolean': (x, y) => x <= y,
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.lte(y) || nearlyEqual(x, y, config.epsilon);
       },
       'Fraction, Fraction': (x, y) => x.compare(y) !== 1,
       'Complex, Complex': function ComplexComplex() {
         throw new TypeError('No ordering relation is defined for complex numbers');
       }
     }, compareUnits, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createSmallerEqNumber = /* #__PURE__ */factory(name$2w, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$2w, {
       'number, number': function numberNumber(x, y) {
         return x <= y || nearlyEqual$1(x, y, config.epsilon);
       }
     });
   });

   var name$2v = 'larger';
   var dependencies$2v = ['typed', 'config', 'matrix', 'DenseMatrix', 'concat'];
   var createLarger = /* #__PURE__ */factory(name$2v, dependencies$2v, _ref => {
     var {
       typed,
       config,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Test whether value x is larger than y.
      *
      * The function returns true when x is larger than y and the relative
      * difference between x and y is larger than the configured epsilon. The
      * function cannot be used to compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.larger(x, y)
      *
      * Examples:
      *
      *    math.larger(2, 3)             // returns false
      *    math.larger(5, 2 + 2)         // returns true
      *
      *    const a = math.unit('5 cm')
      *    const b = math.unit('2 inch')
      *    math.larger(a, b)             // returns false
      *
      * See also:
      *
      *    equal, unequal, smaller, smallerEq, largerEq, compare
      *
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
      */
     return typed(name$2v, createLargerNumber({
       typed,
       config
     }), {
       'boolean, boolean': (x, y) => x > y,
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.gt(y) && !nearlyEqual(x, y, config.epsilon);
       },
       'Fraction, Fraction': (x, y) => x.compare(y) === 1,
       'Complex, Complex': function ComplexComplex() {
         throw new TypeError('No ordering relation is defined for complex numbers');
       }
     }, compareUnits, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createLargerNumber = /* #__PURE__ */factory(name$2v, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$2v, {
       'number, number': function numberNumber(x, y) {
         return x > y && !nearlyEqual$1(x, y, config.epsilon);
       }
     });
   });

   var name$2u = 'largerEq';
   var dependencies$2u = ['typed', 'config', 'matrix', 'DenseMatrix', 'concat'];
   var createLargerEq = /* #__PURE__ */factory(name$2u, dependencies$2u, _ref => {
     var {
       typed,
       config,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     var compareUnits = createCompareUnits({
       typed
     });

     /**
      * Test whether value x is larger or equal to y.
      *
      * The function returns true when x is larger than y or the relative
      * difference between x and y is smaller than the configured epsilon. The
      * function cannot be used to compare values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.largerEq(x, y)
      *
      * Examples:
      *
      *    math.larger(2, 1 + 1)         // returns false
      *    math.largerEq(2, 1 + 1)       // returns true
      *
      * See also:
      *
      *    equal, unequal, smaller, smallerEq, larger, compare
      *
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
      */
     return typed(name$2u, createLargerEqNumber({
       typed,
       config
     }), {
       'boolean, boolean': (x, y) => x >= y,
       'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
         return x.gte(y) || nearlyEqual(x, y, config.epsilon);
       },
       'Fraction, Fraction': (x, y) => x.compare(y) !== -1,
       'Complex, Complex': function ComplexComplex() {
         throw new TypeError('No ordering relation is defined for complex numbers');
       }
     }, compareUnits, matrixAlgorithmSuite({
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
   });
   var createLargerEqNumber = /* #__PURE__ */factory(name$2u, ['typed', 'config'], _ref2 => {
     var {
       typed,
       config
     } = _ref2;
     return typed(name$2u, {
       'number, number': function numberNumber(x, y) {
         return x >= y || nearlyEqual$1(x, y, config.epsilon);
       }
     });
   });

   var name$2t = 'deepEqual';
   var dependencies$2t = ['typed', 'equal'];
   var createDeepEqual = /* #__PURE__ */factory(name$2t, dependencies$2t, _ref => {
     var {
       typed,
       equal
     } = _ref;
     /**
      * Test element wise whether two matrices are equal.
      * The function accepts both matrices and scalar values.
      *
      * Strings are compared by their numerical value.
      *
      * Syntax:
      *
      *    math.deepEqual(x, y)
      *
      * Examples:
      *
      *    math.deepEqual(2, 4)   // returns false
      *
      *    a = [2, 5, 1]
      *    b = [2, 7, 1]
      *
      *    math.deepEqual(a, b)   // returns false
      *    math.equal(a, b)       // returns [true, false, true]
      *
      * See also:
      *
      *    equal, unequal
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
      *            Returns true when the input matrices have the same size and each of their elements is equal.
      */
     return typed(name$2t, {
       'any, any': function anyAny(x, y) {
         return _deepEqual(x.valueOf(), y.valueOf());
       }
     });

     /**
      * Test whether two arrays have the same size and all elements are equal
      * @param {Array | *} x
      * @param {Array | *} y
      * @return {boolean} Returns true if both arrays are deep equal
      */
     function _deepEqual(x, y) {
       if (Array.isArray(x)) {
         if (Array.isArray(y)) {
           var len = x.length;
           if (len !== y.length) {
             return false;
           }
           for (var i = 0; i < len; i++) {
             if (!_deepEqual(x[i], y[i])) {
               return false;
             }
           }
           return true;
         } else {
           return false;
         }
       } else {
         if (Array.isArray(y)) {
           return false;
         } else {
           return equal(x, y);
         }
       }
     }
   });

   var name$2s = 'unequal';
   var dependencies$2s = ['typed', 'config', 'equalScalar', 'matrix', 'DenseMatrix', 'concat'];
   var createUnequal = /* #__PURE__ */factory(name$2s, dependencies$2s, _ref => {
     var {
       typed,
       config,
       equalScalar,
       matrix,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo07xSSf = createMatAlgo07xSSf({
       typed,
       DenseMatrix
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Test whether two values are unequal.
      *
      * The function tests whether the relative difference between x and y is
      * larger than the configured epsilon. The function cannot be used to compare
      * values smaller than approximately 2.22e-16.
      *
      * For matrices, the function is evaluated element wise.
      * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
      * Strings are compared by their numerical value.
      *
      * Values `null` and `undefined` are compared strictly, thus `null` is unequal
      * with everything except `null`, and `undefined` is unequal with everything
      * except `undefined`.
      *
      * Syntax:
      *
      *    math.unequal(x, y)
      *
      * Examples:
      *
      *    math.unequal(2 + 2, 3)       // returns true
      *    math.unequal(2 + 2, 4)       // returns false
      *
      *    const a = math.unit('50 cm')
      *    const b = math.unit('5 m')
      *    math.unequal(a, b)           // returns false
      *
      *    const c = [2, 5, 1]
      *    const d = [2, 7, 1]
      *
      *    math.unequal(c, d)           // returns [false, true, false]
      *    math.deepEqual(c, d)         // returns false
      *
      *    math.unequal(0, null)        // returns true
      * See also:
      *
      *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
      *
      * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
      * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to compare
      * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
      */
     return typed(name$2s, createUnequalNumber({
       typed,
       equalScalar
     }), matrixAlgorithmSuite({
       elop: _unequal,
       SS: matAlgo07xSSf,
       DS: matAlgo03xDSf,
       Ss: matAlgo12xSfs
     }));
     function _unequal(x, y) {
       return !equalScalar(x, y);
     }
   });
   var createUnequalNumber = factory(name$2s, ['typed', 'equalScalar'], _ref2 => {
     var {
       typed,
       equalScalar
     } = _ref2;
     return typed(name$2s, {
       'any, any': function anyAny(x, y) {
         // strict equality for null and undefined?
         if (x === null) {
           return y !== null;
         }
         if (y === null) {
           return x !== null;
         }
         if (x === undefined) {
           return y !== undefined;
         }
         if (y === undefined) {
           return x !== undefined;
         }
         return !equalScalar(x, y);
       }
     });
   });

   var name$2r = 'partitionSelect';
   var dependencies$2r = ['typed', 'isNumeric', 'isNaN', 'compare'];
   var createPartitionSelect = /* #__PURE__ */factory(name$2r, dependencies$2r, _ref => {
     var {
       typed,
       isNumeric,
       isNaN,
       compare
     } = _ref;
     var asc = compare;
     var desc = (a, b) => -compare(a, b);

     /**
      * Partition-based selection of an array or 1D matrix.
      * Will find the kth smallest value, and mutates the input array.
      * Uses Quickselect.
      *
      * Syntax:
      *
      *    math.partitionSelect(x, k)
      *    math.partitionSelect(x, k, compare)
      *
      * Examples:
      *
      *    math.partitionSelect([5, 10, 1], 2)                               // returns 10
      *    math.partitionSelect(['C', 'B', 'A', 'D'], 1, math.compareText)   // returns 'B'
      *
      *    function sortByLength (a, b) {
      *      return a.length - b.length
      *    }
      *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'
      *
      *    // the input array is mutated
      *    arr = [5, 2, 1]
      *    math.partitionSelect(arr, 0) // returns 1, arr is now: [1, 2, 5]
      *    math.partitionSelect(arr, 1, 'desc') // returns 2, arr is now: [5, 2, 1]
      *
      * See also:
      *
      *    sort
      *
      * @param {Matrix | Array} x    A one dimensional matrix or array to sort
      * @param {Number} k            The kth smallest value to be retrieved zero-based index
      * @param {Function | 'asc' | 'desc'} [compare='asc']
      *        An optional comparator function. The function is called as
      *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
      *        and 0 when a == b.
      * @return {*} Returns the kth lowest value.
      */
     return typed(name$2r, {
       'Array | Matrix, number': function ArrayMatrixNumber(x, k) {
         return _partitionSelect(x, k, asc);
       },
       'Array | Matrix, number, string': function ArrayMatrixNumberString(x, k, compare) {
         if (compare === 'asc') {
           return _partitionSelect(x, k, asc);
         } else if (compare === 'desc') {
           return _partitionSelect(x, k, desc);
         } else {
           throw new Error('Compare string must be "asc" or "desc"');
         }
       },
       'Array | Matrix, number, function': _partitionSelect
     });
     function _partitionSelect(x, k, compare) {
       if (!isInteger$1(k) || k < 0) {
         throw new Error('k must be a non-negative integer');
       }
       if (isMatrix(x)) {
         var size = x.size();
         if (size.length > 1) {
           throw new Error('Only one dimensional matrices supported');
         }
         return quickSelect(x.valueOf(), k, compare);
       }
       if (Array.isArray(x)) {
         return quickSelect(x, k, compare);
       }
     }

     /**
      * Quickselect algorithm.
      * Code adapted from:
      * https://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
      *
      * @param {Array} arr
      * @param {Number} k
      * @param {Function} compare
      * @private
      */
     function quickSelect(arr, k, compare) {
       if (k >= arr.length) {
         throw new Error('k out of bounds');
       }

       // check for NaN values since these can cause an infinite while loop
       for (var i = 0; i < arr.length; i++) {
         if (isNumeric(arr[i]) && isNaN(arr[i])) {
           return arr[i]; // return NaN
         }
       }

       var from = 0;
       var to = arr.length - 1;

       // if from == to we reached the kth element
       while (from < to) {
         var r = from;
         var w = to;
         var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];

         // stop if the reader and writer meets
         while (r < w) {
           // arr[r] >= pivot
           if (compare(arr[r], pivot) >= 0) {
             // put the large values at the end
             var tmp = arr[w];
             arr[w] = arr[r];
             arr[r] = tmp;
             --w;
           } else {
             // the value is smaller than the pivot, skip
             ++r;
           }
         }

         // if we stepped up (r++) we need to step one down (arr[r] > pivot)
         if (compare(arr[r], pivot) > 0) {
           --r;
         }

         // the r pointer is on the end of the first k elements
         if (k <= r) {
           to = r;
         } else {
           from = r + 1;
         }
       }
       return arr[k];
     }
   });

   var name$2q = 'sort';
   var dependencies$2q = ['typed', 'matrix', 'compare', 'compareNatural'];
   var createSort = /* #__PURE__ */factory(name$2q, dependencies$2q, _ref => {
     var {
       typed,
       matrix,
       compare,
       compareNatural
     } = _ref;
     var compareAsc = compare;
     var compareDesc = (a, b) => -compare(a, b);

     /**
      * Sort the items in a matrix.
      *
      * Syntax:
      *
      *    math.sort(x)
      *    math.sort(x, compare)
      *
      * Examples:
      *
      *    math.sort([5, 10, 1]) // returns [1, 5, 10]
      *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)
      *    // returns ['A', 'B', 'C', 'D']
      *
      *    function sortByLength (a, b) {
      *      return a.length - b.length
      *    }
      *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)
      *    // returns ['Tom', 'Sara', 'Langdon']
      *
      * See also:
      *
      *    filter, forEach, map, compare, compareNatural
      *
      * @param {Matrix | Array} x    A one dimensional matrix or array to sort
      * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']
      *        An optional _comparator function or name. The function is called as
      *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
      *        and 0 when a == b.
      * @return {Matrix | Array} Returns the sorted matrix.
      */
     return typed(name$2q, {
       Array: function Array(x) {
         _arrayIsVector(x);
         return x.sort(compareAsc);
       },
       Matrix: function Matrix(x) {
         _matrixIsVector(x);
         return matrix(x.toArray().sort(compareAsc), x.storage());
       },
       'Array, function': function ArrayFunction(x, _comparator) {
         _arrayIsVector(x);
         return x.sort(_comparator);
       },
       'Matrix, function': function MatrixFunction(x, _comparator) {
         _matrixIsVector(x);
         return matrix(x.toArray().sort(_comparator), x.storage());
       },
       'Array, string': function ArrayString(x, order) {
         _arrayIsVector(x);
         return x.sort(_comparator(order));
       },
       'Matrix, string': function MatrixString(x, order) {
         _matrixIsVector(x);
         return matrix(x.toArray().sort(_comparator(order)), x.storage());
       }
     });

     /**
      * Get the comparator for given order ('asc', 'desc', 'natural')
      * @param {'asc' | 'desc' | 'natural'} order
      * @return {Function} Returns a _comparator function
      */
     function _comparator(order) {
       if (order === 'asc') {
         return compareAsc;
       } else if (order === 'desc') {
         return compareDesc;
       } else if (order === 'natural') {
         return compareNatural;
       } else {
         throw new Error('String "asc", "desc", or "natural" expected');
       }
     }

     /**
      * Validate whether an array is one dimensional
      * Throws an error when this is not the case
      * @param {Array} array
      * @private
      */
     function _arrayIsVector(array) {
       if (arraySize(array).length !== 1) {
         throw new Error('One dimensional array expected');
       }
     }

     /**
      * Validate whether a matrix is one dimensional
      * Throws an error when this is not the case
      * @param {Matrix} matrix
      * @private
      */
     function _matrixIsVector(matrix) {
       if (matrix.size().length !== 1) {
         throw new Error('One dimensional matrix expected');
       }
     }
   });

   var name$2p = 'max';
   var dependencies$2p = ['typed', 'config', 'numeric', 'larger'];
   var createMax = /* #__PURE__ */factory(name$2p, dependencies$2p, _ref => {
     var {
       typed,
       config,
       numeric,
       larger
     } = _ref;
     /**
      * Compute the maximum value of a matrix or a  list with values.
      * In case of a multidimensional array, the maximum of the flattened array
      * will be calculated. When `dim` is provided, the maximum over the selected
      * dimension will be calculated. Parameter `dim` is zero-based.
      *
      * Syntax:
      *
      *     math.max(a, b, c, ...)
      *     math.max(A)
      *     math.max(A, dimension)
      *
      * Examples:
      *
      *     math.max(2, 1, 4, 3)                  // returns 4
      *     math.max([2, 1, 4, 3])                // returns 4
      *
      *     // maximum over a specified dimension (zero-based)
      *     math.max([[2, 5], [4, 3], [1, 7]], 0) // returns [4, 7]
      *     math.max([[2, 5], [4, 3], [1, 7]], 1) // returns [5, 4, 7]
      *
      *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
      *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
      *
      * See also:
      *
      *    mean, median, min, prod, std, sum, variance
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The maximum value
      */
     return typed(name$2p, {
       // max([a, b, c, d, ...])
       'Array | Matrix': _max,
       // max([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
         return reduce(array, dim.valueOf(), _largest);
       },
       // max(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('Scalar values expected in function max');
         }
         return _max(args);
       }
     });

     /**
      * Return the largest of two values
      * @param {*} x
      * @param {*} y
      * @returns {*} Returns x when x is largest, or y when y is largest
      * @private
      */
     function _largest(x, y) {
       try {
         return larger(x, y) ? x : y;
       } catch (err) {
         throw improveErrorMessage(err, 'max', y);
       }
     }

     /**
      * Recursively calculate the maximum value in an n-dimensional array
      * @param {Array} array
      * @return {number} max
      * @private
      */
     function _max(array) {
       var res;
       deepForEach(array, function (value) {
         try {
           if (isNaN(value) && typeof value === 'number') {
             res = NaN;
           } else if (res === undefined || larger(value, res)) {
             res = value;
           }
         } catch (err) {
           throw improveErrorMessage(err, 'max', value);
         }
       });
       if (res === undefined) {
         throw new Error('Cannot calculate max of an empty array');
       }

       // make sure returning numeric value: parse a string into a numeric value
       if (typeof res === 'string') {
         res = numeric(res, config.number);
       }
       return res;
     }
   });

   var name$2o = 'min';
   var dependencies$2o = ['typed', 'config', 'numeric', 'smaller'];
   var createMin = /* #__PURE__ */factory(name$2o, dependencies$2o, _ref => {
     var {
       typed,
       config,
       numeric,
       smaller
     } = _ref;
     /**
      * Compute the minimum value of a matrix or a  list of values.
      * In case of a multidimensional array, the minimum of the flattened array
      * will be calculated. When `dim` is provided, the minimum over the selected
      * dimension will be calculated. Parameter `dim` is zero-based.
      *
      * Syntax:
      *
      *     math.min(a, b, c, ...)
      *     math.min(A)
      *     math.min(A, dimension)
      *
      * Examples:
      *
      *     math.min(2, 1, 4, 3)                  // returns 1
      *     math.min([2, 1, 4, 3])                // returns 1
      *
      *     // minimum over a specified dimension (zero-based)
      *     math.min([[2, 5], [4, 3], [1, 7]], 0) // returns [1, 3]
      *     math.min([[2, 5], [4, 3], [1, 7]], 1) // returns [2, 3, 1]
      *
      *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
      *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
      *
      * See also:
      *
      *    mean, median, max, prod, std, sum, variance
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The minimum value
      */
     return typed(name$2o, {
       // min([a, b, c, d, ...])
       'Array | Matrix': _min,
       // min([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
         return reduce(array, dim.valueOf(), _smallest);
       },
       // min(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('Scalar values expected in function min');
         }
         return _min(args);
       }
     });

     /**
      * Return the smallest of two values
      * @param {*} x
      * @param {*} y
      * @returns {*} Returns x when x is smallest, or y when y is smallest
      * @private
      */
     function _smallest(x, y) {
       try {
         return smaller(x, y) ? x : y;
       } catch (err) {
         throw improveErrorMessage(err, 'min', y);
       }
     }

     /**
      * Recursively calculate the minimum value in an n-dimensional array
      * @param {Array} array
      * @return {number} min
      * @private
      */
     function _min(array) {
       var min;
       deepForEach(array, function (value) {
         try {
           if (isNaN(value) && typeof value === 'number') {
             min = NaN;
           } else if (min === undefined || smaller(value, min)) {
             min = value;
           }
         } catch (err) {
           throw improveErrorMessage(err, 'min', value);
         }
       });
       if (min === undefined) {
         throw new Error('Cannot calculate min of an empty array');
       }

       // make sure returning numeric value: parse a string into a numeric value
       if (typeof min === 'string') {
         min = numeric(min, config.number);
       }
       return min;
     }
   });

   var name$2n = 'ImmutableDenseMatrix';
   var dependencies$2n = ['smaller', 'DenseMatrix'];
   var createImmutableDenseMatrixClass = /* #__PURE__ */factory(name$2n, dependencies$2n, _ref => {
     var {
       smaller,
       DenseMatrix
     } = _ref;
     function ImmutableDenseMatrix(data, datatype) {
       if (!(this instanceof ImmutableDenseMatrix)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       if (datatype && !isString(datatype)) {
         throw new Error('Invalid datatype: ' + datatype);
       }
       if (isMatrix(data) || isArray(data)) {
         // use DenseMatrix implementation
         var matrix = new DenseMatrix(data, datatype);
         // internal structures
         this._data = matrix._data;
         this._size = matrix._size;
         this._datatype = matrix._datatype;
         this._min = null;
         this._max = null;
       } else if (data && isArray(data.data) && isArray(data.size)) {
         // initialize fields from JSON representation
         this._data = data.data;
         this._size = data.size;
         this._datatype = data.datatype;
         this._min = typeof data.min !== 'undefined' ? data.min : null;
         this._max = typeof data.max !== 'undefined' ? data.max : null;
       } else if (data) {
         // unsupported type
         throw new TypeError('Unsupported type of data (' + typeOf$1(data) + ')');
       } else {
         // nothing provided
         this._data = [];
         this._size = [0];
         this._datatype = datatype;
         this._min = null;
         this._max = null;
       }
     }
     ImmutableDenseMatrix.prototype = new DenseMatrix();

     /**
      * Attach type information
      */
     ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
     ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;

     /**
      * Get a subset of the matrix, or replace a subset of the matrix.
      *
      * Usage:
      *     const subset = matrix.subset(index)               // retrieve subset
      *     const value = matrix.subset(index, replacement)   // replace subset
      *
      * @param {Index} index
      * @param {Array | ImmutableDenseMatrix | *} [replacement]
      * @param {*} [defaultValue=0]      Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be filled with zeros.
      */
     ImmutableDenseMatrix.prototype.subset = function (index) {
       switch (arguments.length) {
         case 1:
           {
             // use base implementation
             var m = DenseMatrix.prototype.subset.call(this, index);
             // check result is a matrix
             if (isMatrix(m)) {
               // return immutable matrix
               return new ImmutableDenseMatrix({
                 data: m._data,
                 size: m._size,
                 datatype: m._datatype
               });
             }
             return m;
           }
         // intentional fall through
         case 2:
         case 3:
           throw new Error('Cannot invoke set subset on an Immutable Matrix instance');
         default:
           throw new SyntaxError('Wrong number of arguments');
       }
     };

     /**
      * Replace a single element in the matrix.
      * @param {Number[]} index   Zero-based index
      * @param {*} value
      * @param {*} [defaultValue]        Default value, filled in on new entries when
      *                                  the matrix is resized. If not provided,
      *                                  new matrix elements will be left undefined.
      * @return {ImmutableDenseMatrix} self
      */
     ImmutableDenseMatrix.prototype.set = function () {
       throw new Error('Cannot invoke set on an Immutable Matrix instance');
     };

     /**
      * Resize the matrix to the given size. Returns a copy of the matrix when
      * `copy=true`, otherwise return the matrix itself (resize in place).
      *
      * @param {Number[]} size           The new size the matrix should have.
      * @param {*} [defaultValue=0]      Default value, filled in on new entries.
      *                                  If not provided, the matrix elements will
      *                                  be filled with zeros.
      * @param {boolean} [copy]          Return a resized copy of the matrix
      *
      * @return {Matrix}                 The resized matrix
      */
     ImmutableDenseMatrix.prototype.resize = function () {
       throw new Error('Cannot invoke resize on an Immutable Matrix instance');
     };

     /**
      * Disallows reshaping in favor of immutability.
      *
      * @throws {Error} Operation not allowed
      */
     ImmutableDenseMatrix.prototype.reshape = function () {
       throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
     };

     /**
      * Create a clone of the matrix
      * @return {ImmutableDenseMatrix} clone
      */
     ImmutableDenseMatrix.prototype.clone = function () {
       return new ImmutableDenseMatrix({
         data: clone$3(this._data),
         size: clone$3(this._size),
         datatype: this._datatype
       });
     };

     /**
      * Get a JSON representation of the matrix
      * @returns {Object}
      */
     ImmutableDenseMatrix.prototype.toJSON = function () {
       return {
         mathjs: 'ImmutableDenseMatrix',
         data: this._data,
         size: this._size,
         datatype: this._datatype
       };
     };

     /**
      * Generate a matrix from a JSON object
      * @param {Object} json  An object structured like
      *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
      *                       where mathjs is optional
      * @returns {ImmutableDenseMatrix}
      */
     ImmutableDenseMatrix.fromJSON = function (json) {
       return new ImmutableDenseMatrix(json);
     };

     /**
      * Swap rows i and j in Matrix.
      *
      * @param {Number} i       Matrix row index 1
      * @param {Number} j       Matrix row index 2
      *
      * @return {Matrix}        The matrix reference
      */
     ImmutableDenseMatrix.prototype.swapRows = function () {
       throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
     };

     /**
      * Calculate the minimum value in the set
      * @return {Number | undefined} min
      */
     ImmutableDenseMatrix.prototype.min = function () {
       // check min has been calculated before
       if (this._min === null) {
         // minimum
         var m = null;
         // compute min
         this.forEach(function (v) {
           if (m === null || smaller(v, m)) {
             m = v;
           }
         });
         this._min = m !== null ? m : undefined;
       }
       return this._min;
     };

     /**
      * Calculate the maximum value in the set
      * @return {Number | undefined} max
      */
     ImmutableDenseMatrix.prototype.max = function () {
       // check max has been calculated before
       if (this._max === null) {
         // maximum
         var m = null;
         // compute max
         this.forEach(function (v) {
           if (m === null || smaller(m, v)) {
             m = v;
           }
         });
         this._max = m !== null ? m : undefined;
       }
       return this._max;
     };
     return ImmutableDenseMatrix;
   }, {
     isClass: true
   });

   var name$2m = 'Index';
   var dependencies$2m = ['ImmutableDenseMatrix', 'getMatrixDataType'];
   var createIndexClass = /* #__PURE__ */factory(name$2m, dependencies$2m, _ref => {
     var {
       ImmutableDenseMatrix,
       getMatrixDataType
     } = _ref;
     /**
      * Create an index. An Index can store ranges and sets for multiple dimensions.
      * Matrix.get, Matrix.set, and math.subset accept an Index as input.
      *
      * Usage:
      *     const index = new Index(range1, range2, matrix1, array1, ...)
      *
      * Where each parameter can be any of:
      *     A number
      *     A string (containing a name of an object property)
      *     An instance of Range
      *     An Array with the Set values
      *     An Array with Booleans
      *     A Matrix with the Set values
      *     A Matrix with Booleans
      *
      * The parameters start, end, and step must be integer numbers.
      *
      * @class Index
      * @Constructor Index
      * @param {...*} ranges
      */
     function Index(ranges) {
       if (!(this instanceof Index)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       this._dimensions = [];
       this._sourceSize = [];
       this._isScalar = true;
       for (var i = 0, ii = arguments.length; i < ii; i++) {
         var arg = arguments[i];
         var argIsArray = isArray(arg);
         var argIsMatrix = isMatrix(arg);
         var sourceSize = null;
         if (isRange(arg)) {
           this._dimensions.push(arg);
           this._isScalar = false;
         } else if (argIsArray || argIsMatrix) {
           // create matrix
           var m = void 0;
           if (getMatrixDataType(arg) === 'boolean') {
             if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());
             if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());
             sourceSize = arg.valueOf().length;
           } else {
             m = _createImmutableMatrix(arg.valueOf());
           }
           this._dimensions.push(m);
           // size
           var size = m.size();
           // scalar
           if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {
             this._isScalar = false;
           }
         } else if (typeof arg === 'number') {
           this._dimensions.push(_createImmutableMatrix([arg]));
         } else if (typeof arg === 'string') {
           // object property (arguments.count should be 1)
           this._dimensions.push(arg);
         } else {
           throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
         }
         this._sourceSize.push(sourceSize);
         // TODO: implement support for wildcard '*'
       }
     }

     /**
      * Attach type information
      */
     Index.prototype.type = 'Index';
     Index.prototype.isIndex = true;
     function _createImmutableMatrix(arg) {
       // loop array elements
       for (var i = 0, l = arg.length; i < l; i++) {
         if (typeof arg[i] !== 'number' || !isInteger$1(arg[i])) {
           throw new TypeError('Index parameters must be positive integer numbers');
         }
       }
       // create matrix
       return new ImmutableDenseMatrix(arg);
     }

     /**
      * Create a clone of the index
      * @memberof Index
      * @return {Index} clone
      */
     Index.prototype.clone = function () {
       var index = new Index();
       index._dimensions = clone$3(this._dimensions);
       index._isScalar = this._isScalar;
       index._sourceSize = this._sourceSize;
       return index;
     };

     /**
      * Create an index from an array with ranges/numbers
      * @memberof Index
      * @param {Array.<Array | number>} ranges
      * @return {Index} index
      * @private
      */
     Index.create = function (ranges) {
       var index = new Index();
       Index.apply(index, ranges);
       return index;
     };

     /**
      * Retrieve the size of the index, the number of elements for each dimension.
      * @memberof Index
      * @returns {number[]} size
      */
     Index.prototype.size = function () {
       var size = [];
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         var d = this._dimensions[i];
         size[i] = typeof d === 'string' ? 1 : d.size()[0];
       }
       return size;
     };

     /**
      * Get the maximum value for each of the indexes ranges.
      * @memberof Index
      * @returns {number[]} max
      */
     Index.prototype.max = function () {
       var values = [];
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         var range = this._dimensions[i];
         values[i] = typeof range === 'string' ? range : range.max();
       }
       return values;
     };

     /**
      * Get the minimum value for each of the indexes ranges.
      * @memberof Index
      * @returns {number[]} min
      */
     Index.prototype.min = function () {
       var values = [];
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         var range = this._dimensions[i];
         values[i] = typeof range === 'string' ? range : range.min();
       }
       return values;
     };

     /**
      * Loop over each of the ranges of the index
      * @memberof Index
      * @param {Function} callback   Called for each range with a Range as first
      *                              argument, the dimension as second, and the
      *                              index object as third.
      */
     Index.prototype.forEach = function (callback) {
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         callback(this._dimensions[i], i, this);
       }
     };

     /**
      * Retrieve the dimension for the given index
      * @memberof Index
      * @param {Number} dim                  Number of the dimension
      * @returns {Range | null} range
      */
     Index.prototype.dimension = function (dim) {
       return this._dimensions[dim] || null;
     };

     /**
      * Test whether this index contains an object property
      * @returns {boolean} Returns true if the index is an object property
      */
     Index.prototype.isObjectProperty = function () {
       return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
     };

     /**
      * Returns the object property name when the Index holds a single object property,
      * else returns null
      * @returns {string | null}
      */
     Index.prototype.getObjectProperty = function () {
       return this.isObjectProperty() ? this._dimensions[0] : null;
     };

     /**
      * Test whether this index contains only a single value.
      *
      * This is the case when the index is created with only scalar values as ranges,
      * not for ranges resolving into a single value.
      * @memberof Index
      * @return {boolean} isScalar
      */
     Index.prototype.isScalar = function () {
       return this._isScalar;
     };

     /**
      * Expand the Index into an array.
      * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
      * @memberof Index
      * @returns {Array} array
      */
     Index.prototype.toArray = function () {
       var array = [];
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         var dimension = this._dimensions[i];
         array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
       }
       return array;
     };

     /**
      * Get the primitive value of the Index, a two dimensional array.
      * Equivalent to Index.toArray().
      * @memberof Index
      * @returns {Array} array
      */
     Index.prototype.valueOf = Index.prototype.toArray;

     /**
      * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
      * @memberof Index
      * @returns {String} str
      */
     Index.prototype.toString = function () {
       var strings = [];
       for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
         var dimension = this._dimensions[i];
         if (typeof dimension === 'string') {
           strings.push(JSON.stringify(dimension));
         } else {
           strings.push(dimension.toString());
         }
       }
       return '[' + strings.join(', ') + ']';
     };

     /**
      * Get a JSON representation of the Index
      * @memberof Index
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
      */
     Index.prototype.toJSON = function () {
       return {
         mathjs: 'Index',
         dimensions: this._dimensions
       };
     };

     /**
      * Instantiate an Index from a JSON object
      * @memberof Index
      * @param {Object} json A JSON object structured as:
      *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
      * @return {Index}
      */
     Index.fromJSON = function (json) {
       return Index.create(json.dimensions);
     };
     return Index;
   }, {
     isClass: true
   });

   /**
    * Receives an array of booleans and returns an array of Numbers for Index
    * @param {Array} booleanArrayIndex An array of booleans
    * @return {Array} A set of numbers ready for index
    */
   function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
     // gets an array of booleans and returns an array of numbers
     var indexOfNumbers = [];
     booleanArrayIndex.forEach((bool, idx) => {
       if (bool) {
         indexOfNumbers.push(idx);
       }
     });
     return indexOfNumbers;
   }

   var name$2l = 'FibonacciHeap';
   var dependencies$2l = ['smaller', 'larger'];
   var createFibonacciHeapClass = /* #__PURE__ */factory(name$2l, dependencies$2l, _ref => {
     var {
       smaller,
       larger
     } = _ref;
     var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);

     /**
      * Fibonacci Heap implementation, used interally for Matrix math.
      * @class FibonacciHeap
      * @constructor FibonacciHeap
      */
     function FibonacciHeap() {
       if (!(this instanceof FibonacciHeap)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }

       // initialize fields
       this._minimum = null;
       this._size = 0;
     }

     /**
      * Attach type information
      */
     FibonacciHeap.prototype.type = 'FibonacciHeap';
     FibonacciHeap.prototype.isFibonacciHeap = true;

     /**
      * Inserts a new data element into the heap. No heap consolidation is
      * performed at this time, the new node is simply inserted into the root
      * list of this heap. Running time: O(1) actual.
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.insert = function (key, value) {
       // create node
       var node = {
         key,
         value,
         degree: 0
       };
       // check we have a node in the minimum
       if (this._minimum) {
         // minimum node
         var minimum = this._minimum;
         // update left & right of node
         node.left = minimum;
         node.right = minimum.right;
         minimum.right = node;
         node.right.left = node;
         // update minimum node in heap if needed
         if (smaller(key, minimum.key)) {
           // node has a smaller key, use it as minimum
           this._minimum = node;
         }
       } else {
         // set left & right
         node.left = node;
         node.right = node;
         // this is the first node
         this._minimum = node;
       }
       // increment number of nodes in heap
       this._size++;
       // return node
       return node;
     };

     /**
      * Returns the number of nodes in heap. Running time: O(1) actual.
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.size = function () {
       return this._size;
     };

     /**
      * Removes all elements from this heap.
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.clear = function () {
       this._minimum = null;
       this._size = 0;
     };

     /**
      * Returns true if the heap is empty, otherwise false.
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.isEmpty = function () {
       return this._size === 0;
     };

     /**
      * Extracts the node with minimum key from heap. Amortized running
      * time: O(log n).
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.extractMinimum = function () {
       // node to remove
       var node = this._minimum;
       // check we have a minimum
       if (node === null) {
         return node;
       }
       // current minimum
       var minimum = this._minimum;
       // get number of children
       var numberOfChildren = node.degree;
       // pointer to the first child
       var x = node.child;
       // for each child of node do...
       while (numberOfChildren > 0) {
         // store node in right side
         var tempRight = x.right;
         // remove x from child list
         x.left.right = x.right;
         x.right.left = x.left;
         // add x to root list of heap
         x.left = minimum;
         x.right = minimum.right;
         minimum.right = x;
         x.right.left = x;
         // set Parent[x] to null
         x.parent = null;
         x = tempRight;
         numberOfChildren--;
       }
       // remove node from root list of heap
       node.left.right = node.right;
       node.right.left = node.left;
       // update minimum
       if (node === node.right) {
         // empty
         minimum = null;
       } else {
         // update minimum
         minimum = node.right;
         // we need to update the pointer to the root with minimum key
         minimum = _findMinimumNode(minimum, this._size);
       }
       // decrement size of heap
       this._size--;
       // update minimum
       this._minimum = minimum;
       // return node
       return node;
     };

     /**
      * Removes a node from the heap given the reference to the node. The trees
      * in the heap will be consolidated, if necessary. This operation may fail
      * to remove the correct element if there are nodes with key value -Infinity.
      * Running time: O(log n) amortized.
      * @memberof FibonacciHeap
      */
     FibonacciHeap.prototype.remove = function (node) {
       // decrease key value
       this._minimum = _decreaseKey(this._minimum, node, -1);
       // remove the smallest
       this.extractMinimum();
     };

     /**
      * Decreases the key value for a heap node, given the new value to take on.
      * The structure of the heap may be changed and will not be consolidated.
      * Running time: O(1) amortized.
      * @memberof FibonacciHeap
      */
     function _decreaseKey(minimum, node, key) {
       // set node key
       node.key = key;
       // get parent node
       var parent = node.parent;
       if (parent && smaller(node.key, parent.key)) {
         // remove node from parent
         _cut(minimum, node, parent);
         // remove all nodes from parent to the root parent
         _cascadingCut(minimum, parent);
       }
       // update minimum node if needed
       if (smaller(node.key, minimum.key)) {
         minimum = node;
       }
       // return minimum
       return minimum;
     }

     /**
      * The reverse of the link operation: removes node from the child list of parent.
      * This method assumes that min is non-null. Running time: O(1).
      * @memberof FibonacciHeap
      */
     function _cut(minimum, node, parent) {
       // remove node from parent children and decrement Degree[parent]
       node.left.right = node.right;
       node.right.left = node.left;
       parent.degree--;
       // reset y.child if necessary
       if (parent.child === node) {
         parent.child = node.right;
       }
       // remove child if degree is 0
       if (parent.degree === 0) {
         parent.child = null;
       }
       // add node to root list of heap
       node.left = minimum;
       node.right = minimum.right;
       minimum.right = node;
       node.right.left = node;
       // set parent[node] to null
       node.parent = null;
       // set mark[node] to false
       node.mark = false;
     }

     /**
      * Performs a cascading cut operation. This cuts node from its parent and then
      * does the same for its parent, and so on up the tree.
      * Running time: O(log n); O(1) excluding the recursion.
      * @memberof FibonacciHeap
      */
     function _cascadingCut(minimum, node) {
       // store parent node
       var parent = node.parent;
       // if there's a parent...
       if (!parent) {
         return;
       }
       // if node is unmarked, set it marked
       if (!node.mark) {
         node.mark = true;
       } else {
         // it's marked, cut it from parent
         _cut(minimum, node, parent);
         // cut its parent as well
         _cascadingCut(parent);
       }
     }

     /**
      * Make the first node a child of the second one. Running time: O(1) actual.
      * @memberof FibonacciHeap
      */
     var _linkNodes = function _linkNodes(node, parent) {
       // remove node from root list of heap
       node.left.right = node.right;
       node.right.left = node.left;
       // make node a Child of parent
       node.parent = parent;
       if (!parent.child) {
         parent.child = node;
         node.right = node;
         node.left = node;
       } else {
         node.left = parent.child;
         node.right = parent.child.right;
         parent.child.right = node;
         node.right.left = node;
       }
       // increase degree[parent]
       parent.degree++;
       // set mark[node] false
       node.mark = false;
     };
     function _findMinimumNode(minimum, size) {
       // to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree
       var arraySize = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
       // create list with initial capacity
       var array = new Array(arraySize);
       // find the number of root nodes.
       var numRoots = 0;
       var x = minimum;
       if (x) {
         numRoots++;
         x = x.right;
         while (x !== minimum) {
           numRoots++;
           x = x.right;
         }
       }
       // vars
       var y;
       // For each node in root list do...
       while (numRoots > 0) {
         // access this node's degree..
         var d = x.degree;
         // get next node
         var next = x.right;
         // check if there is a node already in array with the same degree
         while (true) {
           // get node with the same degree is any
           y = array[d];
           if (!y) {
             break;
           }
           // make one node with the same degree a child of the other, do this based on the key value.
           if (larger(x.key, y.key)) {
             var temp = y;
             y = x;
             x = temp;
           }
           // make y a child of x
           _linkNodes(y, x);
           // we have handled this degree, go to next one.
           array[d] = null;
           d++;
         }
         // save this node for later when we might encounter another of the same degree.
         array[d] = x;
         // move forward through list.
         x = next;
         numRoots--;
       }
       // Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].
       minimum = null;
       // loop nodes in array
       for (var i = 0; i < arraySize; i++) {
         // get current node
         y = array[i];
         if (!y) {
           continue;
         }
         // check if we have a linked list
         if (minimum) {
           // First remove node from root list.
           y.left.right = y.right;
           y.right.left = y.left;
           // now add to root list, again.
           y.left = minimum;
           y.right = minimum.right;
           minimum.right = y;
           y.right.left = y;
           // check if this is a new min.
           if (smaller(y.key, minimum.key)) {
             minimum = y;
           }
         } else {
           minimum = y;
         }
       }
       return minimum;
     }
     return FibonacciHeap;
   }, {
     isClass: true
   });

   var name$2k = 'Spa';
   var dependencies$2k = ['addScalar', 'equalScalar', 'FibonacciHeap'];
   var createSpaClass = /* #__PURE__ */factory(name$2k, dependencies$2k, _ref => {
     var {
       addScalar,
       equalScalar,
       FibonacciHeap
     } = _ref;
     /**
      * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array
      * of the vector elements and an ordered list of non-zero elements.
      */
     function Spa() {
       if (!(this instanceof Spa)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }

       // allocate vector, TODO use typed arrays
       this._values = [];
       this._heap = new FibonacciHeap();
     }

     /**
      * Attach type information
      */
     Spa.prototype.type = 'Spa';
     Spa.prototype.isSpa = true;

     /**
      * Set the value for index i.
      *
      * @param {number} i                       The index
      * @param {number | BigNumber | Complex}   The value at index i
      */
     Spa.prototype.set = function (i, v) {
       // check we have a value @ i
       if (!this._values[i]) {
         // insert in heap
         var node = this._heap.insert(i, v);
         // set the value @ i
         this._values[i] = node;
       } else {
         // update the value @ i
         this._values[i].value = v;
       }
     };
     Spa.prototype.get = function (i) {
       var node = this._values[i];
       if (node) {
         return node.value;
       }
       return 0;
     };
     Spa.prototype.accumulate = function (i, v) {
       // node @ i
       var node = this._values[i];
       if (!node) {
         // insert in heap
         node = this._heap.insert(i, v);
         // initialize value
         this._values[i] = node;
       } else {
         // accumulate value
         node.value = addScalar(node.value, v);
       }
     };
     Spa.prototype.forEach = function (from, to, callback) {
       // references
       var heap = this._heap;
       var values = this._values;
       // nodes
       var nodes = [];
       // node with minimum key, save it
       var node = heap.extractMinimum();
       if (node) {
         nodes.push(node);
       }
       // extract nodes from heap (ordered)
       while (node && node.key <= to) {
         // check it is in range
         if (node.key >= from) {
           // check value is not zero
           if (!equalScalar(node.value, 0)) {
             // invoke callback
             callback(node.key, node.value, this);
           }
         }
         // extract next node, save it
         node = heap.extractMinimum();
         if (node) {
           nodes.push(node);
         }
       }
       // reinsert all nodes in heap
       for (var i = 0; i < nodes.length; i++) {
         // current node
         var n = nodes[i];
         // insert node in heap
         node = heap.insert(n.key, n.value);
         // update values
         values[node.key] = node;
       }
     };
     Spa.prototype.swap = function (i, j) {
       // node @ i and j
       var nodei = this._values[i];
       var nodej = this._values[j];
       // check we need to insert indeces
       if (!nodei && nodej) {
         // insert in heap
         nodei = this._heap.insert(i, nodej.value);
         // remove from heap
         this._heap.remove(nodej);
         // set values
         this._values[i] = nodei;
         this._values[j] = undefined;
       } else if (nodei && !nodej) {
         // insert in heap
         nodej = this._heap.insert(j, nodei.value);
         // remove from heap
         this._heap.remove(nodei);
         // set values
         this._values[j] = nodej;
         this._values[i] = undefined;
       } else if (nodei && nodej) {
         // swap values
         var v = nodei.value;
         nodei.value = nodej.value;
         nodej.value = v;
       }
     };
     return Spa;
   }, {
     isClass: true
   });

   /**
    * Calculate BigNumber e
    * @param {function} BigNumber   BigNumber constructor
    * @returns {BigNumber} Returns e
    */
   var createBigNumberE = memoize(function (BigNumber) {
     return new BigNumber(1).exp();
   }, {
     hasher
   });

   /**
    * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2
    * @param {function} BigNumber   BigNumber constructor
    * @returns {BigNumber} Returns phi
    */
   var createBigNumberPhi = memoize(function (BigNumber) {
     return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
   }, {
     hasher
   });

   /**
    * Calculate BigNumber pi.
    * @param {function} BigNumber   BigNumber constructor
    * @returns {BigNumber} Returns pi
    */
   var createBigNumberPi = memoize(function (BigNumber) {
     return BigNumber.acos(-1);
   }, {
     hasher
   });

   /**
    * Calculate BigNumber tau, tau = 2 * pi
    * @param {function} BigNumber   BigNumber constructor
    * @returns {BigNumber} Returns tau
    */
   var createBigNumberTau = memoize(function (BigNumber) {
     return createBigNumberPi(BigNumber).times(2);
   }, {
     hasher
   });

   /**
    * Create a hash for a BigNumber constructor function. The created has is
    * the configured precision
    * @param {Array} args         Supposed to contain a single entry with
    *                             a BigNumber constructor
    * @return {number} precision
    * @private
    */
   function hasher(args) {
     return args[0].precision;
   }

   function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
   function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
   var name$2j = 'Unit';
   var dependencies$2j = ['?on', 'config', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'abs', 'fix', 'round', 'equal', 'isNumeric', 'format', 'number', 'Complex', 'BigNumber', 'Fraction'];
   var createUnitClass = /* #__PURE__ */factory(name$2j, dependencies$2j, _ref => {
     var {
       on,
       config,
       addScalar,
       subtract,
       multiplyScalar,
       divideScalar,
       pow,
       abs,
       fix,
       round,
       equal,
       isNumeric,
       format,
       number: _number,
       Complex,
       BigNumber: _BigNumber,
       Fraction: _Fraction
     } = _ref;
     var toNumber = _number;
     /**
      * A unit can be constructed in the following ways:
      *
      *     const a = new Unit(value, valuelessUnit)
      *     const b = new Unit(null, valuelessUnit)
      *     const c = Unit.parse(str)
      *
      * Example usage:
      *
      *     const a = new Unit(5, 'cm')               // 50 mm
      *     const b = Unit.parse('23 kg')             // 23 kg
      *     const c = math.in(a, new Unit(null, 'm')  // 0.05 m
      *     const d = new Unit(9.81, "m/s^2")         // 9.81 m/s^2
      *
      * @class Unit
      * @constructor Unit
      * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
      * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
      */
     function Unit(value, valuelessUnit) {
       if (!(this instanceof Unit)) {
         throw new Error('Constructor must be called with the new operator');
       }
       if (!(value === null || value === undefined || isNumeric(value) || isComplex(value))) {
         throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
       }
       this.fixPrefix = false; // if true, function format will not search for the
       // best prefix but leave it as initially provided.
       // fixPrefix is set true by the method Unit.to

       // The justification behind this is that if the constructor is explicitly called,
       // the caller wishes the units to be returned exactly as supplied.
       this.skipAutomaticSimplification = true;
       if (valuelessUnit === undefined) {
         this.units = [];
         this.dimensions = BASE_DIMENSIONS.map(x => 0);
       } else if (typeof valuelessUnit === 'string') {
         var u = Unit.parse(valuelessUnit);
         this.units = u.units;
         this.dimensions = u.dimensions;
       } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
         // clone from valuelessUnit
         this.fixPrefix = valuelessUnit.fixPrefix;
         this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
         this.dimensions = valuelessUnit.dimensions.slice(0);
         this.units = valuelessUnit.units.map(u => _extends$1({}, u));
       } else {
         throw new TypeError('Second parameter in Unit constructor must be a string or valueless Unit');
       }
       this.value = this._normalize(value);
     }

     /**
      * Attach type information
      */
     Object.defineProperty(Unit, 'name', {
       value: 'Unit'
     });
     Unit.prototype.constructor = Unit;
     Unit.prototype.type = 'Unit';
     Unit.prototype.isUnit = true;

     // private variables and functions for the Unit parser
     var text, index, c;
     function skipWhitespace() {
       while (c === ' ' || c === '\t') {
         next();
       }
     }
     function isDigitDot(c) {
       return c >= '0' && c <= '9' || c === '.';
     }
     function isDigit(c) {
       return c >= '0' && c <= '9';
     }
     function next() {
       index++;
       c = text.charAt(index);
     }
     function revert(oldIndex) {
       index = oldIndex;
       c = text.charAt(index);
     }
     function parseNumber() {
       var number = '';
       var oldIndex = index;
       if (c === '+') {
         next();
       } else if (c === '-') {
         number += c;
         next();
       }
       if (!isDigitDot(c)) {
         // a + or - must be followed by a digit
         revert(oldIndex);
         return null;
       }

       // get number, can have a single dot
       if (c === '.') {
         number += c;
         next();
         if (!isDigit(c)) {
           // this is no legal number, it is just a dot
           revert(oldIndex);
           return null;
         }
       } else {
         while (isDigit(c)) {
           number += c;
           next();
         }
         if (c === '.') {
           number += c;
           next();
         }
       }
       while (isDigit(c)) {
         number += c;
         next();
       }

       // check for exponential notation like "2.3e-4" or "1.23e50"
       if (c === 'E' || c === 'e') {
         // The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"

         var tentativeNumber = '';
         var tentativeIndex = index;
         tentativeNumber += c;
         next();
         if (c === '+' || c === '-') {
           tentativeNumber += c;
           next();
         }

         // Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)
         if (!isDigit(c)) {
           // The e or E must belong to something else, so return the number without the e or E.
           revert(tentativeIndex);
           return number;
         }

         // We can now safely say that this is scientific notation.
         number = number + tentativeNumber;
         while (isDigit(c)) {
           number += c;
           next();
         }
       }
       return number;
     }
     function parseUnit() {
       var unitName = '';

       // Alphanumeric characters only; matches [a-zA-Z0-9]
       while (isDigit(c) || Unit.isValidAlpha(c)) {
         unitName += c;
         next();
       }

       // Must begin with [a-zA-Z]
       var firstC = unitName.charAt(0);
       if (Unit.isValidAlpha(firstC)) {
         return unitName;
       } else {
         return null;
       }
     }
     function parseCharacter(toFind) {
       if (c === toFind) {
         next();
         return toFind;
       } else {
         return null;
       }
     }

     /**
      * Parse a string into a unit. The value of the unit is parsed as number,
      * BigNumber, or Fraction depending on the math.js config setting `number`.
      *
      * Throws an exception if the provided string does not contain a valid unit or
      * cannot be parsed.
      * @memberof Unit
      * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
      * @return {Unit} unit
      */
     Unit.parse = function (str, options) {
       options = options || {};
       text = str;
       index = -1;
       c = '';
       if (typeof text !== 'string') {
         throw new TypeError('Invalid argument in Unit.parse, string expected');
       }
       var unit = new Unit();
       unit.units = [];
       var powerMultiplierCurrent = 1;
       var expectingUnit = false;

       // A unit should follow this pattern:
       // [number] ...[ [*/] unit[^number] ]
       // unit[^number] ... [ [*/] unit[^number] ]

       // Rules:
       // number is any floating point number.
       // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
       // The string may optionally begin with a number.
       // Each unit may optionally be followed by ^number.
       // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
       //   2m^2kg/s^2
       // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
       //   4erg

       next();
       skipWhitespace();

       // Optional number at the start of the string
       var valueStr = parseNumber();
       var value = null;
       if (valueStr) {
         if (config.number === 'BigNumber') {
           value = new _BigNumber(valueStr);
         } else if (config.number === 'Fraction') {
           try {
             // not all numbers can be turned in Fractions, for example very small numbers not
             value = new _Fraction(valueStr);
           } catch (err) {
             value = parseFloat(valueStr);
           }
         } else {
           // number
           value = parseFloat(valueStr);
         }
         skipWhitespace(); // Whitespace is not required here

         // handle multiplication or division right after the value, like '1/s'
         if (parseCharacter('*')) {
           powerMultiplierCurrent = 1;
           expectingUnit = true;
         } else if (parseCharacter('/')) {
           powerMultiplierCurrent = -1;
           expectingUnit = true;
         }
       }

       // Stack to keep track of powerMultipliers applied to each parentheses group
       var powerMultiplierStack = [];

       // Running product of all elements in powerMultiplierStack
       var powerMultiplierStackProduct = 1;
       while (true) {
         skipWhitespace();

         // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
         // A '(' will always appear directly before a unit.
         while (c === '(') {
           powerMultiplierStack.push(powerMultiplierCurrent);
           powerMultiplierStackProduct *= powerMultiplierCurrent;
           powerMultiplierCurrent = 1;
           next();
           skipWhitespace();
         }

         // Is there something here?
         var uStr = void 0;
         if (c) {
           var oldC = c;
           uStr = parseUnit();
           if (uStr === null) {
             throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
           }
         } else {
           // End of input.
           break;
         }

         // Verify the unit exists and get the prefix (if any)
         var res = _findUnit(uStr);
         if (res === null) {
           // Unit not found.
           throw new SyntaxError('Unit "' + uStr + '" not found.');
         }
         var power = powerMultiplierCurrent * powerMultiplierStackProduct;
         // Is there a "^ number"?
         skipWhitespace();
         if (parseCharacter('^')) {
           skipWhitespace();
           var p = parseNumber();
           if (p === null) {
             // No valid number found for the power!
             throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
           }
           power *= p;
         }

         // Add the unit to the list
         unit.units.push({
           unit: res.unit,
           prefix: res.prefix,
           power
         });
         for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
           unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
         }

         // Check for and consume closing parentheses, popping from the stack.
         // A ')' will always follow a unit.
         skipWhitespace();
         while (c === ')') {
           if (powerMultiplierStack.length === 0) {
             throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
           }
           powerMultiplierStackProduct /= powerMultiplierStack.pop();
           next();
           skipWhitespace();
         }

         // "*" and "/" should mean we are expecting something to come next.
         // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
         expectingUnit = false;
         if (parseCharacter('*')) {
           // explicit multiplication
           powerMultiplierCurrent = 1;
           expectingUnit = true;
         } else if (parseCharacter('/')) {
           // division
           powerMultiplierCurrent = -1;
           expectingUnit = true;
         } else {
           // implicit multiplication
           powerMultiplierCurrent = 1;
         }

         // Replace the unit into the auto unit system
         if (res.unit.base) {
           var baseDim = res.unit.base.key;
           UNIT_SYSTEMS.auto[baseDim] = {
             unit: res.unit,
             prefix: res.prefix
           };
         }
       }

       // Has the string been entirely consumed?
       skipWhitespace();
       if (c) {
         throw new SyntaxError('Could not parse: "' + str + '"');
       }

       // Is there a trailing slash?
       if (expectingUnit) {
         throw new SyntaxError('Trailing characters: "' + str + '"');
       }

       // Is the parentheses stack empty?
       if (powerMultiplierStack.length !== 0) {
         throw new SyntaxError('Unmatched "(" in "' + text + '"');
       }

       // Are there any units at all?
       if (unit.units.length === 0 && !options.allowNoUnits) {
         throw new SyntaxError('"' + str + '" contains no units');
       }
       unit.value = value !== undefined ? unit._normalize(value) : null;
       return unit;
     };

     /**
      * create a copy of this unit
      * @memberof Unit
      * @return {Unit} Returns a cloned version of the unit
      */
     Unit.prototype.clone = function () {
       var unit = new Unit();
       unit.fixPrefix = this.fixPrefix;
       unit.skipAutomaticSimplification = this.skipAutomaticSimplification;
       unit.value = clone$3(this.value);
       unit.dimensions = this.dimensions.slice(0);
       unit.units = [];
       for (var i = 0; i < this.units.length; i++) {
         unit.units[i] = {};
         for (var p in this.units[i]) {
           if (hasOwnProperty(this.units[i], p)) {
             unit.units[i][p] = this.units[i][p];
           }
         }
       }
       return unit;
     };

     /**
      * Return the type of the value of this unit
      *
      * @memberof Unit
      * @ return {string} type of the value of the unit
      */
     Unit.prototype.valueType = function () {
       return typeOf$1(this.value);
     };

     /**
      * Return whether the unit is derived (such as m/s, or cm^2, but not N)
      * @memberof Unit
      * @return {boolean} True if the unit is derived
      */
     Unit.prototype._isDerived = function () {
       if (this.units.length === 0) {
         return false;
       }
       return this.units.length > 1 || Math.abs(this.units[0].power - 1.0) > 1e-15;
     };

     /**
      * Normalize a value, based on its currently set unit(s)
      * @memberof Unit
      * @param {number | BigNumber | Fraction | boolean} value
      * @return {number | BigNumber | Fraction | boolean} normalized value
      * @private
      */
     Unit.prototype._normalize = function (value) {
       if (value === null || value === undefined || this.units.length === 0) {
         return value;
       }
       var res = value;
       var convert = Unit._getNumberConverter(typeOf$1(value)); // convert to Fraction or BigNumber if needed

       for (var i = 0; i < this.units.length; i++) {
         var unitValue = convert(this.units[i].unit.value);
         var unitPrefixValue = convert(this.units[i].prefix.value);
         var unitPower = convert(this.units[i].power);
         res = multiplyScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
       }
       return res;
     };

     /**
      * Denormalize a value, based on its currently set unit(s)
      * @memberof Unit
      * @param {number} value
      * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
      * @return {number} denormalized value
      * @private
      */
     Unit.prototype._denormalize = function (value, prefixValue) {
       if (value === null || value === undefined || this.units.length === 0) {
         return value;
       }
       var res = value;
       var convert = Unit._getNumberConverter(typeOf$1(value)); // convert to Fraction or BigNumber if needed

       for (var i = 0; i < this.units.length; i++) {
         var unitValue = convert(this.units[i].unit.value);
         var unitPrefixValue = convert(this.units[i].prefix.value);
         var unitPower = convert(this.units[i].power);
         res = divideScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
       }
       return res;
     };

     /**
      * Find a unit from a string
      * @memberof Unit
      * @param {string} str              A string like 'cm' or 'inch'
      * @returns {Object | null} result  When found, an object with fields unit and
      *                                  prefix is returned. Else, null is returned.
      * @private
      */
     var _findUnit = memoize(str => {
       // First, match units names exactly. For example, a user could define 'mm' as 10^-4 m, which is silly, but then we would want 'mm' to match the user-defined unit.
       if (hasOwnProperty(UNITS, str)) {
         var unit = UNITS[str];
         var prefix = unit.prefixes[''];
         return {
           unit,
           prefix
         };
       }
       for (var _name in UNITS) {
         if (hasOwnProperty(UNITS, _name)) {
           if (endsWith(str, _name)) {
             var _unit = UNITS[_name];
             var prefixLen = str.length - _name.length;
             var prefixName = str.substring(0, prefixLen);
             var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : undefined;
             if (_prefix !== undefined) {
               // store unit, prefix, and value
               return {
                 unit: _unit,
                 prefix: _prefix
               };
             }
           }
         }
       }
       return null;
     }, {
       hasher: args => args[0],
       limit: 100
     });

     /**
      * Test if the given expression is a unit.
      * The unit can have a prefix but cannot have a value.
      * @memberof Unit
      * @param {string} name   A string to be tested whether it is a value less unit.
      *                        The unit can have prefix, like "cm"
      * @return {boolean}      true if the given string is a unit
      */
     Unit.isValuelessUnit = function (name) {
       return _findUnit(name) !== null;
     };

     /**
      * check if this unit has given base unit
      * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
      * @memberof Unit
      * @param {BASE_UNITS | string | undefined} base
      */
     Unit.prototype.hasBase = function (base) {
       if (typeof base === 'string') {
         base = BASE_UNITS[base];
       }
       if (!base) {
         return false;
       }

       // All dimensions must be the same
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
           return false;
         }
       }
       return true;
     };

     /**
      * Check if this unit has a base or bases equal to another base or bases
      * For derived units, the exponent on each base also must match
      * @memberof Unit
      * @param {Unit} other
      * @return {boolean} true if equal base
      */
     Unit.prototype.equalBase = function (other) {
       // All dimensions must be the same
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
           return false;
         }
       }
       return true;
     };

     /**
      * Check if this unit equals another unit
      * @memberof Unit
      * @param {Unit} other
      * @return {boolean} true if both units are equal
      */
     Unit.prototype.equals = function (other) {
       return this.equalBase(other) && equal(this.value, other.value);
     };

     /**
      * Multiply this unit with another one or with a scalar
      * @memberof Unit
      * @param {Unit} other
      * @return {Unit} product of this unit and the other unit
      */
     Unit.prototype.multiply = function (_other) {
       var res = this.clone();
       var other = isUnit(_other) ? _other : new Unit(_other);
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         // Dimensions arrays may be of different lengths. Default to 0.
         res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
       }

       // Append other's units list onto res
       for (var _i = 0; _i < other.units.length; _i++) {
         // Make a shallow copy of every unit
         var inverted = _objectSpread$1({}, other.units[_i]);
         res.units.push(inverted);
       }

       // If at least one operand has a value, then the result should also have a value
       if (this.value !== null || other.value !== null) {
         var valThis = this.value === null ? this._normalize(1) : this.value;
         var valOther = other.value === null ? other._normalize(1) : other.value;
         res.value = multiplyScalar(valThis, valOther);
       } else {
         res.value = null;
       }
       if (isUnit(_other)) {
         res.skipAutomaticSimplification = false;
       }
       return getNumericIfUnitless(res);
     };

     /**
      * Divide a number by this unit
      *
      * @memberof Unit
      * @param {numeric} numerator
      * @param {unit} result of dividing numerator by this unit
      */
     Unit.prototype.divideInto = function (numerator) {
       return new Unit(numerator).divide(this);
     };

     /**
      * Divide this unit by another one
      * @memberof Unit
      * @param {Unit | numeric} other
      * @return {Unit} result of dividing this unit by the other unit
      */
     Unit.prototype.divide = function (_other) {
       var res = this.clone();
       var other = isUnit(_other) ? _other : new Unit(_other);
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         // Dimensions arrays may be of different lengths. Default to 0.
         res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
       }

       // Invert and append other's units list onto res
       for (var _i2 = 0; _i2 < other.units.length; _i2++) {
         // Make a shallow copy of every unit
         var inverted = _objectSpread$1(_objectSpread$1({}, other.units[_i2]), {}, {
           power: -other.units[_i2].power
         });
         res.units.push(inverted);
       }

       // If at least one operand has a value, the result should have a value
       if (this.value !== null || other.value !== null) {
         var valThis = this.value === null ? this._normalize(1) : this.value;
         var valOther = other.value === null ? other._normalize(1) : other.value;
         res.value = divideScalar(valThis, valOther);
       } else {
         res.value = null;
       }
       if (isUnit(_other)) {
         res.skipAutomaticSimplification = false;
       }
       return getNumericIfUnitless(res);
     };

     /**
      * Calculate the power of a unit
      * @memberof Unit
      * @param {number | Fraction | BigNumber} p
      * @returns {Unit}      The result: this^p
      */
     Unit.prototype.pow = function (p) {
       var res = this.clone();
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         // Dimensions arrays may be of different lengths. Default to 0.
         res.dimensions[i] = (this.dimensions[i] || 0) * p;
       }

       // Adjust the power of each unit in the list
       for (var _i3 = 0; _i3 < res.units.length; _i3++) {
         res.units[_i3].power *= p;
       }
       if (res.value !== null) {
         res.value = pow(res.value, p);

         // only allow numeric output, we don't want to return a Complex number
         // if (!isNumeric(res.value)) {
         //  res.value = NaN
         // }
         // Update: Complex supported now
       } else {
         res.value = null;
       }
       res.skipAutomaticSimplification = false;
       return getNumericIfUnitless(res);
     };

     /**
      * Return the numeric value of this unit if it is dimensionless, has a value, and config.predictable == false; or the original unit otherwise
      * @param {Unit} unit
      * @returns {number | Fraction | BigNumber | Unit}  The numeric value of the unit if conditions are met, or the original unit otherwise
      */
     function getNumericIfUnitless(unit) {
       if (unit.equalBase(BASE_UNITS.NONE) && unit.value !== null && !config.predictable) {
         return unit.value;
       } else {
         return unit;
       }
     }

     /**
      * Calculate the absolute value of a unit
      * @memberof Unit
      * @param {number | Fraction | BigNumber} x
      * @returns {Unit}      The result: |x|, absolute value of x
      */
     Unit.prototype.abs = function () {
       var ret = this.clone();
       if (ret.value !== null) {
         if (ret._isDerived() || ret.units[0].unit.offset === 0) {
           ret.value = abs(ret.value);
         } else {
           // To give the correct, but unexpected, results for units with an offset.
           // For example, abs(-283.15 degC) = -263.15 degC !!!
           // We must take the offset into consideration here
           var convert = ret._numberConverter(); // convert to Fraction or BigNumber if needed
           var unitValue = convert(ret.units[0].unit.value);
           var nominalOffset = convert(ret.units[0].unit.offset);
           var unitOffset = multiplyScalar(unitValue, nominalOffset);
           ret.value = subtract(abs(addScalar(ret.value, unitOffset)), unitOffset);
         }
       }
       for (var i in ret.units) {
         if (ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
           ret.units[i].unit = UNITS.W;
         }
       }
       return ret;
     };

     /**
      * Convert the unit to a specific unit name.
      * @memberof Unit
      * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
      * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
      */
     Unit.prototype.to = function (valuelessUnit) {
       var value = this.value === null ? this._normalize(1) : this.value;
       var other;
       if (typeof valuelessUnit === 'string') {
         other = Unit.parse(valuelessUnit);
       } else if (isUnit(valuelessUnit)) {
         other = valuelessUnit.clone();
       } else {
         throw new Error('String or Unit expected as parameter');
       }
       if (!this.equalBase(other)) {
         throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
       }
       if (other.value !== null) {
         throw new Error('Cannot convert to a unit with a value');
       }
       if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
         other.value = clone$3(value);
       } else {
         /* Need to adjust value by difference in offset to convert */
         var convert = Unit._getNumberConverter(typeOf$1(value)); // convert to Fraction or BigNumber if needed

         var thisUnitValue = this.units[0].unit.value;
         var thisNominalOffset = this.units[0].unit.offset;
         var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
         var otherUnitValue = other.units[0].unit.value;
         var otherNominalOffset = other.units[0].unit.offset;
         var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
         other.value = addScalar(value, convert(subtract(thisUnitOffset, otherUnitOffset)));
       }
       other.fixPrefix = true;
       other.skipAutomaticSimplification = true;
       return other;
     };

     /**
      * Return the value of the unit when represented with given valueless unit
      * @memberof Unit
      * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
      * @return {number} Returns the unit value as number.
      */
     // TODO: deprecate Unit.toNumber? It's always better to use toNumeric
     Unit.prototype.toNumber = function (valuelessUnit) {
       return toNumber(this.toNumeric(valuelessUnit));
     };

     /**
      * Return the value of the unit in the original numeric type
      * @memberof Unit
      * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
      * @return {number | BigNumber | Fraction} Returns the unit value
      */
     Unit.prototype.toNumeric = function (valuelessUnit) {
       var other;
       if (valuelessUnit) {
         // Allow getting the numeric value without converting to a different unit
         other = this.to(valuelessUnit);
       } else {
         other = this.clone();
       }
       if (other._isDerived() || other.units.length === 0) {
         return other._denormalize(other.value);
       } else {
         return other._denormalize(other.value, other.units[0].prefix.value);
       }
     };

     /**
      * Get a string representation of the unit.
      * @memberof Unit
      * @return {string}
      */
     Unit.prototype.toString = function () {
       return this.format();
     };

     /**
      * Get a JSON representation of the unit
      * @memberof Unit
      * @returns {Object} Returns a JSON object structured as:
      *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
      */
     Unit.prototype.toJSON = function () {
       return {
         mathjs: 'Unit',
         value: this._denormalize(this.value),
         unit: this.formatUnits(),
         fixPrefix: this.fixPrefix
       };
     };

     /**
      * Instantiate a Unit from a JSON object
      * @memberof Unit
      * @param {Object} json  A JSON object structured as:
      *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
      * @return {Unit}
      */
     Unit.fromJSON = function (json) {
       var unit = new Unit(json.value, json.unit);
       unit.fixPrefix = json.fixPrefix || false;
       return unit;
     };

     /**
      * Returns the string representation of the unit.
      * @memberof Unit
      * @return {string}
      */
     Unit.prototype.valueOf = Unit.prototype.toString;

     /**
      * Simplify this Unit's unit list and return a new Unit with the simplified list.
      * The returned Unit will contain a list of the "best" units for formatting.
      */
     Unit.prototype.simplify = function () {
       var ret = this.clone();
       var proposedUnitList = [];

       // Search for a matching base
       var matchingBase;
       for (var key in currentUnitSystem) {
         if (hasOwnProperty(currentUnitSystem, key)) {
           if (ret.hasBase(BASE_UNITS[key])) {
             matchingBase = key;
             break;
           }
         }
       }
       if (matchingBase === 'NONE') {
         ret.units = [];
       } else {
         var matchingUnit;
         if (matchingBase) {
           // Does the unit system have a matching unit?
           if (hasOwnProperty(currentUnitSystem, matchingBase)) {
             matchingUnit = currentUnitSystem[matchingBase];
           }
         }
         if (matchingUnit) {
           ret.units = [{
             unit: matchingUnit.unit,
             prefix: matchingUnit.prefix,
             power: 1.0
           }];
         } else {
           // Multiple units or units with powers are formatted like this:
           // 5 (kg m^2) / (s^3 mol)
           // Build an representation from the base units of the current unit system
           var missingBaseDim = false;
           for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
             var baseDim = BASE_DIMENSIONS[i];
             if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
               if (hasOwnProperty(currentUnitSystem, baseDim)) {
                 proposedUnitList.push({
                   unit: currentUnitSystem[baseDim].unit,
                   prefix: currentUnitSystem[baseDim].prefix,
                   power: ret.dimensions[i] || 0
                 });
               } else {
                 missingBaseDim = true;
               }
             }
           }

           // Is the proposed unit list "simpler" than the existing one?
           if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
             // Replace this unit list with the proposed list
             ret.units = proposedUnitList;
           }
         }
       }
       return ret;
     };

     /**
      * Returns a new Unit in the SI system with the same value as this one
      */
     Unit.prototype.toSI = function () {
       var ret = this.clone();
       var proposedUnitList = [];

       // Multiple units or units with powers are formatted like this:
       // 5 (kg m^2) / (s^3 mol)
       // Build an representation from the base units of the SI unit system
       for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
         var baseDim = BASE_DIMENSIONS[i];
         if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
           if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
             proposedUnitList.push({
               unit: UNIT_SYSTEMS.si[baseDim].unit,
               prefix: UNIT_SYSTEMS.si[baseDim].prefix,
               power: ret.dimensions[i] || 0
             });
           } else {
             throw new Error('Cannot express custom unit ' + baseDim + ' in SI units');
           }
         }
       }

       // Replace this unit list with the proposed list
       ret.units = proposedUnitList;
       ret.fixPrefix = true;
       ret.skipAutomaticSimplification = true;
       return ret;
     };

     /**
      * Get a string representation of the units of this Unit, without the value. The unit list is formatted as-is without first being simplified.
      * @memberof Unit
      * @return {string}
      */
     Unit.prototype.formatUnits = function () {
       var strNum = '';
       var strDen = '';
       var nNum = 0;
       var nDen = 0;
       for (var i = 0; i < this.units.length; i++) {
         if (this.units[i].power > 0) {
           nNum++;
           strNum += ' ' + this.units[i].prefix.name + this.units[i].unit.name;
           if (Math.abs(this.units[i].power - 1.0) > 1e-15) {
             strNum += '^' + this.units[i].power;
           }
         } else if (this.units[i].power < 0) {
           nDen++;
         }
       }
       if (nDen > 0) {
         for (var _i4 = 0; _i4 < this.units.length; _i4++) {
           if (this.units[_i4].power < 0) {
             if (nNum > 0) {
               strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;
               if (Math.abs(this.units[_i4].power + 1.0) > 1e-15) {
                 strDen += '^' + -this.units[_i4].power;
               }
             } else {
               strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;
               strDen += '^' + this.units[_i4].power;
             }
           }
         }
       }
       // Remove leading " "
       strNum = strNum.substr(1);
       strDen = strDen.substr(1);

       // Add parans for better copy/paste back into evaluate, for example, or for better pretty print formatting
       if (nNum > 1 && nDen > 0) {
         strNum = '(' + strNum + ')';
       }
       if (nDen > 1 && nNum > 0) {
         strDen = '(' + strDen + ')';
       }
       var str = strNum;
       if (nNum > 0 && nDen > 0) {
         str += ' / ';
       }
       str += strDen;
       return str;
     };

     /**
      * Get a string representation of the Unit, with optional formatting options.
      * @memberof Unit
      * @param {Object | number | Function} [options]  Formatting options. See
      *                                                lib/utils/number:format for a
      *                                                description of the available
      *                                                options.
      * @return {string}
      */
     Unit.prototype.format = function (options) {
       // Simplfy the unit list, unless it is valueless or was created directly in the
       // constructor or as the result of to or toSI
       var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();

       // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible. Otherwise, use a real-valued unit instead of a complex-valued one.
       var isImaginary = false;
       if (typeof simp.value !== 'undefined' && simp.value !== null && isComplex(simp.value)) {
         // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
         isImaginary = Math.abs(simp.value.re) < 1e-14;
       }
       for (var i in simp.units) {
         if (hasOwnProperty(simp.units, i)) {
           if (simp.units[i].unit) {
             if (simp.units[i].unit.name === 'VA' && isImaginary) {
               simp.units[i].unit = UNITS.VAR;
             } else if (simp.units[i].unit.name === 'VAR' && !isImaginary) {
               simp.units[i].unit = UNITS.VA;
             }
           }
         }
       }

       // Now apply the best prefix
       // Units must have only one unit and not have the fixPrefix flag set
       if (simp.units.length === 1 && !simp.fixPrefix) {
         // Units must have integer powers, otherwise the prefix will change the
         // outputted value by not-an-integer-power-of-ten
         if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
           // Apply the best prefix
           simp.units[0].prefix = simp._bestPrefix();
         }
       }
       var value = simp._denormalize(simp.value);
       var str = simp.value !== null ? format(value, options || {}) : '';
       var unitStr = simp.formatUnits();
       if (simp.value && isComplex(simp.value)) {
         str = '(' + str + ')'; // Surround complex values with ( ) to enable better parsing
       }

       if (unitStr.length > 0 && str.length > 0) {
         str += ' ';
       }
       str += unitStr;
       return str;
     };

     /**
      * Calculate the best prefix using current value.
      * @memberof Unit
      * @returns {Object} prefix
      * @private
      */
     Unit.prototype._bestPrefix = function () {
       if (this.units.length !== 1) {
         throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
       }
       if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
         throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
       }

       // find the best prefix value (resulting in the value of which
       // the absolute value of the log10 is closest to zero,
       // though with a little offset of 1.2 for nicer values: you get a
       // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...

       // Note: the units value can be any numeric type, but to find the best
       // prefix it's enough to work with limited precision of a regular number
       // Update: using mathjs abs since we also allow complex numbers
       var absValue = this.value !== null ? abs(this.value) : 0;
       var absUnitValue = abs(this.units[0].unit.value);
       var bestPrefix = this.units[0].prefix;
       if (absValue === 0) {
         return bestPrefix;
       }
       var power = this.units[0].power;
       var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
       if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix; // Allow the original prefix
       bestDiff = Math.abs(bestDiff);
       var prefixes = this.units[0].unit.prefixes;
       for (var p in prefixes) {
         if (hasOwnProperty(prefixes, p)) {
           var prefix = prefixes[p];
           if (prefix.scientific) {
             var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
             if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
               // choose the prefix with the smallest diff, or if equal, choose the one
               // with the shortest name (can happen with SHORTLONG for example)
               bestPrefix = prefix;
               bestDiff = diff;
             }
           }
         }
       }
       return bestPrefix;
     };

     /**
      * Returns an array of units whose sum is equal to this unit
      * @memberof Unit
      * @param {Array} [parts] An array of strings or valueless units.
      *
      *   Example:
      *
      *   const u = new Unit(1, 'm')
      *   u.splitUnit(['feet', 'inch'])
      *     [ 3 feet, 3.3700787401575 inch ]
      *
      * @return {Array} An array of units.
      */
     Unit.prototype.splitUnit = function (parts) {
       var x = this.clone();
       var ret = [];
       for (var i = 0; i < parts.length; i++) {
         // Convert x to the requested unit
         x = x.to(parts[i]);
         if (i === parts.length - 1) break;

         // Get the numeric value of this unit
         var xNumeric = x.toNumeric();

         // Check to see if xNumeric is nearly equal to an integer,
         // since fix can incorrectly round down if there is round-off error
         var xRounded = round(xNumeric);
         var xFixed = void 0;
         var isNearlyEqual = equal(xRounded, xNumeric);
         if (isNearlyEqual) {
           xFixed = xRounded;
         } else {
           xFixed = fix(x.toNumeric());
         }
         var y = new Unit(xFixed, parts[i].toString());
         ret.push(y);
         x = subtract(x, y);
       }

       // This little bit fixes a bug where the remainder should be 0 but is a little bit off.
       // But instead of comparing x, the remainder, with zero--we will compare the sum of
       // all the parts so far with the original value. If they are nearly equal,
       // we set the remainder to 0.
       var testSum = 0;
       for (var _i5 = 0; _i5 < ret.length; _i5++) {
         testSum = addScalar(testSum, ret[_i5].value);
       }
       if (equal(testSum, this.value)) {
         x.value = 0;
       }
       ret.push(x);
       return ret;
     };
     var PREFIXES = {
       NONE: {
         '': {
           name: '',
           value: 1,
           scientific: true
         }
       },
       SHORT: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         da: {
           name: 'da',
           value: 1e1,
           scientific: false
         },
         h: {
           name: 'h',
           value: 1e2,
           scientific: false
         },
         k: {
           name: 'k',
           value: 1e3,
           scientific: true
         },
         M: {
           name: 'M',
           value: 1e6,
           scientific: true
         },
         G: {
           name: 'G',
           value: 1e9,
           scientific: true
         },
         T: {
           name: 'T',
           value: 1e12,
           scientific: true
         },
         P: {
           name: 'P',
           value: 1e15,
           scientific: true
         },
         E: {
           name: 'E',
           value: 1e18,
           scientific: true
         },
         Z: {
           name: 'Z',
           value: 1e21,
           scientific: true
         },
         Y: {
           name: 'Y',
           value: 1e24,
           scientific: true
         },
         d: {
           name: 'd',
           value: 1e-1,
           scientific: false
         },
         c: {
           name: 'c',
           value: 1e-2,
           scientific: false
         },
         m: {
           name: 'm',
           value: 1e-3,
           scientific: true
         },
         u: {
           name: 'u',
           value: 1e-6,
           scientific: true
         },
         n: {
           name: 'n',
           value: 1e-9,
           scientific: true
         },
         p: {
           name: 'p',
           value: 1e-12,
           scientific: true
         },
         f: {
           name: 'f',
           value: 1e-15,
           scientific: true
         },
         a: {
           name: 'a',
           value: 1e-18,
           scientific: true
         },
         z: {
           name: 'z',
           value: 1e-21,
           scientific: true
         },
         y: {
           name: 'y',
           value: 1e-24,
           scientific: true
         }
       },
       LONG: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         deca: {
           name: 'deca',
           value: 1e1,
           scientific: false
         },
         hecto: {
           name: 'hecto',
           value: 1e2,
           scientific: false
         },
         kilo: {
           name: 'kilo',
           value: 1e3,
           scientific: true
         },
         mega: {
           name: 'mega',
           value: 1e6,
           scientific: true
         },
         giga: {
           name: 'giga',
           value: 1e9,
           scientific: true
         },
         tera: {
           name: 'tera',
           value: 1e12,
           scientific: true
         },
         peta: {
           name: 'peta',
           value: 1e15,
           scientific: true
         },
         exa: {
           name: 'exa',
           value: 1e18,
           scientific: true
         },
         zetta: {
           name: 'zetta',
           value: 1e21,
           scientific: true
         },
         yotta: {
           name: 'yotta',
           value: 1e24,
           scientific: true
         },
         deci: {
           name: 'deci',
           value: 1e-1,
           scientific: false
         },
         centi: {
           name: 'centi',
           value: 1e-2,
           scientific: false
         },
         milli: {
           name: 'milli',
           value: 1e-3,
           scientific: true
         },
         micro: {
           name: 'micro',
           value: 1e-6,
           scientific: true
         },
         nano: {
           name: 'nano',
           value: 1e-9,
           scientific: true
         },
         pico: {
           name: 'pico',
           value: 1e-12,
           scientific: true
         },
         femto: {
           name: 'femto',
           value: 1e-15,
           scientific: true
         },
         atto: {
           name: 'atto',
           value: 1e-18,
           scientific: true
         },
         zepto: {
           name: 'zepto',
           value: 1e-21,
           scientific: true
         },
         yocto: {
           name: 'yocto',
           value: 1e-24,
           scientific: true
         }
       },
       SQUARED: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         da: {
           name: 'da',
           value: 1e2,
           scientific: false
         },
         h: {
           name: 'h',
           value: 1e4,
           scientific: false
         },
         k: {
           name: 'k',
           value: 1e6,
           scientific: true
         },
         M: {
           name: 'M',
           value: 1e12,
           scientific: true
         },
         G: {
           name: 'G',
           value: 1e18,
           scientific: true
         },
         T: {
           name: 'T',
           value: 1e24,
           scientific: true
         },
         P: {
           name: 'P',
           value: 1e30,
           scientific: true
         },
         E: {
           name: 'E',
           value: 1e36,
           scientific: true
         },
         Z: {
           name: 'Z',
           value: 1e42,
           scientific: true
         },
         Y: {
           name: 'Y',
           value: 1e48,
           scientific: true
         },
         d: {
           name: 'd',
           value: 1e-2,
           scientific: false
         },
         c: {
           name: 'c',
           value: 1e-4,
           scientific: false
         },
         m: {
           name: 'm',
           value: 1e-6,
           scientific: true
         },
         u: {
           name: 'u',
           value: 1e-12,
           scientific: true
         },
         n: {
           name: 'n',
           value: 1e-18,
           scientific: true
         },
         p: {
           name: 'p',
           value: 1e-24,
           scientific: true
         },
         f: {
           name: 'f',
           value: 1e-30,
           scientific: true
         },
         a: {
           name: 'a',
           value: 1e-36,
           scientific: true
         },
         z: {
           name: 'z',
           value: 1e-42,
           scientific: true
         },
         y: {
           name: 'y',
           value: 1e-48,
           scientific: true
         }
       },
       CUBIC: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         da: {
           name: 'da',
           value: 1e3,
           scientific: false
         },
         h: {
           name: 'h',
           value: 1e6,
           scientific: false
         },
         k: {
           name: 'k',
           value: 1e9,
           scientific: true
         },
         M: {
           name: 'M',
           value: 1e18,
           scientific: true
         },
         G: {
           name: 'G',
           value: 1e27,
           scientific: true
         },
         T: {
           name: 'T',
           value: 1e36,
           scientific: true
         },
         P: {
           name: 'P',
           value: 1e45,
           scientific: true
         },
         E: {
           name: 'E',
           value: 1e54,
           scientific: true
         },
         Z: {
           name: 'Z',
           value: 1e63,
           scientific: true
         },
         Y: {
           name: 'Y',
           value: 1e72,
           scientific: true
         },
         d: {
           name: 'd',
           value: 1e-3,
           scientific: false
         },
         c: {
           name: 'c',
           value: 1e-6,
           scientific: false
         },
         m: {
           name: 'm',
           value: 1e-9,
           scientific: true
         },
         u: {
           name: 'u',
           value: 1e-18,
           scientific: true
         },
         n: {
           name: 'n',
           value: 1e-27,
           scientific: true
         },
         p: {
           name: 'p',
           value: 1e-36,
           scientific: true
         },
         f: {
           name: 'f',
           value: 1e-45,
           scientific: true
         },
         a: {
           name: 'a',
           value: 1e-54,
           scientific: true
         },
         z: {
           name: 'z',
           value: 1e-63,
           scientific: true
         },
         y: {
           name: 'y',
           value: 1e-72,
           scientific: true
         }
       },
       BINARY_SHORT_SI: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         k: {
           name: 'k',
           value: 1e3,
           scientific: true
         },
         M: {
           name: 'M',
           value: 1e6,
           scientific: true
         },
         G: {
           name: 'G',
           value: 1e9,
           scientific: true
         },
         T: {
           name: 'T',
           value: 1e12,
           scientific: true
         },
         P: {
           name: 'P',
           value: 1e15,
           scientific: true
         },
         E: {
           name: 'E',
           value: 1e18,
           scientific: true
         },
         Z: {
           name: 'Z',
           value: 1e21,
           scientific: true
         },
         Y: {
           name: 'Y',
           value: 1e24,
           scientific: true
         }
       },
       BINARY_SHORT_IEC: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         Ki: {
           name: 'Ki',
           value: 1024,
           scientific: true
         },
         Mi: {
           name: 'Mi',
           value: Math.pow(1024, 2),
           scientific: true
         },
         Gi: {
           name: 'Gi',
           value: Math.pow(1024, 3),
           scientific: true
         },
         Ti: {
           name: 'Ti',
           value: Math.pow(1024, 4),
           scientific: true
         },
         Pi: {
           name: 'Pi',
           value: Math.pow(1024, 5),
           scientific: true
         },
         Ei: {
           name: 'Ei',
           value: Math.pow(1024, 6),
           scientific: true
         },
         Zi: {
           name: 'Zi',
           value: Math.pow(1024, 7),
           scientific: true
         },
         Yi: {
           name: 'Yi',
           value: Math.pow(1024, 8),
           scientific: true
         }
       },
       BINARY_LONG_SI: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         kilo: {
           name: 'kilo',
           value: 1e3,
           scientific: true
         },
         mega: {
           name: 'mega',
           value: 1e6,
           scientific: true
         },
         giga: {
           name: 'giga',
           value: 1e9,
           scientific: true
         },
         tera: {
           name: 'tera',
           value: 1e12,
           scientific: true
         },
         peta: {
           name: 'peta',
           value: 1e15,
           scientific: true
         },
         exa: {
           name: 'exa',
           value: 1e18,
           scientific: true
         },
         zetta: {
           name: 'zetta',
           value: 1e21,
           scientific: true
         },
         yotta: {
           name: 'yotta',
           value: 1e24,
           scientific: true
         }
       },
       BINARY_LONG_IEC: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         kibi: {
           name: 'kibi',
           value: 1024,
           scientific: true
         },
         mebi: {
           name: 'mebi',
           value: Math.pow(1024, 2),
           scientific: true
         },
         gibi: {
           name: 'gibi',
           value: Math.pow(1024, 3),
           scientific: true
         },
         tebi: {
           name: 'tebi',
           value: Math.pow(1024, 4),
           scientific: true
         },
         pebi: {
           name: 'pebi',
           value: Math.pow(1024, 5),
           scientific: true
         },
         exi: {
           name: 'exi',
           value: Math.pow(1024, 6),
           scientific: true
         },
         zebi: {
           name: 'zebi',
           value: Math.pow(1024, 7),
           scientific: true
         },
         yobi: {
           name: 'yobi',
           value: Math.pow(1024, 8),
           scientific: true
         }
       },
       BTU: {
         '': {
           name: '',
           value: 1,
           scientific: true
         },
         MM: {
           name: 'MM',
           value: 1e6,
           scientific: true
         }
       }
     };
     PREFIXES.SHORTLONG = _extends$1({}, PREFIXES.SHORT, PREFIXES.LONG);
     PREFIXES.BINARY_SHORT = _extends$1({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
     PREFIXES.BINARY_LONG = _extends$1({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);

     /* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
      * Index  Dimension
      * -----  ---------
      *   0    Length
      *   1    Mass
      *   2    Time
      *   3    Current
      *   4    Temperature
      *   5    Luminous intensity
      *   6    Amount of substance
      *   7    Angle
      *   8    Bit (digital)
      * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm °C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
      *
      */

     var BASE_DIMENSIONS = ['MASS', 'LENGTH', 'TIME', 'CURRENT', 'TEMPERATURE', 'LUMINOUS_INTENSITY', 'AMOUNT_OF_SUBSTANCE', 'ANGLE', 'BIT'];
     var BASE_UNITS = {
       NONE: {
         dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
       },
       MASS: {
         dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
       },
       LENGTH: {
         dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
       },
       TIME: {
         dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
       },
       CURRENT: {
         dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
       },
       TEMPERATURE: {
         dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
       },
       LUMINOUS_INTENSITY: {
         dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
       },
       AMOUNT_OF_SUBSTANCE: {
         dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
       },
       FORCE: {
         dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
       },
       SURFACE: {
         dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
       },
       VOLUME: {
         dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
       },
       ENERGY: {
         dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
       },
       POWER: {
         dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
       },
       PRESSURE: {
         dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
       },
       ELECTRIC_CHARGE: {
         dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
       },
       ELECTRIC_CAPACITANCE: {
         dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
       },
       ELECTRIC_POTENTIAL: {
         dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
       },
       ELECTRIC_RESISTANCE: {
         dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
       },
       ELECTRIC_INDUCTANCE: {
         dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
       },
       ELECTRIC_CONDUCTANCE: {
         dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
       },
       MAGNETIC_FLUX: {
         dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
       },
       MAGNETIC_FLUX_DENSITY: {
         dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
       },
       FREQUENCY: {
         dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
       },
       ANGLE: {
         dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
       },
       BIT: {
         dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
       }
     };
     for (var key in BASE_UNITS) {
       if (hasOwnProperty(BASE_UNITS, key)) {
         BASE_UNITS[key].key = key;
       }
     }
     var BASE_UNIT_NONE = {};
     var UNIT_NONE = {
       name: '',
       base: BASE_UNIT_NONE,
       value: 1,
       offset: 0,
       dimensions: BASE_DIMENSIONS.map(x => 0)
     };
     var UNITS = {
       // length
       meter: {
         name: 'meter',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       inch: {
         name: 'inch',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.0254,
         offset: 0
       },
       foot: {
         name: 'foot',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.3048,
         offset: 0
       },
       yard: {
         name: 'yard',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.9144,
         offset: 0
       },
       mile: {
         name: 'mile',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 1609.344,
         offset: 0
       },
       link: {
         name: 'link',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.201168,
         offset: 0
       },
       rod: {
         name: 'rod',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 5.0292,
         offset: 0
       },
       chain: {
         name: 'chain',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 20.1168,
         offset: 0
       },
       angstrom: {
         name: 'angstrom',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 1e-10,
         offset: 0
       },
       m: {
         name: 'm',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       in: {
         name: 'in',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.0254,
         offset: 0
       },
       ft: {
         name: 'ft',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.3048,
         offset: 0
       },
       yd: {
         name: 'yd',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.9144,
         offset: 0
       },
       mi: {
         name: 'mi',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 1609.344,
         offset: 0
       },
       li: {
         name: 'li',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.201168,
         offset: 0
       },
       rd: {
         name: 'rd',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 5.029210,
         offset: 0
       },
       ch: {
         name: 'ch',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 20.1168,
         offset: 0
       },
       mil: {
         name: 'mil',
         base: BASE_UNITS.LENGTH,
         prefixes: PREFIXES.NONE,
         value: 0.0000254,
         offset: 0
       },
       // 1/1000 inch

       // Surface
       m2: {
         name: 'm2',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.SQUARED,
         value: 1,
         offset: 0
       },
       sqin: {
         name: 'sqin',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 0.00064516,
         offset: 0
       },
       // 645.16 mm2
       sqft: {
         name: 'sqft',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 0.09290304,
         offset: 0
       },
       // 0.09290304 m2
       sqyd: {
         name: 'sqyd',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 0.83612736,
         offset: 0
       },
       // 0.83612736 m2
       sqmi: {
         name: 'sqmi',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 2589988.110336,
         offset: 0
       },
       // 2.589988110336 km2
       sqrd: {
         name: 'sqrd',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 25.29295,
         offset: 0
       },
       // 25.29295 m2
       sqch: {
         name: 'sqch',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 404.6873,
         offset: 0
       },
       // 404.6873 m2
       sqmil: {
         name: 'sqmil',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 6.4516e-10,
         offset: 0
       },
       // 6.4516 * 10^-10 m2
       acre: {
         name: 'acre',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 4046.86,
         offset: 0
       },
       // 4046.86 m2
       hectare: {
         name: 'hectare',
         base: BASE_UNITS.SURFACE,
         prefixes: PREFIXES.NONE,
         value: 10000,
         offset: 0
       },
       // 10000 m2

       // Volume
       m3: {
         name: 'm3',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.CUBIC,
         value: 1,
         offset: 0
       },
       L: {
         name: 'L',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.SHORT,
         value: 0.001,
         offset: 0
       },
       // litre
       l: {
         name: 'l',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.SHORT,
         value: 0.001,
         offset: 0
       },
       // litre
       litre: {
         name: 'litre',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.LONG,
         value: 0.001,
         offset: 0
       },
       cuin: {
         name: 'cuin',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 1.6387064e-5,
         offset: 0
       },
       // 1.6387064e-5 m3
       cuft: {
         name: 'cuft',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.028316846592,
         offset: 0
       },
       // 28.316 846 592 L
       cuyd: {
         name: 'cuyd',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.764554857984,
         offset: 0
       },
       // 764.554 857 984 L
       teaspoon: {
         name: 'teaspoon',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.000005,
         offset: 0
       },
       // 5 mL
       tablespoon: {
         name: 'tablespoon',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.000015,
         offset: 0
       },
       // 15 mL
       // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
       drop: {
         name: 'drop',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 5e-8,
         offset: 0
       },
       // 0.05 mL = 5e-8 m3
       gtt: {
         name: 'gtt',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 5e-8,
         offset: 0
       },
       // 0.05 mL = 5e-8 m3

       // Liquid volume
       minim: {
         name: 'minim',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.00000006161152,
         offset: 0
       },
       // 0.06161152 mL
       fluiddram: {
         name: 'fluiddram',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0000036966911,
         offset: 0
       },
       // 3.696691 mL
       fluidounce: {
         name: 'fluidounce',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.00002957353,
         offset: 0
       },
       // 29.57353 mL
       gill: {
         name: 'gill',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0001182941,
         offset: 0
       },
       // 118.2941 mL
       cc: {
         name: 'cc',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 1e-6,
         offset: 0
       },
       // 1e-6 L
       cup: {
         name: 'cup',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0002365882,
         offset: 0
       },
       // 236.5882 mL
       pint: {
         name: 'pint',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0004731765,
         offset: 0
       },
       // 473.1765 mL
       quart: {
         name: 'quart',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0009463529,
         offset: 0
       },
       // 946.3529 mL
       gallon: {
         name: 'gallon',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.003785412,
         offset: 0
       },
       // 3.785412 L
       beerbarrel: {
         name: 'beerbarrel',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.1173478,
         offset: 0
       },
       // 117.3478 L
       oilbarrel: {
         name: 'oilbarrel',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.1589873,
         offset: 0
       },
       // 158.9873 L
       hogshead: {
         name: 'hogshead',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.2384810,
         offset: 0
       },
       // 238.4810 L

       // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
       fldr: {
         name: 'fldr',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0000036966911,
         offset: 0
       },
       // 3.696691 mL
       floz: {
         name: 'floz',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.00002957353,
         offset: 0
       },
       // 29.57353 mL
       gi: {
         name: 'gi',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0001182941,
         offset: 0
       },
       // 118.2941 mL
       cp: {
         name: 'cp',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0002365882,
         offset: 0
       },
       // 236.5882 mL
       pt: {
         name: 'pt',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0004731765,
         offset: 0
       },
       // 473.1765 mL
       qt: {
         name: 'qt',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.0009463529,
         offset: 0
       },
       // 946.3529 mL
       gal: {
         name: 'gal',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.003785412,
         offset: 0
       },
       // 3.785412 L
       bbl: {
         name: 'bbl',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.1173478,
         offset: 0
       },
       // 117.3478 L
       obl: {
         name: 'obl',
         base: BASE_UNITS.VOLUME,
         prefixes: PREFIXES.NONE,
         value: 0.1589873,
         offset: 0
       },
       // 158.9873 L
       // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?

       // Mass
       g: {
         name: 'g',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.SHORT,
         value: 0.001,
         offset: 0
       },
       gram: {
         name: 'gram',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.LONG,
         value: 0.001,
         offset: 0
       },
       ton: {
         name: 'ton',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.SHORT,
         value: 907.18474,
         offset: 0
       },
       t: {
         name: 't',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.SHORT,
         value: 1000,
         offset: 0
       },
       tonne: {
         name: 'tonne',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.LONG,
         value: 1000,
         offset: 0
       },
       grain: {
         name: 'grain',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 64.79891e-6,
         offset: 0
       },
       dram: {
         name: 'dram',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 1.7718451953125e-3,
         offset: 0
       },
       ounce: {
         name: 'ounce',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 28.349523125e-3,
         offset: 0
       },
       poundmass: {
         name: 'poundmass',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 453.59237e-3,
         offset: 0
       },
       hundredweight: {
         name: 'hundredweight',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 45.359237,
         offset: 0
       },
       stick: {
         name: 'stick',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 115e-3,
         offset: 0
       },
       stone: {
         name: 'stone',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 6.35029318,
         offset: 0
       },
       gr: {
         name: 'gr',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 64.79891e-6,
         offset: 0
       },
       dr: {
         name: 'dr',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 1.7718451953125e-3,
         offset: 0
       },
       oz: {
         name: 'oz',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 28.349523125e-3,
         offset: 0
       },
       lbm: {
         name: 'lbm',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 453.59237e-3,
         offset: 0
       },
       cwt: {
         name: 'cwt',
         base: BASE_UNITS.MASS,
         prefixes: PREFIXES.NONE,
         value: 45.359237,
         offset: 0
       },
       // Time
       s: {
         name: 's',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       min: {
         name: 'min',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 60,
         offset: 0
       },
       h: {
         name: 'h',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 3600,
         offset: 0
       },
       second: {
         name: 'second',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       sec: {
         name: 'sec',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       minute: {
         name: 'minute',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 60,
         offset: 0
       },
       hour: {
         name: 'hour',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 3600,
         offset: 0
       },
       day: {
         name: 'day',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 86400,
         offset: 0
       },
       week: {
         name: 'week',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 7 * 86400,
         offset: 0
       },
       month: {
         name: 'month',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 2629800,
         // 1/12th of Julian year
         offset: 0
       },
       year: {
         name: 'year',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 31557600,
         // Julian year
         offset: 0
       },
       decade: {
         name: 'decade',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 315576000,
         // Julian decade
         offset: 0
       },
       century: {
         name: 'century',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 3155760000,
         // Julian century
         offset: 0
       },
       millennium: {
         name: 'millennium',
         base: BASE_UNITS.TIME,
         prefixes: PREFIXES.NONE,
         value: 31557600000,
         // Julian millennium
         offset: 0
       },
       // Frequency
       hertz: {
         name: 'Hertz',
         base: BASE_UNITS.FREQUENCY,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0,
         reciprocal: true
       },
       Hz: {
         name: 'Hz',
         base: BASE_UNITS.FREQUENCY,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0,
         reciprocal: true
       },
       // Angle
       rad: {
         name: 'rad',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       radian: {
         name: 'radian',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
       deg: {
         name: 'deg',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.SHORT,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       degree: {
         name: 'degree',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.LONG,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
       grad: {
         name: 'grad',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.SHORT,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       gradian: {
         name: 'gradian',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.LONG,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
       cycle: {
         name: 'cycle',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.NONE,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
       arcsec: {
         name: 'arcsec',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.NONE,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
       arcmin: {
         name: 'arcmin',
         base: BASE_UNITS.ANGLE,
         prefixes: PREFIXES.NONE,
         value: null,
         // will be filled in by calculateAngleValues()
         offset: 0
       },
       // Electric current
       A: {
         name: 'A',
         base: BASE_UNITS.CURRENT,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       ampere: {
         name: 'ampere',
         base: BASE_UNITS.CURRENT,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       // Temperature
       // K(C) = °C + 273.15
       // K(F) = (°F + 459.67) * (5 / 9)
       // K(R) = °R * (5 / 9)
       K: {
         name: 'K',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       degC: {
         name: 'degC',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 273.15
       },
       degF: {
         name: 'degF',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.SHORT,
         value: new _Fraction(5, 9),
         offset: 459.67
       },
       degR: {
         name: 'degR',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.SHORT,
         value: new _Fraction(5, 9),
         offset: 0
       },
       kelvin: {
         name: 'kelvin',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       celsius: {
         name: 'celsius',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 273.15
       },
       fahrenheit: {
         name: 'fahrenheit',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.LONG,
         value: new _Fraction(5, 9),
         offset: 459.67
       },
       rankine: {
         name: 'rankine',
         base: BASE_UNITS.TEMPERATURE,
         prefixes: PREFIXES.LONG,
         value: new _Fraction(5, 9),
         offset: 0
       },
       // amount of substance
       mol: {
         name: 'mol',
         base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       mole: {
         name: 'mole',
         base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       // luminous intensity
       cd: {
         name: 'cd',
         base: BASE_UNITS.LUMINOUS_INTENSITY,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       candela: {
         name: 'candela',
         base: BASE_UNITS.LUMINOUS_INTENSITY,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       // TODO: units STERADIAN
       // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
       // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},

       // Force
       N: {
         name: 'N',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       newton: {
         name: 'newton',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       dyn: {
         name: 'dyn',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.SHORT,
         value: 0.00001,
         offset: 0
       },
       dyne: {
         name: 'dyne',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.LONG,
         value: 0.00001,
         offset: 0
       },
       lbf: {
         name: 'lbf',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.NONE,
         value: 4.4482216152605,
         offset: 0
       },
       poundforce: {
         name: 'poundforce',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.NONE,
         value: 4.4482216152605,
         offset: 0
       },
       kip: {
         name: 'kip',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.LONG,
         value: 4448.2216,
         offset: 0
       },
       kilogramforce: {
         name: 'kilogramforce',
         base: BASE_UNITS.FORCE,
         prefixes: PREFIXES.NONE,
         value: 9.80665,
         offset: 0
       },
       // Energy
       J: {
         name: 'J',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       joule: {
         name: 'joule',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       erg: {
         name: 'erg',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.SHORTLONG,
         // Both kiloerg and kerg are acceptable
         value: 1e-7,
         offset: 0
       },
       Wh: {
         name: 'Wh',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.SHORT,
         value: 3600,
         offset: 0
       },
       BTU: {
         name: 'BTU',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.BTU,
         value: 1055.05585262,
         offset: 0
       },
       eV: {
         name: 'eV',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.SHORT,
         value: 1.602176565e-19,
         offset: 0
       },
       electronvolt: {
         name: 'electronvolt',
         base: BASE_UNITS.ENERGY,
         prefixes: PREFIXES.LONG,
         value: 1.602176565e-19,
         offset: 0
       },
       // Power
       W: {
         name: 'W',
         base: BASE_UNITS.POWER,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       watt: {
         name: 'watt',
         base: BASE_UNITS.POWER,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       hp: {
         name: 'hp',
         base: BASE_UNITS.POWER,
         prefixes: PREFIXES.NONE,
         value: 745.6998715386,
         offset: 0
       },
       // Electrical power units
       VAR: {
         name: 'VAR',
         base: BASE_UNITS.POWER,
         prefixes: PREFIXES.SHORT,
         value: Complex.I,
         offset: 0
       },
       VA: {
         name: 'VA',
         base: BASE_UNITS.POWER,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Pressure
       Pa: {
         name: 'Pa',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       psi: {
         name: 'psi',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 6894.75729276459,
         offset: 0
       },
       atm: {
         name: 'atm',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 101325,
         offset: 0
       },
       bar: {
         name: 'bar',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.SHORTLONG,
         value: 100000,
         offset: 0
       },
       torr: {
         name: 'torr',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 133.322,
         offset: 0
       },
       mmHg: {
         name: 'mmHg',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 133.322,
         offset: 0
       },
       mmH2O: {
         name: 'mmH2O',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 9.80665,
         offset: 0
       },
       cmH2O: {
         name: 'cmH2O',
         base: BASE_UNITS.PRESSURE,
         prefixes: PREFIXES.NONE,
         value: 98.0665,
         offset: 0
       },
       // Electric charge
       coulomb: {
         name: 'coulomb',
         base: BASE_UNITS.ELECTRIC_CHARGE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       C: {
         name: 'C',
         base: BASE_UNITS.ELECTRIC_CHARGE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Electric capacitance
       farad: {
         name: 'farad',
         base: BASE_UNITS.ELECTRIC_CAPACITANCE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       F: {
         name: 'F',
         base: BASE_UNITS.ELECTRIC_CAPACITANCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Electric potential
       volt: {
         name: 'volt',
         base: BASE_UNITS.ELECTRIC_POTENTIAL,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       V: {
         name: 'V',
         base: BASE_UNITS.ELECTRIC_POTENTIAL,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Electric resistance
       ohm: {
         name: 'ohm',
         base: BASE_UNITS.ELECTRIC_RESISTANCE,
         prefixes: PREFIXES.SHORTLONG,
         // Both Mohm and megaohm are acceptable
         value: 1,
         offset: 0
       },
       /*
        * Unicode breaks in browsers if charset is not specified
       Ω: {
         name: 'Ω',
         base: BASE_UNITS.ELECTRIC_RESISTANCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       */
       // Electric inductance
       henry: {
         name: 'henry',
         base: BASE_UNITS.ELECTRIC_INDUCTANCE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       H: {
         name: 'H',
         base: BASE_UNITS.ELECTRIC_INDUCTANCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Electric conductance
       siemens: {
         name: 'siemens',
         base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       S: {
         name: 'S',
         base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Magnetic flux
       weber: {
         name: 'weber',
         base: BASE_UNITS.MAGNETIC_FLUX,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       Wb: {
         name: 'Wb',
         base: BASE_UNITS.MAGNETIC_FLUX,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Magnetic flux density
       tesla: {
         name: 'tesla',
         base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
         prefixes: PREFIXES.LONG,
         value: 1,
         offset: 0
       },
       T: {
         name: 'T',
         base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
         prefixes: PREFIXES.SHORT,
         value: 1,
         offset: 0
       },
       // Binary
       b: {
         name: 'b',
         base: BASE_UNITS.BIT,
         prefixes: PREFIXES.BINARY_SHORT,
         value: 1,
         offset: 0
       },
       bits: {
         name: 'bits',
         base: BASE_UNITS.BIT,
         prefixes: PREFIXES.BINARY_LONG,
         value: 1,
         offset: 0
       },
       B: {
         name: 'B',
         base: BASE_UNITS.BIT,
         prefixes: PREFIXES.BINARY_SHORT,
         value: 8,
         offset: 0
       },
       bytes: {
         name: 'bytes',
         base: BASE_UNITS.BIT,
         prefixes: PREFIXES.BINARY_LONG,
         value: 8,
         offset: 0
       }
     };

     // aliases (formerly plurals)
     var ALIASES = {
       meters: 'meter',
       inches: 'inch',
       feet: 'foot',
       yards: 'yard',
       miles: 'mile',
       links: 'link',
       rods: 'rod',
       chains: 'chain',
       angstroms: 'angstrom',
       lt: 'l',
       litres: 'litre',
       liter: 'litre',
       liters: 'litre',
       teaspoons: 'teaspoon',
       tablespoons: 'tablespoon',
       minims: 'minim',
       fluiddrams: 'fluiddram',
       fluidounces: 'fluidounce',
       gills: 'gill',
       cups: 'cup',
       pints: 'pint',
       quarts: 'quart',
       gallons: 'gallon',
       beerbarrels: 'beerbarrel',
       oilbarrels: 'oilbarrel',
       hogsheads: 'hogshead',
       gtts: 'gtt',
       grams: 'gram',
       tons: 'ton',
       tonnes: 'tonne',
       grains: 'grain',
       drams: 'dram',
       ounces: 'ounce',
       poundmasses: 'poundmass',
       hundredweights: 'hundredweight',
       sticks: 'stick',
       lb: 'lbm',
       lbs: 'lbm',
       kips: 'kip',
       kgf: 'kilogramforce',
       acres: 'acre',
       hectares: 'hectare',
       sqfeet: 'sqft',
       sqyard: 'sqyd',
       sqmile: 'sqmi',
       sqmiles: 'sqmi',
       mmhg: 'mmHg',
       mmh2o: 'mmH2O',
       cmh2o: 'cmH2O',
       seconds: 'second',
       secs: 'second',
       minutes: 'minute',
       mins: 'minute',
       hours: 'hour',
       hr: 'hour',
       hrs: 'hour',
       days: 'day',
       weeks: 'week',
       months: 'month',
       years: 'year',
       decades: 'decade',
       centuries: 'century',
       millennia: 'millennium',
       hertz: 'hertz',
       radians: 'radian',
       degrees: 'degree',
       gradians: 'gradian',
       cycles: 'cycle',
       arcsecond: 'arcsec',
       arcseconds: 'arcsec',
       arcminute: 'arcmin',
       arcminutes: 'arcmin',
       BTUs: 'BTU',
       watts: 'watt',
       joules: 'joule',
       amperes: 'ampere',
       amps: 'ampere',
       amp: 'ampere',
       coulombs: 'coulomb',
       volts: 'volt',
       ohms: 'ohm',
       farads: 'farad',
       webers: 'weber',
       teslas: 'tesla',
       electronvolts: 'electronvolt',
       moles: 'mole',
       bit: 'bits',
       byte: 'bytes'
     };

     /**
      * Calculate the values for the angle units.
      * Value is calculated as number or BigNumber depending on the configuration
      * @param {{number: 'number' | 'BigNumber'}} config
      */
     function calculateAngleValues(config) {
       if (config.number === 'BigNumber') {
         var pi = createBigNumberPi(_BigNumber);
         UNITS.rad.value = new _BigNumber(1);
         UNITS.deg.value = pi.div(180); // 2 * pi / 360
         UNITS.grad.value = pi.div(200); // 2 * pi / 400
         UNITS.cycle.value = pi.times(2); // 2 * pi
         UNITS.arcsec.value = pi.div(648000); // 2 * pi / 360 / 3600
         UNITS.arcmin.value = pi.div(10800); // 2 * pi / 360 / 60
       } else {
         // number
         UNITS.rad.value = 1;
         UNITS.deg.value = Math.PI / 180; // 2 * pi / 360
         UNITS.grad.value = Math.PI / 200; // 2 * pi / 400
         UNITS.cycle.value = Math.PI * 2; // 2 * pi
         UNITS.arcsec.value = Math.PI / 648000; // 2 * pi / 360 / 3600
         UNITS.arcmin.value = Math.PI / 10800; // 2 * pi / 360 / 60
       }

       // copy to the full names of the angles
       UNITS.radian.value = UNITS.rad.value;
       UNITS.degree.value = UNITS.deg.value;
       UNITS.gradian.value = UNITS.grad.value;
     }

     // apply the angle values now
     calculateAngleValues(config);
     if (on) {
       // recalculate the values on change of configuration
       on('config', function (curr, prev) {
         if (curr.number !== prev.number) {
           calculateAngleValues(curr);
         }
       });
     }

     /**
      * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
      * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
      * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
      */
     var UNIT_SYSTEMS = {
       si: {
         // Base units
         NONE: {
           unit: UNIT_NONE,
           prefix: PREFIXES.NONE['']
         },
         LENGTH: {
           unit: UNITS.m,
           prefix: PREFIXES.SHORT['']
         },
         MASS: {
           unit: UNITS.g,
           prefix: PREFIXES.SHORT.k
         },
         TIME: {
           unit: UNITS.s,
           prefix: PREFIXES.SHORT['']
         },
         CURRENT: {
           unit: UNITS.A,
           prefix: PREFIXES.SHORT['']
         },
         TEMPERATURE: {
           unit: UNITS.K,
           prefix: PREFIXES.SHORT['']
         },
         LUMINOUS_INTENSITY: {
           unit: UNITS.cd,
           prefix: PREFIXES.SHORT['']
         },
         AMOUNT_OF_SUBSTANCE: {
           unit: UNITS.mol,
           prefix: PREFIXES.SHORT['']
         },
         ANGLE: {
           unit: UNITS.rad,
           prefix: PREFIXES.SHORT['']
         },
         BIT: {
           unit: UNITS.bits,
           prefix: PREFIXES.SHORT['']
         },
         // Derived units
         FORCE: {
           unit: UNITS.N,
           prefix: PREFIXES.SHORT['']
         },
         ENERGY: {
           unit: UNITS.J,
           prefix: PREFIXES.SHORT['']
         },
         POWER: {
           unit: UNITS.W,
           prefix: PREFIXES.SHORT['']
         },
         PRESSURE: {
           unit: UNITS.Pa,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_CHARGE: {
           unit: UNITS.C,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_CAPACITANCE: {
           unit: UNITS.F,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_POTENTIAL: {
           unit: UNITS.V,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_RESISTANCE: {
           unit: UNITS.ohm,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_INDUCTANCE: {
           unit: UNITS.H,
           prefix: PREFIXES.SHORT['']
         },
         ELECTRIC_CONDUCTANCE: {
           unit: UNITS.S,
           prefix: PREFIXES.SHORT['']
         },
         MAGNETIC_FLUX: {
           unit: UNITS.Wb,
           prefix: PREFIXES.SHORT['']
         },
         MAGNETIC_FLUX_DENSITY: {
           unit: UNITS.T,
           prefix: PREFIXES.SHORT['']
         },
         FREQUENCY: {
           unit: UNITS.Hz,
           prefix: PREFIXES.SHORT['']
         }
       }
     };

     // Clone to create the other unit systems
     UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
     UNIT_SYSTEMS.cgs.LENGTH = {
       unit: UNITS.m,
       prefix: PREFIXES.SHORT.c
     };
     UNIT_SYSTEMS.cgs.MASS = {
       unit: UNITS.g,
       prefix: PREFIXES.SHORT['']
     };
     UNIT_SYSTEMS.cgs.FORCE = {
       unit: UNITS.dyn,
       prefix: PREFIXES.SHORT['']
     };
     UNIT_SYSTEMS.cgs.ENERGY = {
       unit: UNITS.erg,
       prefix: PREFIXES.NONE['']
     };
     // there are wholly 4 unique cgs systems for electricity and magnetism,
     // so let's not worry about it unless somebody complains

     UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
     UNIT_SYSTEMS.us.LENGTH = {
       unit: UNITS.ft,
       prefix: PREFIXES.NONE['']
     };
     UNIT_SYSTEMS.us.MASS = {
       unit: UNITS.lbm,
       prefix: PREFIXES.NONE['']
     };
     UNIT_SYSTEMS.us.TEMPERATURE = {
       unit: UNITS.degF,
       prefix: PREFIXES.NONE['']
     };
     UNIT_SYSTEMS.us.FORCE = {
       unit: UNITS.lbf,
       prefix: PREFIXES.NONE['']
     };
     UNIT_SYSTEMS.us.ENERGY = {
       unit: UNITS.BTU,
       prefix: PREFIXES.BTU['']
     };
     UNIT_SYSTEMS.us.POWER = {
       unit: UNITS.hp,
       prefix: PREFIXES.NONE['']
     };
     UNIT_SYSTEMS.us.PRESSURE = {
       unit: UNITS.psi,
       prefix: PREFIXES.NONE['']
     };

     // Add additional unit systems here.

     // Choose a unit system to seed the auto unit system.
     UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));

     // Set the current unit system
     var currentUnitSystem = UNIT_SYSTEMS.auto;

     /**
      * Set a unit system for formatting derived units.
      * @param {string} [name] The name of the unit system.
      */
     Unit.setUnitSystem = function (name) {
       if (hasOwnProperty(UNIT_SYSTEMS, name)) {
         currentUnitSystem = UNIT_SYSTEMS[name];
       } else {
         throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
       }
     };

     /**
      * Return the current unit system.
      * @return {string} The current unit system.
      */
     Unit.getUnitSystem = function () {
       for (var _key in UNIT_SYSTEMS) {
         if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
           if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
             return _key;
           }
         }
       }
     };

     /**
      * Converters to convert from number to an other numeric type like BigNumber
      * or Fraction
      */
     Unit.typeConverters = {
       BigNumber: function BigNumber(x) {
         if (x !== null && x !== void 0 && x.isFraction) return new _BigNumber(x.n).div(x.d).times(x.s);
         return new _BigNumber(x + ''); // stringify to prevent constructor error
       },

       Fraction: function Fraction(x) {
         return new _Fraction(x);
       },
       Complex: function Complex(x) {
         return x;
       },
       number: function number(x) {
         if (x !== null && x !== void 0 && x.isFraction) return _number(x);
         return x;
       }
     };

     /**
      * Retrieve the right converter function corresponding with this unit's
      * value
      *
      * @memberof Unit
      * @return {Function}
      */
     Unit.prototype._numberConverter = function () {
       var convert = Unit.typeConverters[this.valueType()];
       if (convert) {
         return convert;
       }
       throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
     };

     /**
      * Retrieve the right convertor function corresponding with the type
      * of provided exampleValue.
      *
      * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
      *                        In case of an unknown type,
      * @return {Function}
      */
     Unit._getNumberConverter = function (type) {
       if (!Unit.typeConverters[type]) {
         throw new TypeError('Unsupported type "' + type + '"');
       }
       return Unit.typeConverters[type];
     };

     // Add dimensions to each built-in unit
     for (var _key2 in UNITS) {
       if (hasOwnProperty(UNITS, _key2)) {
         var unit = UNITS[_key2];
         unit.dimensions = unit.base.dimensions;
       }
     }

     // Create aliases
     for (var _name2 in ALIASES) {
       if (hasOwnProperty(ALIASES, _name2)) {
         var _unit2 = UNITS[ALIASES[_name2]];
         var alias = {};
         for (var _key3 in _unit2) {
           if (hasOwnProperty(_unit2, _key3)) {
             alias[_key3] = _unit2[_key3];
           }
         }
         alias.name = _name2;
         UNITS[_name2] = alias;
       }
     }

     /**
      * Checks if a character is a valid latin letter (upper or lower case).
      * Note that this function can be overridden, for example to allow support of other alphabets.
      * @param {string} c Tested character
      */
     Unit.isValidAlpha = function isValidAlpha(c) {
       return /^[a-zA-Z]$/.test(c);
     };
     function assertUnitNameIsValid(name) {
       for (var i = 0; i < name.length; i++) {
         c = name.charAt(i);
         if (i === 0 && !Unit.isValidAlpha(c)) {
           throw new Error('Invalid unit name (must begin with alpha character): "' + name + '"');
         }
         if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
           throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name + '"');
         }
       }
     }

     /**
      * Wrapper around createUnitSingle.
      * Example:
      *  createUnit({
      *    foo: { },
      *    bar: {
      *      definition: 'kg/foo',
      *      aliases: ['ba', 'barr', 'bars'],
      *      offset: 200
      *    },
      *    baz: '4 bar'
      *  },
      *  {
      *    override: true
      *  })
      * @param {object} obj      Object map. Each key becomes a unit which is defined by its value.
      * @param {object} options
      */
     Unit.createUnit = function (obj, options) {
       if (typeof obj !== 'object') {
         throw new TypeError("createUnit expects first parameter to be of type 'Object'");
       }

       // Remove all units and aliases we are overriding
       if (options && options.override) {
         for (var _key4 in obj) {
           if (hasOwnProperty(obj, _key4)) {
             Unit.deleteUnit(_key4);
           }
           if (obj[_key4].aliases) {
             for (var i = 0; i < obj[_key4].aliases.length; i++) {
               Unit.deleteUnit(obj[_key4].aliases[i]);
             }
           }
         }
       }

       // TODO: traverse multiple times until all units have been added
       var lastUnit;
       for (var _key5 in obj) {
         if (hasOwnProperty(obj, _key5)) {
           lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
         }
       }
       return lastUnit;
     };

     /**
      * Create a user-defined unit and register it with the Unit type.
      * Example:
      *  createUnitSingle('knot', '0.514444444 m/s')
      *  createUnitSingle('acre', new Unit(43560, 'ft^2'))
      *
      * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
      * @param {string, Unit, Object} definition      Definition of the unit in terms
      * of existing units. For example, '0.514444444 m / s'. Can be a Unit, a string,
      * or an Object. If an Object, may have the following properties:
      *   - definition {string|Unit} The definition of this unit.
      *   - prefixes {string} "none", "short", "long", "binary_short", or "binary_long".
      *     The default is "none".
      *   - aliases {Array} Array of strings. Example: ['knots', 'kt', 'kts']
      *   - offset {Numeric} An offset to apply when converting from the unit. For
      *     example, the offset for celsius is 273.15 and the offset for farhenheit
      *     is 459.67. Default is 0.
      *   - baseName {string} If the unit's dimension does not match that of any other
      *     base unit, the name of the newly create base unit. Otherwise, this property
      *     has no effect.
      *
      * @return {Unit}
      */
     Unit.createUnitSingle = function (name, obj) {
       if (typeof obj === 'undefined' || obj === null) {
         obj = {};
       }
       if (typeof name !== 'string') {
         throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
       }

       // Check collisions with existing units
       if (hasOwnProperty(UNITS, name)) {
         throw new Error('Cannot create unit "' + name + '": a unit with that name already exists');
       }

       // TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.

       assertUnitNameIsValid(name);
       var defUnit = null; // The Unit from which the new unit will be created.
       var aliases = [];
       var offset = 0;
       var definition;
       var prefixes;
       var baseName;
       if (obj && obj.type === 'Unit') {
         defUnit = obj.clone();
       } else if (typeof obj === 'string') {
         if (obj !== '') {
           definition = obj;
         }
       } else if (typeof obj === 'object') {
         definition = obj.definition;
         prefixes = obj.prefixes;
         offset = obj.offset;
         baseName = obj.baseName;
         if (obj.aliases) {
           aliases = obj.aliases.valueOf(); // aliases could be a Matrix, so convert to Array
         }
       } else {
         throw new TypeError('Cannot create unit "' + name + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
       }
       if (aliases) {
         for (var i = 0; i < aliases.length; i++) {
           if (hasOwnProperty(UNITS, aliases[i])) {
             throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
           }
         }
       }
       if (definition && typeof definition === 'string' && !defUnit) {
         try {
           defUnit = Unit.parse(definition, {
             allowNoUnits: true
           });
         } catch (ex) {
           ex.message = 'Could not create unit "' + name + '" from "' + definition + '": ' + ex.message;
           throw ex;
         }
       } else if (definition && definition.type === 'Unit') {
         defUnit = definition.clone();
       }
       aliases = aliases || [];
       offset = offset || 0;
       if (prefixes && prefixes.toUpperCase) {
         prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
       } else {
         prefixes = PREFIXES.NONE;
       }

       // If defUnit is null, it is because the user did not
       // specify a defintion. So create a new base dimension.
       var newUnit = {};
       if (!defUnit) {
         // Add a new base dimension
         baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo
         if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
           throw new Error('Cannot create new base unit "' + name + '": a base unit with that name already exists (and cannot be overridden)');
         }
         BASE_DIMENSIONS.push(baseName);

         // Push 0 onto existing base units
         for (var b in BASE_UNITS) {
           if (hasOwnProperty(BASE_UNITS, b)) {
             BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
           }
         }

         // Add the new base unit
         var newBaseUnit = {
           dimensions: []
         };
         for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
           newBaseUnit.dimensions[_i6] = 0;
         }
         newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
         newBaseUnit.key = baseName;
         BASE_UNITS[baseName] = newBaseUnit;
         newUnit = {
           name,
           value: 1,
           dimensions: BASE_UNITS[baseName].dimensions.slice(0),
           prefixes,
           offset,
           base: BASE_UNITS[baseName]
         };
         currentUnitSystem[baseName] = {
           unit: newUnit,
           prefix: PREFIXES.NONE['']
         };
       } else {
         newUnit = {
           name,
           value: defUnit.value,
           dimensions: defUnit.dimensions.slice(0),
           prefixes,
           offset
         };

         // Create a new base if no matching base exists
         var anyMatch = false;
         for (var _i7 in BASE_UNITS) {
           if (hasOwnProperty(BASE_UNITS, _i7)) {
             var match = true;
             for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
               if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                 match = false;
                 break;
               }
             }
             if (match) {
               anyMatch = true;
               newUnit.base = BASE_UNITS[_i7];
               break;
             }
           }
         }
         if (!anyMatch) {
           baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo
           // Add the new base unit
           var _newBaseUnit = {
             dimensions: defUnit.dimensions.slice(0)
           };
           _newBaseUnit.key = baseName;
           BASE_UNITS[baseName] = _newBaseUnit;
           currentUnitSystem[baseName] = {
             unit: newUnit,
             prefix: PREFIXES.NONE['']
           };
           newUnit.base = BASE_UNITS[baseName];
         }
       }
       Unit.UNITS[name] = newUnit;
       for (var _i8 = 0; _i8 < aliases.length; _i8++) {
         var aliasName = aliases[_i8];
         var _alias = {};
         for (var _key6 in newUnit) {
           if (hasOwnProperty(newUnit, _key6)) {
             _alias[_key6] = newUnit[_key6];
           }
         }
         _alias.name = aliasName;
         Unit.UNITS[aliasName] = _alias;
       }
       // delete the memoization cache, since adding a new unit to the array
       // invalidates all old results
       delete _findUnit.cache;
       return new Unit(null, name);
     };
     Unit.deleteUnit = function (name) {
       delete Unit.UNITS[name];
     };

     // expose arrays with prefixes, dimensions, units, systems
     Unit.PREFIXES = PREFIXES;
     Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
     Unit.BASE_UNITS = BASE_UNITS;
     Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
     Unit.UNITS = UNITS;
     return Unit;
   }, {
     isClass: true
   });

   var name$2i = 'unit';
   var dependencies$2i = ['typed', 'Unit'];

   // This function is named createUnitFunction to prevent a naming conflict with createUnit
   var createUnitFunction = /* #__PURE__ */factory(name$2i, dependencies$2i, _ref => {
     var {
       typed,
       Unit
     } = _ref;
     /**
      * Create a unit. Depending on the passed arguments, the function
      * will create and return a new math.Unit object.
      * When a matrix is provided, all elements will be converted to units.
      *
      * Syntax:
      *
      *     math.unit(unit : string)
      *     math.unit(value : number, valuelessUnit : Unit)
      *     math.unit(value : number, valuelessUnit : string)
      *
      * Examples:
      *
      *    const kph = math.unit('km/h')   // returns Unit km/h (valueless)
      *    const v = math.unit(25, kph)    // returns Unit 25 km/h
      *    const a = math.unit(5, 'cm')    // returns Unit 50 mm
      *    const b = math.unit('23 kg')    // returns Unit 23 kg
      *    a.to('m')                       // returns Unit 0.05 m
      *
      * See also:
      *
      *    bignumber, boolean, complex, index, matrix, number, string, createUnit
      *
      * @param {* | Array | Matrix} args   A number and unit.
      * @return {Unit | Array | Matrix}    The created unit
      */

     return typed(name$2i, {
       Unit: function Unit(x) {
         return x.clone();
       },
       string: function string(x) {
         if (Unit.isValuelessUnit(x)) {
           return new Unit(null, x); // a pure unit
         }

         return Unit.parse(x, {
           allowNoUnits: true
         }); // a unit with value, like '5cm'
       },

       'number | BigNumber | Fraction | Complex, string | Unit': function numberBigNumberFractionComplexStringUnit(value, unit) {
         return new Unit(value, unit);
       },
       'number | BigNumber | Fraction': function numberBigNumberFraction(value) {
         // dimensionless
         return new Unit(value);
       },
       'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))
     });
   });

   var name$2h = 'sparse';
   var dependencies$2h = ['typed', 'SparseMatrix'];
   var createSparse = /* #__PURE__ */factory(name$2h, dependencies$2h, _ref => {
     var {
       typed,
       SparseMatrix
     } = _ref;
     /**
      * Create a Sparse Matrix. The function creates a new `math.Matrix` object from
      * an `Array`. A Matrix has utility functions to manipulate the data in the
      * matrix, like getting the size and getting or setting values in the matrix.
      * Note that a Sparse Matrix is always 2-dimensional, so for example if
      * you create one from a plain array of _n_ numbers, you get an _n_ by 1
      * Sparse "column vector".
      *
      * Syntax:
      *
      *    math.sparse()               // creates an empty sparse matrix.
      *    math.sparse(data)           // creates a sparse matrix with initial data.
      *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.
      *
      * Examples:
      *
      *    let m = math.sparse([[1, 2], [3, 4]])
      *    m.size()                        // Array [2, 2]
      *    m.resize([3, 2], 5)
      *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
      *    m.get([1, 0])                    // number 3
      *    let v = math.sparse([0, 0, 1])
      *    v.size()                        // Array [3, 1]
      *    v.get([2, 0])                   // number 1
      *
      * See also:
      *
      *    bignumber, boolean, complex, index, number, string, unit, matrix
      *
      * @param {Array | Matrix} [data]    A two dimensional array
      *
      * @return {Matrix} The created matrix
      */
     return typed(name$2h, {
       '': function _() {
         return new SparseMatrix([]);
       },
       string: function string(datatype) {
         return new SparseMatrix([], datatype);
       },
       'Array | Matrix': function ArrayMatrix(data) {
         return new SparseMatrix(data);
       },
       'Array | Matrix, string': function ArrayMatrixString(data, datatype) {
         return new SparseMatrix(data, datatype);
       }
     });
   });

   var name$2g = 'createUnit';
   var dependencies$2g = ['typed', 'Unit'];
   var createCreateUnit = /* #__PURE__ */factory(name$2g, dependencies$2g, _ref => {
     var {
       typed,
       Unit
     } = _ref;
     /**
      * Create a user-defined unit and register it with the Unit type.
      *
      * Syntax:
      *
      *     math.createUnit({
      *       baseUnit1: {
      *         aliases: [string, ...]
      *         prefixes: object
      *       },
      *       unit2: {
      *         definition: string,
      *         aliases: [string, ...]
      *         prefixes: object,
      *         offset: number
      *       },
      *       unit3: string    // Shortcut
      *     })
      *
      *     // Another shortcut:
      *     math.createUnit(string, unit : string, [object])
      *
      * Examples:
      *
      *     math.createUnit('foo')
      *     math.createUnit('knot', {definition: '0.514444444 m/s', aliases: ['knots', 'kt', 'kts']})
      *     math.createUnit('mph', '1 mile/hour')
      *     math.createUnit('km', math.unit(1000, 'm'))
      *
      * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
      * @param {string, UnitDefinition, Unit} definition      Definition of the unit in terms of existing units. For example, '0.514444444 m / s'.
      * @param {Object} options   (optional) An object containing any of the following properties:
      *     - `prefixes {string}` "none", "short", "long", "binary_short", or "binary_long". The default is "none".
      *     - `aliases {Array}` Array of strings. Example: ['knots', 'kt', 'kts']
      *     - `offset {Numeric}` An offset to apply when converting from the unit. For example, the offset for celsius is 273.15. Default is 0.
      *
      * See also:
      *
      *     unit
      *
      * @return {Unit} The new unit
      */
     return typed(name$2g, {
       // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
       'Object, Object': function ObjectObject(obj, options) {
         return Unit.createUnit(obj, options);
       },
       // Same as above but without the options.
       Object: function Object(obj) {
         return Unit.createUnit(obj, {});
       },
       // Shortcut method for creating one unit.
       'string, Unit | string | Object, Object': function stringUnitStringObjectObject(name, def, options) {
         var obj = {};
         obj[name] = def;
         return Unit.createUnit(obj, options);
       },
       // Same as above but without the options.
       'string, Unit | string | Object': function stringUnitStringObject(name, def) {
         var obj = {};
         obj[name] = def;
         return Unit.createUnit(obj, {});
       },
       // Without a definition, creates a base unit.
       string: function string(name) {
         var obj = {};
         obj[name] = {};
         return Unit.createUnit(obj, {});
       }
     });
   });

   var name$2f = 'acos';
   var dependencies$2f = ['typed', 'config', 'Complex'];
   var createAcos = /* #__PURE__ */factory(name$2f, dependencies$2f, _ref => {
     var {
       typed,
       config,
       Complex
     } = _ref;
     /**
      * Calculate the inverse cosine of a value.
      *
      * To avoid confusion with the matrix arccosine, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.acos(x)
      *
      * Examples:
      *
      *    math.acos(0.5)           // returns number 1.0471975511965979
      *    math.acos(math.cos(1.5)) // returns number 1.5
      *
      *    math.acos(2)             // returns Complex 0 + 1.3169578969248166 i
      *
      * See also:
      *
      *    cos, atan, asin
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} The arc cosine of x
      */
     return typed(name$2f, {
       number: function number(x) {
         if (x >= -1 && x <= 1 || config.predictable) {
           return Math.acos(x);
         } else {
           return new Complex(x, 0).acos();
         }
       },
       Complex: function Complex(x) {
         return x.acos();
       },
       BigNumber: function BigNumber(x) {
         return x.acos();
       }
     });
   });

   var name$2e = 'acosh';
   var dependencies$2e = ['typed', 'config', 'Complex'];
   var createAcosh = /* #__PURE__ */factory(name$2e, dependencies$2e, _ref => {
     var {
       typed,
       config,
       Complex
     } = _ref;
     /**
      * Calculate the hyperbolic arccos of a value,
      * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.acosh(x)
      *
      * Examples:
      *
      *    math.acosh(1.5)       // returns 0.9624236501192069
      *
      * See also:
      *
      *    cosh, asinh, atanh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arccosine of x
      */
     return typed(name$2e, {
       number: function number(x) {
         if (x >= 1 || config.predictable) {
           return acoshNumber(x);
         }
         if (x <= -1) {
           return new Complex(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
         }
         return new Complex(x, 0).acosh();
       },
       Complex: function Complex(x) {
         return x.acosh();
       },
       BigNumber: function BigNumber(x) {
         return x.acosh();
       }
     });
   });

   var name$2d = 'acot';
   var dependencies$2d = ['typed', 'BigNumber'];
   var createAcot = /* #__PURE__ */factory(name$2d, dependencies$2d, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
      *
      * To avoid confusion with the matrix arccotanget, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.acot(x)
      *
      * Examples:
      *
      *    math.acot(0.5)           // returns number 1.1071487177940904
      *    math.acot(2)             // returns number 0.4636476090008061
      *    math.acot(math.cot(1.5)) // returns number 1.5
      *
      * See also:
      *
      *    cot, atan
      *
      * @param {number | BigNumber| Complex} x   Function input
      * @return {number | BigNumber| Complex} The arc cotangent of x
      */
     return typed(name$2d, {
       number: acotNumber,
       Complex: function Complex(x) {
         return x.acot();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).atan();
       }
     });
   });

   var name$2c = 'acoth';
   var dependencies$2c = ['typed', 'config', 'Complex', 'BigNumber'];
   var createAcoth = /* #__PURE__ */factory(name$2c, dependencies$2c, _ref => {
     var {
       typed,
       config,
       Complex,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic arccotangent of a value,
      * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
      *
      * To avoid confusion with the matrix hyperbolic arccotangent, this
      * function does not apply to matrices.
      *
      * Syntax:
      *
      *    math.acoth(x)
      *
      * Examples:
      *
      *    math.acoth(0.5)       // returns 0.8047189562170503
      *
      * See also:
      *
      *    acsch, asech
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arccotangent of x
      */
     return typed(name$2c, {
       number: function number(x) {
         if (x >= 1 || x <= -1 || config.predictable) {
           return acothNumber(x);
         }
         return new Complex(x, 0).acoth();
       },
       Complex: function Complex(x) {
         return x.acoth();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).atanh();
       }
     });
   });

   var name$2b = 'acsc';
   var dependencies$2b = ['typed', 'config', 'Complex', 'BigNumber'];
   var createAcsc = /* #__PURE__ */factory(name$2b, dependencies$2b, _ref => {
     var {
       typed,
       config,
       Complex,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
      *
      * To avoid confusion with the matrix arccosecant, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.acsc(x)
      *
      * Examples:
      *
      *    math.acsc(2)             // returns 0.5235987755982989
      *    math.acsc(0.5)           // returns Complex 1.5707963267948966 -1.3169578969248166i
      *    math.acsc(math.csc(1.5)) // returns number ~1.5
      *
      * See also:
      *
      *    csc, asin, asec
      *
      * @param {number | BigNumber | Complex} x   Function input
      * @return {number | BigNumber | Complex} The arc cosecant of x
      */
     return typed(name$2b, {
       number: function number(x) {
         if (x <= -1 || x >= 1 || config.predictable) {
           return acscNumber(x);
         }
         return new Complex(x, 0).acsc();
       },
       Complex: function Complex(x) {
         return x.acsc();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).asin();
       }
     });
   });

   var name$2a = 'acsch';
   var dependencies$2a = ['typed', 'BigNumber'];
   var createAcsch = /* #__PURE__ */factory(name$2a, dependencies$2a, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic arccosecant of a value,
      * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
      *
      * To avoid confusion with the matrix hyperbolic arccosecant, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.acsch(x)
      *
      * Examples:
      *
      *    math.acsch(0.5)       // returns 1.4436354751788103
      *
      * See also:
      *
      *    asech, acoth
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arccosecant of x
      */
     return typed(name$2a, {
       number: acschNumber,
       Complex: function Complex(x) {
         return x.acsch();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).asinh();
       }
     });
   });

   var name$29 = 'asec';
   var dependencies$29 = ['typed', 'config', 'Complex', 'BigNumber'];
   var createAsec = /* #__PURE__ */factory(name$29, dependencies$29, _ref => {
     var {
       typed,
       config,
       Complex,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
      *
      * To avoid confusion with the matrix arcsecant, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.asec(x)
      *
      * Examples:
      *
      *    math.asec(2)             // returns 1.0471975511965979
      *    math.asec(math.sec(1.5)) // returns 1.5
      *
      *    math.asec(0.5)           // returns Complex 0 + 1.3169578969248166i
      *
      * See also:
      *
      *    acos, acot, acsc
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} The arc secant of x
      */
     return typed(name$29, {
       number: function number(x) {
         if (x <= -1 || x >= 1 || config.predictable) {
           return asecNumber(x);
         }
         return new Complex(x, 0).asec();
       },
       Complex: function Complex(x) {
         return x.asec();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).acos();
       }
     });
   });

   var name$28 = 'asech';
   var dependencies$28 = ['typed', 'config', 'Complex', 'BigNumber'];
   var createAsech = /* #__PURE__ */factory(name$28, dependencies$28, _ref => {
     var {
       typed,
       config,
       Complex,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic arcsecant of a value,
      * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
      *
      * To avoid confusion with the matrix hyperbolic arcsecant, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.asech(x)
      *
      * Examples:
      *
      *    math.asech(0.5)       // returns 1.3169578969248166
      *
      * See also:
      *
      *    acsch, acoth
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arcsecant of x
      */
     return typed(name$28, {
       number: function number(x) {
         if (x <= 1 && x >= -1 || config.predictable) {
           var xInv = 1 / x;
           if (xInv > 0 || config.predictable) {
             return asechNumber(x);
           }
           var ret = Math.sqrt(xInv * xInv - 1);
           return new Complex(Math.log(ret - xInv), Math.PI);
         }
         return new Complex(x, 0).asech();
       },
       Complex: function Complex(x) {
         return x.asech();
       },
       BigNumber: function BigNumber(x) {
         return new _BigNumber(1).div(x).acosh();
       }
     });
   });

   var name$27 = 'asin';
   var dependencies$27 = ['typed', 'config', 'Complex'];
   var createAsin = /* #__PURE__ */factory(name$27, dependencies$27, _ref => {
     var {
       typed,
       config,
       Complex
     } = _ref;
     /**
      * Calculate the inverse sine of a value.
      *
      * To avoid confusion with the matric arcsine, this function does not apply
      * to matrices.
      *
      * Syntax:
      *
      *    math.asin(x)
      *
      * Examples:
      *
      *    math.asin(0.5)           // returns number 0.5235987755982989
      *    math.asin(math.sin(1.5)) // returns number ~1.5
      *
      *    math.asin(2)             // returns Complex 1.5707963267948966 -1.3169578969248166i
      *
      * See also:
      *
      *    sin, atan, acos
      *
      * @param {number | BigNumber | Complex} x   Function input
      * @return {number | BigNumber | Complex} The arc sine of x
      */
     return typed(name$27, {
       number: function number(x) {
         if (x >= -1 && x <= 1 || config.predictable) {
           return Math.asin(x);
         } else {
           return new Complex(x, 0).asin();
         }
       },
       Complex: function Complex(x) {
         return x.asin();
       },
       BigNumber: function BigNumber(x) {
         return x.asin();
       }
     });
   });

   var name$26 = 'asinh';
   var dependencies$26 = ['typed'];
   var createAsinh = /* #__PURE__ */factory(name$26, dependencies$26, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the hyperbolic arcsine of a value,
      * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
      *
      * To avoid confusion with the matrix hyperbolic arcsine, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.asinh(x)
      *
      * Examples:
      *
      *    math.asinh(0.5)       // returns 0.48121182505960347
      *
      * See also:
      *
      *    acosh, atanh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arcsine of x
      */
     return typed('asinh', {
       number: asinhNumber,
       Complex: function Complex(x) {
         return x.asinh();
       },
       BigNumber: function BigNumber(x) {
         return x.asinh();
       }
     });
   });

   var name$25 = 'atan';
   var dependencies$25 = ['typed'];
   var createAtan = /* #__PURE__ */factory(name$25, dependencies$25, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the inverse tangent of a value.
      *
      * To avoid confusion with matrix arctangent, this function does not apply
      * to matrices.
      *
      * Syntax:
      *
      *    math.atan(x)
      *
      * Examples:
      *
      *    math.atan(0.5)           // returns number 0.4636476090008061
      *    math.atan(2)             // returns number 1.1071487177940904
      *    math.atan(math.tan(1.5)) // returns number 1.5
      *
      * See also:
      *
      *    tan, asin, acos
      *
      * @param {number | BigNumber | Complex} x   Function input
      * @return {number | BigNumber | Complex} The arc tangent of x
      */
     return typed('atan', {
       number: function number(x) {
         return Math.atan(x);
       },
       Complex: function Complex(x) {
         return x.atan();
       },
       BigNumber: function BigNumber(x) {
         return x.atan();
       }
     });
   });

   var name$24 = 'atan2';
   var dependencies$24 = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'DenseMatrix', 'concat'];
   var createAtan2 = /* #__PURE__ */factory(name$24, dependencies$24, _ref => {
     var {
       typed,
       matrix,
       equalScalar,
       BigNumber,
       DenseMatrix,
       concat
     } = _ref;
     var matAlgo02xDS0 = createMatAlgo02xDS0({
       typed,
       equalScalar
     });
     var matAlgo03xDSf = createMatAlgo03xDSf({
       typed
     });
     var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
       typed,
       equalScalar
     });
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo12xSfs = createMatAlgo12xSfs({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });

     /**
      * Calculate the inverse tangent function with two arguments, y/x.
      * By providing two arguments, the right quadrant of the computed angle can be
      * determined.
      *
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.atan2(y, x)
      *
      * Examples:
      *
      *    math.atan2(2, 2) / math.pi       // returns number 0.25
      *
      *    const angle = math.unit(60, 'deg') // returns Unit 60 deg
      *    const x = math.cos(angle)
      *    const y = math.sin(angle)
      *
      *    math.atan(2)             // returns number 1.1071487177940904
      *
      * See also:
      *
      *    tan, atan, sin, cos
      *
      * @param {number | Array | Matrix} y  Second dimension
      * @param {number | Array | Matrix} x  First dimension
      * @return {number | Array | Matrix} Four-quadrant inverse tangent
      */
     return typed(name$24, {
       'number, number': Math.atan2,
       // Complex numbers doesn't seem to have a reasonable implementation of
       // atan2(). Even Matlab removed the support, after they only calculated
       // the atan only on base of the real part of the numbers and ignored
       // the imaginary.

       'BigNumber, BigNumber': (y, x) => BigNumber.atan2(y, x)
     }, matrixAlgorithmSuite({
       scalar: 'number | BigNumber',
       SS: matAlgo09xS0Sf,
       DS: matAlgo03xDSf,
       SD: matAlgo02xDS0,
       Ss: matAlgo11xS0s,
       sS: matAlgo12xSfs
     }));
   });

   var name$23 = 'atanh';
   var dependencies$23 = ['typed', 'config', 'Complex'];
   var createAtanh = /* #__PURE__ */factory(name$23, dependencies$23, _ref => {
     var {
       typed,
       config,
       Complex
     } = _ref;
     /**
      * Calculate the hyperbolic arctangent of a value,
      * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
      *
      * To avoid confusion with the matrix hyperbolic arctangent, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.atanh(x)
      *
      * Examples:
      *
      *    math.atanh(0.5)       // returns 0.5493061443340549
      *
      * See also:
      *
      *    acosh, asinh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic arctangent of x
      */
     return typed(name$23, {
       number: function number(x) {
         if (x <= 1 && x >= -1 || config.predictable) {
           return atanhNumber(x);
         }
         return new Complex(x, 0).atanh();
       },
       Complex: function Complex(x) {
         return x.atanh();
       },
       BigNumber: function BigNumber(x) {
         return x.atanh();
       }
     });
   });

   var createTrigUnit = /* #__PURE__ */factory('trigUnit', ['typed'], _ref => {
     var {
       typed
     } = _ref;
     return {
       Unit: typed.referToSelf(self => x => {
         if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
           throw new TypeError('Unit in function cot is no angle');
         }
         return typed.find(self, x.valueType())(x.value);
       })
     };
   });

   var name$22 = 'cos';
   var dependencies$22 = ['typed'];
   var createCos = /* #__PURE__ */factory(name$22, dependencies$22, _ref => {
     var {
       typed
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the cosine of a value.
      *
      * To avoid confusion with the matrix cosine, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.cos(x)
      *
      * Examples:
      *
      *    math.cos(2)                      // returns number -0.4161468365471422
      *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
      *    math.cos(math.unit(180, 'deg'))  // returns number -1
      *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
      *
      *    const angle = 0.2
      *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
      *
      * See also:
      *
      *    cos, tan
      *
      * @param {number | BigNumber | Complex | Unit} x  Function input
      * @return {number | BigNumber | Complex} Cosine of x
      */
     return typed(name$22, {
       number: Math.cos,
       'Complex | BigNumber': x => x.cos()
     }, trigUnit);
   });

   var name$21 = 'cosh';
   var dependencies$21 = ['typed'];
   var createCosh = /* #__PURE__ */factory(name$21, dependencies$21, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the hyperbolic cosine of a value,
      * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
      *
      * To avoid confusion with the matrix hyperbolic cosine, this function does
      * not apply to matrices.
      *
      * Syntax:
      *
      *    math.cosh(x)
      *
      * Examples:
      *
      *    math.cosh(0.5)       // returns number 1.1276259652063807
      *
      * See also:
      *
      *    sinh, tanh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic cosine of x
      */
     return typed(name$21, {
       number: cosh$2,
       'Complex | BigNumber': x => x.cosh()
     });
   });

   var name$20 = 'cot';
   var dependencies$20 = ['typed', 'BigNumber'];
   var createCot = /* #__PURE__ */factory(name$20, dependencies$20, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
      *
      * To avoid confusion with the matrix cotangent, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.cot(x)
      *
      * Examples:
      *
      *    math.cot(2)      // returns number -0.45765755436028577
      *    1 / math.tan(2)  // returns number -0.45765755436028577
      *
      * See also:
      *
      *    tan, sec, csc
      *
      * @param {number | Complex | Unit | Array | Matrix} x  Function input
      * @return {number | Complex | Array | Matrix} Cotangent of x
      */
     return typed(name$20, {
       number: cotNumber,
       Complex: x => x.cot(),
       BigNumber: x => new _BigNumber(1).div(x.tan())
     }, trigUnit);
   });

   var name$1$ = 'coth';
   var dependencies$1$ = ['typed', 'BigNumber'];
   var createCoth = /* #__PURE__ */factory(name$1$, dependencies$1$, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic cotangent of a value,
      * defined as `coth(x) = 1 / tanh(x)`.
      *
      * To avoid confusion with the matrix hyperbolic cotangent, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.coth(x)
      *
      * Examples:
      *
      *    // coth(x) = 1 / tanh(x)
      *    math.coth(2)         // returns 1.0373147207275482
      *    1 / math.tanh(2)     // returns 1.0373147207275482
      *
      * See also:
      *
      *    sinh, tanh, cosh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic cotangent of x
      */
     return typed(name$1$, {
       number: cothNumber,
       Complex: x => x.coth(),
       BigNumber: x => new _BigNumber(1).div(x.tanh())
     });
   });

   var name$1_ = 'csc';
   var dependencies$1_ = ['typed', 'BigNumber'];
   var createCsc = /* #__PURE__ */factory(name$1_, dependencies$1_, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
      *
      * To avoid confusion with the matrix cosecant, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.csc(x)
      *
      * Examples:
      *
      *    math.csc(2)      // returns number 1.099750170294617
      *    1 / math.sin(2)  // returns number 1.099750170294617
      *
      * See also:
      *
      *    sin, sec, cot
      *
      * @param {number | BigNumber | Complex | Unit} x  Function input
      * @return {number | BigNumber | Complex} Cosecant of x
      */
     return typed(name$1_, {
       number: cscNumber,
       Complex: x => x.csc(),
       BigNumber: x => new _BigNumber(1).div(x.sin())
     }, trigUnit);
   });

   var name$1Z = 'csch';
   var dependencies$1Z = ['typed', 'BigNumber'];
   var createCsch = /* #__PURE__ */factory(name$1Z, dependencies$1Z, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic cosecant of a value,
      * defined as `csch(x) = 1 / sinh(x)`.
      *
      * To avoid confusion with the matrix hyperbolic cosecant, this function
      * does not apply to matrices.
      *
      * Syntax:
      *
      *    math.csch(x)
      *
      * Examples:
      *
      *    // csch(x) = 1/ sinh(x)
      *    math.csch(0.5)       // returns 1.9190347513349437
      *    1 / math.sinh(0.5)   // returns 1.9190347513349437
      *
      * See also:
      *
      *    sinh, sech, coth
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic cosecant of x
      */
     return typed(name$1Z, {
       number: cschNumber,
       Complex: x => x.csch(),
       BigNumber: x => new _BigNumber(1).div(x.sinh())
     });
   });

   var name$1Y = 'sec';
   var dependencies$1Y = ['typed', 'BigNumber'];
   var createSec = /* #__PURE__ */factory(name$1Y, dependencies$1Y, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
      *
      * To avoid confusion with the matrix secant, this function does not
      * apply to matrices.
      *
      * Syntax:
      *
      *    math.sec(x)
      *
      * Examples:
      *
      *    math.sec(2)      // returns number -2.4029979617223822
      *    1 / math.cos(2)  // returns number -2.4029979617223822
      *
      * See also:
      *
      *    cos, csc, cot
      *
      * @param {number | BigNumber | Complex | Unit} x  Function input
      * @return {number | BigNumber | Complex} Secant of x
      */
     return typed(name$1Y, {
       number: secNumber,
       Complex: x => x.sec(),
       BigNumber: x => new _BigNumber(1).div(x.cos())
     }, trigUnit);
   });

   var name$1X = 'sech';
   var dependencies$1X = ['typed', 'BigNumber'];
   var createSech = /* #__PURE__ */factory(name$1X, dependencies$1X, _ref => {
     var {
       typed,
       BigNumber: _BigNumber
     } = _ref;
     /**
      * Calculate the hyperbolic secant of a value,
      * defined as `sech(x) = 1 / cosh(x)`.
      *
      * To avoid confusion with the matrix hyperbolic secant, this function does
      * not apply to matrices.
      *
      * Syntax:
      *
      *    math.sech(x)
      *
      * Examples:
      *
      *    // sech(x) = 1/ cosh(x)
      *    math.sech(0.5)       // returns 0.886818883970074
      *    1 / math.cosh(0.5)   // returns 0.886818883970074
      *
      * See also:
      *
      *    cosh, csch, coth
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic secant of x
      */
     return typed(name$1X, {
       number: sechNumber,
       Complex: x => x.sech(),
       BigNumber: x => new _BigNumber(1).div(x.cosh())
     });
   });

   var name$1W = 'sin';
   var dependencies$1W = ['typed'];
   var createSin = /* #__PURE__ */factory(name$1W, dependencies$1W, _ref => {
     var {
       typed
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the sine of a value.
      *
      * To avoid confusion with the matrix sine, this function does not apply
      * to matrices.
      *
      * Syntax:
      *
      *    math.sin(x)
      *
      * Examples:
      *
      *    math.sin(2)                      // returns number 0.9092974268256813
      *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
      *    math.sin(math.unit(90, 'deg'))   // returns number 1
      *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
      *
      *    const angle = 0.2
      *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
      *
      * See also:
      *
      *    cos, tan
      *
      * @param {number | BigNumber | Complex | Unit} x  Function input
      * @return {number | BigNumber | Complex} Sine of x
      */
     return typed(name$1W, {
       number: Math.sin,
       'Complex | BigNumber': x => x.sin()
     }, trigUnit);
   });

   var name$1V = 'sinh';
   var dependencies$1V = ['typed'];
   var createSinh = /* #__PURE__ */factory(name$1V, dependencies$1V, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the hyperbolic sine of a value,
      * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
      *
      * To avoid confusion with the matrix hyperbolic sine, this function does
      * not apply to matrices.
      *
      * Syntax:
      *
      *    math.sinh(x)
      *
      * Examples:
      *
      *    math.sinh(0.5)       // returns number 0.5210953054937474
      *
      * See also:
      *
      *    cosh, tanh
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic sine of x
      */
     return typed(name$1V, {
       number: sinhNumber,
       'Complex | BigNumber': x => x.sinh()
     });
   });

   var name$1U = 'tan';
   var dependencies$1U = ['typed'];
   var createTan = /* #__PURE__ */factory(name$1U, dependencies$1U, _ref => {
     var {
       typed
     } = _ref;
     var trigUnit = createTrigUnit({
       typed
     });

     /**
      * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
      *
      * To avoid confusion with the matrix tangent, this function does not apply
      * to matrices.
      *
      * Syntax:
      *
      *    math.tan(x)
      *
      * Examples:
      *
      *    math.tan(0.5)                    // returns number 0.5463024898437905
      *    math.sin(0.5) / math.cos(0.5)    // returns number 0.5463024898437905
      *    math.tan(math.pi / 4)            // returns number 1
      *    math.tan(math.unit(45, 'deg'))   // returns number 1
      *
      * See also:
      *
      *    atan, sin, cos
      *
      * @param {number | BigNumber | Complex | Unit} x  Function input
      * @return {number | BigNumber | Complex} Tangent of x
      */
     return typed(name$1U, {
       number: Math.tan,
       'Complex | BigNumber': x => x.tan()
     }, trigUnit);
   });

   var name$1T = 'tanh';
   var dependencies$1T = ['typed'];
   var createTanh = /* #__PURE__ */factory(name$1T, dependencies$1T, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Calculate the hyperbolic tangent of a value,
      * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
      *
      * To avoid confusion with matrix hyperbolic tangent, this function does
      * not apply to matrices.
      *
      * Syntax:
      *
      *    math.tanh(x)
      *
      * Examples:
      *
      *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
      *    math.tanh(0.5)                   // returns 0.46211715726000974
      *    math.sinh(0.5) / math.cosh(0.5)  // returns 0.46211715726000974
      *    1 / math.coth(0.5)               // returns 0.46211715726000974
      *
      * See also:
      *
      *    sinh, cosh, coth
      *
      * @param {number | BigNumber | Complex} x  Function input
      * @return {number | BigNumber | Complex} Hyperbolic tangent of x
      */
     return typed('tanh', {
       number: tanh$2,
       'Complex | BigNumber': x => x.tanh()
     });
   });

   var name$1S = 'setCartesian';
   var dependencies$1S = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
   var createSetCartesian = /* #__PURE__ */factory(name$1S, dependencies$1S, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index,
       DenseMatrix
     } = _ref;
     /**
      * Create the cartesian product of two (multi)sets.
      * Multi-dimension arrays will be converted to single-dimension arrays
      * and the values will be sorted in ascending order before the operation.
      *
      * Syntax:
      *
      *    math.setCartesian(set1, set2)
      *
      * Examples:
      *
      *    math.setCartesian([1, 2], [3, 4])        // returns [[1, 3], [1, 4], [2, 3], [2, 4]]
      *    math.setCartesian([4, 3], [2, 1])        // returns [[3, 1], [3, 2], [4, 1], [4, 2]]
      *
      * See also:
      *
      *    setUnion, setIntersect, setDifference, setPowerset
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {Array | Matrix}    The cartesian product of two (multi)sets
      */
     return typed(name$1S, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         var result = [];
         if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
           // if any of them is empty, return empty
           var b1 = flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
           var b2 = flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
           result = [];
           for (var i = 0; i < b1.length; i++) {
             for (var j = 0; j < b2.length; j++) {
               result.push([b1[i], b2[j]]);
             }
           }
         }
         // return an array, if both inputs were arrays
         if (Array.isArray(a1) && Array.isArray(a2)) {
           return result;
         }
         // return a matrix otherwise
         return new DenseMatrix(result);
       }
     });
   });

   var name$1R = 'setDifference';
   var dependencies$1R = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
   var createSetDifference = /* #__PURE__ */factory(name$1R, dependencies$1R, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index,
       DenseMatrix
     } = _ref;
     /**
      * Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
      * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
      *
      * Syntax:
      *
      *    math.setDifference(set1, set2)
      *
      * Examples:
      *
      *    math.setDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2]
      *    math.setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2]
      *
      * See also:
      *
      *    setUnion, setIntersect, setSymDifference
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {Array | Matrix}    The difference of two (multi)sets
      */
     return typed(name$1R, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         var result;
         if (subset(size(a1), new Index(0)) === 0) {
           // empty-anything=empty
           result = [];
         } else if (subset(size(a2), new Index(0)) === 0) {
           // anything-empty=anything
           return flatten$1(a1.toArray());
         } else {
           var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
           var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
           result = [];
           var inb2;
           for (var i = 0; i < b1.length; i++) {
             inb2 = false;
             for (var j = 0; j < b2.length; j++) {
               if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                 // the identifier is always a decimal int
                 inb2 = true;
                 break;
               }
             }
             if (!inb2) {
               result.push(b1[i]);
             }
           }
         }
         // return an array, if both inputs were arrays
         if (Array.isArray(a1) && Array.isArray(a2)) {
           return generalize(result);
         }
         // return a matrix otherwise
         return new DenseMatrix(generalize(result));
       }
     });
   });

   var name$1Q = 'setDistinct';
   var dependencies$1Q = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
   var createSetDistinct = /* #__PURE__ */factory(name$1Q, dependencies$1Q, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index,
       DenseMatrix
     } = _ref;
     /**
      * Collect the distinct elements of a multiset.
      * A multi-dimension array will be converted to a single-dimension array before the operation.
      *
      * Syntax:
      *
      *    math.setDistinct(set)
      *
      * Examples:
      *
      *    math.setDistinct([1, 1, 1, 2, 2, 3])        // returns [1, 2, 3]
      *
      * See also:
      *
      *    setMultiplicity
      *
      * @param {Array | Matrix}    a  A multiset
      * @return {Array | Matrix}    A set containing the distinc elements of the multiset
      */
     return typed(name$1Q, {
       'Array | Matrix': function ArrayMatrix(a) {
         var result;
         if (subset(size(a), new Index(0)) === 0) {
           // if empty, return empty
           result = [];
         } else {
           var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
           result = [];
           result.push(b[0]);
           for (var i = 1; i < b.length; i++) {
             if (compareNatural(b[i], b[i - 1]) !== 0) {
               result.push(b[i]);
             }
           }
         }
         // return an array, if the input was an array
         if (Array.isArray(a)) {
           return result;
         }
         // return a matrix otherwise
         return new DenseMatrix(result);
       }
     });
   });

   var name$1P = 'setIntersect';
   var dependencies$1P = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
   var createSetIntersect = /* #__PURE__ */factory(name$1P, dependencies$1P, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index,
       DenseMatrix
     } = _ref;
     /**
      * Create the intersection of two (multi)sets.
      * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
      *
      * Syntax:
      *
      *    math.setIntersect(set1, set2)
      *
      * Examples:
      *
      *    math.setIntersect([1, 2, 3, 4], [3, 4, 5, 6])            // returns [3, 4]
      *    math.setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [3, 4]
      *
      * See also:
      *
      *    setUnion, setDifference
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {Array | Matrix}    The intersection of two (multi)sets
      */
     return typed(name$1P, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         var result;
         if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
           // of any of them is empty, return empty
           result = [];
         } else {
           var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
           var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
           result = [];
           for (var i = 0; i < b1.length; i++) {
             for (var j = 0; j < b2.length; j++) {
               if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                 // the identifier is always a decimal int
                 result.push(b1[i]);
                 break;
               }
             }
           }
         }
         // return an array, if both inputs were arrays
         if (Array.isArray(a1) && Array.isArray(a2)) {
           return generalize(result);
         }
         // return a matrix otherwise
         return new DenseMatrix(generalize(result));
       }
     });
   });

   var name$1O = 'setIsSubset';
   var dependencies$1O = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
   var createSetIsSubset = /* #__PURE__ */factory(name$1O, dependencies$1O, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index
     } = _ref;
     /**
      * Check whether a (multi)set is a subset of another (multi)set. (Every element of set1 is the element of set2.)
      * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
      *
      * Syntax:
      *
      *    math.setIsSubset(set1, set2)
      *
      * Examples:
      *
      *    math.setIsSubset([1, 2], [3, 4, 5, 6])        // returns false
      *    math.setIsSubset([3, 4], [3, 4, 5, 6])        // returns true
      *
      * See also:
      *
      *    setUnion, setIntersect, setDifference
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {boolean} Returns true when a1 is a subset of a2, returns false otherwise
      */
     return typed(name$1O, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         if (subset(size(a1), new Index(0)) === 0) {
           // empty is a subset of anything
           return true;
         } else if (subset(size(a2), new Index(0)) === 0) {
           // anything is not a subset of empty
           return false;
         }
         var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
         var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
         var inb2;
         for (var i = 0; i < b1.length; i++) {
           inb2 = false;
           for (var j = 0; j < b2.length; j++) {
             if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
               // the identifier is always a decimal int
               inb2 = true;
               break;
             }
           }
           if (inb2 === false) {
             return false;
           }
         }
         return true;
       }
     });
   });

   var name$1N = 'setMultiplicity';
   var dependencies$1N = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
   var createSetMultiplicity = /* #__PURE__ */factory(name$1N, dependencies$1N, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index
     } = _ref;
     /**
      * Count the multiplicity of an element in a multiset.
      * A multi-dimension array will be converted to a single-dimension array before the operation.
      *
      * Syntax:
      *
      *    math.setMultiplicity(element, set)
      *
      * Examples:
      *
      *    math.setMultiplicity(1, [1, 2, 2, 4])    // returns 1
      *    math.setMultiplicity(2, [1, 2, 2, 4])    // returns 2
      *
      * See also:
      *
      *    setDistinct, setSize
      *
      * @param {number | BigNumber | Fraction | Complex} e  An element in the multiset
      * @param {Array | Matrix}     a  A multiset
      * @return {number}            The number of how many times the multiset contains the element
      */
     return typed(name$1N, {
       'number | BigNumber | Fraction | Complex, Array | Matrix': function numberBigNumberFractionComplexArrayMatrix(e, a) {
         if (subset(size(a), new Index(0)) === 0) {
           // if empty, return 0
           return 0;
         }
         var b = flatten$1(Array.isArray(a) ? a : a.toArray());
         var count = 0;
         for (var i = 0; i < b.length; i++) {
           if (compareNatural(b[i], e) === 0) {
             count++;
           }
         }
         return count;
       }
     });
   });

   var name$1M = 'setPowerset';
   var dependencies$1M = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
   var createSetPowerset = /* #__PURE__ */factory(name$1M, dependencies$1M, _ref => {
     var {
       typed,
       size,
       subset,
       compareNatural,
       Index
     } = _ref;
     /**
      * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)
      * A multi-dimension array will be converted to a single-dimension array before the operation.
      *
      * Syntax:
      *
      *    math.setPowerset(set)
      *
      * Examples:
      *
      *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
      *
      * See also:
      *
      *    setCartesian
      *
      * @param {Array | Matrix}    a  A (multi)set
      * @return {Array}    The powerset of the (multi)set
      */
     return typed(name$1M, {
       'Array | Matrix': function ArrayMatrix(a) {
         if (subset(size(a), new Index(0)) === 0) {
           // if empty, return empty
           return [];
         }
         var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
         var result = [];
         var number = 0;
         while (number.toString(2).length <= b.length) {
           result.push(_subset(b, number.toString(2).split('').reverse()));
           number++;
         }
         // can not return a matrix, because of the different size of the subarrays
         return _sort(result);
       }
     });

     // create subset
     function _subset(array, bitarray) {
       var result = [];
       for (var i = 0; i < bitarray.length; i++) {
         if (bitarray[i] === '1') {
           result.push(array[i]);
         }
       }
       return result;
     }

     // sort subsests by length
     function _sort(array) {
       var temp = [];
       for (var i = array.length - 1; i > 0; i--) {
         for (var j = 0; j < i; j++) {
           if (array[j].length > array[j + 1].length) {
             temp = array[j];
             array[j] = array[j + 1];
             array[j + 1] = temp;
           }
         }
       }
       return array;
     }
   });

   var name$1L = 'setSize';
   var dependencies$1L = ['typed', 'compareNatural'];
   var createSetSize = /* #__PURE__ */factory(name$1L, dependencies$1L, _ref => {
     var {
       typed,
       compareNatural
     } = _ref;
     /**
      * Count the number of elements of a (multi)set. When a second parameter is 'true', count only the unique values.
      * A multi-dimension array will be converted to a single-dimension array before the operation.
      *
      * Syntax:
      *
      *    math.setSize(set)
      *    math.setSize(set, unique)
      *
      * Examples:
      *
      *    math.setSize([1, 2, 2, 4])          // returns 4
      *    math.setSize([1, 2, 2, 4], true)    // returns 3
      *
      * See also:
      *
      *    setUnion, setIntersect, setDifference
      *
      * @param {Array | Matrix} a  A multiset
      * @param {boolean} [unique]  If true, only the unique values are counted. False by default
      * @return {number}           The number of elements of the (multi)set
      */
     return typed(name$1L, {
       'Array | Matrix': function ArrayMatrix(a) {
         return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
       },
       'Array | Matrix, boolean': function ArrayMatrixBoolean(a, unique) {
         if (unique === false || a.length === 0) {
           return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
         } else {
           var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
           var count = 1;
           for (var i = 1; i < b.length; i++) {
             if (compareNatural(b[i], b[i - 1]) !== 0) {
               count++;
             }
           }
           return count;
         }
       }
     });
   });

   var name$1K = 'setSymDifference';
   var dependencies$1K = ['typed', 'size', 'concat', 'subset', 'setDifference', 'Index'];
   var createSetSymDifference = /* #__PURE__ */factory(name$1K, dependencies$1K, _ref => {
     var {
       typed,
       size,
       concat,
       subset,
       setDifference,
       Index
     } = _ref;
     /**
      * Create the symmetric difference of two (multi)sets.
      * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
      *
      * Syntax:
      *
      *    math.setSymDifference(set1, set2)
      *
      * Examples:
      *
      *    math.setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 5, 6]
      *    math.setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 5, 6]
      *
      * See also:
      *
      *    setUnion, setIntersect, setDifference
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {Array | Matrix}    The symmetric difference of two (multi)sets
      */
     return typed(name$1K, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         if (subset(size(a1), new Index(0)) === 0) {
           // if any of them is empty, return the other one
           return flatten$1(a2);
         } else if (subset(size(a2), new Index(0)) === 0) {
           return flatten$1(a1);
         }
         var b1 = flatten$1(a1);
         var b2 = flatten$1(a2);
         return concat(setDifference(b1, b2), setDifference(b2, b1));
       }
     });
   });

   var name$1J = 'setUnion';
   var dependencies$1J = ['typed', 'size', 'concat', 'subset', 'setIntersect', 'setSymDifference', 'Index'];
   var createSetUnion = /* #__PURE__ */factory(name$1J, dependencies$1J, _ref => {
     var {
       typed,
       size,
       concat,
       subset,
       setIntersect,
       setSymDifference,
       Index
     } = _ref;
     /**
      * Create the union of two (multi)sets.
      * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
      *
      * Syntax:
      *
      *    math.setUnion(set1, set2)
      *
      * Examples:
      *
      *    math.setUnion([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 3, 4, 5, 6]
      *    math.setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 3, 4, 5, 6]
      *
      * See also:
      *
      *    setIntersect, setDifference
      *
      * @param {Array | Matrix}    a1  A (multi)set
      * @param {Array | Matrix}    a2  A (multi)set
      * @return {Array | Matrix}    The union of two (multi)sets
      */
     return typed(name$1J, {
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
         if (subset(size(a1), new Index(0)) === 0) {
           // if any of them is empty, return the other one
           return flatten$1(a2);
         } else if (subset(size(a2), new Index(0)) === 0) {
           return flatten$1(a1);
         }
         var b1 = flatten$1(a1);
         var b2 = flatten$1(a2);
         return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
       }
     });
   });

   var name$1I = 'add';
   var dependencies$1I = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix', 'concat'];
   var createAdd = /* #__PURE__ */factory(name$1I, dependencies$1I, _ref => {
     var {
       typed,
       matrix,
       addScalar,
       equalScalar,
       DenseMatrix,
       SparseMatrix,
       concat
     } = _ref;
     var matAlgo01xDSid = createMatAlgo01xDSid({
       typed
     });
     var matAlgo04xSidSid = createMatAlgo04xSidSid({
       typed,
       equalScalar
     });
     var matAlgo10xSids = createMatAlgo10xSids({
       typed,
       DenseMatrix
     });
     var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
       typed,
       matrix,
       concat
     });
     /**
     * Add two or more values, `x + y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.add(x, y)
     *    math.add(x, y, z, ...)
     *
     * Examples:
     *
     *    math.add(2, 3)               // returns number 5
     *    math.add(2, 3, 4)            // returns number 9
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(-4, 1)
     *    math.add(a, b)               // returns Complex -2 + 4i
     *
     *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
     *
     *    const c = math.unit('5 cm')
     *    const d = math.unit('2.1 mm')
     *    math.add(c, d)               // returns Unit 52.1 mm
     *
     *    math.add("2.3", "4")         // returns number 6.3
     *
     * See also:
     *
     *    subtract, sum
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
     */
     return typed(name$1I, {
       'any, any': addScalar,
       'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {
         var result = self(x, y);
         for (var i = 0; i < rest.length; i++) {
           result = self(result, rest[i]);
         }
         return result;
       })
     }, matrixAlgorithmSuite({
       elop: addScalar,
       DS: matAlgo01xDSid,
       SS: matAlgo04xSidSid,
       Ss: matAlgo10xSids
     }));
   });

   var name$1H = 'hypot';
   var dependencies$1H = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];
   var createHypot = /* #__PURE__ */factory(name$1H, dependencies$1H, _ref => {
     var {
       typed,
       abs,
       addScalar,
       divideScalar,
       multiplyScalar,
       sqrt,
       smaller,
       isPositive
     } = _ref;
     /**
      * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
      *
      *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
      *
      * For matrix input, the hypotenusa is calculated for all values in the matrix.
      *
      * Syntax:
      *
      *     math.hypot(a, b, ...)
      *     math.hypot([a, b, c, ...])
      *
      * Examples:
      *
      *     math.hypot(3, 4)      // 5
      *     math.hypot(3, 4, 5)   // 7.0710678118654755
      *     math.hypot([3, 4, 5]) // 7.0710678118654755
      *     math.hypot(-2)        // 2
      *
      * See also:
      *
      *     abs, norm
      *
      * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.
      *                                                          Matrix and Array input is flattened and returns a
      *                                                          single number for the whole matrix.
      * @return {number | BigNumber} Returns the hypothenusa of the input values.
      */
     return typed(name$1H, {
       '... number | BigNumber': _hypot,
       Array: _hypot,
       Matrix: M => _hypot(flatten$1(M.toArray()))
     });

     /**
      * Calculate the hypotenusa for an Array with values
      * @param {Array.<number | BigNumber>} args
      * @return {number | BigNumber} Returns the result
      * @private
      */
     function _hypot(args) {
       // code based on `hypot` from es6-shim:
       // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
       var result = 0;
       var largest = 0;
       for (var i = 0; i < args.length; i++) {
         if (isComplex(args[i])) {
           throw new TypeError('Unexpected type of argument to hypot');
         }
         var value = abs(args[i]);
         if (smaller(largest, value)) {
           result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
           result = addScalar(result, 1);
           largest = value;
         } else {
           result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
         }
       }
       return multiplyScalar(largest, sqrt(result));
     }
   });

   var name$1G = 'norm';
   var dependencies$1G = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];
   var createNorm = /* #__PURE__ */factory(name$1G, dependencies$1G, _ref => {
     var {
       typed,
       abs,
       add,
       pow,
       conj,
       sqrt,
       multiply,
       equalScalar,
       larger,
       smaller,
       matrix,
       ctranspose,
       eigs
     } = _ref;
     /**
      * Calculate the norm of a number, vector or matrix.
      *
      * The second parameter p is optional. If not provided, it defaults to 2.
      *
      * Syntax:
      *
      *    math.norm(x)
      *    math.norm(x, p)
      *
      * Examples:
      *
      *    math.abs(-3.5)                         // returns 3.5
      *    math.norm(-3.5)                        // returns 3.5
      *
      *    math.norm(math.complex(3, -4))         // returns 5
      *
      *    math.norm([1, 2, -3], Infinity)        // returns 3
      *    math.norm([1, 2, -3], -Infinity)       // returns 1
      *
      *    math.norm([3, 4], 2)                   // returns 5
      *
      *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
      *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
      *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
      *
      * See also:
      *
      *    abs, hypot
      *
      * @param  {number | BigNumber | Complex | Array | Matrix} x
      *            Value for which to calculate the norm
      * @param  {number | BigNumber | string} [p=2]
      *            Vector space.
      *            Supported numbers include Infinity and -Infinity.
      *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
      * @return {number | BigNumber} the p-norm
      */
     return typed(name$1G, {
       number: Math.abs,
       Complex: function Complex(x) {
         return x.abs();
       },
       BigNumber: function BigNumber(x) {
         // norm(x) = abs(x)
         return x.abs();
       },
       boolean: function boolean(x) {
         // norm(x) = abs(x)
         return Math.abs(x);
       },
       Array: function Array(x) {
         return _norm(matrix(x), 2);
       },
       Matrix: function Matrix(x) {
         return _norm(x, 2);
       },
       'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {
         return _norm(matrix(x), p);
       },
       'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {
         return _norm(x, p);
       }
     });

     /**
      * Calculate the plus infinity norm for a vector
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _vectorNormPlusInfinity(x) {
       // norm(x, Infinity) = max(abs(x))
       var pinf = 0;
       // skip zeros since abs(0) === 0
       x.forEach(function (value) {
         var v = abs(value);
         if (larger(v, pinf)) {
           pinf = v;
         }
       }, true);
       return pinf;
     }

     /**
      * Calculate the minus infinity norm for a vector
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _vectorNormMinusInfinity(x) {
       // norm(x, -Infinity) = min(abs(x))
       var ninf;
       // skip zeros since abs(0) === 0
       x.forEach(function (value) {
         var v = abs(value);
         if (!ninf || smaller(v, ninf)) {
           ninf = v;
         }
       }, true);
       return ninf || 0;
     }

     /**
      * Calculate the norm for a vector
      * @param {Matrix} x
      * @param {number | string} p
      * @returns {number} Returns the norm
      * @private
      */
     function _vectorNorm(x, p) {
       // check p
       if (p === Number.POSITIVE_INFINITY || p === 'inf') {
         return _vectorNormPlusInfinity(x);
       }
       if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
         return _vectorNormMinusInfinity(x);
       }
       if (p === 'fro') {
         return _norm(x, 2);
       }
       if (typeof p === 'number' && !isNaN(p)) {
         // check p != 0
         if (!equalScalar(p, 0)) {
           // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
           var n = 0;
           // skip zeros since abs(0) === 0
           x.forEach(function (value) {
             n = add(pow(abs(value), p), n);
           }, true);
           return pow(n, 1 / p);
         }
         return Number.POSITIVE_INFINITY;
       }
       // invalid parameter value
       throw new Error('Unsupported parameter value');
     }

     /**
      * Calculate the Frobenius norm for a matrix
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _matrixNormFrobenius(x) {
       // norm(x) = sqrt(sum(diag(x'x)))
       var fro = 0;
       x.forEach(function (value, index) {
         fro = add(fro, multiply(value, conj(value)));
       });
       return abs(sqrt(fro));
     }

     /**
      * Calculate the norm L1 for a matrix
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _matrixNormOne(x) {
       // norm(x) = the largest column sum
       var c = [];
       // result
       var maxc = 0;
       // skip zeros since abs(0) == 0
       x.forEach(function (value, index) {
         var j = index[1];
         var cj = add(c[j] || 0, abs(value));
         if (larger(cj, maxc)) {
           maxc = cj;
         }
         c[j] = cj;
       }, true);
       return maxc;
     }

     /**
      * Calculate the norm L2 for a matrix
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _matrixNormTwo(x) {
       // norm(x) = sqrt( max eigenvalue of A*.A)
       var sizeX = x.size();
       if (sizeX[0] !== sizeX[1]) {
         throw new RangeError('Invalid matrix dimensions');
       }
       var tx = ctranspose(x);
       var squaredX = multiply(tx, x);
       var eigenVals = eigs(squaredX).values.toArray();
       var rho = eigenVals[eigenVals.length - 1];
       return abs(sqrt(rho));
     }

     /**
      * Calculate the infinity norm for a matrix
      * @param {Matrix} x
      * @returns {number} Returns the norm
      * @private
      */
     function _matrixNormInfinity(x) {
       // norm(x) = the largest row sum
       var r = [];
       // result
       var maxr = 0;
       // skip zeros since abs(0) == 0
       x.forEach(function (value, index) {
         var i = index[0];
         var ri = add(r[i] || 0, abs(value));
         if (larger(ri, maxr)) {
           maxr = ri;
         }
         r[i] = ri;
       }, true);
       return maxr;
     }

     /**
      * Calculate the norm for a 2D Matrix (M*N)
      * @param {Matrix} x
      * @param {number | string} p
      * @returns {number} Returns the norm
      * @private
      */
     function _matrixNorm(x, p) {
       // check p
       if (p === 1) {
         return _matrixNormOne(x);
       }
       if (p === Number.POSITIVE_INFINITY || p === 'inf') {
         return _matrixNormInfinity(x);
       }
       if (p === 'fro') {
         return _matrixNormFrobenius(x);
       }
       if (p === 2) {
         return _matrixNormTwo(x);
       } // invalid parameter value

       throw new Error('Unsupported parameter value ' + p);
     }

     /**
      * Calculate the norm for an array
      * @param {Matrix} x
      * @param {number | string} p
      * @returns {number} Returns the norm
      * @private
      */
     function _norm(x, p) {
       // size
       var sizeX = x.size();

       // check if it is a vector
       if (sizeX.length === 1) {
         return _vectorNorm(x, p);
       }
       // MxN matrix
       if (sizeX.length === 2) {
         if (sizeX[0] && sizeX[1]) {
           return _matrixNorm(x, p);
         } else {
           throw new RangeError('Invalid matrix dimensions');
         }
       }
     }
   });

   var name$1F = 'dot';
   var dependencies$1F = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];
   var createDot = /* #__PURE__ */factory(name$1F, dependencies$1F, _ref => {
     var {
       typed,
       addScalar,
       multiplyScalar,
       conj,
       size
     } = _ref;
     /**
      * Calculate the dot product of two vectors. The dot product of
      * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
      *
      *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
      *
      * Syntax:
      *
      *    math.dot(x, y)
      *
      * Examples:
      *
      *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
      *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
      *
      * See also:
      *
      *    multiply, cross
      *
      * @param  {Array | Matrix} x     First vector
      * @param  {Array | Matrix} y     Second vector
      * @return {number}               Returns the dot product of `x` and `y`
      */
     return typed(name$1F, {
       'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
       'SparseMatrix, SparseMatrix': _sparseDot
     });
     function _validateDim(x, y) {
       var xSize = _size(x);
       var ySize = _size(y);
       var xLen, yLen;
       if (xSize.length === 1) {
         xLen = xSize[0];
       } else if (xSize.length === 2 && xSize[1] === 1) {
         xLen = xSize[0];
       } else {
         throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
       }
       if (ySize.length === 1) {
         yLen = ySize[0];
       } else if (ySize.length === 2 && ySize[1] === 1) {
         yLen = ySize[0];
       } else {
         throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
       }
       if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
       if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
       return xLen;
     }
     function _denseDot(a, b) {
       var N = _validateDim(a, b);
       var adata = isMatrix(a) ? a._data : a;
       var adt = isMatrix(a) ? a._datatype : undefined;
       var bdata = isMatrix(b) ? b._data : b;
       var bdt = isMatrix(b) ? b._datatype : undefined;

       // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)
       var aIsColumn = _size(a).length === 2;
       var bIsColumn = _size(b).length === 2;
       var add = addScalar;
       var mul = multiplyScalar;

       // process data types
       if (adt && bdt && adt === bdt && typeof adt === 'string') {
         var dt = adt;
         // find signatures that matches (dt, dt)
         add = typed.find(addScalar, [dt, dt]);
         mul = typed.find(multiplyScalar, [dt, dt]);
       }

       // both vectors 1-dimensional
       if (!aIsColumn && !bIsColumn) {
         var c = mul(conj(adata[0]), bdata[0]);
         for (var i = 1; i < N; i++) {
           c = add(c, mul(conj(adata[i]), bdata[i]));
         }
         return c;
       }

       // a is 1-dim, b is column
       if (!aIsColumn && bIsColumn) {
         var _c = mul(conj(adata[0]), bdata[0][0]);
         for (var _i = 1; _i < N; _i++) {
           _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
         }
         return _c;
       }

       // a is column, b is 1-dim
       if (aIsColumn && !bIsColumn) {
         var _c2 = mul(conj(adata[0][0]), bdata[0]);
         for (var _i2 = 1; _i2 < N; _i2++) {
           _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
         }
         return _c2;
       }

       // both vectors are column
       if (aIsColumn && bIsColumn) {
         var _c3 = mul(conj(adata[0][0]), bdata[0][0]);
         for (var _i3 = 1; _i3 < N; _i3++) {
           _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
         }
         return _c3;
       }
     }
     function _sparseDot(x, y) {
       _validateDim(x, y);
       var xindex = x._index;
       var xvalues = x._values;
       var yindex = y._index;
       var yvalues = y._values;

       // TODO optimize add & mul using datatype
       var c = 0;
       var add = addScalar;
       var mul = multiplyScalar;
       var i = 0;
       var j = 0;
       while (i < xindex.length && j < yindex.length) {
         var I = xindex[i];
         var J = yindex[j];
         if (I < J) {
           i++;
           continue;
         }
         if (I > J) {
           j++;
           continue;
         }
         if (I === J) {
           c = add(c, mul(xvalues[i], yvalues[j]));
           i++;
           j++;
         }
       }
       return c;
     }

     // TODO remove this once #1771 is fixed
     function _size(x) {
       return isMatrix(x) ? x.size() : size(x);
     }
   });

   var name$1E = 'trace';
   var dependencies$1E = ['typed', 'matrix', 'add'];
   var createTrace = /* #__PURE__ */factory(name$1E, dependencies$1E, _ref => {
     var {
       typed,
       matrix,
       add
     } = _ref;
     /**
      * Calculate the trace of a matrix: the sum of the elements on the main
      * diagonal of a square matrix.
      *
      * Syntax:
      *
      *    math.trace(x)
      *
      * Examples:
      *
      *    math.trace([[1, 2], [3, 4]]) // returns 5
      *
      *    const A = [
      *      [1, 2, 3],
      *      [-1, 2, 3],
      *      [2, 0, 3]
      *    ]
      *    math.trace(A) // returns 6
      *
      * See also:
      *
      *    diag
      *
      * @param {Array | Matrix} x  A matrix
      *
      * @return {number} The trace of `x`
      */
     return typed('trace', {
       Array: function _arrayTrace(x) {
         // use dense matrix implementation
         return _denseTrace(matrix(x));
       },
       SparseMatrix: _sparseTrace,
       DenseMatrix: _denseTrace,
       any: clone$3
     });
     function _denseTrace(m) {
       // matrix size & data
       var size = m._size;
       var data = m._data;

       // process dimensions
       switch (size.length) {
         case 1:
           // vector
           if (size[0] === 1) {
             // return data[0]
             return clone$3(data[0]);
           }
           throw new RangeError('Matrix must be square (size: ' + format$1(size) + ')');
         case 2:
           {
             // two dimensional
             var rows = size[0];
             var cols = size[1];
             if (rows === cols) {
               // calulate sum
               var sum = 0;
               // loop diagonal
               for (var i = 0; i < rows; i++) {
                 sum = add(sum, data[i][i]);
               }
               // return trace
               return sum;
             } else {
               throw new RangeError('Matrix must be square (size: ' + format$1(size) + ')');
             }
           }
         default:
           // multi dimensional
           throw new RangeError('Matrix must be two dimensional (size: ' + format$1(size) + ')');
       }
     }
     function _sparseTrace(m) {
       // matrix arrays
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;
       var size = m._size;
       // check dimensions
       var rows = size[0];
       var columns = size[1];
       // matrix must be square
       if (rows === columns) {
         // calulate sum
         var sum = 0;
         // check we have data (avoid looping columns)
         if (values.length > 0) {
           // loop columns
           for (var j = 0; j < columns; j++) {
             // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
             var k0 = ptr[j];
             var k1 = ptr[j + 1];
             // loop k within [k0, k1[
             for (var k = k0; k < k1; k++) {
               // row index
               var i = index[k];
               // check row
               if (i === j) {
                 // accumulate value
                 sum = add(sum, values[k]);
                 // exit loop
                 break;
               }
               if (i > j) {
                 // exit loop, no value on the diagonal for column j
                 break;
               }
             }
           }
         }
         // return trace
         return sum;
       }
       throw new RangeError('Matrix must be square (size: ' + format$1(size) + ')');
     }
   });

   var name$1D = 'index';
   var dependencies$1D = ['typed', 'Index'];
   var createIndex = /* #__PURE__ */factory(name$1D, dependencies$1D, _ref => {
     var {
       typed,
       Index
     } = _ref;
     /**
      * Create an index. An Index can store ranges having start, step, and end
      * for multiple dimensions.
      * Matrix.get, Matrix.set, and math.subset accept an Index as input.
      *
      * Syntax:
      *
      *     math.index(range1, range2, ...)
      *
      * Where each range can be any of:
      *
      * - A number
      * - A string for getting/setting an object property
      * - An instance of `Range`
      * - A one-dimensional Array or a Matrix with numbers or booleans
      *
      * Indexes must be zero-based, integer numbers.
      *
      * Examples:
      *
      *    const b = [1, 2, 3, 4, 5]
      *    math.subset(b, math.index([1, 2, 3]))                         // returns [2, 3, 4]
      *    math.subset(b, math.index([false, true, true, true, false]))  // returns [2, 3, 4]
      *
      *    const a = math.matrix([[1, 2], [3, 4]])
      *    a.subset(math.index(0, 1))             // returns 2
      *    a.subset(math.index(0, [false, true])) // returns 2
      *
      * See also:
      *
      *    bignumber, boolean, complex, matrix, number, string, unit
      *
      * @param {...*} ranges   Zero or more ranges or numbers.
      * @return {Index}        Returns the created index
      */
     return typed(name$1D, {
       '...number | string | BigNumber | Range | Array | Matrix': function numberStringBigNumberRangeArrayMatrix(args) {
         var ranges = args.map(function (arg) {
           if (isBigNumber(arg)) {
             return arg.toNumber(); // convert BigNumber to Number
           } else if (isArray(arg) || isMatrix(arg)) {
             return arg.map(function (elem) {
               // convert BigNumber to Number
               return isBigNumber(elem) ? elem.toNumber() : elem;
             });
           } else {
             return arg;
           }
         });
         var res = new Index();
         Index.apply(res, ranges);
         return res;
       }
     });
   });

   // Reserved keywords not allowed to use in the parser
   var keywords = new Set(['end']);

   var name$1C = 'Node';
   var dependencies$1C = ['mathWithTransform'];
   var createNode = /* #__PURE__ */factory(name$1C, dependencies$1C, _ref => {
     var {
       mathWithTransform
     } = _ref;
     /**
      * Validate the symbol names of a scope.
      * Throws an error when the scope contains an illegal symbol.
      * @param {Object} scope
      */
     function _validateScope(scope) {
       for (var symbol of [...keywords]) {
         if (scope.has(symbol)) {
           throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
         }
       }
     }
     class Node {
       get type() {
         return 'Node';
       }
       get isNode() {
         return true;
       }

       /**
        * Evaluate the node
        * @param {Object} [scope]  Scope to read/write variables
        * @return {*}              Returns the result
        */
       evaluate(scope) {
         return this.compile().evaluate(scope);
       }

       /**
        * Compile the node into an optimized, evauatable JavaScript function
        * @return {{evaluate: function([Object])}} object
        *                Returns an object with a function 'evaluate',
        *                which can be invoked as expr.evaluate([scope: Object]),
        *                where scope is an optional object with
        *                variables.
        */
       compile() {
         var expr = this._compile(mathWithTransform, {});
         var args = {};
         var context = null;
         function evaluate(scope) {
           var s = createMap$1(scope);
           _validateScope(s);
           return expr(s, args, context);
         }
         return {
           evaluate
         };
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         throw new Error('Method _compile must be implemented by type ' + this.type);
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         // must be implemented by each of the Node implementations
         throw new Error('Cannot run forEach on a Node interface');
       }

       /**
        * Create a new Node whose children are the results of calling the
        * provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {OperatorNode} Returns a transformed copy of the node
        */
       map(callback) {
         // must be implemented by each of the Node implementations
         throw new Error('Cannot run map on a Node interface');
       }

       /**
        * Validate whether an object is a Node, for use with map
        * @param {Node} node
        * @returns {Node} Returns the input if it's a node, else throws an Error
        * @protected
        */
       _ifNode(node) {
         if (!isNode(node)) {
           throw new TypeError('Callback function must return a Node');
         }
         return node;
       }

       /**
        * Recursively traverse all nodes in a node tree. Executes given callback for
        * this node and each of its child nodes.
        * @param {function(node: Node, path: string, parent: Node)} callback
        *          A callback called for every node in the node tree.
        */
       traverse(callback) {
         // execute callback for itself
         // eslint-disable-next-line
         callback(this, null, null);

         // recursively traverse over all children of a node
         function _traverse(node, callback) {
           node.forEach(function (child, path, parent) {
             callback(child, path, parent);
             _traverse(child, callback);
           });
         }
         _traverse(this, callback);
       }

       /**
        * Recursively transform a node tree via a transform function.
        *
        * For example, to replace all nodes of type SymbolNode having name 'x' with
        * a ConstantNode with value 2:
        *
        *     const res = Node.transform(function (node, path, parent) {
        *       if (node && node.isSymbolNode) && (node.name === 'x')) {
        *         return new ConstantNode(2)
        *       }
        *       else {
        *         return node
        *       }
        *     })
        *
        * @param {function(node: Node, path: string, parent: Node) : Node} callback
        *          A mapping function accepting a node, and returning
        *          a replacement for the node or the original node. The "signature"
        *          of the callback must be:
        *          callback(node: Node, index: string, parent: Node) : Node
        * @return {Node} Returns the original node or its replacement
        */
       transform(callback) {
         function _transform(child, path, parent) {
           var replacement = callback(child, path, parent);
           if (replacement !== child) {
             // stop iterating when the node is replaced
             return replacement;
           }
           return child.map(_transform);
         }
         return _transform(this, null, null);
       }

       /**
        * Find any node in the node tree matching given filter function. For
        * example, to find all nodes of type SymbolNode having name 'x':
        *
        *     const results = Node.filter(function (node) {
        *       return (node && node.isSymbolNode) && (node.name === 'x')
        *     })
        *
        * @param {function(node: Node, path: string, parent: Node) : Node} callback
        *            A test function returning true when a node matches, and false
        *            otherwise. Function signature:
        *            callback(node: Node, index: string, parent: Node) : boolean
        * @return {Node[]} nodes
        *            An array with nodes matching given filter criteria
        */
       filter(callback) {
         var nodes = [];
         this.traverse(function (node, path, parent) {
           if (callback(node, path, parent)) {
             nodes.push(node);
           }
         });
         return nodes;
       }

       /**
        * Create a shallow clone of this node
        * @return {Node}
        */
       clone() {
         // must be implemented by each of the Node implementations
         throw new Error('Cannot clone a Node interface');
       }

       /**
        * Create a deep clone of this node
        * @return {Node}
        */
       cloneDeep() {
         return this.map(function (node) {
           return node.cloneDeep();
         });
       }

       /**
        * Deep compare this node with another node.
        * @param {Node} other
        * @return {boolean} Returns true when both nodes are of the same type and
        *                   contain the same values (as do their childs)
        */
       equals(other) {
         return other ? this.type === other.type && deepStrictEqual(this, other) : false;
       }

       /**
        * Get string representation. (wrapper function)
        *
        * This function can get an object of the following form:
        * {
        *    handler: //This can be a callback function of the form
        *             // "function callback(node, options)"or
        *             // a map that maps function names (used in FunctionNodes)
        *             // to callbacks
        *    parenthesis: "keep" //the parenthesis option (This is optional)
        * }
        *
        * @param {Object} [options]
        * @return {string}
        */
       toString(options) {
         var customString = this._getCustomString(options);
         if (typeof customString !== 'undefined') {
           return customString;
         }
         return this._toString(options);
       }

       /**
        * Get a JSON representation of the node
        * Both .toJSON() and the static .fromJSON(json) should be implemented by all
        * implementations of Node
        * @returns {Object}
        */
       toJSON() {
         throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);
       }

       /**
        * Get HTML representation. (wrapper function)
        *
        * This function can get an object of the following form:
        * {
        *    handler: //This can be a callback function of the form
        *             // "function callback(node, options)" or
        *             // a map that maps function names (used in FunctionNodes)
        *             // to callbacks
        *    parenthesis: "keep" //the parenthesis option (This is optional)
        * }
        *
        * @param {Object} [options]
        * @return {string}
        */
       toHTML(options) {
         var customString = this._getCustomString(options);
         if (typeof customString !== 'undefined') {
           return customString;
         }
         return this.toHTML(options);
       }

       /**
        * Internal function to generate the string output.
        * This has to be implemented by every Node
        *
        * @throws {Error}
        */
       _toString() {
         // must be implemented by each of the Node implementations
         throw new Error('_toString not implemented for ' + this.type);
       }

       /**
        * Get LaTeX representation. (wrapper function)
        *
        * This function can get an object of the following form:
        * {
        *    handler: //This can be a callback function of the form
        *             // "function callback(node, options)"or
        *             // a map that maps function names (used in FunctionNodes)
        *             // to callbacks
        *    parenthesis: "keep" //the parenthesis option (This is optional)
        * }
        *
        * @param {Object} [options]
        * @return {string}
        */
       toTex(options) {
         var customString = this._getCustomString(options);
         if (typeof customString !== 'undefined') {
           return customString;
         }
         return this._toTex(options);
       }

       /**
        * Internal function to generate the LaTeX output.
        * This has to be implemented by every Node
        *
        * @param {Object} [options]
        * @throws {Error}
        */
       _toTex(options) {
         // must be implemented by each of the Node implementations
         throw new Error('_toTex not implemented for ' + this.type);
       }

       /**
        * Helper used by `to...` functions.
        */
       _getCustomString(options) {
         if (options && typeof options === 'object') {
           switch (typeof options.handler) {
             case 'object':
             case 'undefined':
               return;
             case 'function':
               return options.handler(this, options);
             default:
               throw new TypeError('Object or function expected as callback');
           }
         }
       }

       /**
        * Get identifier.
        * @return {string}
        */
       getIdentifier() {
         return this.type;
       }

       /**
        * Get the content of the current Node.
        * @return {Node} node
        **/
       getContent() {
         return this;
       }
     }
     return Node;
   }, {
     isClass: true,
     isNode: true
   });

   /**
    * Transform zero-based indices to one-based indices in errors
    * @param {Error} err
    * @returns {Error | IndexError} Returns the transformed error
    */
   function errorTransform(err) {
     if (err && err.isIndexError) {
       return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);
     }
     return err;
   }

   function accessFactory(_ref) {
     var {
       subset
     } = _ref;
     /**
      * Retrieve part of an object:
      *
      * - Retrieve a property from an object
      * - Retrieve a part of a string
      * - Retrieve a matrix subset
      *
      * @param {Object | Array | Matrix | string} object
      * @param {Index} index
      * @return {Object | Array | Matrix | string} Returns the subset
      */
     return function access(object, index) {
       try {
         if (Array.isArray(object)) {
           return subset(object, index);
         } else if (object && typeof object.subset === 'function') {
           // Matrix
           return object.subset(index);
         } else if (typeof object === 'string') {
           // TODO: move getStringSubset into a separate util file, use that
           return subset(object, index);
         } else if (typeof object === 'object') {
           if (!index.isObjectProperty()) {
             throw new TypeError('Cannot apply a numeric index as object property');
           }
           return getSafeProperty(object, index.getObjectProperty());
         } else {
           throw new TypeError('Cannot apply index: unsupported type of object');
         }
       } catch (err) {
         throw errorTransform(err);
       }
     };
   }

   var name$1B = 'AccessorNode';
   var dependencies$1B = ['subset', 'Node'];
   var createAccessorNode = /* #__PURE__ */factory(name$1B, dependencies$1B, _ref => {
     var {
       subset,
       Node
     } = _ref;
     var access = accessFactory({
       subset
     });

     /**
      * Are parenthesis needed?
      * @private
      */
     function needParenthesis(node) {
       // TODO: maybe make a method on the nodes which tells whether they need parenthesis?
       return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
     }
     class AccessorNode extends Node {
       /**
        * @constructor AccessorNode
        * @extends {Node}
        * Access an object property or get a matrix subset
        *
        * @param {Node} object                 The object from which to retrieve
        *                                      a property or subset.
        * @param {IndexNode} index             IndexNode containing ranges
        */
       constructor(object, index) {
         super();
         if (!isNode(object)) {
           throw new TypeError('Node expected for parameter "object"');
         }
         if (!isIndexNode(index)) {
           throw new TypeError('IndexNode expected for parameter "index"');
         }
         this.object = object;
         this.index = index;
       }

       // readonly property name
       get name() {
         if (this.index) {
           return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';
         } else {
           return this.object.name || '';
         }
       }
       get type() {
         return name$1B;
       }
       get isAccessorNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalObject = this.object._compile(math, argNames);
         var evalIndex = this.index._compile(math, argNames);
         if (this.index.isObjectProperty()) {
           var prop = this.index.getObjectProperty();
           return function evalAccessorNode(scope, args, context) {
             // get a property from an object evaluated using the scope.
             return getSafeProperty(evalObject(scope, args, context), prop);
           };
         } else {
           return function evalAccessorNode(scope, args, context) {
             var object = evalObject(scope, args, context);
             // we pass just object here instead of context:
             var index = evalIndex(scope, args, object);
             return access(object, index);
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.object, 'object', this);
         callback(this.index, 'index', this);
       }

       /**
        * Create a new AccessorNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {AccessorNode} Returns a transformed copy of the node
        */
       map(callback) {
         return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {AccessorNode}
        */
       clone() {
         return new AccessorNode(this.object, this.index);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string}
        */
       _toString(options) {
         var object = this.object.toString(options);
         if (needParenthesis(this.object)) {
           object = '(' + object + ')';
         }
         return object + this.index.toString(options);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string}
        */
       toHTML(options) {
         var object = this.object.toHTML(options);
         if (needParenthesis(this.object)) {
           object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         return object + this.index.toHTML(options);
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string}
        */
       _toTex(options) {
         var object = this.object.toTex(options);
         if (needParenthesis(this.object)) {
           object = '\\left(\' + object + \'\\right)';
         }
         return object + this.index.toTex(options);
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1B,
           object: this.object,
           index: this.index
         };
       }

       /**
        * Instantiate an AccessorNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
        *     where mathjs is optional
        * @returns {AccessorNode}
        */
       static fromJSON(json) {
         return new AccessorNode(json.object, json.index);
       }
     }
     _defineProperty(AccessorNode, "name", name$1B);
     return AccessorNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1A = 'ArrayNode';
   var dependencies$1A = ['Node'];
   var createArrayNode = /* #__PURE__ */factory(name$1A, dependencies$1A, _ref => {
     var {
       Node
     } = _ref;
     class ArrayNode extends Node {
       /**
        * @constructor ArrayNode
        * @extends {Node}
        * Holds an 1-dimensional array with items
        * @param {Node[]} [items]   1 dimensional array with items
        */
       constructor(items) {
         super();
         this.items = items || [];

         // validate input
         if (!Array.isArray(this.items) || !this.items.every(isNode)) {
           throw new TypeError('Array containing Nodes expected');
         }
       }
       get type() {
         return name$1A;
       }
       get isArrayNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalItems = map$1(this.items, function (item) {
           return item._compile(math, argNames);
         });
         var asMatrix = math.config.matrix !== 'Array';
         if (asMatrix) {
           var matrix = math.matrix;
           return function evalArrayNode(scope, args, context) {
             return matrix(map$1(evalItems, function (evalItem) {
               return evalItem(scope, args, context);
             }));
           };
         } else {
           return function evalArrayNode(scope, args, context) {
             return map$1(evalItems, function (evalItem) {
               return evalItem(scope, args, context);
             });
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         for (var i = 0; i < this.items.length; i++) {
           var node = this.items[i];
           callback(node, 'items[' + i + ']', this);
         }
       }

       /**
        * Create a new ArrayNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {ArrayNode} Returns a transformed copy of the node
        */
       map(callback) {
         var items = [];
         for (var i = 0; i < this.items.length; i++) {
           items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
         }
         return new ArrayNode(items);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {ArrayNode}
        */
       clone() {
         return new ArrayNode(this.items.slice(0));
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toString(options) {
         var items = this.items.map(function (node) {
           return node.toString(options);
         });
         return '[' + items.join(', ') + ']';
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1A,
           items: this.items
         };
       }

       /**
        * Instantiate an ArrayNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "ArrayNode", items: [...]}`,
        *                       where mathjs is optional
        * @returns {ArrayNode}
        */
       static fromJSON(json) {
         return new ArrayNode(json.items);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toHTML(options) {
         var items = this.items.map(function (node) {
           return node.toHTML(options);
         });
         return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         function itemsToTex(items, nested) {
           var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
           var itemsFormRow = nested || mixedItems;
           var itemSep = itemsFormRow ? '&' : '\\\\';
           var itemsTex = items.map(function (node) {
             if (node.items) {
               return itemsToTex(node.items, !nested);
             } else {
               return node.toTex(options);
             }
           }).join(itemSep);
           return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\begin{bmatrix}' + itemsTex + '\\end{bmatrix}' : itemsTex;
         }
         return itemsToTex(this.items, false);
       }
     }
     _defineProperty(ArrayNode, "name", name$1A);
     return ArrayNode;
   }, {
     isClass: true,
     isNode: true
   });

   function assignFactory(_ref) {
     var {
       subset,
       matrix
     } = _ref;
     /**
      * Replace part of an object:
      *
      * - Assign a property to an object
      * - Replace a part of a string
      * - Replace a matrix subset
      *
      * @param {Object | Array | Matrix | string} object
      * @param {Index} index
      * @param {*} value
      * @return {Object | Array | Matrix | string} Returns the original object
      *                                            except in case of a string
      */
     // TODO: change assign to return the value instead of the object
     return function assign(object, index, value) {
       try {
         if (Array.isArray(object)) {
           var result = matrix(object).subset(index, value).valueOf();

           // shallow copy all (updated) items into the original array
           result.forEach((item, index) => {
             object[index] = item;
           });
           return object;
         } else if (object && typeof object.subset === 'function') {
           // Matrix
           return object.subset(index, value);
         } else if (typeof object === 'string') {
           // TODO: move setStringSubset into a separate util file, use that
           return subset(object, index, value);
         } else if (typeof object === 'object') {
           if (!index.isObjectProperty()) {
             throw TypeError('Cannot apply a numeric index as object property');
           }
           setSafeProperty(object, index.getObjectProperty(), value);
           return object;
         } else {
           throw new TypeError('Cannot apply index: unsupported type of object');
         }
       } catch (err) {
         throw errorTransform(err);
       }
     };
   }

   // list of identifiers of nodes in order of their precedence
   // also contains information about left/right associativity
   // and which other operator the operator is associative with
   // Example:
   // addition is associative with addition and subtraction, because:
   // (a+b)+c=a+(b+c)
   // (a+b)-c=a+(b-c)
   //
   // postfix operators are left associative, prefix operators
   // are right associative
   //
   // It's also possible to set the following properties:
   // latexParens: if set to false, this node doesn't need to be enclosed
   //              in parentheses when using LaTeX
   // latexLeftParens: if set to false, this !OperatorNode's!
   //                  left argument doesn't need to be enclosed
   //                  in parentheses
   // latexRightParens: the same for the right argument
   var properties = [{
     // assignment
     AssignmentNode: {},
     FunctionAssignmentNode: {}
   }, {
     // conditional expression
     ConditionalNode: {
       latexLeftParens: false,
       latexRightParens: false,
       latexParens: false
       // conditionals don't need parentheses in LaTeX because
       // they are 2 dimensional
     }
   }, {
     // logical or
     'OperatorNode:or': {
       op: 'or',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // logical xor
     'OperatorNode:xor': {
       op: 'xor',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // logical and
     'OperatorNode:and': {
       op: 'and',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // bitwise or
     'OperatorNode:bitOr': {
       op: '|',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // bitwise xor
     'OperatorNode:bitXor': {
       op: '^|',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // bitwise and
     'OperatorNode:bitAnd': {
       op: '&',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // relational operators
     'OperatorNode:equal': {
       op: '==',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:unequal': {
       op: '!=',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:smaller': {
       op: '<',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:larger': {
       op: '>',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:smallerEq': {
       op: '<=',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:largerEq': {
       op: '>=',
       associativity: 'left',
       associativeWith: []
     },
     RelationalNode: {
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // bitshift operators
     'OperatorNode:leftShift': {
       op: '<<',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:rightArithShift': {
       op: '>>',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:rightLogShift': {
       op: '>>>',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // unit conversion
     'OperatorNode:to': {
       op: 'to',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // range
     RangeNode: {}
   }, {
     // addition, subtraction
     'OperatorNode:add': {
       op: '+',
       associativity: 'left',
       associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']
     },
     'OperatorNode:subtract': {
       op: '-',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // multiply, divide, modulus
     'OperatorNode:multiply': {
       op: '*',
       associativity: 'left',
       associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']
     },
     'OperatorNode:divide': {
       op: '/',
       associativity: 'left',
       associativeWith: [],
       latexLeftParens: false,
       latexRightParens: false,
       latexParens: false
       // fractions don't require parentheses because
       // they're 2 dimensional, so parens aren't needed
       // in LaTeX
     },

     'OperatorNode:dotMultiply': {
       op: '.*',
       associativity: 'left',
       associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']
     },
     'OperatorNode:dotDivide': {
       op: './',
       associativity: 'left',
       associativeWith: []
     },
     'OperatorNode:mod': {
       op: 'mod',
       associativity: 'left',
       associativeWith: []
     }
   }, {
     // Repeat multiplication for implicit multiplication
     'OperatorNode:multiply': {
       associativity: 'left',
       associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']
     }
   }, {
     // unary prefix operators
     'OperatorNode:unaryPlus': {
       op: '+',
       associativity: 'right'
     },
     'OperatorNode:unaryMinus': {
       op: '-',
       associativity: 'right'
     },
     'OperatorNode:bitNot': {
       op: '~',
       associativity: 'right'
     },
     'OperatorNode:not': {
       op: 'not',
       associativity: 'right'
     }
   }, {
     // exponentiation
     'OperatorNode:pow': {
       op: '^',
       associativity: 'right',
       associativeWith: [],
       latexRightParens: false
       // the exponent doesn't need parentheses in
       // LaTeX because it's 2 dimensional
       // (it's on top)
     },

     'OperatorNode:dotPow': {
       op: '.^',
       associativity: 'right',
       associativeWith: []
     }
   }, {
     // factorial
     'OperatorNode:factorial': {
       op: '!',
       associativity: 'left'
     }
   }, {
     // matrix transpose
     'OperatorNode:ctranspose': {
       op: "'",
       associativity: 'left'
     }
   }];

   /**
    * Returns the first non-parenthesis internal node, but only
    * when the 'parenthesis' option is unset or auto.
    * @param {Node} _node
    * @param {string} parenthesis
    * @return {Node}
    */
   function unwrapParen(_node, parenthesis) {
     if (!parenthesis || parenthesis !== 'auto') return _node;
     var node = _node;
     while (isParenthesisNode(node)) node = node.content;
     return node;
   }

   /**
    * Get the precedence of a Node.
    * Higher number for higher precedence, starting with 0.
    * Returns null if the precedence is undefined.
    *
    * @param {Node} _node
    * @param {string} parenthesis
    * @param {string} implicit
    * @param {Node} parent (for determining context for implicit multiplication)
    * @return {number | null}
    */
   function getPrecedence(_node, parenthesis, implicit, parent) {
     var node = _node;
     if (parenthesis !== 'keep') {
       // ParenthesisNodes are only ignored when not in 'keep' mode
       node = _node.getContent();
     }
     var identifier = node.getIdentifier();
     var precedence = null;
     for (var i = 0; i < properties.length; i++) {
       if (identifier in properties[i]) {
         precedence = i;
         break;
       }
     }
     // Bump up precedence of implicit multiplication, except when preceded
     // by a "Rule 2" fraction ( [unaryOp]constant / constant )
     if (identifier === 'OperatorNode:multiply' && node.implicit && implicit !== 'show') {
       var leftArg = unwrapParen(node.args[0], parenthesis);
       if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
         precedence += 1;
       }
     }
     return precedence;
   }

   /**
    * Get the associativity of an operator (left or right).
    * Returns a string containing 'left' or 'right' or null if
    * the associativity is not defined.
    *
    * @param {Node} _node
    * @param {string} parenthesis
    * @return {string|null}
    * @throws {Error}
    */
   function getAssociativity(_node, parenthesis) {
     var node = _node;
     if (parenthesis !== 'keep') {
       // ParenthesisNodes are only ignored when not in 'keep' mode
       node = _node.getContent();
     }
     var identifier = node.getIdentifier();
     var index = getPrecedence(node, parenthesis);
     if (index === null) {
       // node isn't in the list
       return null;
     }
     var property = properties[index][identifier];
     if (hasOwnProperty(property, 'associativity')) {
       if (property.associativity === 'left') {
         return 'left';
       }
       if (property.associativity === 'right') {
         return 'right';
       }
       // associativity is invalid
       throw Error('\'' + identifier + '\' has the invalid associativity \'' + property.associativity + '\'.');
     }

     // associativity is undefined
     return null;
   }

   /**
    * Check if an operator is associative with another operator.
    * Returns either true or false or null if not defined.
    *
    * @param {Node} nodeA
    * @param {Node} nodeB
    * @param {string} parenthesis
    * @return {boolean | null}
    */
   function isAssociativeWith(nodeA, nodeB, parenthesis) {
     // ParenthesisNodes are only ignored when not in 'keep' mode
     var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;
     var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;
     var identifierA = a.getIdentifier();
     var identifierB = b.getIdentifier();
     var index = getPrecedence(a, parenthesis);
     if (index === null) {
       // node isn't in the list
       return null;
     }
     var property = properties[index][identifierA];
     if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {
       for (var i = 0; i < property.associativeWith.length; i++) {
         if (property.associativeWith[i] === identifierB) {
           return true;
         }
       }
       return false;
     }

     // associativeWith is not defined
     return null;
   }

   /**
    * Get the operator associated with a function name.
    * Returns a string with the operator symbol, or null if the
    * input is not the name of a function associated with an
    * operator.
    *
    * @param {string} Function name
    * @return {string | null} Associated operator symbol, if any
    */
   function getOperator(fn) {
     var identifier = 'OperatorNode:' + fn;
     for (var group of properties) {
       if (identifier in group) {
         return group[identifier].op;
       }
     }
     return null;
   }

   var name$1z = 'AssignmentNode';
   var dependencies$1z = ['subset', '?matrix',
   // FIXME: should not be needed at all, should be handled by subset
   'Node'];
   var createAssignmentNode = /* #__PURE__ */factory(name$1z, dependencies$1z, _ref => {
     var {
       subset,
       matrix,
       Node
     } = _ref;
     var access = accessFactory({
       subset
     });
     var assign = assignFactory({
       subset,
       matrix
     });

     /*
      * Is parenthesis needed?
      * @param {node} node
      * @param {string} [parenthesis='keep']
      * @param {string} implicit
      * @private
      */
     function needParenthesis(node, parenthesis, implicit) {
       if (!parenthesis) {
         parenthesis = 'keep';
       }
       var precedence = getPrecedence(node, parenthesis, implicit);
       var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
       return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;
     }
     class AssignmentNode extends Node {
       /**
        * @constructor AssignmentNode
        * @extends {Node}
        *
        * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
        * replace a subset of a matrix like `A[2,2]=42`.
        *
        * Syntax:
        *
        *     new AssignmentNode(symbol, value)
        *     new AssignmentNode(object, index, value)
        *
        * Usage:
        *
        *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
        *    new AssignmentNode(new SymbolNode('a'),
        *                       new IndexNode('b'),
        *                       new ConstantNode(2))   // a.b=2
        *    new AssignmentNode(new SymbolNode('a'),
        *                       new IndexNode(1, 2),
        *                       new ConstantNode(3))  // a[1,2]=3
        *
        * @param {SymbolNode | AccessorNode} object
        *     Object on which to assign a value
        * @param {IndexNode} [index=null]
        *     Index, property name or matrix index. Optional. If not provided
        *     and `object` is a SymbolNode, the property is assigned to the
        *     global scope.
        * @param {Node} value
        *     The value to be assigned
        */
       constructor(object, index, value) {
         super();
         this.object = object;
         this.index = value ? index : null;
         this.value = value || index;

         // validate input
         if (!isSymbolNode(object) && !isAccessorNode(object)) {
           throw new TypeError('SymbolNode or AccessorNode expected as "object"');
         }
         if (isSymbolNode(object) && object.name === 'end') {
           throw new Error('Cannot assign to symbol "end"');
         }
         if (this.index && !isIndexNode(this.index)) {
           // index is optional
           throw new TypeError('IndexNode expected as "index"');
         }
         if (!isNode(this.value)) {
           throw new TypeError('Node expected as "value"');
         }
       }

       // class name for typing purposes:

       // readonly property name
       get name() {
         if (this.index) {
           return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';
         } else {
           return this.object.name || '';
         }
       }
       get type() {
         return name$1z;
       }
       get isAssignmentNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalObject = this.object._compile(math, argNames);
         var evalIndex = this.index ? this.index._compile(math, argNames) : null;
         var evalValue = this.value._compile(math, argNames);
         var name = this.object.name;
         if (!this.index) {
           // apply a variable to the scope, for example `a=2`
           if (!isSymbolNode(this.object)) {
             throw new TypeError('SymbolNode expected as object');
           }
           return function evalAssignmentNode(scope, args, context) {
             var value = evalValue(scope, args, context);
             scope.set(name, value);
             return value;
           };
         } else if (this.index.isObjectProperty()) {
           // apply an object property for example `a.b=2`
           var prop = this.index.getObjectProperty();
           return function evalAssignmentNode(scope, args, context) {
             var object = evalObject(scope, args, context);
             var value = evalValue(scope, args, context);
             setSafeProperty(object, prop, value);
             return value;
           };
         } else if (isSymbolNode(this.object)) {
           // update a matrix subset, for example `a[2]=3`
           return function evalAssignmentNode(scope, args, context) {
             var childObject = evalObject(scope, args, context);
             var value = evalValue(scope, args, context);
             // Important:  we pass childObject instead of context:
             var index = evalIndex(scope, args, childObject);
             scope.set(name, assign(childObject, index, value));
             return value;
           };
         } else {
           // isAccessorNode(node.object) === true
           // update a matrix subset, for example `a.b[2]=3`

           // we will not use the compile function of the AccessorNode, but
           // compile it ourselves here as we need the parent object of the
           // AccessorNode:
           // wee need to apply the updated object to parent object
           var evalParentObject = this.object.object._compile(math, argNames);
           if (this.object.index.isObjectProperty()) {
             var parentProp = this.object.index.getObjectProperty();
             return function evalAssignmentNode(scope, args, context) {
               var parent = evalParentObject(scope, args, context);
               var childObject = getSafeProperty(parent, parentProp);
               // Important: we pass childObject instead of context:
               var index = evalIndex(scope, args, childObject);
               var value = evalValue(scope, args, context);
               setSafeProperty(parent, parentProp, assign(childObject, index, value));
               return value;
             };
           } else {
             // if some parameters use the 'end' parameter, we need to calculate
             // the size
             var evalParentIndex = this.object.index._compile(math, argNames);
             return function evalAssignmentNode(scope, args, context) {
               var parent = evalParentObject(scope, args, context);
               // Important: we pass parent instead of context:
               var parentIndex = evalParentIndex(scope, args, parent);
               var childObject = access(parent, parentIndex);
               // Important:  we pass childObject instead of context
               var index = evalIndex(scope, args, childObject);
               var value = evalValue(scope, args, context);
               assign(parent, parentIndex, assign(childObject, index, value));
               return value;
             };
           }
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.object, 'object', this);
         if (this.index) {
           callback(this.index, 'index', this);
         }
         callback(this.value, 'value', this);
       }

       /**
        * Create a new AssignmentNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {AssignmentNode} Returns a transformed copy of the node
        */
       map(callback) {
         var object = this._ifNode(callback(this.object, 'object', this));
         var index = this.index ? this._ifNode(callback(this.index, 'index', this)) : null;
         var value = this._ifNode(callback(this.value, 'value', this));
         return new AssignmentNode(object, index, value);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {AssignmentNode}
        */
       clone() {
         return new AssignmentNode(this.object, this.index, this.value);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string}
        */
       _toString(options) {
         var object = this.object.toString(options);
         var index = this.index ? this.index.toString(options) : '';
         var value = this.value.toString(options);
         if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
           value = '(' + value + ')';
         }
         return object + index + ' = ' + value;
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1z,
           object: this.object,
           index: this.index,
           value: this.value
         };
       }

       /**
        * Instantiate an AssignmentNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
        *     where mathjs is optional
        * @returns {AssignmentNode}
        */
       static fromJSON(json) {
         return new AssignmentNode(json.object, json.index, json.value);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string}
        */
       toHTML(options) {
         var object = this.object.toHTML(options);
         var index = this.index ? this.index.toHTML(options) : '';
         var value = this.value.toHTML(options);
         if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
           value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
         }
         return object + index + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + value;
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string}
        */
       _toTex(options) {
         var object = this.object.toTex(options);
         var index = this.index ? this.index.toTex(options) : '';
         var value = this.value.toTex(options);
         if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
           value = "\\left(".concat(value, "\\right)");
         }
         return object + index + ':=' + value;
       }
     }
     _defineProperty(AssignmentNode, "name", name$1z);
     return AssignmentNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1y = 'BlockNode';
   var dependencies$1y = ['ResultSet', 'Node'];
   var createBlockNode = /* #__PURE__ */factory(name$1y, dependencies$1y, _ref => {
     var {
       ResultSet,
       Node
     } = _ref;
     class BlockNode extends Node {
       /**
        * @constructor BlockNode
        * @extends {Node}
        * Holds a set with blocks
        * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
        *            An array with blocks, where a block is constructed as an
        *            Object with properties block, which is a Node, and visible,
        *            which is a boolean. The property visible is optional and
        *            is true by default
        */
       constructor(blocks) {
         super();
         // validate input, copy blocks
         if (!Array.isArray(blocks)) throw new Error('Array expected');
         this.blocks = blocks.map(function (block) {
           var node = block && block.node;
           var visible = block && block.visible !== undefined ? block.visible : true;
           if (!isNode(node)) throw new TypeError('Property "node" must be a Node');
           if (typeof visible !== 'boolean') {
             throw new TypeError('Property "visible" must be a boolean');
           }
           return {
             node,
             visible
           };
         });
       }
       get type() {
         return name$1y;
       }
       get isBlockNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalBlocks = map$1(this.blocks, function (block) {
           return {
             evaluate: block.node._compile(math, argNames),
             visible: block.visible
           };
         });
         return function evalBlockNodes(scope, args, context) {
           var results = [];
           forEach$1(evalBlocks, function evalBlockNode(block) {
             var result = block.evaluate(scope, args, context);
             if (block.visible) {
               results.push(result);
             }
           });
           return new ResultSet(results);
         };
       }

       /**
        * Execute a callback for each of the child blocks of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         for (var i = 0; i < this.blocks.length; i++) {
           callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
         }
       }

       /**
        * Create a new BlockNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {BlockNode} Returns a transformed copy of the node
        */
       map(callback) {
         var blocks = [];
         for (var i = 0; i < this.blocks.length; i++) {
           var block = this.blocks[i];
           var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));
           blocks[i] = {
             node,
             visible: block.visible
           };
         }
         return new BlockNode(blocks);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {BlockNode}
        */
       clone() {
         var blocks = this.blocks.map(function (block) {
           return {
             node: block.node,
             visible: block.visible
           };
         });
         return new BlockNode(blocks);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toString(options) {
         return this.blocks.map(function (param) {
           return param.node.toString(options) + (param.visible ? '' : ';');
         }).join('\n');
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1y,
           blocks: this.blocks
         };
       }

       /**
        * Instantiate an BlockNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
        *     where mathjs is optional
        * @returns {BlockNode}
        */
       static fromJSON(json) {
         return new BlockNode(json.blocks);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toHTML(options) {
         return this.blocks.map(function (param) {
           return param.node.toHTML(options) + (param.visible ? '' : '<span class="math-separator">;</span>');
         }).join('<span class="math-separator"><br /></span>');
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         return this.blocks.map(function (param) {
           return param.node.toTex(options) + (param.visible ? '' : ';');
         }).join('\\;\\;\n');
       }
     }
     _defineProperty(BlockNode, "name", name$1y);
     return BlockNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1x = 'ConditionalNode';
   var dependencies$1x = ['Node'];
   var createConditionalNode = /* #__PURE__ */factory(name$1x, dependencies$1x, _ref => {
     var {
       Node
     } = _ref;
     /**
      * Test whether a condition is met
      * @param {*} condition
      * @returns {boolean} true if condition is true or non-zero, else false
      */
     function testCondition(condition) {
       if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {
         return !!condition;
       }
       if (condition) {
         if (isBigNumber(condition)) {
           return !condition.isZero();
         }
         if (isComplex(condition)) {
           return !!(condition.re || condition.im);
         }
         if (isUnit(condition)) {
           return !!condition.value;
         }
       }
       if (condition === null || condition === undefined) {
         return false;
       }
       throw new TypeError('Unsupported type of condition "' + typeOf$1(condition) + '"');
     }
     class ConditionalNode extends Node {
       /**
        * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
        *
        * @param {Node} condition   Condition, must result in a boolean
        * @param {Node} trueExpr    Expression evaluated when condition is true
        * @param {Node} falseExpr   Expression evaluated when condition is true
        *
        * @constructor ConditionalNode
        * @extends {Node}
        */
       constructor(condition, trueExpr, falseExpr) {
         super();
         if (!isNode(condition)) {
           throw new TypeError('Parameter condition must be a Node');
         }
         if (!isNode(trueExpr)) {
           throw new TypeError('Parameter trueExpr must be a Node');
         }
         if (!isNode(falseExpr)) {
           throw new TypeError('Parameter falseExpr must be a Node');
         }
         this.condition = condition;
         this.trueExpr = trueExpr;
         this.falseExpr = falseExpr;
       }
       get type() {
         return name$1x;
       }
       get isConditionalNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalCondition = this.condition._compile(math, argNames);
         var evalTrueExpr = this.trueExpr._compile(math, argNames);
         var evalFalseExpr = this.falseExpr._compile(math, argNames);
         return function evalConditionalNode(scope, args, context) {
           return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.condition, 'condition', this);
         callback(this.trueExpr, 'trueExpr', this);
         callback(this.falseExpr, 'falseExpr', this);
       }

       /**
        * Create a new ConditionalNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {ConditionalNode} Returns a transformed copy of the node
        */
       map(callback) {
         return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {ConditionalNode}
        */
       clone() {
         return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var precedence = getPrecedence(this, parenthesis, options && options.implicit);

         // Enclose Arguments in parentheses if they are an OperatorNode
         // or have lower or equal precedence
         // NOTE: enclosing all OperatorNodes in parentheses is a decision
         // purely based on aesthetics and readability
         var condition = this.condition.toString(options);
         var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {
           condition = '(' + condition + ')';
         }
         var trueExpr = this.trueExpr.toString(options);
         var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {
           trueExpr = '(' + trueExpr + ')';
         }
         var falseExpr = this.falseExpr.toString(options);
         var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {
           falseExpr = '(' + falseExpr + ')';
         }
         return condition + ' ? ' + trueExpr + ' : ' + falseExpr;
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1x,
           condition: this.condition,
           trueExpr: this.trueExpr,
           falseExpr: this.falseExpr
         };
       }

       /**
        * Instantiate an ConditionalNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     ```
        *     {"mathjs": "ConditionalNode",
        *      "condition": ...,
        *      "trueExpr": ...,
        *      "falseExpr": ...}
        *     ```
        *     where mathjs is optional
        * @returns {ConditionalNode}
        */
       static fromJSON(json) {
         return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var precedence = getPrecedence(this, parenthesis, options && options.implicit);

         // Enclose Arguments in parentheses if they are an OperatorNode
         // or have lower or equal precedence
         // NOTE: enclosing all OperatorNodes in parentheses is a decision
         // purely based on aesthetics and readability
         var condition = this.condition.toHTML(options);
         var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {
           condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         var trueExpr = this.trueExpr.toHTML(options);
         var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {
           trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         var falseExpr = this.falseExpr.toHTML(options);
         var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
         if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {
           falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         return '\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\quad{\\text{if }\\;' + this.condition.toTex(options) + '}\\\\{' + this.falseExpr.toTex(options) + '}, &\\quad{\\text{otherwise}}\\end{cases}';
       }
     }
     _defineProperty(ConditionalNode, "name", name$1x);
     return ConditionalNode;
   }, {
     isClass: true,
     isNode: true
   });

   // Map the characters to escape to their escaped values. The list is derived
   // from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters

   var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

   var defaultEscapes = {
     "{": "\\{",
     "}": "\\}",
     "\\": "\\textbackslash{}",
     "#": "\\#",
     $: "\\$",
     "%": "\\%",
     "&": "\\&",
     "^": "\\textasciicircum{}",
     _: "\\_",
     "~": "\\textasciitilde{}"
   };
   var formatEscapes = {
     "\u2013": "\\--",
     "\u2014": "\\---",
     " ": "~",
     "\t": "\\qquad{}",
     "\r\n": "\\newline{}",
     "\n": "\\newline{}"
   };

   var defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {
     return _extends({}, defaultEscapes, formatEscapes);
   };

   /**
    * Escape a string to be used in LaTeX documents.
    * @param {string} str the string to be escaped.
    * @param {boolean} params.preserveFormatting whether formatting escapes should
    *  be performed (default: false).
    * @param {function} params.escapeMapFn the function to modify the escape maps.
    * @return {string} the escaped string, ready to be used in LaTeX.
    */
   var dist = function (str) {
     var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
         _ref$preserveFormatti = _ref.preserveFormatting,
         preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,
         _ref$escapeMapFn = _ref.escapeMapFn,
         escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;

     var runningStr = String(str);
     var result = "";

     var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});
     var escapeKeys = Object.keys(escapes); // as it is reused later on

     // Algorithm: Go through the string character by character, if it matches
     // with one of the special characters then we'll replace it with the escaped
     // version.

     var _loop = function _loop() {
       var specialCharFound = false;
       escapeKeys.forEach(function (key, index) {
         if (specialCharFound) {
           return;
         }
         if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
           result += escapes[escapeKeys[index]];
           runningStr = runningStr.slice(key.length, runningStr.length);
           specialCharFound = true;
         }
       });
       if (!specialCharFound) {
         result += runningStr.slice(0, 1);
         runningStr = runningStr.slice(1, runningStr.length);
       }
     };

     while (runningStr) {
       _loop();
     }
     return result;
   };

   var escapeLatexLib = /*@__PURE__*/getDefaultExportFromCjs(dist);

   /* eslint no-template-curly-in-string: "off" */

   var latexSymbols = {
     // GREEK LETTERS
     Alpha: 'A',
     alpha: '\\alpha',
     Beta: 'B',
     beta: '\\beta',
     Gamma: '\\Gamma',
     gamma: '\\gamma',
     Delta: '\\Delta',
     delta: '\\delta',
     Epsilon: 'E',
     epsilon: '\\epsilon',
     varepsilon: '\\varepsilon',
     Zeta: 'Z',
     zeta: '\\zeta',
     Eta: 'H',
     eta: '\\eta',
     Theta: '\\Theta',
     theta: '\\theta',
     vartheta: '\\vartheta',
     Iota: 'I',
     iota: '\\iota',
     Kappa: 'K',
     kappa: '\\kappa',
     varkappa: '\\varkappa',
     Lambda: '\\Lambda',
     lambda: '\\lambda',
     Mu: 'M',
     mu: '\\mu',
     Nu: 'N',
     nu: '\\nu',
     Xi: '\\Xi',
     xi: '\\xi',
     Omicron: 'O',
     omicron: 'o',
     Pi: '\\Pi',
     pi: '\\pi',
     varpi: '\\varpi',
     Rho: 'P',
     rho: '\\rho',
     varrho: '\\varrho',
     Sigma: '\\Sigma',
     sigma: '\\sigma',
     varsigma: '\\varsigma',
     Tau: 'T',
     tau: '\\tau',
     Upsilon: '\\Upsilon',
     upsilon: '\\upsilon',
     Phi: '\\Phi',
     phi: '\\phi',
     varphi: '\\varphi',
     Chi: 'X',
     chi: '\\chi',
     Psi: '\\Psi',
     psi: '\\psi',
     Omega: '\\Omega',
     omega: '\\omega',
     // logic
     true: '\\mathrm{True}',
     false: '\\mathrm{False}',
     // other
     i: 'i',
     // TODO use \i ??
     inf: '\\infty',
     Inf: '\\infty',
     infinity: '\\infty',
     Infinity: '\\infty',
     oo: '\\infty',
     lim: '\\lim',
     undefined: '\\mathbf{?}'
   };
   var latexOperators = {
     transpose: '^\\top',
     ctranspose: '^H',
     factorial: '!',
     pow: '^',
     dotPow: '.^\\wedge',
     // TODO find ideal solution
     unaryPlus: '+',
     unaryMinus: '-',
     bitNot: '\\~',
     // TODO find ideal solution
     not: '\\neg',
     multiply: '\\cdot',
     divide: '\\frac',
     // TODO how to handle that properly?
     dotMultiply: '.\\cdot',
     // TODO find ideal solution
     dotDivide: '.:',
     // TODO find ideal solution
     mod: '\\mod',
     add: '+',
     subtract: '-',
     to: '\\rightarrow',
     leftShift: '<<',
     rightArithShift: '>>',
     rightLogShift: '>>>',
     equal: '=',
     unequal: '\\neq',
     smaller: '<',
     larger: '>',
     smallerEq: '\\leq',
     largerEq: '\\geq',
     bitAnd: '\\&',
     bitXor: '\\underline{|}',
     bitOr: '|',
     and: '\\wedge',
     xor: '\\veebar',
     or: '\\vee'
   };
   var latexFunctions = {
     // arithmetic
     abs: {
       1: '\\left|${args[0]}\\right|'
     },
     add: {
       2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
     },
     cbrt: {
       1: '\\sqrt[3]{${args[0]}}'
     },
     ceil: {
       1: '\\left\\lceil${args[0]}\\right\\rceil'
     },
     cube: {
       1: '\\left(${args[0]}\\right)^3'
     },
     divide: {
       2: '\\frac{${args[0]}}{${args[1]}}'
     },
     dotDivide: {
       2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
     },
     dotMultiply: {
       2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
     },
     dotPow: {
       2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
     },
     exp: {
       1: '\\exp\\left(${args[0]}\\right)'
     },
     expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
     fix: {
       1: '\\mathrm{${name}}\\left(${args[0]}\\right)'
     },
     floor: {
       1: '\\left\\lfloor${args[0]}\\right\\rfloor'
     },
     gcd: '\\gcd\\left(${args}\\right)',
     hypot: '\\hypot\\left(${args}\\right)',
     log: {
       1: '\\ln\\left(${args[0]}\\right)',
       2: '\\log_{${args[1]}}\\left(${args[0]}\\right)'
     },
     log10: {
       1: '\\log_{10}\\left(${args[0]}\\right)'
     },
     log1p: {
       1: '\\ln\\left(${args[0]}+1\\right)',
       2: '\\log_{${args[1]}}\\left(${args[0]}+1\\right)'
     },
     log2: '\\log_{2}\\left(${args[0]}\\right)',
     mod: {
       2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
     },
     multiply: {
       2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
     },
     norm: {
       1: '\\left\\|${args[0]}\\right\\|',
       2: undefined // use default template
     },

     nthRoot: {
       2: '\\sqrt[${args[1]}]{${args[0]}}'
     },
     nthRoots: {
       2: '\\{y : $y^{args[1]} = {${args[0]}}\\}'
     },
     pow: {
       2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
     },
     round: {
       1: '\\left\\lfloor${args[0]}\\right\\rceil',
       2: undefined // use default template
     },

     sign: {
       1: '\\mathrm{${name}}\\left(${args[0]}\\right)'
     },
     sqrt: {
       1: '\\sqrt{${args[0]}}'
     },
     square: {
       1: '\\left(${args[0]}\\right)^2'
     },
     subtract: {
       2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
     },
     unaryMinus: {
       1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
     },
     unaryPlus: {
       1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
     },
     // bitwise
     bitAnd: {
       2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
     },
     bitNot: {
       1: latexOperators.bitNot + '\\left(${args[0]}\\right)'
     },
     bitOr: {
       2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
     },
     bitXor: {
       2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
     },
     leftShift: {
       2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
     },
     rightArithShift: {
       2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
     },
     rightLogShift: {
       2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
     },
     // combinatorics
     bellNumbers: {
       1: '\\mathrm{B}_{${args[0]}}'
     },
     catalan: {
       1: '\\mathrm{C}_{${args[0]}}'
     },
     stirlingS2: {
       2: '\\mathrm{S}\\left(${args}\\right)'
     },
     // complex
     arg: {
       1: '\\arg\\left(${args[0]}\\right)'
     },
     conj: {
       1: '\\left(${args[0]}\\right)^*'
     },
     im: {
       1: '\\Im\\left\\lbrace${args[0]}\\right\\rbrace'
     },
     re: {
       1: '\\Re\\left\\lbrace${args[0]}\\right\\rbrace'
     },
     // logical
     and: {
       2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
     },
     not: {
       1: latexOperators.not + '\\left(${args[0]}\\right)'
     },
     or: {
       2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
     },
     xor: {
       2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
     },
     // matrix
     cross: {
       2: '\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)'
     },
     ctranspose: {
       1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
     },
     det: {
       1: '\\det\\left(${args[0]}\\right)'
     },
     dot: {
       2: '\\left(${args[0]}\\cdot${args[1]}\\right)'
     },
     expm: {
       1: '\\exp\\left(${args[0]}\\right)'
     },
     inv: {
       1: '\\left(${args[0]}\\right)^{-1}'
     },
     pinv: {
       1: '\\left(${args[0]}\\right)^{+}'
     },
     sqrtm: {
       1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
     },
     trace: {
       1: '\\mathrm{tr}\\left(${args[0]}\\right)'
     },
     transpose: {
       1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
     },
     // probability
     combinations: {
       2: '\\binom{${args[0]}}{${args[1]}}'
     },
     combinationsWithRep: {
       2: '\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)'
     },
     factorial: {
       1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
     },
     gamma: {
       1: '\\Gamma\\left(${args[0]}\\right)'
     },
     lgamma: {
       1: '\\ln\\Gamma\\left(${args[0]}\\right)'
     },
     // relational
     equal: {
       2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
     },
     larger: {
       2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
     },
     largerEq: {
       2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
     },
     smaller: {
       2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
     },
     smallerEq: {
       2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
     },
     unequal: {
       2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
     },
     // special
     erf: {
       1: 'erf\\left(${args[0]}\\right)'
     },
     // statistics
     max: '\\max\\left(${args}\\right)',
     min: '\\min\\left(${args}\\right)',
     variance: '\\mathrm{Var}\\left(${args}\\right)',
     // trigonometry
     acos: {
       1: '\\cos^{-1}\\left(${args[0]}\\right)'
     },
     acosh: {
       1: '\\cosh^{-1}\\left(${args[0]}\\right)'
     },
     acot: {
       1: '\\cot^{-1}\\left(${args[0]}\\right)'
     },
     acoth: {
       1: '\\coth^{-1}\\left(${args[0]}\\right)'
     },
     acsc: {
       1: '\\csc^{-1}\\left(${args[0]}\\right)'
     },
     acsch: {
       1: '\\mathrm{csch}^{-1}\\left(${args[0]}\\right)'
     },
     asec: {
       1: '\\sec^{-1}\\left(${args[0]}\\right)'
     },
     asech: {
       1: '\\mathrm{sech}^{-1}\\left(${args[0]}\\right)'
     },
     asin: {
       1: '\\sin^{-1}\\left(${args[0]}\\right)'
     },
     asinh: {
       1: '\\sinh^{-1}\\left(${args[0]}\\right)'
     },
     atan: {
       1: '\\tan^{-1}\\left(${args[0]}\\right)'
     },
     atan2: {
       2: '\\mathrm{atan2}\\left(${args}\\right)'
     },
     atanh: {
       1: '\\tanh^{-1}\\left(${args[0]}\\right)'
     },
     cos: {
       1: '\\cos\\left(${args[0]}\\right)'
     },
     cosh: {
       1: '\\cosh\\left(${args[0]}\\right)'
     },
     cot: {
       1: '\\cot\\left(${args[0]}\\right)'
     },
     coth: {
       1: '\\coth\\left(${args[0]}\\right)'
     },
     csc: {
       1: '\\csc\\left(${args[0]}\\right)'
     },
     csch: {
       1: '\\mathrm{csch}\\left(${args[0]}\\right)'
     },
     sec: {
       1: '\\sec\\left(${args[0]}\\right)'
     },
     sech: {
       1: '\\mathrm{sech}\\left(${args[0]}\\right)'
     },
     sin: {
       1: '\\sin\\left(${args[0]}\\right)'
     },
     sinh: {
       1: '\\sinh\\left(${args[0]}\\right)'
     },
     tan: {
       1: '\\tan\\left(${args[0]}\\right)'
     },
     tanh: {
       1: '\\tanh\\left(${args[0]}\\right)'
     },
     // unit
     to: {
       2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
     },
     // utils
     numeric: function numeric(node, options) {
       // Not sure if this is strictly right but should work correctly for the vast majority of use cases.
       return node.args[0].toTex();
     },
     // type
     number: {
       0: '0',
       1: '\\left(${args[0]}\\right)',
       2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
     },
     string: {
       0: '\\mathtt{""}',
       1: '\\mathrm{string}\\left(${args[0]}\\right)'
     },
     bignumber: {
       0: '0',
       1: '\\left(${args[0]}\\right)'
     },
     complex: {
       0: '0',
       1: '\\left(${args[0]}\\right)',
       2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
     },
     matrix: {
       0: '\\begin{bmatrix}\\end{bmatrix}',
       1: '\\left(${args[0]}\\right)',
       2: '\\left(${args[0]}\\right)'
     },
     sparse: {
       0: '\\begin{bsparse}\\end{bsparse}',
       1: '\\left(${args[0]}\\right)'
     },
     unit: {
       1: '\\left(${args[0]}\\right)',
       2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
     }
   };
   var defaultTemplate = '\\mathrm{${name}}\\left(${args}\\right)';
   var latexUnits = {
     deg: '^\\circ'
   };
   function escapeLatex(string) {
     return escapeLatexLib(string, {
       preserveFormatting: true
     });
   }

   // @param {string} name
   // @param {boolean} isUnit
   function toSymbol(name, isUnit) {
     isUnit = typeof isUnit === 'undefined' ? false : isUnit;
     if (isUnit) {
       if (hasOwnProperty(latexUnits, name)) {
         return latexUnits[name];
       }
       return '\\mathrm{' + escapeLatex(name) + '}';
     }
     if (hasOwnProperty(latexSymbols, name)) {
       return latexSymbols[name];
     }
     return escapeLatex(name);
   }

   var name$1w = 'ConstantNode';
   var dependencies$1w = ['Node'];
   var createConstantNode = /* #__PURE__ */factory(name$1w, dependencies$1w, _ref => {
     var {
       Node
     } = _ref;
     class ConstantNode extends Node {
       /**
        * A ConstantNode holds a constant value like a number or string.
        *
        * Usage:
        *
        *     new ConstantNode(2.3)
        *     new ConstantNode('hello')
        *
        * @param {*} value    Value can be any type (number, BigNumber, string, ...)
        * @constructor ConstantNode
        * @extends {Node}
        */
       constructor(value) {
         super();
         this.value = value;
       }
       get type() {
         return name$1w;
       }
       get isConstantNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var value = this.value;
         return function evalConstantNode() {
           return value;
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         // nothing to do, we don't have any children
       }

       /**
        * Create a new ConstantNode with children produced by the given callback.
        * Trivial because there are no children.
        * @param {function(child: Node, path: string, parent: Node) : Node} callback
        * @returns {ConstantNode} Returns a clone of the node
        */
       map(callback) {
         return this.clone();
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {ConstantNode}
        */
       clone() {
         return new ConstantNode(this.value);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         return format$1(this.value, options);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var value = this._toString(options);
         switch (typeOf$1(this.value)) {
           case 'number':
           case 'BigNumber':
           case 'Fraction':
             return '<span class="math-number">' + value + '</span>';
           case 'string':
             return '<span class="math-string">' + value + '</span>';
           case 'boolean':
             return '<span class="math-boolean">' + value + '</span>';
           case 'null':
             return '<span class="math-null-symbol">' + value + '</span>';
           case 'undefined':
             return '<span class="math-undefined">' + value + '</span>';
           default:
             return '<span class="math-symbol">' + value + '</span>';
         }
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1w,
           value: this.value
         };
       }

       /**
        * Instantiate a ConstantNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "SymbolNode", value: 2.3}`,
        *                       where mathjs is optional
        * @returns {ConstantNode}
        */
       static fromJSON(json) {
         return new ConstantNode(json.value);
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var value = this._toString(options);
         switch (typeOf$1(this.value)) {
           case 'string':
             return '\\mathtt{' + escapeLatex(value) + '}';
           case 'number':
           case 'BigNumber':
             {
               if (!isFinite(this.value)) {
                 return this.value.valueOf() < 0 ? '-\\infty' : '\\infty';
               }
               var index = value.toLowerCase().indexOf('e');
               if (index !== -1) {
                 return value.substring(0, index) + '\\cdot10^{' + value.substring(index + 1) + '}';
               }
             }
             return value;
           case 'Fraction':
             return this.value.toLatex();
           default:
             return value;
         }
       }
     }
     _defineProperty(ConstantNode, "name", name$1w);
     return ConstantNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1v = 'FunctionAssignmentNode';
   var dependencies$1v = ['typed', 'Node'];
   var createFunctionAssignmentNode = /* #__PURE__ */factory(name$1v, dependencies$1v, _ref => {
     var {
       typed,
       Node
     } = _ref;
     /**
      * Is parenthesis needed?
      * @param {Node} node
      * @param {Object} parenthesis
      * @param {string} implicit
      * @private
      */
     function needParenthesis(node, parenthesis, implicit) {
       var precedence = getPrecedence(node, parenthesis, implicit);
       var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
       return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;
     }
     class FunctionAssignmentNode extends Node {
       /**
        * @constructor FunctionAssignmentNode
        * @extends {Node}
        * Function assignment
        *
        * @param {string} name           Function name
        * @param {string[] | Array.<{name: string, type: string}>} params
        *                                Array with function parameter names, or an
        *                                array with objects containing the name
        *                                and type of the parameter
        * @param {Node} expr             The function expression
        */
       constructor(name, params, expr) {
         super();
         // validate input
         if (typeof name !== 'string') {
           throw new TypeError('String expected for parameter "name"');
         }
         if (!Array.isArray(params)) {
           throw new TypeError('Array containing strings or objects expected for parameter "params"');
         }
         if (!isNode(expr)) {
           throw new TypeError('Node expected for parameter "expr"');
         }
         if (keywords.has(name)) {
           throw new Error('Illegal function name, "' + name + '" is a reserved keyword');
         }
         var paramNames = new Set();
         for (var param of params) {
           var _name = typeof param === 'string' ? param : param.name;
           if (paramNames.has(_name)) {
             throw new Error("Duplicate parameter name \"".concat(_name, "\""));
           } else {
             paramNames.add(_name);
           }
         }
         this.name = name;
         this.params = params.map(function (param) {
           return param && param.name || param;
         });
         this.types = params.map(function (param) {
           return param && param.type || 'any';
         });
         this.expr = expr;
       }
       get type() {
         return name$1v;
       }
       get isFunctionAssignmentNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var childArgNames = Object.create(argNames);
         forEach$1(this.params, function (param) {
           childArgNames[param] = true;
         });

         // compile the function expression with the child args
         var evalExpr = this.expr._compile(math, childArgNames);
         var name = this.name;
         var params = this.params;
         var signature = join(this.types, ',');
         var syntax = name + '(' + join(this.params, ', ') + ')';
         return function evalFunctionAssignmentNode(scope, args, context) {
           var signatures = {};
           signatures[signature] = function () {
             var childArgs = Object.create(args);
             for (var i = 0; i < params.length; i++) {
               childArgs[params[i]] = arguments[i];
             }
             return evalExpr(scope, childArgs, context);
           };
           var fn = typed(name, signatures);
           fn.syntax = syntax;
           scope.set(name, fn);
           return fn;
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.expr, 'expr', this);
       }

       /**
        * Create a new FunctionAssignmentNode whose children are the results of
        * calling the provided callback function for each child of the original
        * node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
        */
       map(callback) {
         var expr = this._ifNode(callback(this.expr, 'expr', this));
         return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {FunctionAssignmentNode}
        */
       clone() {
         return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
       }

       /**
        * get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var expr = this.expr.toString(options);
         if (needParenthesis(this, parenthesis, options && options.implicit)) {
           expr = '(' + expr + ')';
         }
         return this.name + '(' + this.params.join(', ') + ') = ' + expr;
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         var types = this.types;
         return {
           mathjs: name$1v,
           name: this.name,
           params: this.params.map(function (param, index) {
             return {
               name: param,
               type: types[index]
             };
           }),
           expr: this.expr
         };
       }

       /**
        * Instantiate an FunctionAssignmentNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     ```
        *     {"mathjs": "FunctionAssignmentNode",
        *      name: ..., params: ..., expr: ...}
        *     ```
        *     where mathjs is optional
        * @returns {FunctionAssignmentNode}
        */
       static fromJSON(json) {
         return new FunctionAssignmentNode(json.name, json.params, json.expr);
       }

       /**
        * get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var params = [];
         for (var i = 0; i < this.params.length; i++) {
           params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + '</span>');
         }
         var expr = this.expr.toHTML(options);
         if (needParenthesis(this, parenthesis, options && options.implicit)) {
           expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         return '<span class="math-function">' + escape(this.name) + '</span>' + '<span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span>' + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + expr;
       }

       /**
        * get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var expr = this.expr.toTex(options);
         if (needParenthesis(this, parenthesis, options && options.implicit)) {
           expr = "\\left(".concat(expr, "\\right)");
         }
         return '\\mathrm{' + this.name + '}\\left(' + this.params.map(toSymbol).join(',') + '\\right):=' + expr;
       }
     }
     _defineProperty(FunctionAssignmentNode, "name", name$1v);
     return FunctionAssignmentNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1u = 'IndexNode';
   var dependencies$1u = ['Node', 'size'];
   var createIndexNode = /* #__PURE__ */factory(name$1u, dependencies$1u, _ref => {
     var {
       Node,
       size
     } = _ref;
     class IndexNode extends Node {
       /**
        * @constructor IndexNode
        * @extends Node
        *
        * Describes a subset of a matrix or an object property.
        * Cannot be used on its own, needs to be used within an AccessorNode or
        * AssignmentNode.
        *
        * @param {Node[]} dimensions
        * @param {boolean} [dotNotation=false]
        *     Optional property describing whether this index was written using dot
        *     notation like `a.b`, or using bracket notation like `a["b"]`
        *     (which is the default). This property is used for string conversion.
        */
       constructor(dimensions, dotNotation) {
         super();
         this.dimensions = dimensions;
         this.dotNotation = dotNotation || false;

         // validate input
         if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
           throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
         }
         if (this.dotNotation && !this.isObjectProperty()) {
           throw new Error('dotNotation only applicable for object properties');
         }
       }
       get type() {
         return name$1u;
       }
       get isIndexNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         // TODO: implement support for bignumber (currently bignumbers are silently
         //       reduced to numbers when changing the value to zero-based)

         // TODO: Optimization: when the range values are ConstantNodes,
         //       we can beforehand resolve the zero-based value

         // optimization for a simple object property
         var evalDimensions = map$1(this.dimensions, function (dimension, i) {
           var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;
           if (needsEnd) {
             // SymbolNode 'end' is used inside the index,
             // like in `A[end]` or `A[end - 2]`
             var childArgNames = Object.create(argNames);
             childArgNames.end = true;
             var _evalDimension = dimension._compile(math, childArgNames);
             return function evalDimension(scope, args, context) {
               if (!isMatrix(context) && !isArray(context) && !isString(context)) {
                 throw new TypeError('Cannot resolve "end": ' + 'context must be a Matrix, Array, or string but is ' + typeOf$1(context));
               }
               var s = size(context).valueOf();
               var childArgs = Object.create(args);
               childArgs.end = s[i];
               return _evalDimension(scope, childArgs, context);
             };
           } else {
             // SymbolNode `end` not used
             return dimension._compile(math, argNames);
           }
         });
         var index = getSafeProperty(math, 'index');
         return function evalIndexNode(scope, args, context) {
           var dimensions = map$1(evalDimensions, function (evalDimension) {
             return evalDimension(scope, args, context);
           });
           return index(...dimensions);
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         for (var i = 0; i < this.dimensions.length; i++) {
           callback(this.dimensions[i], 'dimensions[' + i + ']', this);
         }
       }

       /**
        * Create a new IndexNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {IndexNode} Returns a transformed copy of the node
        */
       map(callback) {
         var dimensions = [];
         for (var i = 0; i < this.dimensions.length; i++) {
           dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));
         }
         return new IndexNode(dimensions, this.dotNotation);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {IndexNode}
        */
       clone() {
         return new IndexNode(this.dimensions.slice(0), this.dotNotation);
       }

       /**
        * Test whether this IndexNode contains a single property name
        * @return {boolean}
        */
       isObjectProperty() {
         return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';
       }

       /**
        * Returns the property name if IndexNode contains a property.
        * If not, returns null.
        * @return {string | null}
        */
       getObjectProperty() {
         return this.isObjectProperty() ? this.dimensions[0].value : null;
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         // format the parameters like "[1, 0:5]"
         return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1u,
           dimensions: this.dimensions,
           dotNotation: this.dotNotation
         };
       }

       /**
        * Instantiate an IndexNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
        *     where mathjs is optional
        * @returns {IndexNode}
        */
       static fromJSON(json) {
         return new IndexNode(json.dimensions, json.dotNotation);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         // format the parameters like "[1, 0:5]"
         var dimensions = [];
         for (var i = 0; i < this.dimensions.length; i++) {
           dimensions[i] = this.dimensions[i].toHTML();
         }
         if (this.dotNotation) {
           return '<span class="math-operator math-accessor-operator">.</span>' + '<span class="math-symbol math-property">' + escape(this.getObjectProperty()) + '</span>';
         } else {
           return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
         }
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var dimensions = this.dimensions.map(function (range) {
           return range.toTex(options);
         });
         return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';
       }
     }
     _defineProperty(IndexNode, "name", name$1u);
     return IndexNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1t = 'ObjectNode';
   var dependencies$1t = ['Node'];
   var createObjectNode = /* #__PURE__ */factory(name$1t, dependencies$1t, _ref => {
     var {
       Node
     } = _ref;
     class ObjectNode extends Node {
       /**
        * @constructor ObjectNode
        * @extends {Node}
        * Holds an object with keys/values
        * @param {Object.<string, Node>} [properties]   object with key/value pairs
        */
       constructor(properties) {
         super();
         this.properties = properties || {};

         // validate input
         if (properties) {
           if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {
             return isNode(properties[key]);
           })) {
             throw new TypeError('Object containing Nodes expected');
           }
         }
       }
       get type() {
         return name$1t;
       }
       get isObjectNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var evalEntries = {};
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             // we stringify/parse the key here to resolve unicode characters,
             // so you cannot create a key like {"co\\u006Estructor": null}
             var stringifiedKey = stringify(key);
             var parsedKey = JSON.parse(stringifiedKey);
             var prop = getSafeProperty(this.properties, key);
             evalEntries[parsedKey] = prop._compile(math, argNames);
           }
         }
         return function evalObjectNode(scope, args, context) {
           var obj = {};
           for (var _key in evalEntries) {
             if (hasOwnProperty(evalEntries, _key)) {
               obj[_key] = evalEntries[_key](scope, args, context);
             }
           }
           return obj;
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             callback(this.properties[key], 'properties[' + stringify(key) + ']', this);
           }
         }
       }

       /**
        * Create a new ObjectNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {ObjectNode} Returns a transformed copy of the node
        */
       map(callback) {
         var properties = {};
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));
           }
         }
         return new ObjectNode(properties);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {ObjectNode}
        */
       clone() {
         var properties = {};
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             properties[key] = this.properties[key];
           }
         }
         return new ObjectNode(properties);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toString(options) {
         var entries = [];
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             entries.push(stringify(key) + ': ' + this.properties[key].toString(options));
           }
         }
         return '{' + entries.join(', ') + '}';
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1t,
           properties: this.properties
         };
       }

       /**
        * Instantiate an OperatorNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
        *                       where mathjs is optional
        * @returns {ObjectNode}
        */
       static fromJSON(json) {
         return new ObjectNode(json.properties);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toHTML(options) {
         var entries = [];
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             entries.push('<span class="math-symbol math-property">' + escape(key) + '</span>' + '<span class="math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator">' + ':</span>' + this.properties[key].toHTML(options));
           }
         }
         return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var entries = [];
         for (var key in this.properties) {
           if (hasOwnProperty(this.properties, key)) {
             entries.push('\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\');
           }
         }
         var tex = '\\left\\{\\begin{array}{ll}' + entries.join('\n') + '\\end{array}\\right\\}';
         return tex;
       }
     }
     _defineProperty(ObjectNode, "name", name$1t);
     return ObjectNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1s = 'OperatorNode';
   var dependencies$1s = ['Node'];
   var createOperatorNode = /* #__PURE__ */factory(name$1s, dependencies$1s, _ref => {
     var {
       Node
     } = _ref;
     /**
      * Returns true if the expression starts with a constant, under
      * the current parenthesization:
      * @param {Node} expression
      * @param {string} parenthesis
      * @return {boolean}
      */
     function startsWithConstant(expr, parenthesis) {
       var curNode = expr;
       if (parenthesis === 'auto') {
         while (isParenthesisNode(curNode)) curNode = curNode.content;
       }
       if (isConstantNode(curNode)) return true;
       if (isOperatorNode(curNode)) {
         return startsWithConstant(curNode.args[0], parenthesis);
       }
       return false;
     }

     /**
      * Calculate which parentheses are necessary. Gets an OperatorNode
      * (which is the root of the tree) and an Array of Nodes
      * (this.args) and returns an array where 'true' means that an argument
      * has to be enclosed in parentheses whereas 'false' means the opposite.
      *
      * @param {OperatorNode} root
      * @param {string} parenthesis
      * @param {Node[]} args
      * @param {boolean} latex
      * @return {boolean[]}
      * @private
      */
     function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
       // precedence of the root OperatorNode
       var precedence = getPrecedence(root, parenthesis, implicit);
       var associativity = getAssociativity(root, parenthesis);
       if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {
         return args.map(function (arg) {
           switch (arg.getContent().type) {
             // Nodes that don't need extra parentheses
             case 'ArrayNode':
             case 'ConstantNode':
             case 'SymbolNode':
             case 'ParenthesisNode':
               return false;
             default:
               return true;
           }
         });
       }
       var result;
       switch (args.length) {
         case 0:
           result = [];
           break;
         case 1:
           // unary operators
           {
             // precedence of the operand
             var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);

             // handle special cases for LaTeX, where some of the parentheses aren't needed
             if (latex && operandPrecedence !== null) {
               var operandIdentifier;
               var rootIdentifier;
               if (parenthesis === 'keep') {
                 operandIdentifier = args[0].getIdentifier();
                 rootIdentifier = root.getIdentifier();
               } else {
                 // Ignore Parenthesis Nodes when not in 'keep' mode
                 operandIdentifier = args[0].getContent().getIdentifier();
                 rootIdentifier = root.getContent().getIdentifier();
               }
               if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                 result = [false];
                 break;
               }
               if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                 result = [false];
                 break;
               }
             }
             if (operandPrecedence === null) {
               // if the operand has no defined precedence, no parens are needed
               result = [false];
               break;
             }
             if (operandPrecedence <= precedence) {
               // if the operands precedence is lower, parens are needed
               result = [true];
               break;
             }

             // otherwise, no parens needed
             result = [false];
           }
           break;
         case 2:
           // binary operators
           {
             var lhsParens; // left hand side needs parenthesis?
             // precedence of the left hand side
             var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
             // is the root node associative with the left hand side
             var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
             if (lhsPrecedence === null) {
               // if the left hand side has no defined precedence, no parens are needed
               // FunctionNode for example
               lhsParens = false;
             } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {
               // In case of equal precedence, if the root node is left associative
               // parens are **never** necessary for the left hand side.
               // If it is right associative however, parens are necessary
               // if the root node isn't associative with the left hand side
               lhsParens = true;
             } else if (lhsPrecedence < precedence) {
               lhsParens = true;
             } else {
               lhsParens = false;
             }
             var rhsParens; // right hand side needs parenthesis?
             // precedence of the right hand side
             var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
             // is the root node associative with the right hand side?
             var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
             if (rhsPrecedence === null) {
               // if the right hand side has no defined precedence, no parens are needed
               // FunctionNode for example
               rhsParens = false;
             } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {
               // In case of equal precedence, if the root node is right associative
               // parens are **never** necessary for the right hand side.
               // If it is left associative however, parens are necessary
               // if the root node isn't associative with the right hand side
               rhsParens = true;
             } else if (rhsPrecedence < precedence) {
               rhsParens = true;
             } else {
               rhsParens = false;
             }

             // handle special cases for LaTeX, where some of the parentheses aren't needed
             if (latex) {
               var _rootIdentifier;
               var lhsIdentifier;
               var rhsIdentifier;
               if (parenthesis === 'keep') {
                 _rootIdentifier = root.getIdentifier();
                 lhsIdentifier = root.args[0].getIdentifier();
                 rhsIdentifier = root.args[1].getIdentifier();
               } else {
                 // Ignore ParenthesisNodes when not in 'keep' mode
                 _rootIdentifier = root.getContent().getIdentifier();
                 lhsIdentifier = root.args[0].getContent().getIdentifier();
                 rhsIdentifier = root.args[1].getContent().getIdentifier();
               }
               if (lhsPrecedence !== null) {
                 if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                   lhsParens = false;
                 }
                 if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                   lhsParens = false;
                 }
               }
               if (rhsPrecedence !== null) {
                 if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                   rhsParens = false;
                 }
                 if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                   rhsParens = false;
                 }
               }
             }
             result = [lhsParens, rhsParens];
           }
           break;
         default:
           if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {
             result = args.map(function (arg) {
               var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);
               var assocWithArg = isAssociativeWith(root, arg, parenthesis);
               var argAssociativity = getAssociativity(arg, parenthesis);
               if (argPrecedence === null) {
                 // if the argument has no defined precedence, no parens are needed
                 return false;
               } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                 return true;
               } else if (argPrecedence < precedence) {
                 return true;
               }
               return false;
             });
           }
           break;
       }

       // Handles an edge case of parentheses with implicit multiplication
       // of ConstantNode.
       // In that case, parenthesize ConstantNodes that follow an unparenthesized
       // expression, even though they normally wouldn't be printed.
       if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {
         for (var i = 1; i < result.length; ++i) {
           if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {
             result[i] = true;
           }
         }
       }
       return result;
     }
     class OperatorNode extends Node {
       /**
        * @constructor OperatorNode
        * @extends {Node}
        * An operator with two arguments, like 2+3
        *
        * @param {string} op           Operator name, for example '+'
        * @param {string} fn           Function name, for example 'add'
        * @param {Node[]} args         Operator arguments
        * @param {boolean} [implicit]  Is this an implicit multiplication?
        * @param {boolean} [isPercentage] Is this an percentage Operation?
        */
       constructor(op, fn, args, implicit, isPercentage) {
         super();
         // validate input
         if (typeof op !== 'string') {
           throw new TypeError('string expected for parameter "op"');
         }
         if (typeof fn !== 'string') {
           throw new TypeError('string expected for parameter "fn"');
         }
         if (!Array.isArray(args) || !args.every(isNode)) {
           throw new TypeError('Array containing Nodes expected for parameter "args"');
         }
         this.implicit = implicit === true;
         this.isPercentage = isPercentage === true;
         this.op = op;
         this.fn = fn;
         this.args = args || [];
       }
       get type() {
         return name$1s;
       }
       get isOperatorNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         // validate fn
         if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {
           if (!math[this.fn]) {
             throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
           } else {
             throw new Error('No access to function "' + this.fn + '"');
           }
         }
         var fn = getSafeProperty(math, this.fn);
         var evalArgs = map$1(this.args, function (arg) {
           return arg._compile(math, argNames);
         });
         if (evalArgs.length === 1) {
           var evalArg0 = evalArgs[0];
           return function evalOperatorNode(scope, args, context) {
             return fn(evalArg0(scope, args, context));
           };
         } else if (evalArgs.length === 2) {
           var _evalArg = evalArgs[0];
           var evalArg1 = evalArgs[1];
           return function evalOperatorNode(scope, args, context) {
             return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
           };
         } else {
           return function evalOperatorNode(scope, args, context) {
             return fn.apply(null, map$1(evalArgs, function (evalArg) {
               return evalArg(scope, args, context);
             }));
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         for (var i = 0; i < this.args.length; i++) {
           callback(this.args[i], 'args[' + i + ']', this);
         }
       }

       /**
        * Create a new OperatorNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {OperatorNode} Returns a transformed copy of the node
        */
       map(callback) {
         var args = [];
         for (var i = 0; i < this.args.length; i++) {
           args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
         }
         return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {OperatorNode}
        */
       clone() {
         return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
       }

       /**
        * Check whether this is an unary OperatorNode:
        * has exactly one argument, like `-a`.
        * @return {boolean}
        *     Returns true when an unary operator node, false otherwise.
        */
       isUnary() {
         return this.args.length === 1;
       }

       /**
        * Check whether this is a binary OperatorNode:
        * has exactly two arguments, like `a + b`.
        * @return {boolean}
        *     Returns true when a binary operator node, false otherwise.
        */
       isBinary() {
         return this.args.length === 2;
       }

       /**
        * Get string representation.
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var implicit = options && options.implicit ? options.implicit : 'hide';
         var args = this.args;
         var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
         if (args.length === 1) {
           // unary operators
           var assoc = getAssociativity(this, parenthesis);
           var operand = args[0].toString(options);
           if (parens[0]) {
             operand = '(' + operand + ')';
           }

           // for example for "not", we want a space between operand and argument
           var opIsNamed = /[a-zA-Z]+/.test(this.op);
           if (assoc === 'right') {
             // prefix operator
             return this.op + (opIsNamed ? ' ' : '') + operand;
           } else if (assoc === 'left') {
             // postfix
             return operand + (opIsNamed ? ' ' : '') + this.op;
           }

           // fall back to postfix
           return operand + this.op;
         } else if (args.length === 2) {
           var lhs = args[0].toString(options); // left hand side
           var rhs = args[1].toString(options); // right hand side
           if (parens[0]) {
             // left hand side in parenthesis?
             lhs = '(' + lhs + ')';
           }
           if (parens[1]) {
             // right hand side in parenthesis?
             rhs = '(' + rhs + ')';
           }
           if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
             return lhs + ' ' + rhs;
           }
           return lhs + ' ' + this.op + ' ' + rhs;
         } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
           var stringifiedArgs = args.map(function (arg, index) {
             arg = arg.toString(options);
             if (parens[index]) {
               // put in parenthesis?
               arg = '(' + arg + ')';
             }
             return arg;
           });
           if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
             return stringifiedArgs.join(' ');
           }
           return stringifiedArgs.join(' ' + this.op + ' ');
         } else {
           // fallback to formatting as a function call
           return this.fn + '(' + this.args.join(', ') + ')';
         }
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1s,
           op: this.op,
           fn: this.fn,
           args: this.args,
           implicit: this.implicit,
           isPercentage: this.isPercentage
         };
       }

       /**
        * Instantiate an OperatorNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     ```
        *     {"mathjs": "OperatorNode",
        *      "op": "+", "fn": "add", "args": [...],
        *      "implicit": false,
        *      "isPercentage":false}
        *     ```
        *     where mathjs is optional
        * @returns {OperatorNode}
        */
       static fromJSON(json) {
         return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);
       }

       /**
        * Get HTML representation.
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var implicit = options && options.implicit ? options.implicit : 'hide';
         var args = this.args;
         var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
         if (args.length === 1) {
           // unary operators
           var assoc = getAssociativity(this, parenthesis);
           var operand = args[0].toHTML(options);
           if (parens[0]) {
             operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
           }
           if (assoc === 'right') {
             // prefix operator
             return '<span class="math-operator math-unary-operator ' + 'math-lefthand-unary-operator">' + escape(this.op) + '</span>' + operand;
           } else {
             // postfix when assoc === 'left' or undefined
             return operand + '<span class="math-operator math-unary-operator ' + 'math-righthand-unary-operator">' + escape(this.op) + '</span>';
           }
         } else if (args.length === 2) {
           // binary operatoes
           var lhs = args[0].toHTML(options); // left hand side
           var rhs = args[1].toHTML(options); // right hand side
           if (parens[0]) {
             // left hand side in parenthesis?
             lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
           }
           if (parens[1]) {
             // right hand side in parenthesis?
             rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
           }
           if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
             return lhs + '<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>' + rhs;
           }
           return lhs + '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + '</span>' + rhs;
         } else {
           var stringifiedArgs = args.map(function (arg, index) {
             arg = arg.toHTML(options);
             if (parens[index]) {
               // put in parenthesis?
               arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
             }
             return arg;
           });
           if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
             if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
               return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>');
             }
             return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + '</span>');
           } else {
             // fallback to formatting as a function call
             return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">' + '(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
           }
         }
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var implicit = options && options.implicit ? options.implicit : 'hide';
         var args = this.args;
         var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
         var op = latexOperators[this.fn];
         op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op

         if (args.length === 1) {
           // unary operators
           var assoc = getAssociativity(this, parenthesis);
           var operand = args[0].toTex(options);
           if (parens[0]) {
             operand = "\\left(".concat(operand, "\\right)");
           }
           if (assoc === 'right') {
             // prefix operator
             return op + operand;
           } else if (assoc === 'left') {
             // postfix operator
             return operand + op;
           }

           // fall back to postfix
           return operand + op;
         } else if (args.length === 2) {
           // binary operators
           var lhs = args[0]; // left hand side
           var lhsTex = lhs.toTex(options);
           if (parens[0]) {
             lhsTex = "\\left(".concat(lhsTex, "\\right)");
           }
           var rhs = args[1]; // right hand side
           var rhsTex = rhs.toTex(options);
           if (parens[1]) {
             rhsTex = "\\left(".concat(rhsTex, "\\right)");
           }

           // handle some exceptions (due to the way LaTeX works)
           var lhsIdentifier;
           if (parenthesis === 'keep') {
             lhsIdentifier = lhs.getIdentifier();
           } else {
             // Ignore ParenthesisNodes if in 'keep' mode
             lhsIdentifier = lhs.getContent().getIdentifier();
           }
           switch (this.getIdentifier()) {
             case 'OperatorNode:divide':
               // op contains '\\frac' at this point
               return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';
             case 'OperatorNode:pow':
               lhsTex = '{' + lhsTex + '}';
               rhsTex = '{' + rhsTex + '}';
               switch (lhsIdentifier) {
                 case 'ConditionalNode': //
                 case 'OperatorNode:divide':
                   lhsTex = "\\left(".concat(lhsTex, "\\right)");
               }
               break;
             case 'OperatorNode:multiply':
               if (this.implicit && implicit === 'hide') {
                 return lhsTex + '~' + rhsTex;
               }
           }
           return lhsTex + op + rhsTex;
         } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
           var texifiedArgs = args.map(function (arg, index) {
             arg = arg.toTex(options);
             if (parens[index]) {
               arg = "\\left(".concat(arg, "\\right)");
             }
             return arg;
           });
           if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {
             return texifiedArgs.join('~');
           }
           return texifiedArgs.join(op);
         } else {
           // fall back to formatting as a function call
           // as this is a fallback, it doesn't use
           // fancy function names
           return '\\mathrm{' + this.fn + '}\\left(' + args.map(function (arg) {
             return arg.toTex(options);
           }).join(',') + '\\right)';
         }
       }

       /**
        * Get identifier.
        * @return {string}
        */
       getIdentifier() {
         return this.type + ':' + this.fn;
       }
     }
     _defineProperty(OperatorNode, "name", name$1s);
     return OperatorNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1r = 'ParenthesisNode';
   var dependencies$1r = ['Node'];
   var createParenthesisNode = /* #__PURE__ */factory(name$1r, dependencies$1r, _ref => {
     var {
       Node
     } = _ref;
     class ParenthesisNode extends Node {
       /**
        * @constructor ParenthesisNode
        * @extends {Node}
        * A parenthesis node describes manual parenthesis from the user input
        * @param {Node} content
        * @extends {Node}
        */
       constructor(content) {
         super();
         // validate input
         if (!isNode(content)) {
           throw new TypeError('Node expected for parameter "content"');
         }
         this.content = content;
       }
       get type() {
         return name$1r;
       }
       get isParenthesisNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         return this.content._compile(math, argNames);
       }

       /**
        * Get the content of the current Node.
        * @return {Node} content
        * @override
        **/
       getContent() {
         return this.content.getContent();
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.content, 'content', this);
       }

       /**
        * Create a new ParenthesisNode whose child is the result of calling
        * the provided callback function on the child of this node.
        * @param {function(child: Node, path: string, parent: Node) : Node} callback
        * @returns {ParenthesisNode} Returns a clone of the node
        */
       map(callback) {
         var content = callback(this.content, 'content', this);
         return new ParenthesisNode(content);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {ParenthesisNode}
        */
       clone() {
         return new ParenthesisNode(this.content);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toString(options) {
         if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
           return '(' + this.content.toString(options) + ')';
         }
         return this.content.toString(options);
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1r,
           content: this.content
         };
       }

       /**
        * Instantiate an ParenthesisNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
        *                       where mathjs is optional
        * @returns {ParenthesisNode}
        */
       static fromJSON(json) {
         return new ParenthesisNode(json.content);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toHTML(options) {
         if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
           return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         return this.content.toHTML(options);
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toTex(options) {
         if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
           return "\\left(".concat(this.content.toTex(options), "\\right)");
         }
         return this.content.toTex(options);
       }
     }
     _defineProperty(ParenthesisNode, "name", name$1r);
     return ParenthesisNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1q = 'RangeNode';
   var dependencies$1q = ['Node'];
   var createRangeNode = /* #__PURE__ */factory(name$1q, dependencies$1q, _ref => {
     var {
       Node
     } = _ref;
     /**
      * Calculate the necessary parentheses
      * @param {Node} node
      * @param {string} parenthesis
      * @param {string} implicit
      * @return {Object} parentheses
      * @private
      */
     function calculateNecessaryParentheses(node, parenthesis, implicit) {
       var precedence = getPrecedence(node, parenthesis, implicit);
       var parens = {};
       var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
       parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';
       if (node.step) {
         var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
         parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';
       }
       var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
       parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';
       return parens;
     }
     class RangeNode extends Node {
       /**
        * @constructor RangeNode
        * @extends {Node}
        * create a range
        * @param {Node} start  included lower-bound
        * @param {Node} end    included upper-bound
        * @param {Node} [step] optional step
        */
       constructor(start, end, step) {
         super();
         // validate inputs
         if (!isNode(start)) throw new TypeError('Node expected');
         if (!isNode(end)) throw new TypeError('Node expected');
         if (step && !isNode(step)) throw new TypeError('Node expected');
         if (arguments.length > 3) throw new Error('Too many arguments');
         this.start = start; // included lower-bound
         this.end = end; // included upper-bound
         this.step = step || null; // optional step
       }

       get type() {
         return name$1q;
       }
       get isRangeNode() {
         return true;
       }

       /**
        * Check whether the RangeNode needs the `end` symbol to be defined.
        * This end is the size of the Matrix in current dimension.
        * @return {boolean}
        */
       needsEnd() {
         // find all `end` symbols in this RangeNode
         var endSymbols = this.filter(function (node) {
           return isSymbolNode(node) && node.name === 'end';
         });
         return endSymbols.length > 0;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var range = math.range;
         var evalStart = this.start._compile(math, argNames);
         var evalEnd = this.end._compile(math, argNames);
         if (this.step) {
           var evalStep = this.step._compile(math, argNames);
           return function evalRangeNode(scope, args, context) {
             return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
           };
         } else {
           return function evalRangeNode(scope, args, context) {
             return range(evalStart(scope, args, context), evalEnd(scope, args, context));
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.start, 'start', this);
         callback(this.end, 'end', this);
         if (this.step) {
           callback(this.step, 'step', this);
         }
       }

       /**
        * Create a new RangeNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {RangeNode} Returns a transformed copy of the node
        */
       map(callback) {
         return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {RangeNode}
        */
       clone() {
         return new RangeNode(this.start, this.end, this.step && this.step);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);

         // format string as start:step:stop
         var str;
         var start = this.start.toString(options);
         if (parens.start) {
           start = '(' + start + ')';
         }
         str = start;
         if (this.step) {
           var step = this.step.toString(options);
           if (parens.step) {
             step = '(' + step + ')';
           }
           str += ':' + step;
         }
         var end = this.end.toString(options);
         if (parens.end) {
           end = '(' + end + ')';
         }
         str += ':' + end;
         return str;
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1q,
           start: this.start,
           end: this.end,
           step: this.step
         };
       }

       /**
        * Instantiate an RangeNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
        *     where mathjs is optional
        * @returns {RangeNode}
        */
       static fromJSON(json) {
         return new RangeNode(json.start, json.end, json.step);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);

         // format string as start:step:stop
         var str;
         var start = this.start.toHTML(options);
         if (parens.start) {
           start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         str = start;
         if (this.step) {
           var step = this.step.toHTML(options);
           if (parens.step) {
             step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
           }
           str += '<span class="math-operator math-range-operator">:</span>' + step;
         }
         var end = this.end.toHTML(options);
         if (parens.end) {
           end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
         }
         str += '<span class="math-operator math-range-operator">:</span>' + end;
         return str;
       }

       /**
        * Get LaTeX representation
        * @params {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
         var str = this.start.toTex(options);
         if (parens.start) {
           str = "\\left(".concat(str, "\\right)");
         }
         if (this.step) {
           var step = this.step.toTex(options);
           if (parens.step) {
             step = "\\left(".concat(step, "\\right)");
           }
           str += ':' + step;
         }
         var end = this.end.toTex(options);
         if (parens.end) {
           end = "\\left(".concat(end, "\\right)");
         }
         str += ':' + end;
         return str;
       }
     }
     _defineProperty(RangeNode, "name", name$1q);
     return RangeNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1p = 'RelationalNode';
   var dependencies$1p = ['Node'];
   var createRelationalNode = /* #__PURE__ */factory(name$1p, dependencies$1p, _ref => {
     var {
       Node
     } = _ref;
     var operatorMap = {
       equal: '==',
       unequal: '!=',
       smaller: '<',
       larger: '>',
       smallerEq: '<=',
       largerEq: '>='
     };
     class RelationalNode extends Node {
       /**
        * A node representing a chained conditional expression, such as 'x > y > z'
        *
        * @param {String[]} conditionals
        *     An array of conditional operators used to compare the parameters
        * @param {Node[]} params
        *     The parameters that will be compared
        *
        * @constructor RelationalNode
        * @extends {Node}
        */
       constructor(conditionals, params) {
         super();
         if (!Array.isArray(conditionals)) {
           throw new TypeError('Parameter conditionals must be an array');
         }
         if (!Array.isArray(params)) {
           throw new TypeError('Parameter params must be an array');
         }
         if (conditionals.length !== params.length - 1) {
           throw new TypeError('Parameter params must contain exactly one more element ' + 'than parameter conditionals');
         }
         this.conditionals = conditionals;
         this.params = params;
       }
       get type() {
         return name$1p;
       }
       get isRelationalNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var self = this;
         var compiled = this.params.map(p => p._compile(math, argNames));
         return function evalRelationalNode(scope, args, context) {
           var evalLhs;
           var evalRhs = compiled[0](scope, args, context);
           for (var i = 0; i < self.conditionals.length; i++) {
             evalLhs = evalRhs;
             evalRhs = compiled[i + 1](scope, args, context);
             var condFn = getSafeProperty(math, self.conditionals[i]);
             if (!condFn(evalLhs, evalRhs)) {
               return false;
             }
           }
           return true;
         };
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);
       }

       /**
        * Create a new RelationalNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {RelationalNode} Returns a transformed copy of the node
        */
       map(callback) {
         return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {RelationalNode}
        */
       clone() {
         return new RelationalNode(this.conditionals, this.params);
       }

       /**
        * Get string representation.
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var precedence = getPrecedence(this, parenthesis, options && options.implicit);
         var paramStrings = this.params.map(function (p, index) {
           var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
           return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);
         });
         var ret = paramStrings[0];
         for (var i = 0; i < this.conditionals.length; i++) {
           ret += ' ' + operatorMap[this.conditionals[i]];
           ret += ' ' + paramStrings[i + 1];
         }
         return ret;
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1p,
           conditionals: this.conditionals,
           params: this.params
         };
       }

       /**
        * Instantiate a RelationalNode from its JSON representation
        * @param {Object} json
        *     An object structured like
        *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
        *     where mathjs is optional
        * @returns {RelationalNode}
        */
       static fromJSON(json) {
         return new RelationalNode(json.conditionals, json.params);
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var precedence = getPrecedence(this, parenthesis, options && options.implicit);
         var paramStrings = this.params.map(function (p, index) {
           var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
           return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
         });
         var ret = paramStrings[0];
         for (var i = 0; i < this.conditionals.length; i++) {
           ret += '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];
         }
         return ret;
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
         var precedence = getPrecedence(this, parenthesis, options && options.implicit);
         var paramStrings = this.params.map(function (p, index) {
           var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
           return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\left(' + p.toTex(options) + '\right)' : p.toTex(options);
         });
         var ret = paramStrings[0];
         for (var i = 0; i < this.conditionals.length; i++) {
           ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
         }
         return ret;
       }
     }
     _defineProperty(RelationalNode, "name", name$1p);
     return RelationalNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1o = 'SymbolNode';
   var dependencies$1o = ['math', '?Unit', 'Node'];
   var createSymbolNode = /* #__PURE__ */factory(name$1o, dependencies$1o, _ref => {
     var {
       math,
       Unit,
       Node
     } = _ref;
     /**
      * Check whether some name is a valueless unit like "inch".
      * @param {string} name
      * @return {boolean}
      */
     function isValuelessUnit(name) {
       return Unit ? Unit.isValuelessUnit(name) : false;
     }
     class SymbolNode extends Node {
       /**
        * @constructor SymbolNode
        * @extends {Node}
        * A symbol node can hold and resolve a symbol
        * @param {string} name
        * @extends {Node}
        */
       constructor(name) {
         super();
         // validate input
         if (typeof name !== 'string') {
           throw new TypeError('String expected for parameter "name"');
         }
         this.name = name;
       }
       get type() {
         return 'SymbolNode';
       }
       get isSymbolNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         var name = this.name;
         if (argNames[name] === true) {
           // this is a FunctionAssignment argument
           // (like an x when inside the expression of a function
           // assignment `f(x) = ...`)
           return function (scope, args, context) {
             return getSafeProperty(args, name);
           };
         } else if (name in math) {
           return function (scope, args, context) {
             return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);
           };
         } else {
           var isUnit = isValuelessUnit(name);
           return function (scope, args, context) {
             return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         // nothing to do, we don't have any children
       }

       /**
        * Create a new SymbolNode with children produced by the given callback.
        * Trivial since a SymbolNode has no children
        * @param {function(child: Node, path: string, parent: Node) : Node} callback
        * @returns {SymbolNode} Returns a clone of the node
        */
       map(callback) {
         return this.clone();
       }

       /**
        * Throws an error 'Undefined symbol {name}'
        * @param {string} name
        */
       static onUndefinedSymbol(name) {
         throw new Error('Undefined symbol ' + name);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {SymbolNode}
        */
       clone() {
         return new SymbolNode(this.name);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toString(options) {
         return this.name;
       }

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toHTML(options) {
         var name = escape(this.name);
         if (name === 'true' || name === 'false') {
           return '<span class="math-symbol math-boolean">' + name + '</span>';
         } else if (name === 'i') {
           return '<span class="math-symbol math-imaginary-symbol">' + name + '</span>';
         } else if (name === 'Infinity') {
           return '<span class="math-symbol math-infinity-symbol">' + name + '</span>';
         } else if (name === 'NaN') {
           return '<span class="math-symbol math-nan-symbol">' + name + '</span>';
         } else if (name === 'null') {
           return '<span class="math-symbol math-null-symbol">' + name + '</span>';
         } else if (name === 'undefined') {
           return '<span class="math-symbol math-undefined-symbol">' + name + '</span>';
         }
         return '<span class="math-symbol">' + name + '</span>';
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: 'SymbolNode',
           name: this.name
         };
       }

       /**
        * Instantiate a SymbolNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "SymbolNode", name: "x"}`,
        *                       where mathjs is optional
        * @returns {SymbolNode}
        */
       static fromJSON(json) {
         return new SymbolNode(json.name);
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        * @override
        */
       _toTex(options) {
         var isUnit = false;
         if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {
           isUnit = true;
         }
         var symbol = toSymbol(this.name, isUnit);
         if (symbol[0] === '\\') {
           // no space needed if the symbol starts with '\'
           return symbol;
         }
         // the space prevents symbols from breaking stuff like '\cdot'
         // if it's written right before the symbol
         return ' ' + symbol;
       }
     }
     return SymbolNode;
   }, {
     isClass: true,
     isNode: true
   });

   /**
    * Create a new scope which can access the parent scope,
    * but does not affect it when written. This is suitable for variable definitions
    * within a block node, or function definition.
    *
    * If parent scope has a createSubScope method, it delegates to that. Otherwise,
    * creates an empty map, and copies the parent scope to it, adding in
    * the remaining `args`.
    *
    * @param {Map} parentScope
    * @param  {...any} args
    * @returns {Map}
    */
   function createSubScope(parentScope) {
     for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       args[_key - 1] = arguments[_key];
     }
     if (typeof parentScope.createSubScope === 'function') {
       return assign(parentScope.createSubScope(), ...args);
     }
     return assign(createEmptyMap(), parentScope, ...args);
   }

   var name$1n = 'FunctionNode';
   var dependencies$1n = ['math', 'Node', 'SymbolNode'];
   var createFunctionNode = /* #__PURE__ */factory(name$1n, dependencies$1n, _ref => {
     var {
       math,
       Node,
       SymbolNode
     } = _ref;
     /* format to fixed length */
     var strin = entity => format$1(entity, {
       truncate: 78
     });

     /*
      * Expand a LaTeX template
      *
      * @param {string} template
      * @param {Node} node
      * @param {Object} options
      * @private
      **/
     function expandTemplate(template, node, options) {
       var latex = '';

       // Match everything of the form ${identifier} or ${identifier[2]} or $$
       // while submatching identifier and 2 (in the second case)
       var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
       var inputPos = 0; // position in the input string
       var match;
       while ((match = regex.exec(template)) !== null) {
         // go through all matches
         // add everything in front of the match to the LaTeX string
         latex += template.substring(inputPos, match.index);
         inputPos = match.index;
         if (match[0] === '$$') {
           // escaped dollar sign
           latex += '$';
           inputPos++;
         } else {
           // template parameter
           inputPos += match[0].length;
           var property = node[match[1]];
           if (!property) {
             throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');
           }
           if (match[2] === undefined) {
             // no square brackets
             switch (typeof property) {
               case 'string':
                 latex += property;
                 break;
               case 'object':
                 if (isNode(property)) {
                   latex += property.toTex(options);
                 } else if (Array.isArray(property)) {
                   // make array of Nodes into comma separated list
                   latex += property.map(function (arg, index) {
                     if (isNode(arg)) {
                       return arg.toTex(options);
                     }
                     throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');
                   }).join(',');
                 } else {
                   throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
                 }
                 break;
               default:
                 throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
             }
           } else {
             // with square brackets
             if (isNode(property[match[2]] && property[match[2]])) {
               latex += property[match[2]].toTex(options);
             } else {
               throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');
             }
           }
         }
       }
       latex += template.slice(inputPos); // append rest of the template

       return latex;
     }
     class FunctionNode extends Node {
       /**
        * @constructor FunctionNode
        * @extends {./Node}
        * invoke a list with arguments on a node
        * @param {./Node | string} fn
        *     Item resolving to a function on which to invoke
        *     the arguments, typically a SymboNode or AccessorNode
        * @param {./Node[]} args
        */
       constructor(fn, args) {
         super();
         if (typeof fn === 'string') {
           fn = new SymbolNode(fn);
         }

         // validate input
         if (!isNode(fn)) throw new TypeError('Node expected as parameter "fn"');
         if (!Array.isArray(args) || !args.every(isNode)) {
           throw new TypeError('Array containing Nodes expected for parameter "args"');
         }
         this.fn = fn;
         this.args = args || [];
       }

       // readonly property name
       get name() {
         return this.fn.name || '';
       }
       get type() {
         return name$1n;
       }
       get isFunctionNode() {
         return true;
       }

       /**
        * Compile a node into a JavaScript function.
        * This basically pre-calculates as much as possible and only leaves open
        * calculations which depend on a dynamic scope with variables.
        * @param {Object} math     Math.js namespace with functions and constants.
        * @param {Object} argNames An object with argument names as key and `true`
        *                          as value. Used in the SymbolNode to optimize
        *                          for arguments from user assigned functions
        *                          (see FunctionAssignmentNode) or special symbols
        *                          like `end` (see IndexNode).
        * @return {function} Returns a function which can be called like:
        *                        evalNode(scope: Object, args: Object, context: *)
        */
       _compile(math, argNames) {
         // compile arguments
         var evalArgs = this.args.map(arg => arg._compile(math, argNames));
         if (isSymbolNode(this.fn)) {
           var _name = this.fn.name;
           if (!argNames[_name]) {
             // we can statically determine whether the function
             // has the rawArgs property
             var fn = _name in math ? getSafeProperty(math, _name) : undefined;
             var isRaw = typeof fn === 'function' && fn.rawArgs === true;
             var resolveFn = scope => {
               var value;
               if (scope.has(_name)) {
                 value = scope.get(_name);
               } else if (_name in math) {
                 value = getSafeProperty(math, _name);
               } else {
                 return FunctionNode.onUndefinedFunction(_name);
               }
               if (typeof value === 'function') {
                 return value;
               }
               throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
             };
             if (isRaw) {
               // pass unevaluated parameters (nodes) to the function
               // "raw" evaluation
               var rawArgs = this.args;
               return function evalFunctionNode(scope, args, context) {
                 var fn = resolveFn(scope);
                 return fn(rawArgs, math, createSubScope(scope, args), scope);
               };
             } else {
               // "regular" evaluation
               switch (evalArgs.length) {
                 case 0:
                   return function evalFunctionNode(scope, args, context) {
                     var fn = resolveFn(scope);
                     return fn();
                   };
                 case 1:
                   return function evalFunctionNode(scope, args, context) {
                     var fn = resolveFn(scope);
                     var evalArg0 = evalArgs[0];
                     return fn(evalArg0(scope, args, context));
                   };
                 case 2:
                   return function evalFunctionNode(scope, args, context) {
                     var fn = resolveFn(scope);
                     var evalArg0 = evalArgs[0];
                     var evalArg1 = evalArgs[1];
                     return fn(evalArg0(scope, args, context), evalArg1(scope, args, context));
                   };
                 default:
                   return function evalFunctionNode(scope, args, context) {
                     var fn = resolveFn(scope);
                     var values = evalArgs.map(evalArg => evalArg(scope, args, context));
                     return fn(...values);
                   };
               }
             }
           } else {
             // the function symbol is an argName
             var _rawArgs = this.args;
             return function evalFunctionNode(scope, args, context) {
               var fn = getSafeProperty(args, _name);
               if (typeof fn !== 'function') {
                 throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn)));
               }
               if (fn.rawArgs) {
                 // "Raw" evaluation
                 return fn(_rawArgs, math, createSubScope(scope, args), scope);
               } else {
                 var values = evalArgs.map(evalArg => evalArg(scope, args, context));
                 return fn.apply(fn, values);
               }
             };
           }
         } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
           // execute the function with the right context:
           // the object of the AccessorNode

           var evalObject = this.fn.object._compile(math, argNames);
           var prop = this.fn.index.getObjectProperty();
           var _rawArgs2 = this.args;
           return function evalFunctionNode(scope, args, context) {
             var object = evalObject(scope, args, context);
             var fn = getSafeMethod(object, prop);
             if (fn !== null && fn !== void 0 && fn.rawArgs) {
               // "Raw" evaluation
               return fn(_rawArgs2, math, createSubScope(scope, args), scope);
             } else {
               // "regular" evaluation
               var values = evalArgs.map(evalArg => evalArg(scope, args, context));
               return fn.apply(object, values);
             }
           };
         } else {
           // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()
           // we have to dynamically determine whether the function has the
           // rawArgs property
           var fnExpr = this.fn.toString();
           var evalFn = this.fn._compile(math, argNames);
           var _rawArgs3 = this.args;
           return function evalFunctionNode(scope, args, context) {
             var fn = evalFn(scope, args, context);
             if (typeof fn !== 'function') {
               throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn)));
             }
             if (fn.rawArgs) {
               // "Raw" evaluation
               return fn(_rawArgs3, math, createSubScope(scope, args), scope);
             } else {
               // "regular" evaluation
               var values = evalArgs.map(evalArg => evalArg(scope, args, context));
               return fn.apply(fn, values);
             }
           };
         }
       }

       /**
        * Execute a callback for each of the child nodes of this node
        * @param {function(child: Node, path: string, parent: Node)} callback
        */
       forEach(callback) {
         callback(this.fn, 'fn', this);
         for (var i = 0; i < this.args.length; i++) {
           callback(this.args[i], 'args[' + i + ']', this);
         }
       }

       /**
        * Create a new FunctionNode whose children are the results of calling
        * the provided callback function for each child of the original node.
        * @param {function(child: Node, path: string, parent: Node): Node} callback
        * @returns {FunctionNode} Returns a transformed copy of the node
        */
       map(callback) {
         var fn = this._ifNode(callback(this.fn, 'fn', this));
         var args = [];
         for (var i = 0; i < this.args.length; i++) {
           args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
         }
         return new FunctionNode(fn, args);
       }

       /**
        * Create a clone of this node, a shallow copy
        * @return {FunctionNode}
        */
       clone() {
         return new FunctionNode(this.fn, this.args.slice(0));
       }

       /**
        * Throws an error 'Undefined function {name}'
        * @param {string} name
        */

       /**
        * Get string representation. (wrapper function)
        * This overrides parts of Node's toString function.
        * If callback is an object containing callbacks, it
        * calls the correct callback for the current node,
        * otherwise it falls back to calling Node's toString
        * function.
        *
        * @param {Object} options
        * @return {string} str
        * @override
        */
       toString(options) {
         var customString;
         var name = this.fn.toString(options);
         if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, name)) {
           // callback is a map of callback functions
           customString = options.handler[name](this, options);
         }
         if (typeof customString !== 'undefined') {
           return customString;
         }

         // fall back to Node's toString
         return super.toString(options);
       }

       /**
        * Get string representation
        * @param {Object} options
        * @return {string} str
        */
       _toString(options) {
         var args = this.args.map(function (arg) {
           return arg.toString(options);
         });
         var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options);

         // format the arguments like "add(2, 4.2)"
         return fn + '(' + args.join(', ') + ')';
       }

       /**
        * Get a JSON representation of the node
        * @returns {Object}
        */
       toJSON() {
         return {
           mathjs: name$1n,
           fn: this.fn,
           args: this.args
         };
       }

       /**
        * Instantiate an AssignmentNode from its JSON representation
        * @param {Object} json  An object structured like
        *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
        *                       where mathjs is optional
        * @returns {FunctionNode}
        */

       /**
        * Get HTML representation
        * @param {Object} options
        * @return {string} str
        */
       toHTML(options) {
         var args = this.args.map(function (arg) {
           return arg.toHTML(options);
         });

         // format the arguments like "add(2, 4.2)"
         return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
       }

       /**
        * Get LaTeX representation. (wrapper function)
        * This overrides parts of Node's toTex function.
        * If callback is an object containing callbacks, it
        * calls the correct callback for the current node,
        * otherwise it falls back to calling Node's toTex
        * function.
        *
        * @param {Object} options
        * @return {string}
        */
       toTex(options) {
         var customTex;
         if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, this.name)) {
           // callback is a map of callback functions
           customTex = options.handler[this.name](this, options);
         }
         if (typeof customTex !== 'undefined') {
           return customTex;
         }

         // fall back to Node's toTex
         return super.toTex(options);
       }

       /**
        * Get LaTeX representation
        * @param {Object} options
        * @return {string} str
        */
       _toTex(options) {
         var args = this.args.map(function (arg) {
           // get LaTeX of the arguments
           return arg.toTex(options);
         });
         var latexConverter;
         if (latexFunctions[this.name]) {
           latexConverter = latexFunctions[this.name];
         }

         // toTex property on the function itself
         if (math[this.name] && (typeof math[this.name].toTex === 'function' || typeof math[this.name].toTex === 'object' || typeof math[this.name].toTex === 'string')) {
           // .toTex is a callback function
           latexConverter = math[this.name].toTex;
         }
         var customToTex;
         switch (typeof latexConverter) {
           case 'function':
             // a callback function
             customToTex = latexConverter(this, options);
             break;
           case 'string':
             // a template string
             customToTex = expandTemplate(latexConverter, this, options);
             break;
           case 'object':
             // an object with different "converters" for different
             // numbers of arguments
             switch (typeof latexConverter[args.length]) {
               case 'function':
                 customToTex = latexConverter[args.length](this, options);
                 break;
               case 'string':
                 customToTex = expandTemplate(latexConverter[args.length], this, options);
                 break;
             }
         }
         if (typeof customToTex !== 'undefined') {
           return customToTex;
         }
         return expandTemplate(defaultTemplate, this, options);
       }

       /**
        * Get identifier.
        * @return {string}
        */
       getIdentifier() {
         return this.type + ':' + this.name;
       }
     }
     _defineProperty(FunctionNode, "name", name$1n);
     _defineProperty(FunctionNode, "onUndefinedFunction", function (name) {
       throw new Error('Undefined function ' + name);
     });
     _defineProperty(FunctionNode, "fromJSON", function (json) {
       return new FunctionNode(json.fn, json.args);
     });
     return FunctionNode;
   }, {
     isClass: true,
     isNode: true
   });

   var name$1m = 'parse';
   var dependencies$1m = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];
   var createParse = /* #__PURE__ */factory(name$1m, dependencies$1m, _ref => {
     var {
       typed,
       numeric,
       config,
       AccessorNode,
       ArrayNode,
       AssignmentNode,
       BlockNode,
       ConditionalNode,
       ConstantNode,
       FunctionAssignmentNode,
       FunctionNode,
       IndexNode,
       ObjectNode,
       OperatorNode,
       ParenthesisNode,
       RangeNode,
       RelationalNode,
       SymbolNode
     } = _ref;
     /**
      * Parse an expression. Returns a node tree, which can be evaluated by
      * invoking node.evaluate().
      *
      * Note the evaluating arbitrary expressions may involve security risks,
      * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.
      *
      * Syntax:
      *
      *     math.parse(expr)
      *     math.parse(expr, options)
      *     math.parse([expr1, expr2, expr3, ...])
      *     math.parse([expr1, expr2, expr3, ...], options)
      *
      * Example:
      *
      *     const node1 = math.parse('sqrt(3^2 + 4^2)')
      *     node1.compile().evaluate() // 5
      *
      *     let scope = {a:3, b:4}
      *     const node2 = math.parse('a * b') // 12
      *     const code2 = node2.compile()
      *     code2.evaluate(scope) // 12
      *     scope.a = 5
      *     code2.evaluate(scope) // 20
      *
      *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])
      *     nodes[2].compile().evaluate() // 12
      *
      * See also:
      *
      *     evaluate, compile
      *
      * @param {string | string[] | Matrix} expr          Expression to be parsed
      * @param {{nodes: Object<string, Node>}} [options]  Available options:
      *                                                   - `nodes` a set of custom nodes
      * @return {Node | Node[]} node
      * @throws {Error}
      */
     var parse = typed(name$1m, {
       string: function string(expression) {
         return parseStart(expression, {});
       },
       'Array | Matrix': function ArrayMatrix(expressions) {
         return parseMultiple(expressions, {});
       },
       'string, Object': function stringObject(expression, options) {
         var extraNodes = options.nodes !== undefined ? options.nodes : {};
         return parseStart(expression, extraNodes);
       },
       'Array | Matrix, Object': parseMultiple
     });
     function parseMultiple(expressions) {
       var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
       var extraNodes = options.nodes !== undefined ? options.nodes : {};

       // parse an array or matrix with expressions
       return deepMap(expressions, function (elem) {
         if (typeof elem !== 'string') throw new TypeError('String expected');
         return parseStart(elem, extraNodes);
       });
     }

     // token types enumeration
     var TOKENTYPE = {
       NULL: 0,
       DELIMITER: 1,
       NUMBER: 2,
       SYMBOL: 3,
       UNKNOWN: 4
     };

     // map with all delimiters
     var DELIMITERS = {
       ',': true,
       '(': true,
       ')': true,
       '[': true,
       ']': true,
       '{': true,
       '}': true,
       '"': true,
       '\'': true,
       ';': true,
       '+': true,
       '-': true,
       '*': true,
       '.*': true,
       '/': true,
       './': true,
       '%': true,
       '^': true,
       '.^': true,
       '~': true,
       '!': true,
       '&': true,
       '|': true,
       '^|': true,
       '=': true,
       ':': true,
       '?': true,
       '==': true,
       '!=': true,
       '<': true,
       '>': true,
       '<=': true,
       '>=': true,
       '<<': true,
       '>>': true,
       '>>>': true
     };

     // map with all named delimiters
     var NAMED_DELIMITERS = {
       mod: true,
       to: true,
       in: true,
       and: true,
       xor: true,
       or: true,
       not: true
     };
     var CONSTANTS = {
       true: true,
       false: false,
       null: null,
       undefined
     };
     var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];
     function initialState() {
       return {
         extraNodes: {},
         // current extra nodes, must be careful not to mutate
         expression: '',
         // current expression
         comment: '',
         // last parsed comment
         index: 0,
         // current index in expr
         token: '',
         // current token
         tokenType: TOKENTYPE.NULL,
         // type of the token
         nestingLevel: 0,
         // level of nesting inside parameters, used to ignore newline characters
         conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here
       };
     }

     /**
      * View upto `length` characters of the expression starting at the current character.
      *
      * @param {Object} state
      * @param {number} [length=1] Number of characters to view
      * @returns {string}
      * @private
      */
     function currentString(state, length) {
       return state.expression.substr(state.index, length);
     }

     /**
      * View the current character. Returns '' if end of expression is reached.
      *
      * @param {Object} state
      * @returns {string}
      * @private
      */
     function currentCharacter(state) {
       return currentString(state, 1);
     }

     /**
      * Get the next character from the expression.
      * The character is stored into the char c. If the end of the expression is
      * reached, the function puts an empty string in c.
      * @private
      */
     function next(state) {
       state.index++;
     }

     /**
      * Preview the previous character from the expression.
      * @return {string} cNext
      * @private
      */
     function prevCharacter(state) {
       return state.expression.charAt(state.index - 1);
     }

     /**
      * Preview the next character from the expression.
      * @return {string} cNext
      * @private
      */
     function nextCharacter(state) {
       return state.expression.charAt(state.index + 1);
     }

     /**
      * Get next token in the current string expr.
      * The token and token type are available as token and tokenType
      * @private
      */
     function getToken(state) {
       state.tokenType = TOKENTYPE.NULL;
       state.token = '';
       state.comment = '';

       // skip over ignored characters:
       while (true) {
         // comments:
         if (currentCharacter(state) === '#') {
           while (currentCharacter(state) !== '\n' && currentCharacter(state) !== '') {
             state.comment += currentCharacter(state);
             next(state);
           }
         }
         // whitespace: space, tab, and newline when inside parameters
         if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
           next(state);
         } else {
           break;
         }
       }

       // check for end of expression
       if (currentCharacter(state) === '') {
         // token is still empty
         state.tokenType = TOKENTYPE.DELIMITER;
         return;
       }

       // check for new line character
       if (currentCharacter(state) === '\n' && !state.nestingLevel) {
         state.tokenType = TOKENTYPE.DELIMITER;
         state.token = currentCharacter(state);
         next(state);
         return;
       }
       var c1 = currentCharacter(state);
       var c2 = currentString(state, 2);
       var c3 = currentString(state, 3);
       if (c3.length === 3 && DELIMITERS[c3]) {
         state.tokenType = TOKENTYPE.DELIMITER;
         state.token = c3;
         next(state);
         next(state);
         next(state);
         return;
       }

       // check for delimiters consisting of 2 characters
       if (c2.length === 2 && DELIMITERS[c2]) {
         state.tokenType = TOKENTYPE.DELIMITER;
         state.token = c2;
         next(state);
         next(state);
         return;
       }

       // check for delimiters consisting of 1 character
       if (DELIMITERS[c1]) {
         state.tokenType = TOKENTYPE.DELIMITER;
         state.token = c1;
         next(state);
         return;
       }

       // check for a number
       if (parse.isDigitDot(c1)) {
         state.tokenType = TOKENTYPE.NUMBER;

         // check for binary, octal, or hex
         var _c = currentString(state, 2);
         if (_c === '0b' || _c === '0o' || _c === '0x') {
           state.token += currentCharacter(state);
           next(state);
           state.token += currentCharacter(state);
           next(state);
           while (parse.isHexDigit(currentCharacter(state))) {
             state.token += currentCharacter(state);
             next(state);
           }
           if (currentCharacter(state) === '.') {
             // this number has a radix point
             state.token += '.';
             next(state);
             // get the digits after the radix
             while (parse.isHexDigit(currentCharacter(state))) {
               state.token += currentCharacter(state);
               next(state);
             }
           } else if (currentCharacter(state) === 'i') {
             // this number has a word size suffix
             state.token += 'i';
             next(state);
             // get the word size
             while (parse.isDigit(currentCharacter(state))) {
               state.token += currentCharacter(state);
               next(state);
             }
           }
           return;
         }

         // get number, can have a single dot
         if (currentCharacter(state) === '.') {
           state.token += currentCharacter(state);
           next(state);
           if (!parse.isDigit(currentCharacter(state))) {
             // this is no number, it is just a dot (can be dot notation)
             state.tokenType = TOKENTYPE.DELIMITER;
             return;
           }
         } else {
           while (parse.isDigit(currentCharacter(state))) {
             state.token += currentCharacter(state);
             next(state);
           }
           if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
             state.token += currentCharacter(state);
             next(state);
           }
         }
         while (parse.isDigit(currentCharacter(state))) {
           state.token += currentCharacter(state);
           next(state);
         }
         // check for exponential notation like "2.3e-4", "1.23e50" or "2e+4"
         if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {
           if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {
             state.token += currentCharacter(state);
             next(state);
             if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {
               state.token += currentCharacter(state);
               next(state);
             }
             // Scientific notation MUST be followed by an exponent
             if (!parse.isDigit(currentCharacter(state))) {
               throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
             }
             while (parse.isDigit(currentCharacter(state))) {
               state.token += currentCharacter(state);
               next(state);
             }
             if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
               throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
             }
           } else if (nextCharacter(state) === '.') {
             next(state);
             throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
           }
         }
         return;
       }

       // check for variables, functions, named operators
       if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
         while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
           state.token += currentCharacter(state);
           next(state);
         }
         if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
           state.tokenType = TOKENTYPE.DELIMITER;
         } else {
           state.tokenType = TOKENTYPE.SYMBOL;
         }
         return;
       }

       // something unknown is found, wrong characters -> a syntax error
       state.tokenType = TOKENTYPE.UNKNOWN;
       while (currentCharacter(state) !== '') {
         state.token += currentCharacter(state);
         next(state);
       }
       throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
     }

     /**
      * Get next token and skip newline tokens
      */
     function getTokenSkipNewline(state) {
       do {
         getToken(state);
       } while (state.token === '\n'); // eslint-disable-line no-unmodified-loop-condition
     }

     /**
      * Open parameters.
      * New line characters will be ignored until closeParams(state) is called
      */
     function openParams(state) {
       state.nestingLevel++;
     }

     /**
      * Close parameters.
      * New line characters will no longer be ignored
      */
     function closeParams(state) {
       state.nestingLevel--;
     }

     /**
      * Checks whether the current character `c` is a valid alpha character:
      *
      * - A latin letter (upper or lower case) Ascii: a-z, A-Z
      * - An underscore                        Ascii: _
      * - A dollar sign                        Ascii: $
      * - A latin letter with accents          Unicode: \u00C0 - \u02AF
      * - A greek letter                       Unicode: \u0370 - \u03FF
      * - A mathematical alphanumeric symbol   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
      *
      * The previous and next characters are needed to determine whether
      * this character is part of a unicode surrogate pair.
      *
      * @param {string} c      Current character in the expression
      * @param {string} cPrev  Previous character
      * @param {string} cNext  Next character
      * @return {boolean}
      */
     parse.isAlpha = function isAlpha(c, cPrev, cNext) {
       return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
     };

     /**
      * Test whether a character is a valid latin, greek, or letter-like character
      * @param {string} c
      * @return {boolean}
      */
     parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
       return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
     };

     /**
      * Test whether two given 16 bit characters form a surrogate pair of a
      * unicode math symbol.
      *
      * https://unicode-table.com/en/
      * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode
      *
      * Note: In ES6 will be unicode aware:
      * https://stackoverflow.com/questions/280712/javascript-unicode-regexes
      * https://mathiasbynens.be/notes/es6-unicode-regex
      *
      * @param {string} high
      * @param {string} low
      * @return {boolean}
      */
     parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
       return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
     };

     /**
      * Check whether given character c is a white space character: space, tab, or enter
      * @param {string} c
      * @param {number} nestingLevel
      * @return {boolean}
      */
     parse.isWhitespace = function isWhitespace(c, nestingLevel) {
       // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
       return c === ' ' || c === '\t' || c === '\n' && nestingLevel > 0;
     };

     /**
      * Test whether the character c is a decimal mark (dot).
      * This is the case when it's not the start of a delimiter '.*', './', or '.^'
      * @param {string} c
      * @param {string} cNext
      * @return {boolean}
      */
     parse.isDecimalMark = function isDecimalMark(c, cNext) {
       return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';
     };

     /**
      * checks if the given char c is a digit or dot
      * @param {string} c   a string with one character
      * @return {boolean}
      */
     parse.isDigitDot = function isDigitDot(c) {
       return c >= '0' && c <= '9' || c === '.';
     };

     /**
      * checks if the given char c is a digit
      * @param {string} c   a string with one character
      * @return {boolean}
      */
     parse.isDigit = function isDigit(c) {
       return c >= '0' && c <= '9';
     };

     /**
      * checks if the given char c is a hex digit
      * @param {string} c   a string with one character
      * @return {boolean}
      */
     parse.isHexDigit = function isHexDigit(c) {
       return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';
     };

     /**
      * Start of the parse levels below, in order of precedence
      * @return {Node} node
      * @private
      */
     function parseStart(expression, extraNodes) {
       var state = initialState();
       _extends$1(state, {
         expression,
         extraNodes
       });
       getToken(state);
       var node = parseBlock(state);

       // check for garbage at the end of the expression
       // an expression ends with a empty character '' and tokenType DELIMITER
       if (state.token !== '') {
         if (state.tokenType === TOKENTYPE.DELIMITER) {
           // user entered a not existing operator like "//"

           // TODO: give hints for aliases, for example with "<>" give as hint " did you mean !== ?"
           throw createError(state, 'Unexpected operator ' + state.token);
         } else {
           throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
         }
       }
       return node;
     }

     /**
      * Parse a block with expressions. Expressions can be separated by a newline
      * character '\n', or by a semicolon ';'. In case of a semicolon, no output
      * of the preceding line is returned.
      * @return {Node} node
      * @private
      */
     function parseBlock(state) {
       var node;
       var blocks = [];
       var visible;
       if (state.token !== '' && state.token !== '\n' && state.token !== ';') {
         node = parseAssignment(state);
         if (state.comment) {
           node.comment = state.comment;
         }
       }

       // TODO: simplify this loop
       while (state.token === '\n' || state.token === ';') {
         // eslint-disable-line no-unmodified-loop-condition
         if (blocks.length === 0 && node) {
           visible = state.token !== ';';
           blocks.push({
             node,
             visible
           });
         }
         getToken(state);
         if (state.token !== '\n' && state.token !== ';' && state.token !== '') {
           node = parseAssignment(state);
           if (state.comment) {
             node.comment = state.comment;
           }
           visible = state.token !== ';';
           blocks.push({
             node,
             visible
           });
         }
       }
       if (blocks.length > 0) {
         return new BlockNode(blocks);
       } else {
         if (!node) {
           node = new ConstantNode(undefined);
           if (state.comment) {
             node.comment = state.comment;
           }
         }
         return node;
       }
     }

     /**
      * Assignment of a function or variable,
      * - can be a variable like 'a=2.3'
      * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'
      * - defining a function like 'f(x) = x^2'
      * @return {Node} node
      * @private
      */
     function parseAssignment(state) {
       var name, args, value, valid;
       var node = parseConditional(state);
       if (state.token === '=') {
         if (isSymbolNode(node)) {
           // parse a variable assignment like 'a = 2/3'
           name = node.name;
           getTokenSkipNewline(state);
           value = parseAssignment(state);
           return new AssignmentNode(new SymbolNode(name), value);
         } else if (isAccessorNode(node)) {
           // parse a matrix subset assignment like 'A[1,2] = 4'
           getTokenSkipNewline(state);
           value = parseAssignment(state);
           return new AssignmentNode(node.object, node.index, value);
         } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
           // parse function assignment like 'f(x) = x^2'
           valid = true;
           args = [];
           name = node.name;
           node.args.forEach(function (arg, index) {
             if (isSymbolNode(arg)) {
               args[index] = arg.name;
             } else {
               valid = false;
             }
           });
           if (valid) {
             getTokenSkipNewline(state);
             value = parseAssignment(state);
             return new FunctionAssignmentNode(name, args, value);
           }
         }
         throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');
       }
       return node;
     }

     /**
      * conditional operation
      *
      *     condition ? truePart : falsePart
      *
      * Note: conditional operator is right-associative
      *
      * @return {Node} node
      * @private
      */
     function parseConditional(state) {
       var node = parseLogicalOr(state);
       while (state.token === '?') {
         // eslint-disable-line no-unmodified-loop-condition
         // set a conditional level, the range operator will be ignored as long
         // as conditionalLevel === state.nestingLevel.
         var prev = state.conditionalLevel;
         state.conditionalLevel = state.nestingLevel;
         getTokenSkipNewline(state);
         var condition = node;
         var trueExpr = parseAssignment(state);
         if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');
         state.conditionalLevel = null;
         getTokenSkipNewline(state);
         var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity

         node = new ConditionalNode(condition, trueExpr, falseExpr);

         // restore the previous conditional level
         state.conditionalLevel = prev;
       }
       return node;
     }

     /**
      * logical or, 'x or y'
      * @return {Node} node
      * @private
      */
     function parseLogicalOr(state) {
       var node = parseLogicalXor(state);
       while (state.token === 'or') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);
       }
       return node;
     }

     /**
      * logical exclusive or, 'x xor y'
      * @return {Node} node
      * @private
      */
     function parseLogicalXor(state) {
       var node = parseLogicalAnd(state);
       while (state.token === 'xor') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);
       }
       return node;
     }

     /**
      * logical and, 'x and y'
      * @return {Node} node
      * @private
      */
     function parseLogicalAnd(state) {
       var node = parseBitwiseOr(state);
       while (state.token === 'and') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);
       }
       return node;
     }

     /**
      * bitwise or, 'x | y'
      * @return {Node} node
      * @private
      */
     function parseBitwiseOr(state) {
       var node = parseBitwiseXor(state);
       while (state.token === '|') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);
       }
       return node;
     }

     /**
      * bitwise exclusive or (xor), 'x ^| y'
      * @return {Node} node
      * @private
      */
     function parseBitwiseXor(state) {
       var node = parseBitwiseAnd(state);
       while (state.token === '^|') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);
       }
       return node;
     }

     /**
      * bitwise and, 'x & y'
      * @return {Node} node
      * @private
      */
     function parseBitwiseAnd(state) {
       var node = parseRelational(state);
       while (state.token === '&') {
         // eslint-disable-line no-unmodified-loop-condition
         getTokenSkipNewline(state);
         node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);
       }
       return node;
     }

     /**
      * Parse a chained conditional, like 'a > b >= c'
      * @return {Node} node
      */
     function parseRelational(state) {
       var params = [parseShift(state)];
       var conditionals = [];
       var operators = {
         '==': 'equal',
         '!=': 'unequal',
         '<': 'smaller',
         '>': 'larger',
         '<=': 'smallerEq',
         '>=': 'largerEq'
       };
       while (hasOwnProperty(operators, state.token)) {
         // eslint-disable-line no-unmodified-loop-condition
         var cond = {
           name: state.token,
           fn: operators[state.token]
         };
         conditionals.push(cond);
         getTokenSkipNewline(state);
         params.push(parseShift(state));
       }
       if (params.length === 1) {
         return params[0];
       } else if (params.length === 2) {
         return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
       } else {
         return new RelationalNode(conditionals.map(c => c.fn), params);
       }
     }

     /**
      * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
      * @return {Node} node
      * @private
      */
     function parseShift(state) {
       var node, name, fn, params;
       node = parseConversion(state);
       var operators = {
         '<<': 'leftShift',
         '>>': 'rightArithShift',
         '>>>': 'rightLogShift'
       };
       while (hasOwnProperty(operators, state.token)) {
         name = state.token;
         fn = operators[name];
         getTokenSkipNewline(state);
         params = [node, parseConversion(state)];
         node = new OperatorNode(name, fn, params);
       }
       return node;
     }

     /**
      * conversion operators 'to' and 'in'
      * @return {Node} node
      * @private
      */
     function parseConversion(state) {
       var node, name, fn, params;
       node = parseRange(state);
       var operators = {
         to: 'to',
         in: 'to' // alias of 'to'
       };

       while (hasOwnProperty(operators, state.token)) {
         name = state.token;
         fn = operators[name];
         getTokenSkipNewline(state);
         if (name === 'in' && state.token === '') {
           // end of expression -> this is the unit 'in' ('inch')
           node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);
         } else {
           // operator 'a to b' or 'a in b'
           params = [node, parseRange(state)];
           node = new OperatorNode(name, fn, params);
         }
       }
       return node;
     }

     /**
      * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
      * @return {Node} node
      * @private
      */
     function parseRange(state) {
       var node;
       var params = [];
       if (state.token === ':') {
         // implicit start=1 (one-based)
         node = new ConstantNode(1);
       } else {
         // explicit start
         node = parseAddSubtract(state);
       }
       if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {
         // we ignore the range operator when a conditional operator is being processed on the same level
         params.push(node);

         // parse step and end
         while (state.token === ':' && params.length < 3) {
           // eslint-disable-line no-unmodified-loop-condition
           getTokenSkipNewline(state);
           if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {
             // implicit end
             params.push(new SymbolNode('end'));
           } else {
             // explicit end
             params.push(parseAddSubtract(state));
           }
         }
         if (params.length === 3) {
           // params = [start, step, end]
           node = new RangeNode(params[0], params[2], params[1]); // start, end, step
         } else {
           // length === 2
           // params = [start, end]
           node = new RangeNode(params[0], params[1]); // start, end
         }
       }

       return node;
     }

     /**
      * add or subtract
      * @return {Node} node
      * @private
      */
     function parseAddSubtract(state) {
       var node, name, fn, params;
       node = parseMultiplyDivide(state);
       var operators = {
         '+': 'add',
         '-': 'subtract'
       };
       while (hasOwnProperty(operators, state.token)) {
         name = state.token;
         fn = operators[name];
         getTokenSkipNewline(state);
         var rightNode = parseMultiplyDivide(state);
         if (rightNode.isPercentage) {
           params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];
         } else {
           params = [node, rightNode];
         }
         node = new OperatorNode(name, fn, params);
       }
       return node;
     }

     /**
      * multiply, divide, modulus
      * @return {Node} node
      * @private
      */
     function parseMultiplyDivide(state) {
       var node, last, name, fn;
       node = parseImplicitMultiplication(state);
       last = node;
       var operators = {
         '*': 'multiply',
         '.*': 'dotMultiply',
         '/': 'divide',
         './': 'dotDivide'
       };
       while (true) {
         if (hasOwnProperty(operators, state.token)) {
           // explicit operators
           name = state.token;
           fn = operators[name];
           getTokenSkipNewline(state);
           last = parseImplicitMultiplication(state);
           node = new OperatorNode(name, fn, [node, last]);
         } else {
           break;
         }
       }
       return node;
     }

     /**
      * implicit multiplication
      * @return {Node} node
      * @private
      */
     function parseImplicitMultiplication(state) {
       var node, last;
       node = parseRule2(state);
       last = node;
       while (true) {
         if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {
           // parse implicit multiplication
           //
           // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
           // number:      implicit multiplication like '(2+3)2'
           // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'
           last = parseRule2(state);
           node = new OperatorNode('*', 'multiply', [node, last], true /* implicit */);
         } else {
           break;
         }
       }
       return node;
     }

     /**
      * Infamous "rule 2" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370
      * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164
      * Explicit division gets higher precedence than implicit multiplication
      * when the division matches this pattern:
      *   [unaryPrefixOp]?[number] / [number] [symbol]
      * @return {Node} node
      * @private
      */
     function parseRule2(state) {
       var node = parsePercentage(state);
       var last = node;
       var tokenStates = [];
       while (true) {
         // Match the "number /" part of the pattern "number / number symbol"
         if (state.token === '/' && rule2Node(last)) {
           // Look ahead to see if the next token is a number
           tokenStates.push(_extends$1({}, state));
           getTokenSkipNewline(state);

           // Match the "number / number" part of the pattern
           if (state.tokenType === TOKENTYPE.NUMBER) {
             // Look ahead again
             tokenStates.push(_extends$1({}, state));
             getTokenSkipNewline(state);

             // Match the "symbol" part of the pattern, or a left parenthesis
             if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {
               // We've matched the pattern "number / number symbol".
               // Rewind once and build the "number / number" node; the symbol will be consumed later
               _extends$1(state, tokenStates.pop());
               tokenStates.pop();
               last = parsePercentage(state);
               node = new OperatorNode('/', 'divide', [node, last]);
             } else {
               // Not a match, so rewind
               tokenStates.pop();
               _extends$1(state, tokenStates.pop());
               break;
             }
           } else {
             // Not a match, so rewind
             _extends$1(state, tokenStates.pop());
             break;
           }
         } else {
           break;
         }
       }
       return node;
     }

     /**
      * percentage or mod
      * @return {Node} node
      * @private
      */
     function parsePercentage(state) {
       var node, name, fn, params;
       node = parseUnary(state);
       var operators = {
         '%': 'mod',
         mod: 'mod'
       };
       while (hasOwnProperty(operators, state.token)) {
         name = state.token;
         fn = operators[name];
         getTokenSkipNewline(state);
         if (name === '%' && state.tokenType === TOKENTYPE.DELIMITER && state.token !== '(') {
           // If the expression contains only %, then treat that as /100
           node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);
         } else {
           params = [node, parseUnary(state)];
           node = new OperatorNode(name, fn, params);
         }
       }
       return node;
     }

     /**
      * Unary plus and minus, and logical and bitwise not
      * @return {Node} node
      * @private
      */
     function parseUnary(state) {
       var name, params, fn;
       var operators = {
         '-': 'unaryMinus',
         '+': 'unaryPlus',
         '~': 'bitNot',
         not: 'not'
       };
       if (hasOwnProperty(operators, state.token)) {
         fn = operators[state.token];
         name = state.token;
         getTokenSkipNewline(state);
         params = [parseUnary(state)];
         return new OperatorNode(name, fn, params);
       }
       return parsePow(state);
     }

     /**
      * power
      * Note: power operator is right associative
      * @return {Node} node
      * @private
      */
     function parsePow(state) {
       var node, name, fn, params;
       node = parseLeftHandOperators(state);
       if (state.token === '^' || state.token === '.^') {
         name = state.token;
         fn = name === '^' ? 'pow' : 'dotPow';
         getTokenSkipNewline(state);
         params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'
         node = new OperatorNode(name, fn, params);
       }
       return node;
     }

     /**
      * Left hand operators: factorial x!, ctranspose x'
      * @return {Node} node
      * @private
      */
     function parseLeftHandOperators(state) {
       var node, name, fn, params;
       node = parseCustomNodes(state);
       var operators = {
         '!': 'factorial',
         '\'': 'ctranspose'
       };
       while (hasOwnProperty(operators, state.token)) {
         name = state.token;
         fn = operators[name];
         getToken(state);
         params = [node];
         node = new OperatorNode(name, fn, params);
         node = parseAccessors(state, node);
       }
       return node;
     }

     /**
      * Parse a custom node handler. A node handler can be used to process
      * nodes in a custom way, for example for handling a plot.
      *
      * A handler must be passed as second argument of the parse function.
      * - must extend math.Node
      * - must contain a function _compile(defs: Object) : string
      * - must contain a function find(filter: Object) : Node[]
      * - must contain a function toString() : string
      * - the constructor is called with a single argument containing all parameters
      *
      * For example:
      *
      *     nodes = {
      *       'plot': PlotHandler
      *     }
      *
      * The constructor of the handler is called as:
      *
      *     node = new PlotHandler(params)
      *
      * The handler will be invoked when evaluating an expression like:
      *
      *     node = math.parse('plot(sin(x), x)', nodes)
      *
      * @return {Node} node
      * @private
      */
     function parseCustomNodes(state) {
       var params = [];
       if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
         var CustomNode = state.extraNodes[state.token];
         getToken(state);

         // parse parameters
         if (state.token === '(') {
           params = [];
           openParams(state);
           getToken(state);
           if (state.token !== ')') {
             params.push(parseAssignment(state));

             // parse a list with parameters
             while (state.token === ',') {
               // eslint-disable-line no-unmodified-loop-condition
               getToken(state);
               params.push(parseAssignment(state));
             }
           }
           if (state.token !== ')') {
             throw createSyntaxError(state, 'Parenthesis ) expected');
           }
           closeParams(state);
           getToken(state);
         }

         // create a new custom node
         // noinspection JSValidateTypes
         return new CustomNode(params);
       }
       return parseSymbol(state);
     }

     /**
      * parse symbols: functions, variables, constants, units
      * @return {Node} node
      * @private
      */
     function parseSymbol(state) {
       var node, name;
       if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
         name = state.token;
         getToken(state);
         if (hasOwnProperty(CONSTANTS, name)) {
           // true, false, null, ...
           node = new ConstantNode(CONSTANTS[name]);
         } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {
           // NaN, Infinity
           node = new ConstantNode(numeric(name, 'number'));
         } else {
           node = new SymbolNode(name);
         }

         // parse function parameters and matrix index
         node = parseAccessors(state, node);
         return node;
       }
       return parseDoubleQuotesString(state);
     }

     /**
      * parse accessors:
      * - function invocation in round brackets (...), for example sqrt(2)
      * - index enclosed in square brackets [...], for example A[2,3]
      * - dot notation for properties, like foo.bar
      * @param {Object} state
      * @param {Node} node    Node on which to apply the parameters. If there
      *                       are no parameters in the expression, the node
      *                       itself is returned
      * @param {string[]} [types]  Filter the types of notations
      *                            can be ['(', '[', '.']
      * @return {Node} node
      * @private
      */
     function parseAccessors(state, node, types) {
       var params;
       while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {
         // eslint-disable-line no-unmodified-loop-condition
         params = [];
         if (state.token === '(') {
           if (isSymbolNode(node) || isAccessorNode(node)) {
             // function invocation like fn(2, 3) or obj.fn(2, 3)
             openParams(state);
             getToken(state);
             if (state.token !== ')') {
               params.push(parseAssignment(state));

               // parse a list with parameters
               while (state.token === ',') {
                 // eslint-disable-line no-unmodified-loop-condition
                 getToken(state);
                 params.push(parseAssignment(state));
               }
             }
             if (state.token !== ')') {
               throw createSyntaxError(state, 'Parenthesis ) expected');
             }
             closeParams(state);
             getToken(state);
             node = new FunctionNode(node, params);
           } else {
             // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)
             // don't parse it here but let it be handled by parseImplicitMultiplication
             // with correct precedence
             return node;
           }
         } else if (state.token === '[') {
           // index notation like variable[2, 3]
           openParams(state);
           getToken(state);
           if (state.token !== ']') {
             params.push(parseAssignment(state));

             // parse a list with parameters
             while (state.token === ',') {
               // eslint-disable-line no-unmodified-loop-condition
               getToken(state);
               params.push(parseAssignment(state));
             }
           }
           if (state.token !== ']') {
             throw createSyntaxError(state, 'Parenthesis ] expected');
           }
           closeParams(state);
           getToken(state);
           node = new AccessorNode(node, new IndexNode(params));
         } else {
           // dot notation like variable.prop
           getToken(state);
           if (state.tokenType !== TOKENTYPE.SYMBOL) {
             throw createSyntaxError(state, 'Property name expected after dot');
           }
           params.push(new ConstantNode(state.token));
           getToken(state);
           var dotNotation = true;
           node = new AccessorNode(node, new IndexNode(params, dotNotation));
         }
       }
       return node;
     }

     /**
      * Parse a double quotes string.
      * @return {Node} node
      * @private
      */
     function parseDoubleQuotesString(state) {
       var node, str;
       if (state.token === '"') {
         str = parseDoubleQuotesStringToken(state);

         // create constant
         node = new ConstantNode(str);

         // parse index parameters
         node = parseAccessors(state, node);
         return node;
       }
       return parseSingleQuotesString(state);
     }

     /**
      * Parse a string surrounded by double quotes "..."
      * @return {string}
      */
     function parseDoubleQuotesStringToken(state) {
       var str = '';
       while (currentCharacter(state) !== '' && currentCharacter(state) !== '"') {
         if (currentCharacter(state) === '\\') {
           // escape character, immediately process the next
           // character to prevent stopping at a next '\"'
           str += currentCharacter(state);
           next(state);
         }
         str += currentCharacter(state);
         next(state);
       }
       getToken(state);
       if (state.token !== '"') {
         throw createSyntaxError(state, 'End of string " expected');
       }
       getToken(state);
       return JSON.parse('"' + str + '"'); // unescape escaped characters
     }

     /**
      * Parse a single quotes string.
      * @return {Node} node
      * @private
      */
     function parseSingleQuotesString(state) {
       var node, str;
       if (state.token === '\'') {
         str = parseSingleQuotesStringToken(state);

         // create constant
         node = new ConstantNode(str);

         // parse index parameters
         node = parseAccessors(state, node);
         return node;
       }
       return parseMatrix(state);
     }

     /**
      * Parse a string surrounded by single quotes '...'
      * @return {string}
      */
     function parseSingleQuotesStringToken(state) {
       var str = '';
       while (currentCharacter(state) !== '' && currentCharacter(state) !== '\'') {
         if (currentCharacter(state) === '\\') {
           // escape character, immediately process the next
           // character to prevent stopping at a next '\''
           str += currentCharacter(state);
           next(state);
         }
         str += currentCharacter(state);
         next(state);
       }
       getToken(state);
       if (state.token !== '\'') {
         throw createSyntaxError(state, 'End of string \' expected');
       }
       getToken(state);
       return JSON.parse('"' + str + '"'); // unescape escaped characters
     }

     /**
      * parse the matrix
      * @return {Node} node
      * @private
      */
     function parseMatrix(state) {
       var array, params, rows, cols;
       if (state.token === '[') {
         // matrix [...]
         openParams(state);
         getToken(state);
         if (state.token !== ']') {
           // this is a non-empty matrix
           var row = parseRow(state);
           if (state.token === ';') {
             // 2 dimensional array
             rows = 1;
             params = [row];

             // the rows of the matrix are separated by dot-comma's
             while (state.token === ';') {
               // eslint-disable-line no-unmodified-loop-condition
               getToken(state);
               params[rows] = parseRow(state);
               rows++;
             }
             if (state.token !== ']') {
               throw createSyntaxError(state, 'End of matrix ] expected');
             }
             closeParams(state);
             getToken(state);

             // check if the number of columns matches in all rows
             cols = params[0].items.length;
             for (var r = 1; r < rows; r++) {
               if (params[r].items.length !== cols) {
                 throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');
               }
             }
             array = new ArrayNode(params);
           } else {
             // 1 dimensional vector
             if (state.token !== ']') {
               throw createSyntaxError(state, 'End of matrix ] expected');
             }
             closeParams(state);
             getToken(state);
             array = row;
           }
         } else {
           // this is an empty matrix "[ ]"
           closeParams(state);
           getToken(state);
           array = new ArrayNode([]);
         }
         return parseAccessors(state, array);
       }
       return parseObject(state);
     }

     /**
      * Parse a single comma-separated row from a matrix, like 'a, b, c'
      * @return {ArrayNode} node
      */
     function parseRow(state) {
       var params = [parseAssignment(state)];
       var len = 1;
       while (state.token === ',') {
         // eslint-disable-line no-unmodified-loop-condition
         getToken(state);

         // parse expression
         params[len] = parseAssignment(state);
         len++;
       }
       return new ArrayNode(params);
     }

     /**
      * parse an object, enclosed in angle brackets{...}, for example {value: 2}
      * @return {Node} node
      * @private
      */
     function parseObject(state) {
       if (state.token === '{') {
         openParams(state);
         var key;
         var properties = {};
         do {
           getToken(state);
           if (state.token !== '}') {
             // parse key
             if (state.token === '"') {
               key = parseDoubleQuotesStringToken(state);
             } else if (state.token === '\'') {
               key = parseSingleQuotesStringToken(state);
             } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
               key = state.token;
               getToken(state);
             } else {
               throw createSyntaxError(state, 'Symbol or string expected as object key');
             }

             // parse key/value separator
             if (state.token !== ':') {
               throw createSyntaxError(state, 'Colon : expected after object key');
             }
             getToken(state);

             // parse key
             properties[key] = parseAssignment(state);
           }
         } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition

         if (state.token !== '}') {
           throw createSyntaxError(state, 'Comma , or bracket } expected after object value');
         }
         closeParams(state);
         getToken(state);
         var node = new ObjectNode(properties);

         // parse index parameters
         node = parseAccessors(state, node);
         return node;
       }
       return parseNumber(state);
     }

     /**
      * parse a number
      * @return {Node} node
      * @private
      */
     function parseNumber(state) {
       var numberStr;
       if (state.tokenType === TOKENTYPE.NUMBER) {
         // this is a number
         numberStr = state.token;
         getToken(state);
         return new ConstantNode(numeric(numberStr, config.number));
       }
       return parseParentheses(state);
     }

     /**
      * parentheses
      * @return {Node} node
      * @private
      */
     function parseParentheses(state) {
       var node;

       // check if it is a parenthesized expression
       if (state.token === '(') {
         // parentheses (...)
         openParams(state);
         getToken(state);
         node = parseAssignment(state); // start again

         if (state.token !== ')') {
           throw createSyntaxError(state, 'Parenthesis ) expected');
         }
         closeParams(state);
         getToken(state);
         node = new ParenthesisNode(node);
         node = parseAccessors(state, node);
         return node;
       }
       return parseEnd(state);
     }

     /**
      * Evaluated when the expression is not yet ended but expected to end
      * @return {Node} res
      * @private
      */
     function parseEnd(state) {
       if (state.token === '') {
         // syntax error or unexpected end of expression
         throw createSyntaxError(state, 'Unexpected end of expression');
       } else {
         throw createSyntaxError(state, 'Value expected');
       }
     }

     /**
      * Shortcut for getting the current row value (one based)
      * Returns the line of the currently handled expression
      * @private
      */
     /* TODO: implement keeping track on the row number
     function row () {
       return null
     }
     */

     /**
      * Shortcut for getting the current col value (one based)
      * Returns the column (position) where the last state.token starts
      * @private
      */
     function col(state) {
       return state.index - state.token.length + 1;
     }

     /**
      * Create an error
      * @param {Object} state
      * @param {string} message
      * @return {SyntaxError} instantiated error
      * @private
      */
     function createSyntaxError(state, message) {
       var c = col(state);
       var error = new SyntaxError(message + ' (char ' + c + ')');
       error.char = c;
       return error;
     }

     /**
      * Create an error
      * @param {Object} state
      * @param {string} message
      * @return {Error} instantiated error
      * @private
      */
     function createError(state, message) {
       var c = col(state);
       var error = new SyntaxError(message + ' (char ' + c + ')');
       error.char = c;
       return error;
     }

     // Now that we can parse, automatically convert strings to Nodes by parsing
     typed.addConversion({
       from: 'string',
       to: 'Node',
       convert: parse
     });
     return parse;
   });

   var name$1l = 'compile';
   var dependencies$1l = ['typed', 'parse'];
   var createCompile = /* #__PURE__ */factory(name$1l, dependencies$1l, _ref => {
     var {
       typed,
       parse
     } = _ref;
     /**
      * Parse and compile an expression.
      * Returns a an object with a function `evaluate([scope])` to evaluate the
      * compiled expression.
      *
      * Syntax:
      *
      *     math.compile(expr)                       // returns one node
      *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
      *
      * Examples:
      *
      *     const code1 = math.compile('sqrt(3^2 + 4^2)')
      *     code1.evaluate() // 5
      *
      *     let scope = {a: 3, b: 4}
      *     const code2 = math.compile('a * b') // 12
      *     code2.evaluate(scope) // 12
      *     scope.a = 5
      *     code2.evaluate(scope) // 20
      *
      *     const nodes = math.compile(['a = 3', 'b = 4', 'a * b'])
      *     nodes[2].evaluate() // 12
      *
      * See also:
      *
      *    parse, evaluate
      *
      * @param {string | string[] | Array | Matrix} expr
      *            The expression to be compiled
      * @return {{evaluate: Function} | Array.<{evaluate: Function}>} code
      *            An object with the compiled expression
      * @throws {Error}
      */
     return typed(name$1l, {
       string: function string(expr) {
         return parse(expr).compile();
       },
       'Array | Matrix': function ArrayMatrix(expr) {
         return deepMap(expr, function (entry) {
           return parse(entry).compile();
         });
       }
     });
   });

   var name$1k = 'evaluate';
   var dependencies$1k = ['typed', 'parse'];
   var createEvaluate = /* #__PURE__ */factory(name$1k, dependencies$1k, _ref => {
     var {
       typed,
       parse
     } = _ref;
     /**
      * Evaluate an expression.
      *
      * Note the evaluating arbitrary expressions may involve security risks,
      * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.
      *
      * Syntax:
      *
      *     math.evaluate(expr)
      *     math.evaluate(expr, scope)
      *     math.evaluate([expr1, expr2, expr3, ...])
      *     math.evaluate([expr1, expr2, expr3, ...], scope)
      *
      * Example:
      *
      *     math.evaluate('(2+3)/4')                // 1.25
      *     math.evaluate('sqrt(3^2 + 4^2)')        // 5
      *     math.evaluate('sqrt(-4)')               // 2i
      *     math.evaluate(['a=3', 'b=4', 'a*b'])    // [3, 4, 12]
      *
      *     let scope = {a:3, b:4}
      *     math.evaluate('a * b', scope)           // 12
      *
      * See also:
      *
      *    parse, compile
      *
      * @param {string | string[] | Matrix} expr   The expression to be evaluated
      * @param {Object} [scope]                    Scope to read/write variables
      * @return {*} The result of the expression
      * @throws {Error}
      */
     return typed(name$1k, {
       string: function string(expr) {
         var scope = createEmptyMap();
         return parse(expr).compile().evaluate(scope);
       },
       'string, Map | Object': function stringMapObject(expr, scope) {
         return parse(expr).compile().evaluate(scope);
       },
       'Array | Matrix': function ArrayMatrix(expr) {
         var scope = createEmptyMap();
         return deepMap(expr, function (entry) {
           return parse(entry).compile().evaluate(scope);
         });
       },
       'Array | Matrix, Map | Object': function ArrayMatrixMapObject(expr, scope) {
         return deepMap(expr, function (entry) {
           return parse(entry).compile().evaluate(scope);
         });
       }
     });
   });

   var name$1j = 'Parser';
   var dependencies$1j = ['evaluate'];
   var createParserClass = /* #__PURE__ */factory(name$1j, dependencies$1j, _ref => {
     var {
       evaluate
     } = _ref;
     /**
      * @constructor Parser
      * Parser contains methods to evaluate or parse expressions, and has a number
      * of convenience methods to get, set, and remove variables from memory. Parser
      * keeps a scope containing variables in memory, which is used for all
      * evaluations.
      *
      * Methods:
      *    const result = parser.evaluate(expr)  // evaluate an expression
      *    const value = parser.get(name)        // retrieve a variable from the parser
      *    const values = parser.getAll()        // retrieve all defined variables
      *    parser.set(name, value)               // set a variable in the parser
      *    parser.remove(name)                   // clear a variable from the
      *                                          // parsers scope
      *    parser.clear()                        // clear the parsers scope
      *
      * Example usage:
      *    const parser = new Parser()
      *    // Note: there is a convenience method which can be used instead:
      *    // const parser = new math.parser()
      *
      *    // evaluate expressions
      *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5
      *    parser.evaluate('sqrt(-4)')               // 2i
      *    parser.evaluate('2 inch in cm')           // 5.08 cm
      *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476
      *
      *    // define variables and functions
      *    parser.evaluate('x = 7 / 2')              // 3.5
      *    parser.evaluate('x + 3')                  // 6.5
      *    parser.evaluate('f(x, y) = x^y')          // f(x, y)
      *    parser.evaluate('f(2, 3)')                // 8
      *
      *    // get and set variables and functions
      *    const x = parser.get('x')                 // 3.5
      *    const f = parser.get('f')                 // function
      *    const g = f(3, 2)                         // 9
      *    parser.set('h', 500)
      *    const i = parser.evaluate('h / 2')        // 250
      *    parser.set('hello', function (name) {
      *        return 'hello, ' + name + '!'
      *    })
      *    parser.evaluate('hello("user")')          // "hello, user!"
      *
      *    // clear defined functions and variables
      *    parser.clear()
      *
      */
     function Parser() {
       if (!(this instanceof Parser)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       Object.defineProperty(this, 'scope', {
         value: createEmptyMap(),
         writable: false
       });
     }

     /**
      * Attach type information
      */
     Parser.prototype.type = 'Parser';
     Parser.prototype.isParser = true;

     /**
      * Parse and evaluate the given expression
      * @param {string | string[]} expr   A string containing an expression,
      *                                   for example "2+3", or a list with expressions
      * @return {*} result     The result, or undefined when the expression was empty
      * @throws {Error}
      */
     Parser.prototype.evaluate = function (expr) {
       // TODO: validate arguments
       return evaluate(expr, this.scope);
     };

     /**
      * Get a variable (a function or variable) by name from the parsers scope.
      * Returns undefined when not found
      * @param {string} name
      * @return {* | undefined} value
      */
     Parser.prototype.get = function (name) {
       // TODO: validate arguments
       if (this.scope.has(name)) {
         return this.scope.get(name);
       }
     };

     /**
      * Get a map with all defined variables
      * @return {Object} values
      */
     Parser.prototype.getAll = function () {
       return toObject(this.scope);
     };

     /**
      * Get a map with all defined variables
      * @return {Map} values
      */
     Parser.prototype.getAllAsMap = function () {
       return this.scope;
     };

     /**
      * Set a symbol (a function or variable) by name from the parsers scope.
      * @param {string} name
      * @param {* | undefined} value
      */
     Parser.prototype.set = function (name, value) {
       this.scope.set(name, value);
       return value;
     };

     /**
      * Remove a variable from the parsers scope
      * @param {string} name
      */
     Parser.prototype.remove = function (name) {
       this.scope.delete(name);
     };

     /**
      * Clear the scope with variables and functions
      */
     Parser.prototype.clear = function () {
       this.scope.clear();
     };
     return Parser;
   }, {
     isClass: true
   });

   var name$1i = 'parser';
   var dependencies$1i = ['typed', 'Parser'];
   var createParser = /* #__PURE__ */factory(name$1i, dependencies$1i, _ref => {
     var {
       typed,
       Parser
     } = _ref;
     /**
      * Create a parser. The function creates a new `math.Parser` object.
      *
      * Syntax:
      *
      *    math.parser()
      *
      * Examples:
      *
      *     const parser = new math.parser()
      *
      *     // evaluate expressions
      *     const a = parser.evaluate('sqrt(3^2 + 4^2)') // 5
      *     const b = parser.evaluate('sqrt(-4)')        // 2i
      *     const c = parser.evaluate('2 inch in cm')    // 5.08 cm
      *     const d = parser.evaluate('cos(45 deg)')     // 0.7071067811865476
      *
      *     // define variables and functions
      *     parser.evaluate('x = 7 / 2')             // 3.5
      *     parser.evaluate('x + 3')                 // 6.5
      *     parser.evaluate('f(x, y) = x^y')         // f(x, y)
      *     parser.evaluate('f(2, 3)')               // 8
      *
      *     // get and set variables and functions
      *     const x = parser.get('x')                // 3.5
      *     const f = parser.get('f')                // function
      *     const g = f(3, 2)                        // 9
      *     parser.set('h', 500)
      *     const i = parser.evaluate('h / 2')       // 250
      *     parser.set('hello', function (name) {
      *       return 'hello, ' + name + '!'
      *     })
      *     parser.evaluate('hello("user")')         // "hello, user!"
      *
      *     // clear defined functions and variables
      *     parser.clear()
      *
      * See also:
      *
      *    evaluate, compile, parse
      *
      * @return {Parser} Parser
      */
     return typed(name$1i, {
       '': function _() {
         return new Parser();
       }
     });
   });

   var name$1h = 'lup';
   var dependencies$1h = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];
   var createLup = /* #__PURE__ */factory(name$1h, dependencies$1h, _ref => {
     var {
       typed,
       matrix,
       abs,
       addScalar,
       divideScalar,
       multiplyScalar,
       subtract,
       larger,
       equalScalar,
       unaryMinus,
       DenseMatrix,
       SparseMatrix,
       Spa
     } = _ref;
     /**
      * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
      * row permutation vector `p` where `A[p,:] = L * U`
      *
      * Syntax:
      *
      *    math.lup(A)
      *
      * Example:
      *
      *    const m = [[2, 1], [1, 4]]
      *    const r = math.lup(m)
      *    // r = {
      *    //   L: [[1, 0], [0.5, 1]],
      *    //   U: [[2, 1], [0, 3.5]],
      *    //   P: [0, 1]
      *    // }
      *
      * See also:
      *
      *    slu, lsolve, lusolve, usolve
      *
      * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
      *
      * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.
      */
     return typed(name$1h, {
       DenseMatrix: function DenseMatrix(m) {
         return _denseLUP(m);
       },
       SparseMatrix: function SparseMatrix(m) {
         return _sparseLUP(m);
       },
       Array: function Array(a) {
         // create dense matrix from array
         var m = matrix(a);
         // lup, use matrix implementation
         var r = _denseLUP(m);
         // result
         return {
           L: r.L.valueOf(),
           U: r.U.valueOf(),
           p: r.p
         };
       }
     });
     function _denseLUP(m) {
       // rows & columns
       var rows = m._size[0];
       var columns = m._size[1];
       // minimum rows and columns
       var n = Math.min(rows, columns);
       // matrix array, clone original data
       var data = clone$3(m._data);
       // l matrix arrays
       var ldata = [];
       var lsize = [rows, n];
       // u matrix arrays
       var udata = [];
       var usize = [n, columns];
       // vars
       var i, j, k;
       // permutation vector
       var p = [];
       for (i = 0; i < rows; i++) {
         p[i] = i;
       }
       // loop columns
       for (j = 0; j < columns; j++) {
         // skip first column in upper triangular matrix
         if (j > 0) {
           // loop rows
           for (i = 0; i < rows; i++) {
             // min i,j
             var min = Math.min(i, j);
             // v[i, j]
             var s = 0;
             // loop up to min
             for (k = 0; k < min; k++) {
               // s = l[i, k] - data[k, j]
               s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
             }
             data[i][j] = subtract(data[i][j], s);
           }
         }
         // row with larger value in cvector, row >= j
         var pi = j;
         var pabsv = 0;
         var vjj = 0;
         // loop rows
         for (i = j; i < rows; i++) {
           // data @ i, j
           var v = data[i][j];
           // absolute value
           var absv = abs(v);
           // value is greater than pivote value
           if (larger(absv, pabsv)) {
             // store row
             pi = i;
             // update max value
             pabsv = absv;
             // value @ [j, j]
             vjj = v;
           }
         }
         // swap rows (j <-> pi)
         if (j !== pi) {
           // swap values j <-> pi in p
           p[j] = [p[pi], p[pi] = p[j]][0];
           // swap j <-> pi in data
           DenseMatrix._swapRows(j, pi, data);
         }
         // check column is in lower triangular matrix
         if (j < rows) {
           // loop rows (lower triangular matrix)
           for (i = j + 1; i < rows; i++) {
             // value @ i, j
             var vij = data[i][j];
             if (!equalScalar(vij, 0)) {
               // update data
               data[i][j] = divideScalar(data[i][j], vjj);
             }
           }
         }
       }
       // loop columns
       for (j = 0; j < columns; j++) {
         // loop rows
         for (i = 0; i < rows; i++) {
           // initialize row in arrays
           if (j === 0) {
             // check row exists in upper triangular matrix
             if (i < columns) {
               // U
               udata[i] = [];
             }
             // L
             ldata[i] = [];
           }
           // check we are in the upper triangular matrix
           if (i < j) {
             // check row exists in upper triangular matrix
             if (i < columns) {
               // U
               udata[i][j] = data[i][j];
             }
             // check column exists in lower triangular matrix
             if (j < rows) {
               // L
               ldata[i][j] = 0;
             }
             continue;
           }
           // diagonal value
           if (i === j) {
             // check row exists in upper triangular matrix
             if (i < columns) {
               // U
               udata[i][j] = data[i][j];
             }
             // check column exists in lower triangular matrix
             if (j < rows) {
               // L
               ldata[i][j] = 1;
             }
             continue;
           }
           // check row exists in upper triangular matrix
           if (i < columns) {
             // U
             udata[i][j] = 0;
           }
           // check column exists in lower triangular matrix
           if (j < rows) {
             // L
             ldata[i][j] = data[i][j];
           }
         }
       }
       // l matrix
       var l = new DenseMatrix({
         data: ldata,
         size: lsize
       });
       // u matrix
       var u = new DenseMatrix({
         data: udata,
         size: usize
       });
       // p vector
       var pv = [];
       for (i = 0, n = p.length; i < n; i++) {
         pv[p[i]] = i;
       }
       // return matrices
       return {
         L: l,
         U: u,
         p: pv,
         toString: function toString() {
           return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
         }
       };
     }
     function _sparseLUP(m) {
       // rows & columns
       var rows = m._size[0];
       var columns = m._size[1];
       // minimum rows and columns
       var n = Math.min(rows, columns);
       // matrix arrays (will not be modified, thanks to permutation vector)
       var values = m._values;
       var index = m._index;
       var ptr = m._ptr;
       // l matrix arrays
       var lvalues = [];
       var lindex = [];
       var lptr = [];
       var lsize = [rows, n];
       // u matrix arrays
       var uvalues = [];
       var uindex = [];
       var uptr = [];
       var usize = [n, columns];
       // vars
       var i, j, k;
       // permutation vectors, (current index -> original index) and (original index -> current index)
       var pvCo = [];
       var pvOc = [];
       for (i = 0; i < rows; i++) {
         pvCo[i] = i;
         pvOc[i] = i;
       }
       // swap indices in permutation vectors (condition x < y)!
       var swapIndeces = function swapIndeces(x, y) {
         // find pv indeces getting data from x and y
         var kx = pvOc[x];
         var ky = pvOc[y];
         // update permutation vector current -> original
         pvCo[kx] = y;
         pvCo[ky] = x;
         // update permutation vector original -> current
         pvOc[x] = ky;
         pvOc[y] = kx;
       };
       // loop columns
       var _loop = function _loop() {
         // sparse accumulator
         var spa = new Spa();
         // check lower triangular matrix has a value @ column j
         if (j < rows) {
           // update ptr
           lptr.push(lvalues.length);
           // first value in j column for lower triangular matrix
           lvalues.push(1);
           lindex.push(j);
         }
         // update ptr
         uptr.push(uvalues.length);
         // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
         var k0 = ptr[j];
         var k1 = ptr[j + 1];
         // copy column j into sparse accumulator
         for (k = k0; k < k1; k++) {
           // row
           i = index[k];
           // copy column values into sparse accumulator (use permutation vector)
           spa.set(pvCo[i], values[k]);
         }
         // skip first column in upper triangular matrix
         if (j > 0) {
           // loop rows in column j (above diagonal)
           spa.forEach(0, j - 1, function (k, vkj) {
             // loop rows in column k (L)
             SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {
               // check row is below k
               if (i > k) {
                 // update spa value
                 spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));
               }
             });
           });
         }
         // row with larger value in spa, row >= j
         var pi = j;
         var vjj = spa.get(j);
         var pabsv = abs(vjj);
         // loop values in spa (order by row, below diagonal)
         spa.forEach(j + 1, rows - 1, function (x, v) {
           // absolute value
           var absv = abs(v);
           // value is greater than pivote value
           if (larger(absv, pabsv)) {
             // store row
             pi = x;
             // update max value
             pabsv = absv;
             // value @ [j, j]
             vjj = v;
           }
         });
         // swap rows (j <-> pi)
         if (j !== pi) {
           // swap values j <-> pi in L
           SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
           // swap values j <-> pi in U
           SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
           // swap values in spa
           spa.swap(j, pi);
           // update permutation vector (swap values @ j, pi)
           swapIndeces(j, pi);
         }
         // loop values in spa (order by row)
         spa.forEach(0, rows - 1, function (x, v) {
           // check we are above diagonal
           if (x <= j) {
             // update upper triangular matrix
             uvalues.push(v);
             uindex.push(x);
           } else {
             // update value
             v = divideScalar(v, vjj);
             // check value is non zero
             if (!equalScalar(v, 0)) {
               // update lower triangular matrix
               lvalues.push(v);
               lindex.push(x);
             }
           }
         });
       };
       for (j = 0; j < columns; j++) {
         _loop();
       }
       // update ptrs
       uptr.push(uvalues.length);
       lptr.push(lvalues.length);

       // return matrices
       return {
         L: new SparseMatrix({
           values: lvalues,
           index: lindex,
           ptr: lptr,
           size: lsize
         }),
         U: new SparseMatrix({
           values: uvalues,
           index: uindex,
           ptr: uptr,
           size: usize
         }),
         p: pvCo,
         toString: function toString() {
           return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
         }
       };
     }
   });

   var name$1g = 'qr';
   var dependencies$1g = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];
   var createQr = /* #__PURE__ */factory(name$1g, dependencies$1g, _ref => {
     var {
       typed,
       matrix,
       zeros,
       identity,
       isZero,
       equal,
       sign,
       sqrt,
       conj,
       unaryMinus,
       addScalar,
       divideScalar,
       multiplyScalar,
       subtract,
       complex
     } = _ref;
     /**
      * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
      * two matrices (`Q`, `R`) where `Q` is an
      * orthogonal matrix and `R` is an upper triangular matrix.
      *
      * Syntax:
      *
      *    math.qr(A)
      *
      * Example:
      *
      *    const m = [
      *      [1, -1,  4],
      *      [1,  4, -2],
      *      [1,  4,  2],
      *      [1,  -1, 0]
      *    ]
      *    const result = math.qr(m)
      *    // r = {
      *    //   Q: [
      *    //     [0.5, -0.5,   0.5],
      *    //     [0.5,  0.5,  -0.5],
      *    //     [0.5,  0.5,   0.5],
      *    //     [0.5, -0.5,  -0.5],
      *    //   ],
      *    //   R: [
      *    //     [2, 3,  2],
      *    //     [0, 5, -2],
      *    //     [0, 0,  4],
      *    //     [0, 0,  0]
      *    //   ]
      *    // }
      *
      * See also:
      *
      *    lup, lusolve
      *
      * @param {Matrix | Array} A    A two dimensional matrix or array
      * for which to get the QR decomposition.
      *
      * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
      * matrix and R: the upper triangular matrix
      */
     return _extends$1(typed(name$1g, {
       DenseMatrix: function DenseMatrix(m) {
         return _denseQR(m);
       },
       SparseMatrix: function SparseMatrix(m) {
         return _sparseQR();
       },
       Array: function Array(a) {
         // create dense matrix from array
         var m = matrix(a);
         // lup, use matrix implementation
         var r = _denseQR(m);
         // result
         return {
           Q: r.Q.valueOf(),
           R: r.R.valueOf()
         };
       }
     }), {
       _denseQRimpl
     });
     function _denseQRimpl(m) {
       // rows & columns (m x n)
       var rows = m._size[0]; // m
       var cols = m._size[1]; // n

       var Q = identity([rows], 'dense');
       var Qdata = Q._data;
       var R = m.clone();
       var Rdata = R._data;

       // vars
       var i, j, k;
       var w = zeros([rows], '');
       for (k = 0; k < Math.min(cols, rows); ++k) {
         /*
          * **k-th Household matrix**
          *
          * The matrix I - 2*v*transpose(v)
          * x     = first column of A
          * x1    = first element of x
          * alpha = x1 / |x1| * |x|
          * e1    = tranpose([1, 0, 0, ...])
          * u     = x - alpha * e1
          * v     = u / |u|
          *
          * Household matrix = I - 2 * v * tranpose(v)
          *
          *  * Initially Q = I and R = A.
          *  * Household matrix is a reflection in a plane normal to v which
          *    will zero out all but the top right element in R.
          *  * Appplying reflection to both Q and R will not change product.
          *  * Repeat this process on the (1,1) minor to get R as an upper
          *    triangular matrix.
          *  * Reflections leave the magnitude of the columns of Q unchanged
          *    so Q remains othoganal.
          *
          */

         var pivot = Rdata[k][k];
         var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
         var conjSgn = conj(sgn);
         var alphaSquared = 0;
         for (i = k; i < rows; i++) {
           alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
         }
         var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
         if (!isZero(alpha)) {
           // first element in vector u
           var u1 = subtract(pivot, alpha);

           // w = v * u1 / |u|    (only elements k to (rows-1) are used)
           w[k] = 1;
           for (i = k + 1; i < rows; i++) {
             w[i] = divideScalar(Rdata[i][k], u1);
           }

           // tau = - conj(u1 / alpha)
           var tau = unaryMinus(conj(divideScalar(u1, alpha)));
           var s = void 0;

           /*
            * tau and w have been choosen so that
            *
            * 2 * v * tranpose(v) = tau * w * tranpose(w)
            */

           /*
            * -- calculate R = R - tau * w * tranpose(w) * R --
            * Only do calculation with rows k to (rows-1)
            * Additionally columns 0 to (k-1) will not be changed by this
            *   multiplication so do not bother recalculating them
            */
           for (j = k; j < cols; j++) {
             s = 0.0;

             // calculate jth element of [tranpose(w) * R]
             for (i = k; i < rows; i++) {
               s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
             }

             // calculate the jth element of [tau * transpose(w) * R]
             s = multiplyScalar(s, tau);
             for (i = k; i < rows; i++) {
               Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
             }
           }
           /*
            * -- calculate Q = Q - tau * Q * w * transpose(w) --
            * Q is a square matrix (rows x rows)
            * Only do calculation with columns k to (rows-1)
            * Additionally rows 0 to (k-1) will not be changed by this
            *   multiplication so do not bother recalculating them
            */
           for (i = 0; i < rows; i++) {
             s = 0.0;

             // calculate ith element of [Q * w]
             for (j = k; j < rows; j++) {
               s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
             }

             // calculate the ith element of [tau * Q * w]
             s = multiplyScalar(s, tau);
             for (j = k; j < rows; ++j) {
               Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
             }
           }
         }
       }

       // return matrices
       return {
         Q,
         R,
         toString: function toString() {
           return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
         }
       };
     }
     function _denseQR(m) {
       var ret = _denseQRimpl(m);
       var Rdata = ret.R._data;
       if (m._data.length > 0) {
         var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;
         for (var i = 0; i < Rdata.length; ++i) {
           for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
             Rdata[i][j] = zero;
           }
         }
       }
       return ret;
     }
     function _sparseQR(m) {
       throw new Error('qr not implemented for sparse matrices yet');
     }
   });

   /**
    * Permutes a sparse matrix C = P * A * Q
    *
    * @param {SparseMatrix}  a         The Matrix A
    * @param {Array}   pinv            The row permutation vector
    * @param {Array}   q               The column permutation vector
    * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
    *
    * @return {Matrix}                 C = P * A * Q, null on error
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csPermute(a, pinv, q, values) {
     // a arrays
     var avalues = a._values;
     var aindex = a._index;
     var aptr = a._ptr;
     var asize = a._size;
     var adt = a._datatype;
     // rows & columns
     var m = asize[0];
     var n = asize[1];
     // c arrays
     var cvalues = values && a._values ? [] : null;
     var cindex = []; // (aptr[n])
     var cptr = []; // (n + 1)
     // initialize vars
     var nz = 0;
     // loop columns
     for (var k = 0; k < n; k++) {
       // column k of C is column q[k] of A
       cptr[k] = nz;
       // apply column permutation
       var j = q ? q[k] : k;
       // loop values in column j of A
       for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
         // row i of A is row pinv[i] of C
         var r = pinv ? pinv[aindex[t]] : aindex[t];
         // index
         cindex[nz] = r;
         // check we need to populate values
         if (cvalues) {
           cvalues[nz] = avalues[t];
         }
         // increment number of nonzero elements
         nz++;
       }
     }
     // finalize the last column of C
     cptr[n] = nz;
     // return C matrix
     return a.createSparseMatrix({
       values: cvalues,
       index: cindex,
       ptr: cptr,
       size: [m, n],
       datatype: adt
     });
   }

   /**
    * Depth-first search and postorder of a tree rooted at node j
    *
    * @param {Number}  j               The tree node
    * @param {Number}  k
    * @param {Array}   w               The workspace array
    * @param {Number}  head            The index offset within the workspace for the head array
    * @param {Number}  next            The index offset within the workspace for the next array
    * @param {Array}   post            The post ordering array
    * @param {Number}  stack           The index offset within the workspace for the stack array
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csTdfs(j, k, w, head, next, post, stack) {
     // variables
     var top = 0;
     // place j on the stack
     w[stack] = j;
     // while (stack is not empty)
     while (top >= 0) {
       // p = top of stack
       var p = w[stack + top];
       // i = youngest child of p
       var i = w[head + p];
       if (i === -1) {
         // p has no unordered children left
         top--;
         // node p is the kth postordered node
         post[k++] = p;
       } else {
         // remove i from children of p
         w[head + p] = w[next + i];
         // increment top
         ++top;
         // start dfs on child node i
         w[stack + top] = i;
       }
     }
     return k;
   }

   /**
    * Post order a tree of forest
    *
    * @param {Array}   parent          The tree or forest
    * @param {Number}  n               Number of columns
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csPost(parent, n) {
     // check inputs
     if (!parent) {
       return null;
     }
     // vars
     var k = 0;
     var j;
     // allocate result
     var post = []; // (n)
     // workspace, head: first n entries, next: next n entries, stack: last n entries
     var w = []; // (3 * n)
     var head = 0;
     var next = n;
     var stack = 2 * n;
     // initialize workspace
     for (j = 0; j < n; j++) {
       // empty linked lists
       w[head + j] = -1;
     }
     // traverse nodes in reverse order
     for (j = n - 1; j >= 0; j--) {
       // check j is a root
       if (parent[j] === -1) {
         continue;
       }
       // add j to list of its parent
       w[next + j] = w[head + parent[j]];
       w[head + parent[j]] = j;
     }
     // loop nodes
     for (j = 0; j < n; j++) {
       // skip j if it is not a root
       if (parent[j] !== -1) {
         continue;
       }
       // depth-first search
       k = csTdfs(j, k, w, head, next, post, stack);
     }
     return post;
   }

   /**
    * Computes the elimination tree of Matrix A (using triu(A)) or the
    * elimination tree of A'A without forming A'A.
    *
    * @param {Matrix}  a               The A Matrix
    * @param {boolean} ata             A value of true the function computes the etree of A'A
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csEtree(a, ata) {
     // check inputs
     if (!a) {
       return null;
     }
     // a arrays
     var aindex = a._index;
     var aptr = a._ptr;
     var asize = a._size;
     // rows & columns
     var m = asize[0];
     var n = asize[1];

     // allocate result
     var parent = []; // (n)

     // allocate workspace
     var w = []; // (n + (ata ? m : 0))
     var ancestor = 0; // first n entries in w
     var prev = n; // last m entries (ata = true)

     var i, inext;

     // check we are calculating A'A
     if (ata) {
       // initialize workspace
       for (i = 0; i < m; i++) {
         w[prev + i] = -1;
       }
     }
     // loop columns
     for (var k = 0; k < n; k++) {
       // node k has no parent yet
       parent[k] = -1;
       // nor does k have an ancestor
       w[ancestor + k] = -1;
       // values in column k
       for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
         // row
         var r = aindex[p];
         // node
         i = ata ? w[prev + r] : r;
         // traverse from i to k
         for (; i !== -1 && i < k; i = inext) {
           // inext = ancestor of i
           inext = w[ancestor + i];
           // path compression
           w[ancestor + i] = k;
           // check no anc., parent is k
           if (inext === -1) {
             parent[i] = k;
           }
         }
         if (ata) {
           w[prev + r] = k;
         }
       }
     }
     return parent;
   }

   /**
    * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
    *
    * @param {Matrix}   a              The sparse matrix
    * @param {function} callback       The callback function, function will be invoked with the following args:
    *                                    - The entry row
    *                                    - The entry column
    *                                    - The entry value
    *                                    - The state parameter
    * @param {any}      other          The state
    *
    * @return                          The number of nonzero elements in the matrix
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csFkeep(a, callback, other) {
     // a arrays
     var avalues = a._values;
     var aindex = a._index;
     var aptr = a._ptr;
     var asize = a._size;
     // columns
     var n = asize[1];
     // nonzero items
     var nz = 0;
     // loop columns
     for (var j = 0; j < n; j++) {
       // get current location of col j
       var p = aptr[j];
       // record new location of col j
       aptr[j] = nz;
       for (; p < aptr[j + 1]; p++) {
         // check we need to keep this item
         if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
           // keep A(i,j)
           aindex[nz] = aindex[p];
           // check we need to process values (pattern only)
           if (avalues) {
             avalues[nz] = avalues[p];
           }
           // increment nonzero items
           nz++;
         }
       }
     }
     // finalize A
     aptr[n] = nz;
     // trim arrays
     aindex.splice(nz, aindex.length - nz);
     // check we need to process values (pattern only)
     if (avalues) {
       avalues.splice(nz, avalues.length - nz);
     }
     // return number of nonzero items
     return nz;
   }

   /**
    * This function "flips" its input about the integer -1.
    *
    * @param {Number}  i               The value to flip
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csFlip(i) {
     // flip the value
     return -i - 2;
   }

   var name$1f = 'csAmd';
   var dependencies$1f = ['add', 'multiply', 'transpose'];
   var createCsAmd = /* #__PURE__ */factory(name$1f, dependencies$1f, _ref => {
     var {
       add,
       multiply,
       transpose
     } = _ref;
     /**
      * Approximate minimum degree ordering. The minimum degree algorithm is a widely used
      * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
      * than A. It is a gready method that selects the sparsest pivot row and column during the course
      * of a right looking sparse Cholesky factorization.
      *
      * Reference: http://faculty.cse.tamu.edu/davis/publications.html
      *
      * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
      * @param {Matrix} m        Sparse Matrix
      */
     return function csAmd(order, a) {
       // check input parameters
       if (!a || order <= 0 || order > 3) {
         return null;
       }
       // a matrix arrays
       var asize = a._size;
       // rows and columns
       var m = asize[0];
       var n = asize[1];
       // initialize vars
       var lemax = 0;
       // dense threshold
       var dense = Math.max(16, 10 * Math.sqrt(n));
       dense = Math.min(n - 2, dense);
       // create target matrix C
       var cm = _createTargetMatrix(order, a, m, n, dense);
       // drop diagonal entries
       csFkeep(cm, _diag, null);
       // C matrix arrays
       var cindex = cm._index;
       var cptr = cm._ptr;

       // number of nonzero elements in C
       var cnz = cptr[n];

       // allocate result (n+1)
       var P = [];

       // create workspace (8 * (n + 1))
       var W = [];
       var len = 0; // first n + 1 entries
       var nv = n + 1; // next n + 1 entries
       var next = 2 * (n + 1); // next n + 1 entries
       var head = 3 * (n + 1); // next n + 1 entries
       var elen = 4 * (n + 1); // next n + 1 entries
       var degree = 5 * (n + 1); // next n + 1 entries
       var w = 6 * (n + 1); // next n + 1 entries
       var hhead = 7 * (n + 1); // last n + 1 entries

       // use P as workspace for last
       var last = P;

       // initialize quotient graph
       var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);

       // initialize degree lists
       var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);

       // minimum degree node
       var mindeg = 0;

       // vars
       var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;

       // while (selecting pivots) do
       while (nel < n) {
         // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
         // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
         // many nodes have been eliminated.
         for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++);
         if (W[next + k] !== -1) {
           last[W[next + k]] = -1;
         }
         // remove k from degree list
         W[head + mindeg] = W[next + k];
         // elenk = |Ek|
         var elenk = W[elen + k];
         // # of nodes k represents
         var nvk = W[nv + k];
         // W[nv + k] nodes of A eliminated
         nel += nvk;

         // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is
         // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
         // degree lists. All elements e in Ek are absorved into element k.
         var dk = 0;
         // flag k as in Lk
         W[nv + k] = -nvk;
         var p = cptr[k];
         // do in place if W[elen + k] === 0
         var pk1 = elenk === 0 ? p : cnz;
         var pk2 = pk1;
         for (k1 = 1; k1 <= elenk + 1; k1++) {
           if (k1 > elenk) {
             // search the nodes in k
             e = k;
             // list of nodes starts at cindex[pj]
             pj = p;
             // length of list of nodes in k
             ln = W[len + k] - elenk;
           } else {
             // search the nodes in e
             e = cindex[p++];
             pj = cptr[e];
             // length of list of nodes in e
             ln = W[len + e];
           }
           for (k2 = 1; k2 <= ln; k2++) {
             i = cindex[pj++];
             // check  node i dead, or seen
             if ((nvi = W[nv + i]) <= 0) {
               continue;
             }
             // W[degree + Lk] += size of node i
             dk += nvi;
             // negate W[nv + i] to denote i in Lk
             W[nv + i] = -nvi;
             // place i in Lk
             cindex[pk2++] = i;
             if (W[next + i] !== -1) {
               last[W[next + i]] = last[i];
             }
             // check we need to remove i from degree list
             if (last[i] !== -1) {
               W[next + last[i]] = W[next + i];
             } else {
               W[head + W[degree + i]] = W[next + i];
             }
           }
           if (e !== k) {
             // absorb e into k
             cptr[e] = csFlip(k);
             // e is now a dead element
             W[w + e] = 0;
           }
         }
         // cindex[cnz...nzmax] is free
         if (elenk !== 0) {
           cnz = pk2;
         }
         // external degree of k - |Lk\i|
         W[degree + k] = dk;
         // element k is in cindex[pk1..pk2-1]
         cptr[k] = pk1;
         W[len + k] = pk2 - pk1;
         // k is now an element
         W[elen + k] = -2;

         // Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
         // scan, no entry in the w array is greater than or equal to mark.

         // clear w if necessary
         mark = _wclear(mark, lemax, W, w, n);
         // scan 1: find |Le\Lk|
         for (pk = pk1; pk < pk2; pk++) {
           i = cindex[pk];
           // check if W[elen + i] empty, skip it
           if ((eln = W[elen + i]) <= 0) {
             continue;
           }
           // W[nv + i] was negated
           nvi = -W[nv + i];
           var wnvi = mark - nvi;
           // scan Ei
           for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
             e = cindex[p];
             if (W[w + e] >= mark) {
               // decrement |Le\Lk|
               W[w + e] -= nvi;
             } else if (W[w + e] !== 0) {
               // ensure e is a live element, 1st time e seen in scan 1
               W[w + e] = W[degree + e] + wnvi;
             }
           }
         }

         // degree update
         // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
         // function h(i) for all nodes in Lk.

         // scan2: degree update
         for (pk = pk1; pk < pk2; pk++) {
           // consider node i in Lk
           i = cindex[pk];
           p1 = cptr[i];
           p2 = p1 + W[elen + i] - 1;
           pn = p1;
           // scan Ei
           for (h = 0, d = 0, p = p1; p <= p2; p++) {
             e = cindex[p];
             // check e is an unabsorbed element
             if (W[w + e] !== 0) {
               // dext = |Le\Lk|
               var dext = W[w + e] - mark;
               if (dext > 0) {
                 // sum up the set differences
                 d += dext;
                 // keep e in Ei
                 cindex[pn++] = e;
                 // compute the hash of node i
                 h += e;
               } else {
                 // aggressive absorb. e->k
                 cptr[e] = csFlip(k);
                 // e is a dead element
                 W[w + e] = 0;
               }
             }
           }
           // W[elen + i] = |Ei|
           W[elen + i] = pn - p1 + 1;
           var p3 = pn;
           var p4 = p1 + W[len + i];
           // prune edges in Ai
           for (p = p2 + 1; p < p4; p++) {
             j = cindex[p];
             // check node j dead or in Lk
             var nvj = W[nv + j];
             if (nvj <= 0) {
               continue;
             }
             // degree(i) += |j|
             d += nvj;
             // place j in node list of i
             cindex[pn++] = j;
             // compute hash for node i
             h += j;
           }
           // check for mass elimination
           if (d === 0) {
             // absorb i into k
             cptr[i] = csFlip(k);
             nvi = -W[nv + i];
             // |Lk| -= |i|
             dk -= nvi;
             // |k| += W[nv + i]
             nvk += nvi;
             nel += nvi;
             W[nv + i] = 0;
             // node i is dead
             W[elen + i] = -1;
           } else {
             // update degree(i)
             W[degree + i] = Math.min(W[degree + i], d);
             // move first node to end
             cindex[pn] = cindex[p3];
             // move 1st el. to end of Ei
             cindex[p3] = cindex[p1];
             // add k as 1st element in of Ei
             cindex[p1] = k;
             // new len of adj. list of node i
             W[len + i] = pn - p1 + 1;
             // finalize hash of i
             h = (h < 0 ? -h : h) % n;
             // place i in hash bucket
             W[next + i] = W[hhead + h];
             W[hhead + h] = i;
             // save hash of i in last[i]
             last[i] = h;
           }
         }
         // finalize |Lk|
         W[degree + k] = dk;
         lemax = Math.max(lemax, dk);
         // clear w
         mark = _wclear(mark + lemax, lemax, W, w, n);

         // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
         // If two nodes have identical adjacency lists, their hash functions wil be identical.
         for (pk = pk1; pk < pk2; pk++) {
           i = cindex[pk];
           // check i is dead, skip it
           if (W[nv + i] >= 0) {
             continue;
           }
           // scan hash bucket of node i
           h = last[i];
           i = W[hhead + h];
           // hash bucket will be empty
           W[hhead + h] = -1;
           for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
             ln = W[len + i];
             eln = W[elen + i];
             for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) {
               W[w + cindex[p]] = mark;
             }
             var jlast = i;
             // compare i with all j
             for (j = W[next + i]; j !== -1;) {
               var ok = W[len + j] === ln && W[elen + j] === eln;
               for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
                 // compare i and j
                 if (W[w + cindex[p]] !== mark) {
                   ok = 0;
                 }
               }
               // check i and j are identical
               if (ok) {
                 // absorb j into i
                 cptr[j] = csFlip(i);
                 W[nv + i] += W[nv + j];
                 W[nv + j] = 0;
                 // node j is dead
                 W[elen + j] = -1;
                 // delete j from hash bucket
                 j = W[next + j];
                 W[next + jlast] = j;
               } else {
                 // j and i are different
                 jlast = j;
                 j = W[next + j];
               }
             }
           }
         }

         // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
         // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.
         for (p = pk1, pk = pk1; pk < pk2; pk++) {
           i = cindex[pk];
           // check  i is dead, skip it
           if ((nvi = -W[nv + i]) <= 0) {
             continue;
           }
           // restore W[nv + i]
           W[nv + i] = nvi;
           // compute external degree(i)
           d = W[degree + i] + dk - nvi;
           d = Math.min(d, n - nel - nvi);
           if (W[head + d] !== -1) {
             last[W[head + d]] = i;
           }
           // put i back in degree list
           W[next + i] = W[head + d];
           last[i] = -1;
           W[head + d] = i;
           // find new minimum degree
           mindeg = Math.min(mindeg, d);
           W[degree + i] = d;
           // place i in Lk
           cindex[p++] = i;
         }
         // # nodes absorbed into k
         W[nv + k] = nvk;
         // length of adj list of element k
         if ((W[len + k] = p - pk1) === 0) {
           // k is a root of the tree
           cptr[k] = -1;
           // k is now a dead element
           W[w + k] = 0;
         }
         if (elenk !== 0) {
           // free unused space in Lk
           cnz = p;
         }
       }

       // Postordering. The elimination is complete, but no permutation has been computed. All that is left
       // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
       // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
       // is computed. The tree is restored by unflipping all of ptr.

       // fix assembly tree
       for (i = 0; i < n; i++) {
         cptr[i] = csFlip(cptr[i]);
       }
       for (j = 0; j <= n; j++) {
         W[head + j] = -1;
       }
       // place unordered nodes in lists
       for (j = n; j >= 0; j--) {
         // skip if j is an element
         if (W[nv + j] > 0) {
           continue;
         }
         // place j in list of its parent
         W[next + j] = W[head + cptr[j]];
         W[head + cptr[j]] = j;
       }
       // place elements in lists
       for (e = n; e >= 0; e--) {
         // skip unless e is an element
         if (W[nv + e] <= 0) {
           continue;
         }
         if (cptr[e] !== -1) {
           // place e in list of its parent
           W[next + e] = W[head + cptr[e]];
           W[head + cptr[e]] = e;
         }
       }
       // postorder the assembly tree
       for (k = 0, i = 0; i <= n; i++) {
         if (cptr[i] === -1) {
           k = csTdfs(i, k, W, head, next, P, w);
         }
       }
       // remove last item in array
       P.splice(P.length - 1, 1);
       // return P
       return P;
     };

     /**
      * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
      * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
      *
      * Order: 0
      *   A natural ordering P=null matrix is returned.
      *
      * Order: 1
      *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
      *   P = M + M'
      *
      * Order: 2
      *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
      *   P = M' * M
      *
      * Order: 3
      *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
      *   P = M' * M
      */
     function _createTargetMatrix(order, a, m, n, dense) {
       // compute A'
       var at = transpose(a);

       // check order = 1, matrix must be square
       if (order === 1 && n === m) {
         // C = A + A'
         return add(a, at);
       }

       // check order = 2, drop dense columns from M'
       if (order === 2) {
         // transpose arrays
         var tindex = at._index;
         var tptr = at._ptr;
         // new column index
         var p2 = 0;
         // loop A' columns (rows)
         for (var j = 0; j < m; j++) {
           // column j of AT starts here
           var p = tptr[j];
           // new column j starts here
           tptr[j] = p2;
           // skip dense col j
           if (tptr[j + 1] - p > dense) {
             continue;
           }
           // map rows in column j of A
           for (var p1 = tptr[j + 1]; p < p1; p++) {
             tindex[p2++] = tindex[p];
           }
         }
         // finalize AT
         tptr[m] = p2;
         // recreate A from new transpose matrix
         a = transpose(at);
         // use A' * A
         return multiply(at, a);
       }

       // use A' * A, square or rectangular matrix
       return multiply(at, a);
     }

     /**
      * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
      *
      *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
      *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
      *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
      *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
      */
     function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
       // Initialize quotient graph
       for (var k = 0; k < n; k++) {
         W[len + k] = cptr[k + 1] - cptr[k];
       }
       W[len + n] = 0;
       // initialize workspace
       for (var i = 0; i <= n; i++) {
         // degree list i is empty
         W[head + i] = -1;
         last[i] = -1;
         W[next + i] = -1;
         // hash list i is empty
         W[hhead + i] = -1;
         // node i is just one node
         W[nv + i] = 1;
         // node i is alive
         W[w + i] = 1;
         // Ek of node i is empty
         W[elen + i] = 0;
         // degree of node i
         W[degree + i] = W[len + i];
       }
       // clear w
       var mark = _wclear(0, 0, W, w, n);
       // n is a dead element
       W[elen + n] = -2;
       // n is a root of assembly tree
       cptr[n] = -1;
       // n is a dead element
       W[w + n] = 0;
       // return mark
       return mark;
     }

     /**
      * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with
      * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
      * output permutation p.
      */
     function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
       // result
       var nel = 0;
       // loop columns
       for (var i = 0; i < n; i++) {
         // degree @ i
         var d = W[degree + i];
         // check node i is empty
         if (d === 0) {
           // element i is dead
           W[elen + i] = -2;
           nel++;
           // i is a root of assembly tree
           cptr[i] = -1;
           W[w + i] = 0;
         } else if (d > dense) {
           // absorb i into element n
           W[nv + i] = 0;
           // node i is dead
           W[elen + i] = -1;
           nel++;
           cptr[i] = csFlip(n);
           W[nv + n]++;
         } else {
           var h = W[head + d];
           if (h !== -1) {
             last[h] = i;
           }
           // put node i in degree list d
           W[next + i] = W[head + d];
           W[head + d] = i;
         }
       }
       return nel;
     }
     function _wclear(mark, lemax, W, w, n) {
       if (mark < 2 || mark + lemax < 0) {
         for (var k = 0; k < n; k++) {
           if (W[w + k] !== 0) {
             W[w + k] = 1;
           }
         }
         mark = 2;
       }
       // at this point, W [0..n-1] < mark holds
       return mark;
     }
     function _diag(i, j) {
       return i !== j;
     }
   });

   /**
    * This function determines if j is a leaf of the ith row subtree.
    * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
    *
    * @param {Number}  i               The ith row subtree
    * @param {Number}  j               The node to test
    * @param {Array}   w               The workspace array
    * @param {Number}  first           The index offset within the workspace for the first array
    * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
    * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
    * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
    *
    * @return {Object}
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
     var s, sparent;

     // our result
     var jleaf = 0;
     var q;

     // check j is a leaf
     if (i <= j || w[first + j] <= w[maxfirst + i]) {
       return -1;
     }
     // update max first[j] seen so far
     w[maxfirst + i] = w[first + j];
     // jprev = previous leaf of ith subtree
     var jprev = w[prevleaf + i];
     w[prevleaf + i] = j;

     // check j is first or subsequent leaf
     if (jprev === -1) {
       // 1st leaf, q = root of ith subtree
       jleaf = 1;
       q = i;
     } else {
       // update jleaf
       jleaf = 2;
       // q = least common ancester (jprev,j)
       for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]);
       for (s = jprev; s !== q; s = sparent) {
         // path compression
         sparent = w[ancestor + s];
         w[ancestor + s] = q;
       }
     }
     return {
       jleaf,
       q
     };
   }

   var name$1e = 'csCounts';
   var dependencies$1e = ['transpose'];
   var createCsCounts = /* #__PURE__ */factory(name$1e, dependencies$1e, _ref => {
     var {
       transpose
     } = _ref;
     /**
      * Computes the column counts using the upper triangular part of A.
      * It transposes A internally, none of the input parameters are modified.
      *
      * @param {Matrix} a           The sparse matrix A
      *
      * @param {Matrix} ata         Count the columns of A'A instead
      *
      * @return                     An array of size n of the column counts or null on error
      *
      * Reference: http://faculty.cse.tamu.edu/davis/publications.html
      */
     return function (a, parent, post, ata) {
       // check inputs
       if (!a || !parent || !post) {
         return null;
       }
       // a matrix arrays
       var asize = a._size;
       // rows and columns
       var m = asize[0];
       var n = asize[1];
       // variables
       var i, j, k, J, p, p0, p1;

       // workspace size
       var s = 4 * n + (ata ? n + m + 1 : 0);
       // allocate workspace
       var w = []; // (s)
       var ancestor = 0; // first n entries
       var maxfirst = n; // next n entries
       var prevleaf = 2 * n; // next n entries
       var first = 3 * n; // next n entries
       var head = 4 * n; // next n + 1 entries (used when ata is true)
       var next = 5 * n + 1; // last entries in workspace
       // clear workspace w[0..s-1]
       for (k = 0; k < s; k++) {
         w[k] = -1;
       }

       // allocate result
       var colcount = []; // (n)

       // AT = A'
       var at = transpose(a);
       // at arrays
       var tindex = at._index;
       var tptr = at._ptr;

       // find w[first + j]
       for (k = 0; k < n; k++) {
         j = post[k];
         // colcount[j]=1 if j is a leaf
         colcount[j] = w[first + j] === -1 ? 1 : 0;
         for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
           w[first + j] = k;
         }
       }

       // initialize ata if needed
       if (ata) {
         // invert post
         for (k = 0; k < n; k++) {
           w[post[k]] = k;
         }
         // loop rows (columns in AT)
         for (i = 0; i < m; i++) {
           // values in column i of AT
           for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
             k = Math.min(k, w[tindex[p]]);
           }
           // place row i in linked list k
           w[next + i] = w[head + k];
           w[head + k] = i;
         }
       }

       // each node in its own set
       for (i = 0; i < n; i++) {
         w[ancestor + i] = i;
       }
       for (k = 0; k < n; k++) {
         // j is the kth node in postordered etree
         j = post[k];
         // check j is not a root
         if (parent[j] !== -1) {
           colcount[parent[j]]--;
         }

         // J=j for LL'=A case
         for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
           for (p = tptr[J]; p < tptr[J + 1]; p++) {
             i = tindex[p];
             var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
             // check A(i,j) is in skeleton
             if (r.jleaf >= 1) {
               colcount[j]++;
             }
             // check account for overlap in q
             if (r.jleaf === 2) {
               colcount[r.q]--;
             }
           }
         }
         if (parent[j] !== -1) {
           w[ancestor + j] = parent[j];
         }
       }
       // sum up colcount's of each child
       for (j = 0; j < n; j++) {
         if (parent[j] !== -1) {
           colcount[parent[j]] += colcount[j];
         }
       }
       return colcount;
     };
   });

   var name$1d = 'csSqr';
   var dependencies$1d = ['add', 'multiply', 'transpose'];
   var createCsSqr = /* #__PURE__ */factory(name$1d, dependencies$1d, _ref => {
     var {
       add,
       multiply,
       transpose
     } = _ref;
     var csAmd = createCsAmd({
       add,
       multiply,
       transpose
     });
     var csCounts = createCsCounts({
       transpose
     });

     /**
      * Symbolic ordering and analysis for QR and LU decompositions.
      *
      * @param {Number}  order           The ordering strategy (see csAmd for more details)
      * @param {Matrix}  a               The A matrix
      * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
      *                                  symbolic ordering and analysis for LU decomposition (false)
      *
      * @return {Object}                 The Symbolic ordering and analysis for matrix A
      *
      * Reference: http://faculty.cse.tamu.edu/davis/publications.html
      */
     return function csSqr(order, a, qr) {
       // a arrays
       var aptr = a._ptr;
       var asize = a._size;
       // columns
       var n = asize[1];
       // vars
       var k;
       // symbolic analysis result
       var s = {};
       // fill-reducing ordering
       s.q = csAmd(order, a);
       // validate results
       if (order && !s.q) {
         return null;
       }
       // QR symbolic analysis
       if (qr) {
         // apply permutations if needed
         var c = order ? csPermute(a, null, s.q, 0) : a;
         // etree of C'*C, where C=A(:,q)
         s.parent = csEtree(c, 1);
         // post order elimination tree
         var post = csPost(s.parent, n);
         // col counts chol(C'*C)
         s.cp = csCounts(c, s.parent, post, 1);
         // check we have everything needed to calculate number of nonzero elements
         if (c && s.parent && s.cp && _vcount(c, s)) {
           // calculate number of nonzero elements
           for (s.unz = 0, k = 0; k < n; k++) {
             s.unz += s.cp[k];
           }
         }
       } else {
         // for LU factorization only, guess nnz(L) and nnz(U)
         s.unz = 4 * aptr[n] + n;
         s.lnz = s.unz;
       }
       // return result S
       return s;
     };

     /**
      * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
      */
     function _vcount(a, s) {
       // a arrays
       var aptr = a._ptr;
       var aindex = a._index;
       var asize = a._size;
       // rows & columns
       var m = asize[0];
       var n = asize[1];
       // initialize s arrays
       s.pinv = []; // (m + n)
       s.leftmost = []; // (m)
       // vars
       var parent = s.parent;
       var pinv = s.pinv;
       var leftmost = s.leftmost;
       // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries
       var w = []; // (m + 3 * n)
       var next = 0;
       var head = m;
       var tail = m + n;
       var nque = m + 2 * n;
       // vars
       var i, k, p, p0, p1;
       // initialize w
       for (k = 0; k < n; k++) {
         // queue k is empty
         w[head + k] = -1;
         w[tail + k] = -1;
         w[nque + k] = 0;
       }
       // initialize row arrays
       for (i = 0; i < m; i++) {
         leftmost[i] = -1;
       }
       // loop columns backwards
       for (k = n - 1; k >= 0; k--) {
         // values & index for column k
         for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
           // leftmost[i] = min(find(A(i,:)))
           leftmost[aindex[p]] = k;
         }
       }
       // scan rows in reverse order
       for (i = m - 1; i >= 0; i--) {
         // row i is not yet ordered
         pinv[i] = -1;
         k = leftmost[i];
         // check row i is empty
         if (k === -1) {
           continue;
         }
         // first row in queue k
         if (w[nque + k]++ === 0) {
           w[tail + k] = i;
         }
         // put i at head of queue k
         w[next + i] = w[head + k];
         w[head + k] = i;
       }
       s.lnz = 0;
       s.m2 = m;
       // find row permutation and nnz(V)
       for (k = 0; k < n; k++) {
         // remove row i from queue k
         i = w[head + k];
         // count V(k,k) as nonzero
         s.lnz++;
         // add a fictitious row
         if (i < 0) {
           i = s.m2++;
         }
         // associate row i with V(:,k)
         pinv[i] = k;
         // skip if V(k+1:m,k) is empty
         if (--nque[k] <= 0) {
           continue;
         }
         // nque[k] is nnz (V(k+1:m,k))
         s.lnz += w[nque + k];
         // move all rows to parent of k
         var pa = parent[k];
         if (pa !== -1) {
           if (w[nque + pa] === 0) {
             w[tail + pa] = w[tail + k];
           }
           w[next + w[tail + k]] = w[head + pa];
           w[head + pa] = w[next + i];
           w[nque + pa] += w[nque + k];
         }
       }
       for (i = 0; i < m; i++) {
         if (pinv[i] < 0) {
           pinv[i] = k++;
         }
       }
       return true;
     }
   });

   /**
    * Checks if the node at w[j] is marked
    *
    * @param {Array}   w               The array
    * @param {Number}  j               The array index
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csMarked(w, j) {
     // check node is marked
     return w[j] < 0;
   }

   /**
    * Marks the node at w[j]
    *
    * @param {Array}   w               The array
    * @param {Number}  j               The array index
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csMark(w, j) {
     // mark w[j]
     w[j] = csFlip(w[j]);
   }

   /**
    * Flips the value if it is negative of returns the same value otherwise.
    *
    * @param {Number}  i               The value to flip
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csUnflip(i) {
     // flip the value if it is negative
     return i < 0 ? csFlip(i) : i;
   }

   /**
    * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting
    * at nodes in B (see csReach()).
    *
    * @param {Number}  j               The starting node for the DFS algorithm
    * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored
    * @param {Number}  top             Start index in stack xi[top..n-1]
    * @param {Number}  k               The kth column in B
    * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
    *                                  The first n entries is the nonzero pattern, the last n entries is the stack
    * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
    *
    * @return {Number}                 New value of top
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csDfs(j, g, top, xi, pinv) {
     // g arrays
     var index = g._index;
     var ptr = g._ptr;
     var size = g._size;
     // columns
     var n = size[1];
     // vars
     var i, p, p2;
     // initialize head
     var head = 0;
     // initialize the recursion stack
     xi[0] = j;
     // loop
     while (head >= 0) {
       // get j from the top of the recursion stack
       j = xi[head];
       // apply permutation vector
       var jnew = pinv ? pinv[j] : j;
       // check node j is marked
       if (!csMarked(ptr, j)) {
         // mark node j as visited
         csMark(ptr, j);
         // update stack (last n entries in xi)
         xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
       }
       // node j done if no unvisited neighbors
       var done = 1;
       // examine all neighbors of j, stack (last n entries in xi)
       for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
         // consider neighbor node i
         i = index[p];
         // check we have visited node i, skip it
         if (csMarked(ptr, i)) {
           continue;
         }
         // pause depth-first search of node j, update stack (last n entries in xi)
         xi[n + head] = p;
         // start dfs at node i
         xi[++head] = i;
         // node j is not done
         done = 0;
         // break, to start dfs(i)
         break;
       }
       // check depth-first search at node j is done
       if (done) {
         // remove j from the recursion stack
         head--;
         // and place in the output stack
         xi[--top] = j;
       }
     }
     return top;
   }

   /**
    * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1
    * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The
    * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).
    *
    * @param {Matrix}  g               The G matrix
    * @param {Matrix}  b               The B matrix
    * @param {Number}  k               The kth column in B
    * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
    *                                  The first n entries is the nonzero pattern, the last n entries is the stack
    * @param {Array}   pinv            The inverse row permutation vector
    *
    * @return {Number}                 The index for the nonzero pattern
    *
    * Reference: http://faculty.cse.tamu.edu/davis/publications.html
    */
   function csReach(g, b, k, xi, pinv) {
     // g arrays
     var gptr = g._ptr;
     var gsize = g._size;
     // b arrays
     var bindex = b._index;
     var bptr = b._ptr;
     // columns
     var n = gsize[1];
     // vars
     var p, p0, p1;
     // initialize top
     var top = n;
     // loop column indeces in B
     for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
       // node i
       var i = bindex[p];
       // check node i is marked
       if (!csMarked(gptr, i)) {
         // start a dfs at unmarked node i
         top = csDfs(i, g, top, xi, pinv);
       }
     }
     // loop columns from top -> n - 1
     for (p = top; p < n; p++) {
       // restore G
       csMark(gptr, xi[p]);
     }
     return top;
   }

   var name$1c = 'csSpsolve';
   var dependencies$1c = ['divideScalar', 'multiply', 'subtract'];
   var createCsSpsolve = /* #__PURE__ */factory(name$1c, dependencies$1c, _ref => {
     var {
       divideScalar,
       multiply,
       subtract
     } = _ref;
     /**
      * The function csSpsolve() computes the solution to G * x = bk, where bk is the
      * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
      * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U
      * is upper triangular with the diagonal entry as the last entry in each column.
      *
      * @param {Matrix}  g               The G matrix
      * @param {Matrix}  b               The B matrix
      * @param {Number}  k               The kth column in B
      * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
      *                                  The first n entries is the nonzero pattern, the last n entries is the stack
      * @param {Array}   x               The soluton to the linear system G * x = b
      * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
      * @param {boolean} lo              The lower (true) upper triangular (false) flag
      *
      * @return {Number}                 The index for the nonzero pattern
      *
      * Reference: http://faculty.cse.tamu.edu/davis/publications.html
      */
     return function csSpsolve(g, b, k, xi, x, pinv, lo) {
       // g arrays
       var gvalues = g._values;
       var gindex = g._index;
       var gptr = g._ptr;
       var gsize = g._size;
       // columns
       var n = gsize[1];
       // b arrays
       var bvalues = b._values;
       var bindex = b._index;
       var bptr = b._ptr;
       // vars
       var p, p0, p1, q;
       // xi[top..n-1] = csReach(B(:,k))
       var top = csReach(g, b, k, xi, pinv);
       // clear x
       for (p = top; p < n; p++) {
         x[xi[p]] = 0;
       }
       // scatter b
       for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
         x[bindex[p]] = bvalues[p];
       }
       // loop columns
       for (var px = top; px < n; px++) {
         // x array index for px
         var j = xi[px];
         // apply permutation vector (U x = b), j maps to column J of G
         var J = pinv ? pinv[j] : j;
         // check column J is empty
         if (J < 0) {
           continue;
         }
         // column value indeces in G, p0 <= p < p1
         p0 = gptr[J];
         p1 = gptr[J + 1];
         // x(j) /= G(j,j)
         x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
         // first entry L(j,j)
         p = lo ? p0 + 1 : p0;
         q = lo ? p1 : p1 - 1;
         // loop
         for (; p < q; p++) {
           // row
           var i = gindex[p];
           // x(i) -= G(i,j) * x(j)
           x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
         }
       }
       // return top of stack
       return top;
     };
   });

   var name$1b = 'csLu';
   var dependencies$1b = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];
   var createCsLu = /* #__PURE__ */factory(name$1b, dependencies$1b, _ref => {
     var {
       abs,
       divideScalar,
       multiply,
       subtract,
       larger,
       largerEq,
       SparseMatrix
     } = _ref;
     var csSpsolve = createCsSpsolve({
       divideScalar,
       multiply,
       subtract
     });

     /**
      * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
      * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L
      * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
      * L * U = A(p, q), where p is the inverse of pinv.
      *
      * @param {Matrix}  m               The A Matrix to factorize
      * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing
      *                                  column ordering q
      * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
      *
      * @return {Number}                 The numeric LU factorization of A or null
      *
      * Reference: http://faculty.cse.tamu.edu/davis/publications.html
      */
     return function csLu(m, s, tol) {
       // validate input
       if (!m) {
         return null;
       }
       // m arrays
       var size = m._size;
       // columns
       var n = size[1];
       // symbolic analysis result
       var q;
       var lnz = 100;
       var unz = 100;
       // update symbolic analysis parameters
       if (s) {
         q = s.q;
         lnz = s.lnz || lnz;
         unz = s.unz || unz;
       }
       // L arrays
       var lvalues = []; // (lnz)
       var lindex = []; // (lnz)
       var lptr = []; // (n + 1)
       // L
       var L = new SparseMatrix({
         values: lvalues,
         index: lindex,
         ptr: lptr,
         size: [n, n]
       });
       // U arrays
       var uvalues = []; // (unz)
       var uindex = []; // (unz)
       var uptr = []; // (n + 1)
       // U
       var U = new SparseMatrix({
         values: uvalues,
         index: uindex,
         ptr: uptr,
         size: [n, n]
       });
       // inverse of permutation vector
       var pinv = []; // (n)
       // vars
       var i, p;
       // allocate arrays
       var x = []; // (n)
       var xi = []; // (2 * n)
       // initialize variables
       for (i = 0; i < n; i++) {
         // clear workspace
         x[i] = 0;
         // no rows pivotal yet
         pinv[i] = -1;
         // no cols of L yet
         lptr[i + 1] = 0;
       }
       // reset number of nonzero elements in L and U
       lnz = 0;
       unz = 0;
       // compute L(:,k) and U(:,k)
       for (var k = 0; k < n; k++) {
         // update ptr
         lptr[k] = lnz;
         uptr[k] = unz;
         // apply column permutations if needed
         var col = q ? q[k] : k;
         // solve triangular system, x = L\A(:,col)
         var top = csSpsolve(L, m, col, xi, x, pinv, 1);
         // find pivot
         var ipiv = -1;
         var a = -1;
         // loop xi[] from top -> n
         for (p = top; p < n; p++) {
           // x[i] is nonzero
           i = xi[p];
           // check row i is not yet pivotal
           if (pinv[i] < 0) {
             // absolute value of x[i]
             var xabs = abs(x[i]);
             // check absoulte value is greater than pivot value
             if (larger(xabs, a)) {
               // largest pivot candidate so far
               a = xabs;
               ipiv = i;
             }
           } else {
             // x(i) is the entry U(pinv[i],k)
             uindex[unz] = pinv[i];
             uvalues[unz++] = x[i];
           }
         }
         // validate we found a valid pivot
         if (ipiv === -1 || a <= 0) {
           return null;
         }
         // update actual pivot column, give preference to diagonal value
         if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
           ipiv = col;
         }
         // the chosen pivot
         var pivot = x[ipiv];
         // last entry in U(:,k) is U(k,k)
         uindex[unz] = k;
         uvalues[unz++] = pivot;
         // ipiv is the kth pivot row
         pinv[ipiv] = k;
         // first entry in L(:,k) is L(k,k) = 1
         lindex[lnz] = ipiv;
         lvalues[lnz++] = 1;
         // L(k+1:n,k) = x / pivot
         for (p = top; p < n; p++) {
           // row
           i = xi[p];
           // check x(i) is an entry in L(:,k)
           if (pinv[i] < 0) {
             // save unpermuted row in L
             lindex[lnz] = i;
             // scale pivot column
             lvalues[lnz++] = divideScalar(x[i], pivot);
           }
           // x[0..n-1] = 0 for next k
           x[i] = 0;
         }
       }
       // update ptr
       lptr[n] = lnz;
       uptr[n] = unz;
       // fix row indices of L for final pinv
       for (p = 0; p < lnz; p++) {
         lindex[p] = pinv[lindex[p]];
       }
       // trim arrays
       lvalues.splice(lnz, lvalues.length - lnz);
       lindex.splice(lnz, lindex.length - lnz);
       uvalues.splice(unz, uvalues.length - unz);
       uindex.splice(unz, uindex.length - unz);
       // return LU factor
       return {
         L,
         U,
         pinv
       };
     };
   });

   var name$1a = 'slu';
   var dependencies$1a = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];
   var createSlu = /* #__PURE__ */factory(name$1a, dependencies$1a, _ref => {
     var {
       typed,
       abs,
       add,
       multiply,
       transpose,
       divideScalar,
       subtract,
       larger,
       largerEq,
       SparseMatrix
     } = _ref;
     var csSqr = createCsSqr({
       add,
       multiply,
       transpose
     });
     var csLu = createCsLu({
       abs,
       divideScalar,
       multiply,
       subtract,
       larger,
       largerEq,
       SparseMatrix
     });

     /**
      * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
      *
      * `P * A * Q = L * U`
      *
      * Syntax:
      *
      *    math.slu(A, order, threshold)
      *
      * Examples:
      *
      *    const A = math.sparse([[4,3], [6, 3]])
      *    math.slu(A, 1, 0.001)
      *    // returns:
      *    // {
      *    //   L: [[1, 0], [1.5, 1]]
      *    //   U: [[4, 3], [0, -1.5]]
      *    //   p: [0, 1]
      *    //   q: [0, 1]
      *    // }
      *
      * See also:
      *
      *    lup, lsolve, usolve, lusolve
      *
      * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
      * @param {Number}       order          The Symbolic Ordering and Analysis order:
      *                                       0 - Natural ordering, no permutation vector q is returned
      *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
      *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.
      *                                           This is appropriatefor LU factorization of unsymmetric matrices.
      *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
      *                                           A dense row is a row with more than 10*sqr(columns) entries.
      * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
      *
      * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
      */
     return typed(name$1a, {
       'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {
         // verify order
         if (!isInteger$1(order) || order < 0 || order > 3) {
           throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');
         }
         // verify threshold
         if (threshold < 0 || threshold > 1) {
           throw new Error('Partial pivoting threshold must be a number from 0 to 1');
         }

         // perform symbolic ordering and analysis
         var s = csSqr(order, a, false);

         // perform lu decomposition
         var f = csLu(a, s, threshold);

         // return decomposition
         return {
           L: f.L,
           U: f.U,
           p: f.pinv,
           q: s.q,
           toString: function toString() {
             return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\np: ' + this.p.toString() + (this.q ? '\nq: ' + this.q.toString() : '') + '\n';
           }
         };
       }
     });
   });

   /**
    * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
    *
    * @param {Array} p           The permutation vector of length n. null value denotes identity
    * @param {Array} b           The input vector
    *
    * @return {Array}            The output vector x = P'b
    */
   function csIpvec(p, b) {
     // vars
     var k;
     var n = b.length;
     var x = [];
     // check permutation vector was provided, p = null denotes identity
     if (p) {
       // loop vector
       for (k = 0; k < n; k++) {
         // apply permutation
         x[p[k]] = b[k];
       }
     } else {
       // loop vector
       for (k = 0; k < n; k++) {
         // x[i] = b[i]
         x[k] = b[k];
       }
     }
     return x;
   }

   var name$19 = 'lusolve';
   var dependencies$19 = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];
   var createLusolve = /* #__PURE__ */factory(name$19, dependencies$19, _ref => {
     var {
       typed,
       matrix,
       lup,
       slu,
       usolve,
       lsolve,
       DenseMatrix
     } = _ref;
     var solveValidation = createSolveValidation({
       DenseMatrix
     });

     /**
      * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
      *
      * Syntax:
      *
      *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
      *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
      *
      * Examples:
      *
      *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
      *
      *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]
      *
      *    const f = math.lup(m)
      *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
      *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]
      *
      *    const a = [[-2, 3], [2, 1]]
      *    const b = [11, 9]
      *    const x = math.lusolve(a, b)  // [[2], [5]]
      *
      * See also:
      *
      *    lup, slu, lsolve, usolve
      *
      * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
      * @param {Matrix | Array} b               Column Vector
      * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
      * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
      *
      * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
      */
     return typed(name$19, {
       'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
         a = matrix(a);
         var d = lup(a);
         var x = _lusolve(d.L, d.U, d.p, null, b);
         return x.valueOf();
       },
       'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {
         var d = lup(a);
         return _lusolve(d.L, d.U, d.p, null, b);
       },
       'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {
         var d = lup(a);
         return _lusolve(d.L, d.U, d.p, null, b);
       },
       'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
         var d = slu(a, order, threshold);
         return _lusolve(d.L, d.U, d.p, d.q, b);
       },
       'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {
         return _lusolve(d.L, d.U, d.p, d.q, b);
       }
     });
     function _toMatrix(a) {
       if (isMatrix(a)) {
         return a;
       }
       if (isArray(a)) {
         return matrix(a);
       }
       throw new TypeError('Invalid Matrix LU decomposition');
     }
     function _lusolve(l, u, p, q, b) {
       // verify decomposition
       l = _toMatrix(l);
       u = _toMatrix(u);

       // apply row permutations if needed (b is a DenseMatrix)
       if (p) {
         b = solveValidation(l, b, true);
         b._data = csIpvec(p, b._data);
       }

       // use forward substitution to resolve L * y = b
       var y = lsolve(l, b);
       // use backward substitution to resolve U * x = y
       var x = usolve(u, y);

       // apply column permutations if needed (x is a DenseMatrix)
       if (q) {
         x._data = csIpvec(q, x._data);
       }
       return x;
     }
   });

   var name$18 = 'polynomialRoot';
   var dependencies$18 = ['typed', 'isZero', 'equalScalar', 'add', 'subtract', 'multiply', 'divide', 'sqrt', 'unaryMinus', 'cbrt', 'typeOf', 'im', 're'];
   var createPolynomialRoot = /* #__PURE__ */factory(name$18, dependencies$18, _ref => {
     var {
       typed,
       isZero,
       equalScalar,
       add,
       subtract,
       multiply,
       divide,
       sqrt,
       unaryMinus,
       cbrt,
       typeOf,
       im,
       re
     } = _ref;
     /**
      * Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
      * Currently operates only on linear, quadratic, and cubic polynomials using the standard
      * formulas for the roots.
      *
      * Syntax:
      *
      *     math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      *
      * Examples:
      *     // linear
      *     math.polynomialRoot(6, 3)                                        // [-2]
      *     math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]
      *     math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]
      *     // quadratic
      *     math.polynomialRoot(2, -3, 1)                                    // [2, 1]
      *     math.polynomialRoot(8, 8, 2)                                     // [-2]
      *     math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]
      *     math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]
      *     math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]
      *     // cubic
      *     math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]
      *     math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]
      *     math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]
      *     math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]
      *
      * See also:
      *     cbrt, sqrt
      *
      * @param {... number | Complex} coeffs
      *     The coefficients of the polynomial, starting with with the constant coefficent, followed
      *     by the linear coefficient and subsequent coefficients of increasing powers.
      * @return {Array} The distinct roots of the polynomial
      */

     return typed(name$18, {
       'number|Complex, ...number|Complex': (constant, restCoeffs) => {
         var coeffs = [constant, ...restCoeffs];
         while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
           coeffs.pop();
         }
         if (coeffs.length < 2) {
           throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
         }
         switch (coeffs.length) {
           case 2:
             // linear
             return [unaryMinus(divide(coeffs[0], coeffs[1]))];
           case 3:
             {
               // quadratic
               var [c, b, a] = coeffs;
               var denom = multiply(2, a);
               var d1 = multiply(b, b);
               var d2 = multiply(4, a, c);
               if (equalScalar(d1, d2)) return [divide(unaryMinus(b), denom)];
               var discriminant = sqrt(subtract(d1, d2));
               return [divide(subtract(discriminant, b), denom), divide(subtract(unaryMinus(discriminant), b), denom)];
             }
           case 4:
             {
               // cubic, cf. https://en.wikipedia.org/wiki/Cubic_equation
               var [d, _c, _b, _a] = coeffs;
               var _denom = unaryMinus(multiply(3, _a));
               var D0_1 = multiply(_b, _b);
               var D0_2 = multiply(3, _a, _c);
               var D1_1 = add(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
               var D1_2 = multiply(9, _a, _b, _c);
               if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
                 return [divide(_b, _denom)];
               }
               var Delta0 = subtract(D0_1, D0_2);
               var Delta1 = subtract(D1_1, D1_2);
               var discriminant1 = add(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
               var discriminant2 = add(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
               if (equalScalar(discriminant1, discriminant2)) {
                 return [divide(subtract(multiply(4, _a, _b, _c), add(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
                 // simple root
                 divide(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0)) // double root
                 ];
               }
               // OK, we have three distinct roots
               var Ccubed;
               if (equalScalar(D0_1, D0_2)) {
                 Ccubed = Delta1;
               } else {
                 Ccubed = divide(add(Delta1, sqrt(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
               }
               var allRoots = true;
               var rawRoots = cbrt(Ccubed, allRoots).toArray().map(C => divide(add(_b, C, divide(Delta0, C)), _denom));
               return rawRoots.map(r => {
                 if (typeOf(r) === 'Complex' && equalScalar(re(r), re(r) + im(r))) {
                   return re(r);
                 }
                 return r;
               });
             }
           default:
             throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
         }
       }
     });
   });

   var name$17 = 'Help';
   var dependencies$17 = ['parse'];
   var createHelpClass = /* #__PURE__ */factory(name$17, dependencies$17, _ref => {
     var {
       parse
     } = _ref;
     /**
      * Documentation object
      * @param {Object} doc  Object containing properties:
      *                      {string} name
      *                      {string} category
      *                      {string} description
      *                      {string[]} syntax
      *                      {string[]} examples
      *                      {string[]} seealso
      * @constructor
      */
     function Help(doc) {
       if (!(this instanceof Help)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       if (!doc) throw new Error('Argument "doc" missing');
       this.doc = doc;
     }

     /**
      * Attach type information
      */
     Help.prototype.type = 'Help';
     Help.prototype.isHelp = true;

     /**
      * Generate a string representation of the Help object
      * @return {string} Returns a string
      * @private
      */
     Help.prototype.toString = function () {
       var doc = this.doc || {};
       var desc = '\n';
       if (doc.name) {
         desc += 'Name: ' + doc.name + '\n\n';
       }
       if (doc.category) {
         desc += 'Category: ' + doc.category + '\n\n';
       }
       if (doc.description) {
         desc += 'Description:\n    ' + doc.description + '\n\n';
       }
       if (doc.syntax) {
         desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
       }
       if (doc.examples) {
         desc += 'Examples:\n';
         var scope = {};
         for (var i = 0; i < doc.examples.length; i++) {
           var expr = doc.examples[i];
           desc += '    ' + expr + '\n';
           var res = void 0;
           try {
             // note: res can be undefined when `expr` is an empty string
             res = parse(expr).compile().evaluate(scope);
           } catch (e) {
             res = e;
           }
           if (res !== undefined && !isHelp(res)) {
             desc += '        ' + format$1(res, {
               precision: 14
             }) + '\n';
           }
         }
         desc += '\n';
       }
       if (doc.mayThrow && doc.mayThrow.length) {
         desc += 'Throws: ' + doc.mayThrow.join(', ') + '\n\n';
       }
       if (doc.seealso && doc.seealso.length) {
         desc += 'See also: ' + doc.seealso.join(', ') + '\n';
       }
       return desc;
     };

     /**
      * Export the help object to JSON
      */
     Help.prototype.toJSON = function () {
       var obj = clone$3(this.doc);
       obj.mathjs = 'Help';
       return obj;
     };

     /**
      * Instantiate a Help object from a JSON object
      * @param {Object} json
      * @returns {Help} Returns a new Help object
      */
     Help.fromJSON = function (json) {
       var doc = {};
       Object.keys(json).filter(prop => prop !== 'mathjs').forEach(prop => {
         doc[prop] = json[prop];
       });
       return new Help(doc);
     };

     /**
      * Returns a string representation of the Help object
      */
     Help.prototype.valueOf = Help.prototype.toString;
     return Help;
   }, {
     isClass: true
   });

   var name$16 = 'Chain';
   var dependencies$16 = ['?on', 'math', 'typed'];
   var createChainClass = /* #__PURE__ */factory(name$16, dependencies$16, _ref => {
     var {
       on,
       math,
       typed
     } = _ref;
     /**
      * @constructor Chain
      * Wrap any value in a chain, allowing to perform chained operations on
      * the value.
      *
      * All methods available in the math.js library can be called upon the chain,
      * and then will be evaluated with the value itself as first argument.
      * The chain can be closed by executing chain.done(), which will return
      * the final value.
      *
      * The Chain has a number of special functions:
      * - done()             Finalize the chained operation and return the
      *                      chain's value.
      * - valueOf()          The same as done()
      * - toString()         Returns a string representation of the chain's value.
      *
      * @param {*} [value]
      */
     function Chain(value) {
       if (!(this instanceof Chain)) {
         throw new SyntaxError('Constructor must be called with the new operator');
       }
       if (isChain(value)) {
         this.value = value.value;
       } else {
         this.value = value;
       }
     }

     /**
      * Attach type information
      */
     Chain.prototype.type = 'Chain';
     Chain.prototype.isChain = true;

     /**
      * Close the chain. Returns the final value.
      * Does the same as method valueOf()
      * @returns {*} value
      */
     Chain.prototype.done = function () {
       return this.value;
     };

     /**
      * Close the chain. Returns the final value.
      * Does the same as method done()
      * @returns {*} value
      */
     Chain.prototype.valueOf = function () {
       return this.value;
     };

     /**
      * Get a string representation of the value in the chain
      * @returns {string}
      */
     Chain.prototype.toString = function () {
       return format$1(this.value);
     };

     /**
      * Get a JSON representation of the chain
      * @returns {Object}
      */
     Chain.prototype.toJSON = function () {
       return {
         mathjs: 'Chain',
         value: this.value
       };
     };

     /**
      * Instantiate a Chain from its JSON representation
      * @param {Object} json  An object structured like
      *                       `{"mathjs": "Chain", value: ...}`,
      *                       where mathjs is optional
      * @returns {Chain}
      */
     Chain.fromJSON = function (json) {
       return new Chain(json.value);
     };

     /**
      * Create a proxy method for the chain
      * @param {string} name
      * @param {Function} fn      The function to be proxied
      *                           If fn is no function, it is silently ignored.
      * @private
      */
     function createProxy(name, fn) {
       if (typeof fn === 'function') {
         Chain.prototype[name] = chainify(fn);
       }
     }

     /**
      * Create a proxy method for the chain
      * @param {string} name
      * @param {function} resolver   The function resolving with the
      *                              function to be proxied
      * @private
      */
     function createLazyProxy(name, resolver) {
       lazy(Chain.prototype, name, function outerResolver() {
         var fn = resolver();
         if (typeof fn === 'function') {
           return chainify(fn);
         }
         return undefined; // if not a function, ignore
       });
     }

     /**
      * Make a function chainable
      * @param {function} fn
      * @return {Function} chain function
      * @private
      */
     function chainify(fn) {
       return function () {
         // Here, `this` will be the context of a Chain instance
         if (arguments.length === 0) {
           return new Chain(fn(this.value));
         }
         var args = [this.value];
         for (var i = 0; i < arguments.length; i++) {
           args[i + 1] = arguments[i];
         }
         if (typed.isTypedFunction(fn)) {
           var sigObject = typed.resolve(fn, args);
           // We want to detect if a rest parameter has matched across the
           // value in the chain and the current arguments of this call.
           // That is the case if and only if the matching signature has
           // exactly one parameter (which then must be a rest parameter
           // as it is matching at least two actual arguments).
           if (sigObject.params.length === 1) {
             throw new Error('chain function ' + fn.name + ' cannot match rest parameter between chain value and additional arguments.');
           }
           return new Chain(sigObject.implementation.apply(fn, args));
         }
         return new Chain(fn.apply(fn, args));
       };
     }

     /**
      * Create a proxy for a single method, or an object with multiple methods.
      * Example usage:
      *
      *   Chain.createProxy('add', function add (x, y) {...})
      *   Chain.createProxy({
      *     add:      function add (x, y) {...},
      *     subtract: function subtract (x, y) {...}
      *   }
      *
      * @param {string | Object} arg0   A name (string), or an object with
      *                                 functions
      * @param {*} [arg1]               A function, when arg0 is a name
      */
     Chain.createProxy = function (arg0, arg1) {
       if (typeof arg0 === 'string') {
         // createProxy(name, value)
         createProxy(arg0, arg1);
       } else {
         var _loop = function _loop(_name) {
           if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {
             createLazyProxy(_name, () => arg0[_name]);
           }
         };
         // createProxy(values)
         for (var _name in arg0) {
           _loop(_name);
         }
       }
     };
     var excludedNames = {
       expression: true,
       docs: true,
       type: true,
       classes: true,
       json: true,
       error: true,
       isChain: true // conflicts with the property isChain of a Chain instance
     };

     // create proxy for everything that is in math.js
     Chain.createProxy(math);

     // register on the import event, automatically add a proxy for every imported function.
     if (on) {
       on('import', function (name, resolver, path) {
         if (!path) {
           // an imported function (not a data type or something special)
           createLazyProxy(name, resolver);
         }
       });
     }
     return Chain;
   }, {
     isClass: true
   });

   var eDocs = {
     name: 'e',
     category: 'Constants',
     syntax: ['e'],
     description: 'Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828',
     examples: ['e', 'e ^ 2', 'exp(2)', 'log(e)'],
     seealso: ['exp']
   };

   var falseDocs = {
     name: 'false',
     category: 'Constants',
     syntax: ['false'],
     description: 'Boolean value false',
     examples: ['false'],
     seealso: ['true']
   };

   var iDocs = {
     name: 'i',
     category: 'Constants',
     syntax: ['i'],
     description: 'Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.',
     examples: ['i', 'i * i', 'sqrt(-1)'],
     seealso: []
   };

   var InfinityDocs = {
     name: 'Infinity',
     category: 'Constants',
     syntax: ['Infinity'],
     description: 'Infinity, a number which is larger than the maximum number that can be handled by a floating point number.',
     examples: ['Infinity', '1 / 0'],
     seealso: []
   };

   var LN10Docs = {
     name: 'LN10',
     category: 'Constants',
     syntax: ['LN10'],
     description: 'Returns the natural logarithm of 10, approximately equal to 2.302',
     examples: ['LN10', 'log(10)'],
     seealso: []
   };

   var LN2Docs = {
     name: 'LN2',
     category: 'Constants',
     syntax: ['LN2'],
     description: 'Returns the natural logarithm of 2, approximately equal to 0.693',
     examples: ['LN2', 'log(2)'],
     seealso: []
   };

   var LOG10EDocs = {
     name: 'LOG10E',
     category: 'Constants',
     syntax: ['LOG10E'],
     description: 'Returns the base-10 logarithm of E, approximately equal to 0.434',
     examples: ['LOG10E', 'log(e, 10)'],
     seealso: []
   };

   var LOG2EDocs = {
     name: 'LOG2E',
     category: 'Constants',
     syntax: ['LOG2E'],
     description: 'Returns the base-2 logarithm of E, approximately equal to 1.442',
     examples: ['LOG2E', 'log(e, 2)'],
     seealso: []
   };

   var NaNDocs = {
     name: 'NaN',
     category: 'Constants',
     syntax: ['NaN'],
     description: 'Not a number',
     examples: ['NaN', '0 / 0'],
     seealso: []
   };

   var nullDocs = {
     name: 'null',
     category: 'Constants',
     syntax: ['null'],
     description: 'Value null',
     examples: ['null'],
     seealso: ['true', 'false']
   };

   var phiDocs = {
     name: 'phi',
     category: 'Constants',
     syntax: ['phi'],
     description: 'Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...',
     examples: ['phi'],
     seealso: []
   };

   var piDocs = {
     name: 'pi',
     category: 'Constants',
     syntax: ['pi'],
     description: 'The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159',
     examples: ['pi', 'sin(pi/2)'],
     seealso: ['tau']
   };

   var SQRT12Docs = {
     name: 'SQRT1_2',
     category: 'Constants',
     syntax: ['SQRT1_2'],
     description: 'Returns the square root of 1/2, approximately equal to 0.707',
     examples: ['SQRT1_2', 'sqrt(1/2)'],
     seealso: []
   };

   var SQRT2Docs = {
     name: 'SQRT2',
     category: 'Constants',
     syntax: ['SQRT2'],
     description: 'Returns the square root of 2, approximately equal to 1.414',
     examples: ['SQRT2', 'sqrt(2)'],
     seealso: []
   };

   var tauDocs = {
     name: 'tau',
     category: 'Constants',
     syntax: ['tau'],
     description: 'Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.',
     examples: ['tau', '2 * pi'],
     seealso: ['pi']
   };

   var trueDocs = {
     name: 'true',
     category: 'Constants',
     syntax: ['true'],
     description: 'Boolean value true',
     examples: ['true'],
     seealso: ['false']
   };

   var versionDocs = {
     name: 'version',
     category: 'Constants',
     syntax: ['version'],
     description: 'A string with the version number of math.js',
     examples: ['version'],
     seealso: []
   };

   var bignumberDocs = {
     name: 'bignumber',
     category: 'Construction',
     syntax: ['bignumber(x)'],
     description: 'Create a big number from a number or string.',
     examples: ['0.1 + 0.2', 'bignumber(0.1) + bignumber(0.2)', 'bignumber("7.2")', 'bignumber("7.2e500")', 'bignumber([0.1, 0.2, 0.3])'],
     seealso: ['boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit']
   };

   var booleanDocs = {
     name: 'boolean',
     category: 'Construction',
     syntax: ['x', 'boolean(x)'],
     description: 'Convert a string or number into a boolean.',
     examples: ['boolean(0)', 'boolean(1)', 'boolean(3)', 'boolean("true")', 'boolean("false")', 'boolean([1, 0, 1, 1])'],
     seealso: ['bignumber', 'complex', 'index', 'matrix', 'number', 'string', 'unit']
   };

   var complexDocs = {
     name: 'complex',
     category: 'Construction',
     syntax: ['complex()', 'complex(re, im)', 'complex(string)'],
     description: 'Create a complex number.',
     examples: ['complex()', 'complex(2, 3)', 'complex("7 - 2i")'],
     seealso: ['bignumber', 'boolean', 'index', 'matrix', 'number', 'string', 'unit']
   };

   var createUnitDocs = {
     name: 'createUnit',
     category: 'Construction',
     syntax: ['createUnit(definitions)', 'createUnit(name, definition)'],
     description: 'Create a user-defined unit and register it with the Unit type.',
     examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
     seealso: ['unit', 'splitUnit']
   };

   var fractionDocs = {
     name: 'fraction',
     category: 'Construction',
     syntax: ['fraction(num)', 'fraction(matrix)', 'fraction(num,den)', 'fraction({n: num, d: den})'],
     description: 'Create a fraction from a number or from integer numerator and denominator.',
     examples: ['fraction(0.125)', 'fraction(1, 3) + fraction(2, 5)', 'fraction({n: 333, d: 53})', 'fraction([sqrt(9), sqrt(10), sqrt(11)])'],
     seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'string', 'unit']
   };

   var indexDocs = {
     name: 'index',
     category: 'Construction',
     syntax: ['[start]', '[start:end]', '[start:step:end]', '[start1, start 2, ...]', '[start1:end1, start2:end2, ...]', '[start1:step1:end1, start2:step2:end2, ...]'],
     description: 'Create an index to get or replace a subset of a matrix',
     examples: ['A = [1, 2, 3; 4, 5, 6]', 'A[1, :]', 'A[1, 2] = 50', 'A[1:2, 1:2] = 1', 'B = [1, 2, 3]', 'B[B>1 and B<3]'],
     seealso: ['bignumber', 'boolean', 'complex', 'matrix,', 'number', 'range', 'string', 'unit']
   };

   var matrixDocs = {
     name: 'matrix',
     category: 'Construction',
     syntax: ['[]', '[a1, b1, ...; a2, b2, ...]', 'matrix()', 'matrix("dense")', 'matrix([...])'],
     description: 'Create a matrix.',
     examples: ['[]', '[1, 2, 3]', '[1, 2, 3; 4, 5, 6]', 'matrix()', 'matrix([3, 4])', 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
     seealso: ['bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'sparse']
   };

   var numberDocs = {
     name: 'number',
     category: 'Construction',
     syntax: ['x', 'number(x)', 'number(unit, valuelessUnit)'],
     description: 'Create a number or convert a string or boolean into a number.',
     examples: ['2', '2e3', '4.05', 'number(2)', 'number("7.2")', 'number(true)', 'number([true, false, true, true])', 'number(unit("52cm"), "m")'],
     seealso: ['bignumber', 'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit']
   };

   var sparseDocs = {
     name: 'sparse',
     category: 'Construction',
     syntax: ['sparse()', 'sparse([a1, b1, ...; a1, b2, ...])', 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
     description: 'Create a sparse matrix.',
     examples: ['sparse()', 'sparse([3, 4; 5, 6])', 'sparse([3, 0; 5, 0], "number")'],
     seealso: ['bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'matrix']
   };

   var splitUnitDocs = {
     name: 'splitUnit',
     category: 'Construction',
     syntax: ['splitUnit(unit: Unit, parts: Unit[])'],
     description: 'Split a unit in an array of units whose sum is equal to the original unit.',
     examples: ['splitUnit(1 m, ["feet", "inch"])'],
     seealso: ['unit', 'createUnit']
   };

   var stringDocs = {
     name: 'string',
     category: 'Construction',
     syntax: ['"text"', 'string(x)'],
     description: 'Create a string or convert a value to a string',
     examples: ['"Hello World!"', 'string(4.2)', 'string(3 + 2i)'],
     seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'unit']
   };

   var unitDocs = {
     name: 'unit',
     category: 'Construction',
     syntax: ['value unit', 'unit(value, unit)', 'unit(string)'],
     description: 'Create a unit.',
     examples: ['5.5 mm', '3 inch', 'unit(7.1, "kilogram")', 'unit("23 deg")'],
     seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'string']
   };

   var configDocs = {
     name: 'config',
     category: 'Core',
     syntax: ['config()', 'config(options)'],
     description: 'Get configuration or change configuration.',
     examples: ['config()', '1/3 + 1/4', 'config({number: "Fraction"})', '1/3 + 1/4'],
     seealso: []
   };

   var importDocs = {
     name: 'import',
     category: 'Core',
     syntax: ['import(functions)', 'import(functions, options)'],
     description: 'Import functions or constants from an object.',
     examples: ['import({myFn: f(x)=x^2, myConstant: 32 })', 'myFn(2)', 'myConstant'],
     seealso: []
   };

   var typedDocs = {
     name: 'typed',
     category: 'Core',
     syntax: ['typed(signatures)', 'typed(name, signatures)'],
     description: 'Create a typed function.',
     examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', 'double(2)', 'double("hello")'],
     seealso: []
   };

   var derivativeDocs = {
     name: 'derivative',
     category: 'Algebra',
     syntax: ['derivative(expr, variable)', 'derivative(expr, variable, {simplify: boolean})'],
     description: 'Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.',
     examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', 'df = derivative(f, x)', 'df.evaluate({x: 3})'],
     seealso: ['simplify', 'parse', 'evaluate']
   };

   var leafCountDocs = {
     name: 'leafCount',
     category: 'Algebra',
     syntax: ['leafCount(expr)'],
     description: 'Computes the number of leaves in the parse tree of the given expression',
     examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
     seealso: ['simplify']
   };

   var lsolveDocs = {
     name: 'lsolve',
     category: 'Algebra',
     syntax: ['x=lsolve(L, b)'],
     description: 'Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.',
     examples: ['a = [-2, 3; 2, 1]', 'b = [11, 9]', 'x = lsolve(a, b)'],
     seealso: ['lsolveAll', 'lup', 'lusolve', 'usolve', 'matrix', 'sparse']
   };

   var lsolveAllDocs = {
     name: 'lsolveAll',
     category: 'Algebra',
     syntax: ['x=lsolveAll(L, b)'],
     description: 'Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.',
     examples: ['a = [-2, 3; 2, 1]', 'b = [11, 9]', 'x = lsolve(a, b)'],
     seealso: ['lsolve', 'lup', 'lusolve', 'usolve', 'matrix', 'sparse']
   };

   var lupDocs = {
     name: 'lup',
     category: 'Algebra',
     syntax: ['lup(m)'],
     description: 'Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U',
     examples: ['lup([[2, 1], [1, 4]])', 'lup(matrix([[2, 1], [1, 4]]))', 'lup(sparse([[2, 1], [1, 4]]))'],
     seealso: ['lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'slu', 'qr']
   };

   var lusolveDocs = {
     name: 'lusolve',
     category: 'Algebra',
     syntax: ['x=lusolve(A, b)', 'x=lusolve(lu, b)'],
     description: 'Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.',
     examples: ['a = [-2, 3; 2, 1]', 'b = [11, 9]', 'x = lusolve(a, b)'],
     seealso: ['lup', 'slu', 'lsolve', 'usolve', 'matrix', 'sparse']
   };

   var polynomialRootDocs = {
     name: 'polynomialRoot',
     category: 'Algebra',
     syntax: ['x=polynomialRoot(-6, 3)', 'x=polynomialRoot(4, -4, 1)', 'x=polynomialRoot(-8, 12, -6, 1)'],
     description: 'Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.',
     examples: ['a = polynomialRoot(-6, 11, -6, 1)'],
     seealso: ['cbrt', 'sqrt']
   };

   var qrDocs = {
     name: 'qr',
     category: 'Algebra',
     syntax: ['qr(A)'],
     description: 'Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.',
     examples: ['qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])'],
     seealso: ['lup', 'slu', 'matrix']
   };

   var rationalizeDocs = {
     name: 'rationalize',
     category: 'Algebra',
     syntax: ['rationalize(expr)', 'rationalize(expr, scope)', 'rationalize(expr, scope, detailed)'],
     description: 'Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.',
     examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
     seealso: ['simplify']
   };

   var resolveDocs = {
     name: 'resolve',
     category: 'Algebra',
     syntax: ['resolve(node, scope)'],
     description: 'Recursively substitute variables in an expression tree.',
     examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
     seealso: ['simplify', 'evaluate'],
     mayThrow: ['ReferenceError']
   };

   var simplifyDocs = {
     name: 'simplify',
     category: 'Algebra',
     syntax: ['simplify(expr)', 'simplify(expr, rules)'],
     description: 'Simplify an expression tree.',
     examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', 'simplified = simplify(f)', 'simplified.evaluate({x: 2})'],
     seealso: ['simplifyCore', 'derivative', 'evaluate', 'parse', 'rationalize', 'resolve']
   };

   var simplifyConstantDocs = {
     name: 'simplifyConstant',
     category: 'Algebra',
     syntax: ['simplifyConstant(expr)', 'simplifyConstant(expr, options)'],
     description: 'Replace constant subexpressions of node with their values.',
     examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
     seealso: ['simplify', 'simplifyCore', 'evaluate']
   };

   var simplifyCoreDocs = {
     name: 'simplifyCore',
     category: 'Algebra',
     syntax: ['simplifyCore(node)'],
     description: 'Perform simple one-pass simplifications on an expression tree.',
     examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
     seealso: ['simplify', 'simplifyConstant', 'evaluate']
   };

   var sluDocs = {
     name: 'slu',
     category: 'Algebra',
     syntax: ['slu(A, order, threshold)'],
     description: 'Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U',
     examples: ['slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)'],
     seealso: ['lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'lup', 'qr']
   };

   var symbolicEqualDocs = {
     name: 'symbolicEqual',
     category: 'Algebra',
     syntax: ['symbolicEqual(expr1, expr2)', 'symbolicEqual(expr1, expr2, options)'],
     description: 'Returns true if the difference of the expressions simplifies to 0',
     examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
     seealso: ['simplify', 'evaluate']
   };

   var usolveDocs = {
     name: 'usolve',
     category: 'Algebra',
     syntax: ['x=usolve(U, b)'],
     description: 'Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.',
     examples: ['x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])'],
     seealso: ['usolveAll', 'lup', 'lusolve', 'lsolve', 'matrix', 'sparse']
   };

   var usolveAllDocs = {
     name: 'usolveAll',
     category: 'Algebra',
     syntax: ['x=usolve(U, b)'],
     description: 'Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.',
     examples: ['x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])'],
     seealso: ['usolve', 'lup', 'lusolve', 'lsolve', 'matrix', 'sparse']
   };

   var absDocs = {
     name: 'abs',
     category: 'Arithmetic',
     syntax: ['abs(x)'],
     description: 'Compute the absolute value.',
     examples: ['abs(3.5)', 'abs(-4.2)'],
     seealso: ['sign']
   };

   var addDocs = {
     name: 'add',
     category: 'Operators',
     syntax: ['x + y', 'add(x, y)'],
     description: 'Add two values.',
     examples: ['a = 2.1 + 3.6', 'a - 3.6', '3 + 2i', '3 cm + 2 inch', '"2.3" + "4"'],
     seealso: ['subtract']
   };

   var cbrtDocs = {
     name: 'cbrt',
     category: 'Arithmetic',
     syntax: ['cbrt(x)', 'cbrt(x, allRoots)'],
     description: 'Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned',
     examples: ['cbrt(64)', 'cube(4)', 'cbrt(-8)', 'cbrt(2 + 3i)', 'cbrt(8i)', 'cbrt(8i, true)', 'cbrt(27 m^3)'],
     seealso: ['square', 'sqrt', 'cube', 'multiply']
   };

   var ceilDocs = {
     name: 'ceil',
     category: 'Arithmetic',
     syntax: ['ceil(x)'],
     description: 'Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.',
     examples: ['ceil(3.2)', 'ceil(3.8)', 'ceil(-4.2)'],
     seealso: ['floor', 'fix', 'round']
   };

   var cubeDocs = {
     name: 'cube',
     category: 'Arithmetic',
     syntax: ['cube(x)'],
     description: 'Compute the cube of a value. The cube of x is x * x * x.',
     examples: ['cube(2)', '2^3', '2 * 2 * 2'],
     seealso: ['multiply', 'square', 'pow']
   };

   var divideDocs = {
     name: 'divide',
     category: 'Operators',
     syntax: ['x / y', 'divide(x, y)'],
     description: 'Divide two values.',
     examples: ['a = 2 / 3', 'a * 3', '4.5 / 2', '3 + 4 / 2', '(3 + 4) / 2', '18 km / 4.5'],
     seealso: ['multiply']
   };

   var dotDivideDocs = {
     name: 'dotDivide',
     category: 'Operators',
     syntax: ['x ./ y', 'dotDivide(x, y)'],
     description: 'Divide two values element wise.',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'b = [2, 1, 1; 3, 2, 5]', 'a ./ b'],
     seealso: ['multiply', 'dotMultiply', 'divide']
   };

   var dotMultiplyDocs = {
     name: 'dotMultiply',
     category: 'Operators',
     syntax: ['x .* y', 'dotMultiply(x, y)'],
     description: 'Multiply two values element wise.',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'b = [2, 1, 1; 3, 2, 5]', 'a .* b'],
     seealso: ['multiply', 'divide', 'dotDivide']
   };

   var dotPowDocs = {
     name: 'dotPow',
     category: 'Operators',
     syntax: ['x .^ y', 'dotPow(x, y)'],
     description: 'Calculates the power of x to y element wise.',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'a .^ 2'],
     seealso: ['pow']
   };

   var expDocs = {
     name: 'exp',
     category: 'Arithmetic',
     syntax: ['exp(x)'],
     description: 'Calculate the exponent of a value.',
     examples: ['exp(1.3)', 'e ^ 1.3', 'log(exp(1.3))', 'x = 2.4', '(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula'],
     seealso: ['expm', 'expm1', 'pow', 'log']
   };

   var expmDocs = {
     name: 'expm',
     category: 'Arithmetic',
     syntax: ['exp(x)'],
     description: 'Compute the matrix exponential, expm(A) = e^A. ' + 'The matrix must be square. ' + 'Not to be confused with exp(a), which performs element-wise exponentiation.',
     examples: ['expm([[0,2],[0,0]])'],
     seealso: ['exp']
   };

   var expm1Docs = {
     name: 'expm1',
     category: 'Arithmetic',
     syntax: ['expm1(x)'],
     description: 'Calculate the value of subtracting 1 from the exponential value.',
     examples: ['expm1(2)', 'pow(e, 2) - 1', 'log(expm1(2) + 1)'],
     seealso: ['exp', 'pow', 'log']
   };

   var fixDocs = {
     name: 'fix',
     category: 'Arithmetic',
     syntax: ['fix(x)'],
     description: 'Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.',
     examples: ['fix(3.2)', 'fix(3.8)', 'fix(-4.2)', 'fix(-4.8)'],
     seealso: ['ceil', 'floor', 'round']
   };

   var floorDocs = {
     name: 'floor',
     category: 'Arithmetic',
     syntax: ['floor(x)'],
     description: 'Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.',
     examples: ['floor(3.2)', 'floor(3.8)', 'floor(-4.2)'],
     seealso: ['ceil', 'fix', 'round']
   };

   var gcdDocs = {
     name: 'gcd',
     category: 'Arithmetic',
     syntax: ['gcd(a, b)', 'gcd(a, b, c, ...)'],
     description: 'Compute the greatest common divisor.',
     examples: ['gcd(8, 12)', 'gcd(-4, 6)', 'gcd(25, 15, -10)'],
     seealso: ['lcm', 'xgcd']
   };

   var hypotDocs = {
     name: 'hypot',
     category: 'Arithmetic',
     syntax: ['hypot(a, b, c, ...)', 'hypot([a, b, c, ...])'],
     description: 'Calculate the hypotenusa of a list with values. ',
     examples: ['hypot(3, 4)', 'sqrt(3^2 + 4^2)', 'hypot(-2)', 'hypot([3, 4, 5])'],
     seealso: ['abs', 'norm']
   };

   var invmodDocs = {
     name: 'invmod',
     category: 'Arithmetic',
     syntax: ['invmod(a, b)'],
     description: 'Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)',
     examples: ['invmod(8, 12)', 'invmod(7, 13)', 'invmod(15151, 15122)'],
     seealso: ['gcd', 'xgcd']
   };

   var lcmDocs = {
     name: 'lcm',
     category: 'Arithmetic',
     syntax: ['lcm(x, y)'],
     description: 'Compute the least common multiple.',
     examples: ['lcm(4, 6)', 'lcm(6, 21)', 'lcm(6, 21, 5)'],
     seealso: ['gcd']
   };

   var logDocs = {
     name: 'log',
     category: 'Arithmetic',
     syntax: ['log(x)', 'log(x, base)'],
     description: 'Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).',
     examples: ['log(3.5)', 'a = log(2.4)', 'exp(a)', '10 ^ 4', 'log(10000, 10)', 'log(10000) / log(10)', 'b = log(1024, 2)', '2 ^ b'],
     seealso: ['exp', 'log1p', 'log2', 'log10']
   };

   var log10Docs = {
     name: 'log10',
     category: 'Arithmetic',
     syntax: ['log10(x)'],
     description: 'Compute the 10-base logarithm of a value.',
     examples: ['log10(0.00001)', 'log10(10000)', '10 ^ 4', 'log(10000) / log(10)', 'log(10000, 10)'],
     seealso: ['exp', 'log']
   };

   var log1pDocs = {
     name: 'log1p',
     category: 'Arithmetic',
     syntax: ['log1p(x)', 'log1p(x, base)'],
     description: 'Calculate the logarithm of a `value+1`',
     examples: ['log1p(2.5)', 'exp(log1p(1.4))', 'pow(10, 4)', 'log1p(9999, 10)', 'log1p(9999) / log(10)'],
     seealso: ['exp', 'log', 'log2', 'log10']
   };

   var log2Docs = {
     name: 'log2',
     category: 'Arithmetic',
     syntax: ['log2(x)'],
     description: 'Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.',
     examples: ['log2(0.03125)', 'log2(16)', 'log2(16) / log2(2)', 'pow(2, 4)'],
     seealso: ['exp', 'log1p', 'log', 'log10']
   };

   var modDocs = {
     name: 'mod',
     category: 'Operators',
     syntax: ['x % y', 'x mod y', 'mod(x, y)'],
     description: 'Calculates the modulus, the remainder of an integer division.',
     examples: ['7 % 3', '11 % 2', '10 mod 4', 'isOdd(x) = x % 2', 'isOdd(2)', 'isOdd(3)'],
     seealso: ['divide']
   };

   var multiplyDocs = {
     name: 'multiply',
     category: 'Operators',
     syntax: ['x * y', 'multiply(x, y)'],
     description: 'multiply two values.',
     examples: ['a = 2.1 * 3.4', 'a / 3.4', '2 * 3 + 4', '2 * (3 + 4)', '3 * 2.1 km'],
     seealso: ['divide']
   };

   var normDocs = {
     name: 'norm',
     category: 'Arithmetic',
     syntax: ['norm(x)', 'norm(x, p)'],
     description: 'Calculate the norm of a number, vector or matrix.',
     examples: ['abs(-3.5)', 'norm(-3.5)', 'norm(3 - 4i)', 'norm([1, 2, -3], Infinity)', 'norm([1, 2, -3], -Infinity)', 'norm([3, 4], 2)', 'norm([[1, 2], [3, 4]], 1)', 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
   };

   var nthRootDocs = {
     name: 'nthRoot',
     category: 'Arithmetic',
     syntax: ['nthRoot(a)', 'nthRoot(a, root)'],
     description: 'Calculate the nth root of a value. ' + 'The principal nth root of a positive real number A, ' + 'is the positive real solution of the equation "x^root = A".',
     examples: ['4 ^ 3', 'nthRoot(64, 3)', 'nthRoot(9, 2)', 'sqrt(9)'],
     seealso: ['nthRoots', 'pow', 'sqrt']
   };

   var nthRootsDocs = {
     name: 'nthRoots',
     category: 'Arithmetic',
     syntax: ['nthRoots(A)', 'nthRoots(A, root)'],
     description: '' + 'Calculate the nth roots of a value. ' + 'An nth root of a positive real number A, ' + 'is a positive real solution of the equation "x^root = A". ' + 'This function returns an array of complex values.',
     examples: ['nthRoots(1)', 'nthRoots(1, 3)'],
     seealso: ['sqrt', 'pow', 'nthRoot']
   };

   var powDocs = {
     name: 'pow',
     category: 'Operators',
     syntax: ['x ^ y', 'pow(x, y)'],
     description: 'Calculates the power of x to y, x^y.',
     examples: ['2^3', '2*2*2', '1 + e ^ (pi * i)', 'pow([[1, 2], [4, 3]], 2)', 'pow([[1, 2], [4, 3]], -1)'],
     seealso: ['multiply', 'nthRoot', 'nthRoots', 'sqrt']
   };

   var roundDocs = {
     name: 'round',
     category: 'Arithmetic',
     syntax: ['round(x)', 'round(x, n)'],
     description: 'round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.',
     examples: ['round(3.2)', 'round(3.8)', 'round(-4.2)', 'round(-4.8)', 'round(pi, 3)', 'round(123.45678, 2)'],
     seealso: ['ceil', 'floor', 'fix']
   };

   var signDocs = {
     name: 'sign',
     category: 'Arithmetic',
     syntax: ['sign(x)'],
     description: 'Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.',
     examples: ['sign(3.5)', 'sign(-4.2)', 'sign(0)'],
     seealso: ['abs']
   };

   var sqrtDocs = {
     name: 'sqrt',
     category: 'Arithmetic',
     syntax: ['sqrt(x)'],
     description: 'Compute the square root value. If x = y * y, then y is the square root of x.',
     examples: ['sqrt(25)', '5 * 5', 'sqrt(-1)'],
     seealso: ['square', 'sqrtm', 'multiply', 'nthRoot', 'nthRoots', 'pow']
   };

   var sqrtmDocs = {
     name: 'sqrtm',
     category: 'Arithmetic',
     syntax: ['sqrtm(x)'],
     description: 'Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.',
     examples: ['sqrtm([[33, 24], [48, 57]])'],
     seealso: ['sqrt', 'abs', 'square', 'multiply']
   };

   var sylvesterDocs = {
     name: 'sylvester',
     category: 'Algebra',
     syntax: ['sylvester(A,B,C)'],
     description: 'Solves the real-valued Sylvester equation AX+XB=C for X',
     examples: ['sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])', 'A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]', 'sylvester(A, B, C)'],
     seealso: ['schur', 'lyap']
   };

   var schurDocs = {
     name: 'schur',
     category: 'Algebra',
     syntax: ['schur(A)'],
     description: 'Performs a real Schur decomposition of the real matrix A = UTU\'',
     examples: ['schur([[1, 0], [-4, 3]])', 'A = [[1, 0], [-4, 3]]', 'schur(A)'],
     seealso: ['lyap', 'sylvester']
   };

   var lyapDocs = {
     name: 'lyap',
     category: 'Algebra',
     syntax: ['lyap(A,Q)'],
     description: 'Solves the Continuous-time Lyapunov equation AP+PA\'+Q=0 for P',
     examples: ['lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])', 'A = [[-2, 0], [1, -4]]', 'Q = [[3, 1], [1, 3]]', 'lyap(A,Q)'],
     seealso: ['schur', 'sylvester']
   };

   var squareDocs = {
     name: 'square',
     category: 'Arithmetic',
     syntax: ['square(x)'],
     description: 'Compute the square of a value. The square of x is x * x.',
     examples: ['square(3)', 'sqrt(9)', '3^2', '3 * 3'],
     seealso: ['multiply', 'pow', 'sqrt', 'cube']
   };

   var subtractDocs = {
     name: 'subtract',
     category: 'Operators',
     syntax: ['x - y', 'subtract(x, y)'],
     description: 'subtract two values.',
     examples: ['a = 5.3 - 2', 'a + 2', '2/3 - 1/6', '2 * 3 - 3', '2.1 km - 500m'],
     seealso: ['add']
   };

   var unaryMinusDocs = {
     name: 'unaryMinus',
     category: 'Operators',
     syntax: ['-x', 'unaryMinus(x)'],
     description: 'Inverse the sign of a value. Converts booleans and strings to numbers.',
     examples: ['-4.5', '-(-5.6)', '-"22"'],
     seealso: ['add', 'subtract', 'unaryPlus']
   };

   var unaryPlusDocs = {
     name: 'unaryPlus',
     category: 'Operators',
     syntax: ['+x', 'unaryPlus(x)'],
     description: 'Converts booleans and strings to numbers.',
     examples: ['+true', '+"2"'],
     seealso: ['add', 'subtract', 'unaryMinus']
   };

   var xgcdDocs = {
     name: 'xgcd',
     category: 'Arithmetic',
     syntax: ['xgcd(a, b)'],
     description: 'Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.',
     examples: ['xgcd(8, 12)', 'gcd(8, 12)', 'xgcd(36163, 21199)'],
     seealso: ['gcd', 'lcm']
   };

   var bitAndDocs = {
     name: 'bitAnd',
     category: 'Bitwise',
     syntax: ['x & y', 'bitAnd(x, y)'],
     description: 'Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0',
     examples: ['5 & 3', 'bitAnd(53, 131)', '[1, 12, 31] & 42'],
     seealso: ['bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
   };

   var bitNotDocs = {
     name: 'bitNot',
     category: 'Bitwise',
     syntax: ['~x', 'bitNot(x)'],
     description: 'Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.',
     examples: ['~1', '~2', 'bitNot([2, -3, 4])'],
     seealso: ['bitAnd', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
   };

   var bitOrDocs = {
     name: 'bitOr',
     category: 'Bitwise',
     syntax: ['x | y', 'bitOr(x, y)'],
     description: 'Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.',
     examples: ['5 | 3', 'bitOr([1, 2, 3], 4)'],
     seealso: ['bitAnd', 'bitNot', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
   };

   var bitXorDocs = {
     name: 'bitXor',
     category: 'Bitwise',
     syntax: ['bitXor(x, y)'],
     description: 'Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.',
     examples: ['bitOr(1, 2)', 'bitXor([2, 3, 4], 4)'],
     seealso: ['bitAnd', 'bitNot', 'bitOr', 'leftShift', 'rightArithShift', 'rightLogShift']
   };

   var leftShiftDocs = {
     name: 'leftShift',
     category: 'Bitwise',
     syntax: ['x << y', 'leftShift(x, y)'],
     description: 'Bitwise left logical shift of a value x by y number of bits.',
     examples: ['4 << 1', '8 >> 1'],
     seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'rightArithShift', 'rightLogShift']
   };

   var rightArithShiftDocs = {
     name: 'rightArithShift',
     category: 'Bitwise',
     syntax: ['x >> y', 'rightArithShift(x, y)'],
     description: 'Bitwise right arithmetic shift of a value x by y number of bits.',
     examples: ['8 >> 1', '4 << 1', '-12 >> 2'],
     seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightLogShift']
   };

   var rightLogShiftDocs = {
     name: 'rightLogShift',
     category: 'Bitwise',
     syntax: ['x >>> y', 'rightLogShift(x, y)'],
     description: 'Bitwise right logical shift of a value x by y number of bits.',
     examples: ['8 >>> 1', '4 << 1', '-12 >>> 2'],
     seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift']
   };

   var bellNumbersDocs = {
     name: 'bellNumbers',
     category: 'Combinatorics',
     syntax: ['bellNumbers(n)'],
     description: 'The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.',
     examples: ['bellNumbers(3)', 'bellNumbers(8)'],
     seealso: ['stirlingS2']
   };

   var catalanDocs = {
     name: 'catalan',
     category: 'Combinatorics',
     syntax: ['catalan(n)'],
     description: 'The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.',
     examples: ['catalan(3)', 'catalan(8)'],
     seealso: ['bellNumbers']
   };

   var compositionDocs = {
     name: 'composition',
     category: 'Combinatorics',
     syntax: ['composition(n, k)'],
     description: 'The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.',
     examples: ['composition(5, 3)'],
     seealso: ['combinations']
   };

   var stirlingS2Docs = {
     name: 'stirlingS2',
     category: 'Combinatorics',
     syntax: ['stirlingS2(n, k)'],
     description: 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
     examples: ['stirlingS2(5, 3)'],
     seealso: ['bellNumbers']
   };

   var argDocs = {
     name: 'arg',
     category: 'Complex',
     syntax: ['arg(x)'],
     description: 'Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).',
     examples: ['arg(2 + 2i)', 'atan2(3, 2)', 'arg(2 + 3i)'],
     seealso: ['re', 'im', 'conj', 'abs']
   };

   var conjDocs = {
     name: 'conj',
     category: 'Complex',
     syntax: ['conj(x)'],
     description: 'Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.',
     examples: ['conj(2 + 3i)', 'conj(2 - 3i)', 'conj(-5.2i)'],
     seealso: ['re', 'im', 'abs', 'arg']
   };

   var imDocs = {
     name: 'im',
     category: 'Complex',
     syntax: ['im(x)'],
     description: 'Get the imaginary part of a complex number.',
     examples: ['im(2 + 3i)', 're(2 + 3i)', 'im(-5.2i)', 'im(2.4)'],
     seealso: ['re', 'conj', 'abs', 'arg']
   };

   var reDocs = {
     name: 're',
     category: 'Complex',
     syntax: ['re(x)'],
     description: 'Get the real part of a complex number.',
     examples: ['re(2 + 3i)', 'im(2 + 3i)', 're(-5.2i)', 're(2.4)'],
     seealso: ['im', 'conj', 'abs', 'arg']
   };

   var evaluateDocs = {
     name: 'evaluate',
     category: 'Expression',
     syntax: ['evaluate(expression)', 'evaluate(expression, scope)', 'evaluate([expr1, expr2, expr3, ...])', 'evaluate([expr1, expr2, expr3, ...], scope)'],
     description: 'Evaluate an expression or an array with expressions.',
     examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
     seealso: []
   };

   var helpDocs = {
     name: 'help',
     category: 'Expression',
     syntax: ['help(object)', 'help(string)'],
     description: 'Display documentation on a function or data type.',
     examples: ['help(sqrt)', 'help("complex")'],
     seealso: []
   };

   var distanceDocs = {
     name: 'distance',
     category: 'Geometry',
     syntax: ['distance([x1, y1], [x2, y2])', 'distance([[x1, y1], [x2, y2]])'],
     description: 'Calculates the Euclidean distance between two points.',
     examples: ['distance([0,0], [4,4])', 'distance([[0,0], [4,4]])'],
     seealso: []
   };

   var intersectDocs = {
     name: 'intersect',
     category: 'Geometry',
     syntax: ['intersect(expr1, expr2, expr3, expr4)', 'intersect(expr1, expr2, expr3)'],
     description: 'Computes the intersection point of lines and/or planes.',
     examples: ['intersect([0, 0], [10, 10], [10, 0], [0, 10])', 'intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])'],
     seealso: []
   };

   var andDocs = {
     name: 'and',
     category: 'Logical',
     syntax: ['x and y', 'and(x, y)'],
     description: 'Logical and. Test whether two values are both defined with a nonzero/nonempty value.',
     examples: ['true and false', 'true and true', '2 and 4'],
     seealso: ['not', 'or', 'xor']
   };

   var notDocs = {
     name: 'not',
     category: 'Logical',
     syntax: ['not x', 'not(x)'],
     description: 'Logical not. Flips the boolean value of given argument.',
     examples: ['not true', 'not false', 'not 2', 'not 0'],
     seealso: ['and', 'or', 'xor']
   };

   var orDocs = {
     name: 'or',
     category: 'Logical',
     syntax: ['x or y', 'or(x, y)'],
     description: 'Logical or. Test if at least one value is defined with a nonzero/nonempty value.',
     examples: ['true or false', 'false or false', '0 or 4'],
     seealso: ['not', 'and', 'xor']
   };

   var xorDocs = {
     name: 'xor',
     category: 'Logical',
     syntax: ['x xor y', 'xor(x, y)'],
     description: 'Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.',
     examples: ['true xor false', 'false xor false', 'true xor true', '0 xor 4'],
     seealso: ['not', 'and', 'or']
   };

   var columnDocs = {
     name: 'column',
     category: 'Matrix',
     syntax: ['column(x, index)'],
     description: 'Return a column from a matrix or array.',
     examples: ['A = [[1, 2], [3, 4]]', 'column(A, 1)', 'column(A, 2)'],
     seealso: ['row', 'matrixFromColumns']
   };

   var concatDocs = {
     name: 'concat',
     category: 'Matrix',
     syntax: ['concat(A, B, C, ...)', 'concat(A, B, C, ..., dim)'],
     description: 'Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.',
     examples: ['A = [1, 2; 5, 6]', 'B = [3, 4; 7, 8]', 'concat(A, B)', 'concat(A, B, 1)', 'concat(A, B, 2)'],
     seealso: ['det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var countDocs = {
     name: 'count',
     category: 'Matrix',
     syntax: ['count(x)'],
     description: 'Count the number of elements of a matrix, array or string.',
     examples: ['a = [1, 2; 3, 4; 5, 6]', 'count(a)', 'size(a)', 'count("hello world")'],
     seealso: ['size']
   };

   var crossDocs = {
     name: 'cross',
     category: 'Matrix',
     syntax: ['cross(A, B)'],
     description: 'Calculate the cross product for two vectors in three dimensional space.',
     examples: ['cross([1, 1, 0],  [0, 1, 1])', 'cross([3, -3, 1], [4, 9, 2])', 'cross([2, 3, 4],  [5, 6, 7])'],
     seealso: ['multiply', 'dot']
   };

   var ctransposeDocs = {
     name: 'ctranspose',
     category: 'Matrix',
     syntax: ['x\'', 'ctranspose(x)'],
     description: 'Complex Conjugate and Transpose a matrix',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'a\'', 'ctranspose(a)'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros']
   };

   var detDocs = {
     name: 'det',
     category: 'Matrix',
     syntax: ['det(x)'],
     description: 'Calculate the determinant of a matrix',
     examples: ['det([1, 2; 3, 4])', 'det([-2, 2, 3; -1, 1, 3; 2, 0, -1])'],
     seealso: ['concat', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var diagDocs = {
     name: 'diag',
     category: 'Matrix',
     syntax: ['diag(x)', 'diag(x, k)'],
     description: 'Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.',
     examples: ['diag(1:3)', 'diag(1:3, 1)', 'a = [1, 2, 3; 4, 5, 6; 7, 8, 9]', 'diag(a)'],
     seealso: ['concat', 'det', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var diffDocs = {
     name: 'diff',
     category: 'Matrix',
     syntax: ['diff(arr)', 'diff(arr, dim)'],
     description: ['Create a new matrix or array with the difference of the passed matrix or array.', 'Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference', 'If no dimension parameter is passed it is assumed as dimension 0', 'Dimension is zero-based in javascript and one-based in the parser', 'Arrays must be \'rectangular\' meaning arrays like [1, 2]', 'If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays'],
     examples: ['A = [1, 2, 4, 7, 0]', 'diff(A)', 'diff(A, 1)', 'B = [[1, 2], [3, 4]]', 'diff(B)', 'diff(B, 1)', 'diff(B, 2)', 'diff(B, bignumber(2))', 'diff([[1, 2], matrix([3, 4])], 2)'],
     seealso: ['subtract', 'partitionSelect']
   };

   var dotDocs = {
     name: 'dot',
     category: 'Matrix',
     syntax: ['dot(A, B)', 'A * B'],
     description: 'Calculate the dot product of two vectors. ' + 'The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] ' + 'is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn',
     examples: ['dot([2, 4, 1], [2, 2, 3])', '[2, 4, 1] * [2, 2, 3]'],
     seealso: ['multiply', 'cross']
   };

   var eigsDocs = {
     name: 'eigs',
     category: 'Matrix',
     syntax: ['eigs(x)'],
     description: 'Calculate the eigenvalues and eigenvectors of a real symmetric matrix',
     examples: ['eigs([[5, 2.3], [2.3, 1]])'],
     seealso: ['inv']
   };

   var filterDocs = {
     name: 'filter',
     category: 'Matrix',
     syntax: ['filter(x, test)'],
     description: 'Filter items in a matrix.',
     examples: ['isPositive(x) = x > 0', 'filter([6, -2, -1, 4, 3], isPositive)', 'filter([6, -2, 0, 1, 0], x != 0)'],
     seealso: ['sort', 'map', 'forEach']
   };

   var flattenDocs = {
     name: 'flatten',
     category: 'Matrix',
     syntax: ['flatten(x)'],
     description: 'Flatten a multi dimensional matrix into a single dimensional matrix.',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'size(a)', 'b = flatten(a)', 'size(b)'],
     seealso: ['concat', 'resize', 'size', 'squeeze']
   };

   var forEachDocs = {
     name: 'forEach',
     category: 'Matrix',
     syntax: ['forEach(x, callback)'],
     description: 'Iterates over all elements of a matrix/array, and executes the given callback function.',
     examples: ['numberOfPets = {}', 'addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;', 'forEach(["Dog","Cat","Cat"], addPet)', 'numberOfPets'],
     seealso: ['map', 'sort', 'filter']
   };

   var getMatrixDataTypeDocs = {
     name: 'getMatrixDataType',
     category: 'Matrix',
     syntax: ['getMatrixDataType(x)'],
     description: 'Find the data type of all elements in a matrix or array, ' + 'for example "number" if all items are a number ' + 'and "Complex" if all values are complex numbers. ' + 'If a matrix contains more than one data type, it will return "mixed".',
     examples: ['getMatrixDataType([1, 2, 3])', 'getMatrixDataType([[5 cm], [2 inch]])', 'getMatrixDataType([1, "text"])', 'getMatrixDataType([1, bignumber(4)])'],
     seealso: ['matrix', 'sparse', 'typeOf']
   };

   var identityDocs = {
     name: 'identity',
     category: 'Matrix',
     syntax: ['identity(n)', 'identity(m, n)', 'identity([m, n])'],
     description: 'Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.',
     examples: ['identity(3)', 'identity(3, 5)', 'a = [1, 2, 3; 4, 5, 6]', 'identity(size(a))'],
     seealso: ['concat', 'det', 'diag', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var invDocs = {
     name: 'inv',
     category: 'Matrix',
     syntax: ['inv(x)'],
     description: 'Calculate the inverse of a matrix',
     examples: ['inv([1, 2; 3, 4])', 'inv(4)', '1 / 4'],
     seealso: ['concat', 'det', 'diag', 'identity', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var pinvDocs = {
     name: 'pinv',
     category: 'Matrix',
     syntax: ['pinv(x)'],
     description: 'Calculate the Moore–Penrose inverse of a matrix',
     examples: ['pinv([1, 2; 3, 4])', 'pinv([[1, 0], [0, 1], [0, 1]])', 'pinv(4)'],
     seealso: ['inv']
   };

   var kronDocs = {
     name: 'kron',
     category: 'Matrix',
     syntax: ['kron(x, y)'],
     description: 'Calculates the kronecker product of 2 matrices or vectors.',
     examples: ['kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])', 'kron([1,1], [2,3,4])'],
     seealso: ['multiply', 'dot', 'cross']
   };

   var mapDocs = {
     name: 'map',
     category: 'Matrix',
     syntax: ['map(x, callback)'],
     description: 'Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.',
     examples: ['map([1, 2, 3], square)'],
     seealso: ['filter', 'forEach']
   };

   var matrixFromColumnsDocs = {
     name: 'matrixFromColumns',
     category: 'Matrix',
     syntax: ['matrixFromColumns(...arr)', 'matrixFromColumns(row1, row2)', 'matrixFromColumns(row1, row2, row3)'],
     description: 'Create a dense matrix from vectors as individual columns.',
     examples: ['matrixFromColumns([1, 2, 3], [[4],[5],[6]])'],
     seealso: ['matrix', 'matrixFromRows', 'matrixFromFunction', 'zeros']
   };

   var matrixFromFunctionDocs = {
     name: 'matrixFromFunction',
     category: 'Matrix',
     syntax: ['matrixFromFunction(size, fn)', 'matrixFromFunction(size, fn, format)', 'matrixFromFunction(size, fn, format, datatype)', 'matrixFromFunction(size, format, fn)', 'matrixFromFunction(size, format, datatype, fn)'],
     description: 'Create a matrix by evaluating a generating function at each index.',
     examples: ['f(I) = I[1] - I[2]', 'matrixFromFunction([3,3], f)', 'g(I) = I[1] - I[2] == 1 ? 4 : 0', 'matrixFromFunction([100, 100], "sparse", g)', 'matrixFromFunction([5], random)'],
     seealso: ['matrix', 'matrixFromRows', 'matrixFromColumns', 'zeros']
   };

   var matrixFromRowsDocs = {
     name: 'matrixFromRows',
     category: 'Matrix',
     syntax: ['matrixFromRows(...arr)', 'matrixFromRows(row1, row2)', 'matrixFromRows(row1, row2, row3)'],
     description: 'Create a dense matrix from vectors as individual rows.',
     examples: ['matrixFromRows([1, 2, 3], [[4],[5],[6]])'],
     seealso: ['matrix', 'matrixFromColumns', 'matrixFromFunction', 'zeros']
   };

   var onesDocs = {
     name: 'ones',
     category: 'Matrix',
     syntax: ['ones(m)', 'ones(m, n)', 'ones(m, n, p, ...)', 'ones([m])', 'ones([m, n])', 'ones([m, n, p, ...])'],
     description: 'Create a matrix containing ones.',
     examples: ['ones(3)', 'ones(3, 5)', 'ones([2,3]) * 4.5', 'a = [1, 2, 3; 4, 5, 6]', 'ones(size(a))'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var partitionSelectDocs = {
     name: 'partitionSelect',
     category: 'Matrix',
     syntax: ['partitionSelect(x, k)', 'partitionSelect(x, k, compare)'],
     description: 'Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.',
     examples: ['partitionSelect([5, 10, 1], 2)', 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', 'arr = [5, 2, 1]', 'partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]', 'arr', 'partitionSelect(arr, 1, \'desc\') # returns 2, arr is now: [5, 2, 1]', 'arr'],
     seealso: ['sort']
   };

   var rangeDocs = {
     name: 'range',
     category: 'Type',
     syntax: ['start:end', 'start:step:end', 'range(start, end)', 'range(start, end, step)', 'range(string)'],
     description: 'Create a range. Lower bound of the range is included, upper bound is excluded.',
     examples: ['1:5', '3:-1:-3', 'range(3, 7)', 'range(0, 12, 2)', 'range("4:10")', 'range(1m, 1m, 3m)', 'a = [1, 2, 3, 4; 5, 6, 7, 8]', 'a[1:2, 1:2]'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var reshapeDocs = {
     name: 'reshape',
     category: 'Matrix',
     syntax: ['reshape(x, sizes)'],
     description: 'Reshape a multi dimensional array to fit the specified dimensions.',
     examples: ['reshape([1, 2, 3, 4, 5, 6], [2, 3])', 'reshape([[1, 2], [3, 4]], [1, 4])', 'reshape([[1, 2], [3, 4]], [4])', 'reshape([1, 2, 3, 4], [-1, 2])'],
     seealso: ['size', 'squeeze', 'resize']
   };

   var resizeDocs = {
     name: 'resize',
     category: 'Matrix',
     syntax: ['resize(x, size)', 'resize(x, size, defaultValue)'],
     description: 'Resize a matrix.',
     examples: ['resize([1,2,3,4,5], [3])', 'resize([1,2,3], [5])', 'resize([1,2,3], [5], -1)', 'resize(2, [2, 3])', 'resize("hello", [8], "!")'],
     seealso: ['size', 'subset', 'squeeze', 'reshape']
   };

   var rotateDocs = {
     name: 'rotate',
     category: 'Matrix',
     syntax: ['rotate(w, theta)', 'rotate(w, theta, v)'],
     description: 'Returns a 2-D rotation matrix (2x2) for a given angle (in radians). ' + 'Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.',
     examples: ['rotate([1, 0], pi / 2)', 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
     seealso: ['matrix', 'rotationMatrix']
   };

   var rotationMatrixDocs = {
     name: 'rotationMatrix',
     category: 'Matrix',
     syntax: ['rotationMatrix(theta)', 'rotationMatrix(theta, v)', 'rotationMatrix(theta, v, format)'],
     description: 'Returns a 2-D rotation matrix (2x2) for a given angle (in radians). ' + 'Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.',
     examples: ['rotationMatrix(pi / 2)', 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
     seealso: ['cos', 'sin']
   };

   var rowDocs = {
     name: 'row',
     category: 'Matrix',
     syntax: ['row(x, index)'],
     description: 'Return a row from a matrix or array.',
     examples: ['A = [[1, 2], [3, 4]]', 'row(A, 1)', 'row(A, 2)'],
     seealso: ['column', 'matrixFromRows']
   };

   var sizeDocs = {
     name: 'size',
     category: 'Matrix',
     syntax: ['size(x)'],
     description: 'Calculate the size of a matrix.',
     examples: ['size(2.3)', 'size("hello world")', 'a = [1, 2; 3, 4; 5, 6]', 'size(a)', 'size(1:6)'],
     seealso: ['concat', 'count', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
   };

   var sortDocs = {
     name: 'sort',
     category: 'Matrix',
     syntax: ['sort(x)', 'sort(x, compare)'],
     description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
     examples: ['sort([5, 10, 1])', 'sort(["C", "B", "A", "D"], "natural")', 'sortByLength(a, b) = size(a)[1] - size(b)[1]', 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
     seealso: ['map', 'filter', 'forEach']
   };

   var squeezeDocs = {
     name: 'squeeze',
     category: 'Matrix',
     syntax: ['squeeze(x)'],
     description: 'Remove inner and outer singleton dimensions from a matrix.',
     examples: ['a = zeros(3,2,1)', 'size(squeeze(a))', 'b = zeros(1,1,3)', 'size(squeeze(b))'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'subset', 'trace', 'transpose', 'zeros']
   };

   var subsetDocs = {
     name: 'subset',
     category: 'Matrix',
     syntax: ['value(index)', 'value(index) = replacement', 'subset(value, [index])', 'subset(value, [index], replacement)'],
     description: 'Get or set a subset of the entries of a matrix or ' + 'characters of a string. ' + 'Indexes are one-based. There should be one index specification for ' + 'each dimension of the target. Each specification can be a single ' + 'index, a list of indices, or a range in colon notation `l:u`. ' + 'In a range, both the lower bound l and upper bound u are included; ' + 'and if a bound is omitted it defaults to the most extreme valid value. ' + 'The cartesian product of the indices specified in each dimension ' + 'determines the target of the operation.',
     examples: ['d = [1, 2; 3, 4]', 'e = []', 'e[1, 1:2] = [5, 6]', 'e[2, :] = [7, 8]', 'f = d * e', 'f[2, 1]', 'f[:, 1]', 'f[[1,2], [1,3]] = [9, 10; 11, 12]', 'f'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'trace', 'transpose', 'zeros']
   };

   var traceDocs = {
     name: 'trace',
     category: 'Matrix',
     syntax: ['trace(A)'],
     description: 'Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.',
     examples: ['A = [1, 2, 3; -1, 2, 3; 2, 0, 3]', 'trace(A)'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros']
   };

   var transposeDocs = {
     name: 'transpose',
     category: 'Matrix',
     syntax: ['x\'', 'transpose(x)'],
     description: 'Transpose a matrix',
     examples: ['a = [1, 2, 3; 4, 5, 6]', 'a\'', 'transpose(a)'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros']
   };

   var zerosDocs = {
     name: 'zeros',
     category: 'Matrix',
     syntax: ['zeros(m)', 'zeros(m, n)', 'zeros(m, n, p, ...)', 'zeros([m])', 'zeros([m, n])', 'zeros([m, n, p, ...])'],
     description: 'Create a matrix containing zeros.',
     examples: ['zeros(3)', 'zeros(3, 5)', 'a = [1, 2, 3; 4, 5, 6]', 'zeros(size(a))'],
     seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose']
   };

   var fftDocs = {
     name: 'fft',
     category: 'Matrix',
     syntax: ['fft(x)'],
     description: 'Calculate N-dimensional fourier transform',
     examples: ['fft([[1, 0], [1, 0]])'],
     seealso: ['ifft']
   };

   var ifftDocs = {
     name: 'ifft',
     category: 'Matrix',
     syntax: ['ifft(x)'],
     description: 'Calculate N-dimensional inverse fourier transform',
     examples: ['ifft([[2, 2], [0, 0]])'],
     seealso: ['fft']
   };

   var combinationsDocs = {
     name: 'combinations',
     category: 'Probability',
     syntax: ['combinations(n, k)'],
     description: 'Compute the number of combinations of n items taken k at a time',
     examples: ['combinations(7, 5)'],
     seealso: ['combinationsWithRep', 'permutations', 'factorial']
   };

   var combinationsWithRepDocs = {
     name: 'combinationsWithRep',
     category: 'Probability',
     syntax: ['combinationsWithRep(n, k)'],
     description: 'Compute the number of combinations of n items taken k at a time with replacements.',
     examples: ['combinationsWithRep(7, 5)'],
     seealso: ['combinations', 'permutations', 'factorial']
   };

   var factorialDocs = {
     name: 'factorial',
     category: 'Probability',
     syntax: ['n!', 'factorial(n)'],
     description: 'Compute the factorial of a value',
     examples: ['5!', '5 * 4 * 3 * 2 * 1', '3!'],
     seealso: ['combinations', 'combinationsWithRep', 'permutations', 'gamma']
   };

   var gammaDocs = {
     name: 'gamma',
     category: 'Probability',
     syntax: ['gamma(n)'],
     description: 'Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.',
     examples: ['gamma(4)', '3!', 'gamma(1/2)', 'sqrt(pi)'],
     seealso: ['factorial']
   };

   var lgammaDocs = {
     name: 'lgamma',
     category: 'Probability',
     syntax: ['lgamma(n)'],
     description: 'Logarithm of the gamma function for real, positive numbers and complex numbers, ' + 'using Lanczos approximation for numbers and Stirling series for complex numbers.',
     examples: ['lgamma(4)', 'lgamma(1/2)', 'lgamma(i)', 'lgamma(complex(1.1, 2))'],
     seealso: ['gamma']
   };

   var kldivergenceDocs = {
     name: 'kldivergence',
     category: 'Probability',
     syntax: ['kldivergence(x, y)'],
     description: 'Calculate the Kullback-Leibler (KL) divergence  between two distributions.',
     examples: ['kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])'],
     seealso: []
   };

   var multinomialDocs = {
     name: 'multinomial',
     category: 'Probability',
     syntax: ['multinomial(A)'],
     description: 'Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.',
     examples: ['multinomial([1, 2, 1])'],
     seealso: ['combinations', 'factorial']
   };

   var permutationsDocs = {
     name: 'permutations',
     category: 'Probability',
     syntax: ['permutations(n)', 'permutations(n, k)'],
     description: 'Compute the number of permutations of n items taken k at a time',
     examples: ['permutations(5)', 'permutations(5, 3)'],
     seealso: ['combinations', 'combinationsWithRep', 'factorial']
   };

   var pickRandomDocs = {
     name: 'pickRandom',
     category: 'Probability',
     syntax: ['pickRandom(array)', 'pickRandom(array, number)', 'pickRandom(array, weights)', 'pickRandom(array, number, weights)', 'pickRandom(array, weights, number)'],
     description: 'Pick a random entry from a given array.',
     examples: ['pickRandom(0:10)', 'pickRandom([1, 3, 1, 6])', 'pickRandom([1, 3, 1, 6], 2)', 'pickRandom([1, 3, 1, 6], [2, 3, 2, 1])', 'pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])', 'pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)'],
     seealso: ['random', 'randomInt']
   };

   var randomDocs = {
     name: 'random',
     category: 'Probability',
     syntax: ['random()', 'random(max)', 'random(min, max)', 'random(size)', 'random(size, max)', 'random(size, min, max)'],
     description: 'Return a random number.',
     examples: ['random()', 'random(10, 20)', 'random([2, 3])'],
     seealso: ['pickRandom', 'randomInt']
   };

   var randomIntDocs = {
     name: 'randomInt',
     category: 'Probability',
     syntax: ['randomInt(max)', 'randomInt(min, max)', 'randomInt(size)', 'randomInt(size, max)', 'randomInt(size, min, max)'],
     description: 'Return a random integer number',
     examples: ['randomInt(10, 20)', 'randomInt([2, 3], 10)'],
     seealso: ['pickRandom', 'random']
   };

   var compareDocs = {
     name: 'compare',
     category: 'Relational',
     syntax: ['compare(x, y)'],
     description: 'Compare two values. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
     examples: ['compare(2, 3)', 'compare(3, 2)', 'compare(2, 2)', 'compare(5cm, 40mm)', 'compare(2, [1, 2, 3])'],
     seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compareNatural', 'compareText']
   };

   var compareNaturalDocs = {
     name: 'compareNatural',
     category: 'Relational',
     syntax: ['compareNatural(x, y)'],
     description: 'Compare two values of any type in a deterministic, natural way. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
     examples: ['compareNatural(2, 3)', 'compareNatural(3, 2)', 'compareNatural(2, 2)', 'compareNatural(5cm, 40mm)', 'compareNatural("2", "10")', 'compareNatural(2 + 3i, 2 + 4i)', 'compareNatural([1, 2, 4], [1, 2, 3])', 'compareNatural([1, 5], [1, 2, 3])', 'compareNatural([1, 2], [1, 2])', 'compareNatural({a: 2}, {a: 4})'],
     seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare', 'compareText']
   };

   var compareTextDocs = {
     name: 'compareText',
     category: 'Relational',
     syntax: ['compareText(x, y)'],
     description: 'Compare two strings lexically. Comparison is case sensitive. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
     examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', 'compare(2, 10)', 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
     seealso: ['compare', 'compareNatural']
   };

   var deepEqualDocs = {
     name: 'deepEqual',
     category: 'Relational',
     syntax: ['deepEqual(x, y)'],
     description: 'Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.',
     examples: ['deepEqual([1,3,4], [1,3,4])', 'deepEqual([1,3,4], [1,3])'],
     seealso: ['equal', 'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare']
   };

   var equalDocs = {
     name: 'equal',
     category: 'Relational',
     syntax: ['x == y', 'equal(x, y)'],
     description: 'Check equality of two values. Returns true if the values are equal, and false if not.',
     examples: ['2+2 == 3', '2+2 == 4', 'a = 3.2', 'b = 6-2.8', 'a == b', '50cm == 0.5m'],
     seealso: ['unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual', 'equalText']
   };

   var equalTextDocs = {
     name: 'equalText',
     category: 'Relational',
     syntax: ['equalText(x, y)'],
     description: 'Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.',
     examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
     seealso: ['compare', 'compareNatural', 'compareText', 'equal']
   };

   var largerDocs = {
     name: 'larger',
     category: 'Relational',
     syntax: ['x > y', 'larger(x, y)'],
     description: 'Check if value x is larger than y. Returns true if x is larger than y, and false if not.',
     examples: ['2 > 3', '5 > 2*2', 'a = 3.3', 'b = 6-2.8', '(a > b)', '(b < a)', '5 cm > 2 inch'],
     seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare']
   };

   var largerEqDocs = {
     name: 'largerEq',
     category: 'Relational',
     syntax: ['x >= y', 'largerEq(x, y)'],
     description: 'Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.',
     examples: ['2 >= 1+1', '2 > 1+1', 'a = 3.2', 'b = 6-2.8', '(a >= b)'],
     seealso: ['equal', 'unequal', 'smallerEq', 'smaller', 'compare']
   };

   var smallerDocs = {
     name: 'smaller',
     category: 'Relational',
     syntax: ['x < y', 'smaller(x, y)'],
     description: 'Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.',
     examples: ['2 < 3', '5 < 2*2', 'a = 3.3', 'b = 6-2.8', '(a < b)', '5 cm < 2 inch'],
     seealso: ['equal', 'unequal', 'larger', 'smallerEq', 'largerEq', 'compare']
   };

   var smallerEqDocs = {
     name: 'smallerEq',
     category: 'Relational',
     syntax: ['x <= y', 'smallerEq(x, y)'],
     description: 'Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.',
     examples: ['2 <= 1+1', '2 < 1+1', 'a = 3.2', 'b = 6-2.8', '(a <= b)'],
     seealso: ['equal', 'unequal', 'larger', 'smaller', 'largerEq', 'compare']
   };

   var unequalDocs = {
     name: 'unequal',
     category: 'Relational',
     syntax: ['x != y', 'unequal(x, y)'],
     description: 'Check unequality of two values. Returns true if the values are unequal, and false if they are equal.',
     examples: ['2+2 != 3', '2+2 != 4', 'a = 3.2', 'b = 6-2.8', 'a != b', '50cm != 0.5m', '5 cm != 2 inch'],
     seealso: ['equal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual']
   };

   var setCartesianDocs = {
     name: 'setCartesian',
     category: 'Set',
     syntax: ['setCartesian(set1, set2)'],
     description: 'Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.',
     examples: ['setCartesian([1, 2], [3, 4])'],
     seealso: ['setUnion', 'setIntersect', 'setDifference', 'setPowerset']
   };

   var setDifferenceDocs = {
     name: 'setDifference',
     category: 'Set',
     syntax: ['setDifference(set1, set2)'],
     description: 'Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
     examples: ['setDifference([1, 2, 3, 4], [3, 4, 5, 6])', 'setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
     seealso: ['setUnion', 'setIntersect', 'setSymDifference']
   };

   var setDistinctDocs = {
     name: 'setDistinct',
     category: 'Set',
     syntax: ['setDistinct(set)'],
     description: 'Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.',
     examples: ['setDistinct([1, 1, 1, 2, 2, 3])'],
     seealso: ['setMultiplicity']
   };

   var setIntersectDocs = {
     name: 'setIntersect',
     category: 'Set',
     syntax: ['setIntersect(set1, set2)'],
     description: 'Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
     examples: ['setIntersect([1, 2, 3, 4], [3, 4, 5, 6])', 'setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
     seealso: ['setUnion', 'setDifference']
   };

   var setIsSubsetDocs = {
     name: 'setIsSubset',
     category: 'Set',
     syntax: ['setIsSubset(set1, set2)'],
     description: 'Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
     examples: ['setIsSubset([1, 2], [3, 4, 5, 6])', 'setIsSubset([3, 4], [3, 4, 5, 6])'],
     seealso: ['setUnion', 'setIntersect', 'setDifference']
   };

   var setMultiplicityDocs = {
     name: 'setMultiplicity',
     category: 'Set',
     syntax: ['setMultiplicity(element, set)'],
     description: 'Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.',
     examples: ['setMultiplicity(1, [1, 2, 2, 4])', 'setMultiplicity(2, [1, 2, 2, 4])'],
     seealso: ['setDistinct', 'setSize']
   };

   var setPowersetDocs = {
     name: 'setPowerset',
     category: 'Set',
     syntax: ['setPowerset(set)'],
     description: 'Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.',
     examples: ['setPowerset([1, 2, 3])'],
     seealso: ['setCartesian']
   };

   var setSizeDocs = {
     name: 'setSize',
     category: 'Set',
     syntax: ['setSize(set)', 'setSize(set, unique)'],
     description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
     examples: ['setSize([1, 2, 2, 4])', 'setSize([1, 2, 2, 4], true)'],
     seealso: ['setUnion', 'setIntersect', 'setDifference']
   };

   var setSymDifferenceDocs = {
     name: 'setSymDifference',
     category: 'Set',
     syntax: ['setSymDifference(set1, set2)'],
     description: 'Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
     examples: ['setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])', 'setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
     seealso: ['setUnion', 'setIntersect', 'setDifference']
   };

   var setUnionDocs = {
     name: 'setUnion',
     category: 'Set',
     syntax: ['setUnion(set1, set2)'],
     description: 'Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
     examples: ['setUnion([1, 2, 3, 4], [3, 4, 5, 6])', 'setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
     seealso: ['setIntersect', 'setDifference']
   };

   var zpk2tfDocs = {
     name: 'zpk2tf',
     category: 'Signal',
     syntax: ['zpk2tf(z, p, k)'],
     description: 'Compute the transfer function of a zero-pole-gain model.',
     examples: ['zpk2tf([1, 2], [-1, -2], 1)', 'zpk2tf([1, 2], [-1, -2])', 'zpk2tf([1 - 3i, 2 + 2i], [-1, -2])'],
     seealso: []
   };

   var freqzDocs = {
     name: 'freqz',
     category: 'Signal',
     syntax: ['freqz(b, a)', 'freqz(b, a, w)'],
     description: 'Calculates the frequency response of a filter given its numerator and denominator coefficients.',
     examples: ['freqz([1, 2], [1, 2, 3])', 'freqz([1, 2], [1, 2, 3], [0, 1])', 'freqz([1, 2], [1, 2, 3], 512)'],
     seealso: []
   };

   var erfDocs = {
     name: 'erf',
     category: 'Special',
     syntax: ['erf(x)'],
     description: 'Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x',
     examples: ['erf(0.2)', 'erf(-0.5)', 'erf(4)'],
     seealso: []
   };

   var zetaDocs = {
     name: 'zeta',
     category: 'Special',
     syntax: ['zeta(s)'],
     description: 'Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane',
     examples: ['zeta(0.2)', 'zeta(-0.5)', 'zeta(4)'],
     seealso: []
   };

   var madDocs = {
     name: 'mad',
     category: 'Statistics',
     syntax: ['mad(a, b, c, ...)', 'mad(A)'],
     description: 'Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.',
     examples: ['mad(10, 20, 30)', 'mad([1, 2, 3])'],
     seealso: ['mean', 'median', 'std', 'abs']
   };

   var maxDocs = {
     name: 'max',
     category: 'Statistics',
     syntax: ['max(a, b, c, ...)', 'max(A)', 'max(A, dimension)'],
     description: 'Compute the maximum value of a list of values.',
     examples: ['max(2, 3, 4, 1)', 'max([2, 3, 4, 1])', 'max([2, 5; 4, 3])', 'max([2, 5; 4, 3], 1)', 'max([2, 5; 4, 3], 2)', 'max(2.7, 7.1, -4.5, 2.0, 4.1)', 'min(2.7, 7.1, -4.5, 2.0, 4.1)'],
     seealso: ['mean', 'median', 'min', 'prod', 'std', 'sum', 'variance']
   };

   var meanDocs = {
     name: 'mean',
     category: 'Statistics',
     syntax: ['mean(a, b, c, ...)', 'mean(A)', 'mean(A, dimension)'],
     description: 'Compute the arithmetic mean of a list of values.',
     examples: ['mean(2, 3, 4, 1)', 'mean([2, 3, 4, 1])', 'mean([2, 5; 4, 3])', 'mean([2, 5; 4, 3], 1)', 'mean([2, 5; 4, 3], 2)', 'mean([1.0, 2.7, 3.2, 4.0])'],
     seealso: ['max', 'median', 'min', 'prod', 'std', 'sum', 'variance']
   };

   var medianDocs = {
     name: 'median',
     category: 'Statistics',
     syntax: ['median(a, b, c, ...)', 'median(A)'],
     description: 'Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.',
     examples: ['median(5, 2, 7)', 'median([3, -1, 5, 7])'],
     seealso: ['max', 'mean', 'min', 'prod', 'std', 'sum', 'variance', 'quantileSeq']
   };

   var minDocs = {
     name: 'min',
     category: 'Statistics',
     syntax: ['min(a, b, c, ...)', 'min(A)', 'min(A, dimension)'],
     description: 'Compute the minimum value of a list of values.',
     examples: ['min(2, 3, 4, 1)', 'min([2, 3, 4, 1])', 'min([2, 5; 4, 3])', 'min([2, 5; 4, 3], 1)', 'min([2, 5; 4, 3], 2)', 'min(2.7, 7.1, -4.5, 2.0, 4.1)', 'max(2.7, 7.1, -4.5, 2.0, 4.1)'],
     seealso: ['max', 'mean', 'median', 'prod', 'std', 'sum', 'variance']
   };

   var modeDocs = {
     name: 'mode',
     category: 'Statistics',
     syntax: ['mode(a, b, c, ...)', 'mode(A)', 'mode(A, a, b, B, c, ...)'],
     description: 'Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.',
     examples: ['mode(2, 1, 4, 3, 1)', 'mode([1, 2.7, 3.2, 4, 2.7])', 'mode(1, 4, 6, 1, 6)'],
     seealso: ['max', 'mean', 'min', 'median', 'prod', 'std', 'sum', 'variance']
   };

   var prodDocs = {
     name: 'prod',
     category: 'Statistics',
     syntax: ['prod(a, b, c, ...)', 'prod(A)'],
     description: 'Compute the product of all values.',
     examples: ['prod(2, 3, 4)', 'prod([2, 3, 4])', 'prod([2, 5; 4, 3])'],
     seealso: ['max', 'mean', 'min', 'median', 'min', 'std', 'sum', 'variance']
   };

   var quantileSeqDocs = {
     name: 'quantileSeq',
     category: 'Statistics',
     syntax: ['quantileSeq(A, prob[, sorted])', 'quantileSeq(A, [prob1, prob2, ...][, sorted])', 'quantileSeq(A, N[, sorted])'],
     description: 'Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.',
     examples: ['quantileSeq([3, -1, 5, 7], 0.5)', 'quantileSeq([3, -1, 5, 7], [1/3, 2/3])', 'quantileSeq([3, -1, 5, 7], 2)', 'quantileSeq([-1, 3, 5, 7], 0.5, true)'],
     seealso: ['mean', 'median', 'min', 'max', 'prod', 'std', 'sum', 'variance']
   };

   var stdDocs = {
     name: 'std',
     category: 'Statistics',
     syntax: ['std(a, b, c, ...)', 'std(A)', 'std(A, dimension)', 'std(A, normalization)', 'std(A, dimension, normalization)'],
     description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
     examples: ['std(2, 4, 6)', 'std([2, 4, 6, 8])', 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', 'std([1, 2, 3; 4, 5, 6])'],
     seealso: ['max', 'mean', 'min', 'median', 'prod', 'sum', 'variance']
   };

   var cumSumDocs = {
     name: 'cumsum',
     category: 'Statistics',
     syntax: ['cumsum(a, b, c, ...)', 'cumsum(A)'],
     description: 'Compute the cumulative sum of all values.',
     examples: ['cumsum(2, 3, 4, 1)', 'cumsum([2, 3, 4, 1])', 'cumsum([1, 2; 3, 4])', 'cumsum([1, 2; 3, 4], 1)', 'cumsum([1, 2; 3, 4], 2)'],
     seealso: ['max', 'mean', 'median', 'min', 'prod', 'std', 'sum', 'variance']
   };

   var sumDocs = {
     name: 'sum',
     category: 'Statistics',
     syntax: ['sum(a, b, c, ...)', 'sum(A)', 'sum(A, dimension)'],
     description: 'Compute the sum of all values.',
     examples: ['sum(2, 3, 4, 1)', 'sum([2, 3, 4, 1])', 'sum([2, 5; 4, 3])'],
     seealso: ['max', 'mean', 'median', 'min', 'prod', 'std', 'sum', 'variance']
   };

   var varianceDocs = {
     name: 'variance',
     category: 'Statistics',
     syntax: ['variance(a, b, c, ...)', 'variance(A)', 'variance(A, dimension)', 'variance(A, normalization)', 'variance(A, dimension, normalization)'],
     description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
     examples: ['variance(2, 4, 6)', 'variance([2, 4, 6, 8])', 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', 'variance([1, 2, 3; 4, 5, 6])'],
     seealso: ['max', 'mean', 'min', 'median', 'min', 'prod', 'std', 'sum']
   };

   var corrDocs = {
     name: 'corr',
     category: 'Statistics',
     syntax: ['corr(A,B)'],
     description: 'Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.',
     examples: ['corr([2, 4, 6, 8],[1, 2, 3, 6])', 'corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))'],
     seealso: ['max', 'mean', 'min', 'median', 'min', 'prod', 'std', 'sum']
   };

   var acosDocs = {
     name: 'acos',
     category: 'Trigonometry',
     syntax: ['acos(x)'],
     description: 'Compute the inverse cosine of a value in radians.',
     examples: ['acos(0.5)', 'acos(cos(2.3))'],
     seealso: ['cos', 'atan', 'asin']
   };

   var acoshDocs = {
     name: 'acosh',
     category: 'Trigonometry',
     syntax: ['acosh(x)'],
     description: 'Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.',
     examples: ['acosh(1.5)'],
     seealso: ['cosh', 'asinh', 'atanh']
   };

   var acotDocs = {
     name: 'acot',
     category: 'Trigonometry',
     syntax: ['acot(x)'],
     description: 'Calculate the inverse cotangent of a value.',
     examples: ['acot(0.5)', 'acot(cot(0.5))', 'acot(2)'],
     seealso: ['cot', 'atan']
   };

   var acothDocs = {
     name: 'acoth',
     category: 'Trigonometry',
     syntax: ['acoth(x)'],
     description: 'Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.',
     examples: ['acoth(2)', 'acoth(0.5)'],
     seealso: ['acsch', 'asech']
   };

   var acscDocs = {
     name: 'acsc',
     category: 'Trigonometry',
     syntax: ['acsc(x)'],
     description: 'Calculate the inverse cotangent of a value.',
     examples: ['acsc(2)', 'acsc(csc(0.5))', 'acsc(0.5)'],
     seealso: ['csc', 'asin', 'asec']
   };

   var acschDocs = {
     name: 'acsch',
     category: 'Trigonometry',
     syntax: ['acsch(x)'],
     description: 'Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.',
     examples: ['acsch(0.5)'],
     seealso: ['asech', 'acoth']
   };

   var asecDocs = {
     name: 'asec',
     category: 'Trigonometry',
     syntax: ['asec(x)'],
     description: 'Calculate the inverse secant of a value.',
     examples: ['asec(0.5)', 'asec(sec(0.5))', 'asec(2)'],
     seealso: ['acos', 'acot', 'acsc']
   };

   var asechDocs = {
     name: 'asech',
     category: 'Trigonometry',
     syntax: ['asech(x)'],
     description: 'Calculate the inverse secant of a value.',
     examples: ['asech(0.5)'],
     seealso: ['acsch', 'acoth']
   };

   var asinDocs = {
     name: 'asin',
     category: 'Trigonometry',
     syntax: ['asin(x)'],
     description: 'Compute the inverse sine of a value in radians.',
     examples: ['asin(0.5)', 'asin(sin(0.5))'],
     seealso: ['sin', 'acos', 'atan']
   };

   var asinhDocs = {
     name: 'asinh',
     category: 'Trigonometry',
     syntax: ['asinh(x)'],
     description: 'Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.',
     examples: ['asinh(0.5)'],
     seealso: ['acosh', 'atanh']
   };

   var atanDocs = {
     name: 'atan',
     category: 'Trigonometry',
     syntax: ['atan(x)'],
     description: 'Compute the inverse tangent of a value in radians.',
     examples: ['atan(0.5)', 'atan(tan(0.5))'],
     seealso: ['tan', 'acos', 'asin']
   };

   var atan2Docs = {
     name: 'atan2',
     category: 'Trigonometry',
     syntax: ['atan2(y, x)'],
     description: 'Computes the principal value of the arc tangent of y/x in radians.',
     examples: ['atan2(2, 2) / pi', 'angle = 60 deg in rad', 'x = cos(angle)', 'y = sin(angle)', 'atan2(y, x)'],
     seealso: ['sin', 'cos', 'tan']
   };

   var atanhDocs = {
     name: 'atanh',
     category: 'Trigonometry',
     syntax: ['atanh(x)'],
     description: 'Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.',
     examples: ['atanh(0.5)'],
     seealso: ['acosh', 'asinh']
   };

   var cosDocs = {
     name: 'cos',
     category: 'Trigonometry',
     syntax: ['cos(x)'],
     description: 'Compute the cosine of x in radians.',
     examples: ['cos(2)', 'cos(pi / 4) ^ 2', 'cos(180 deg)', 'cos(60 deg)', 'sin(0.2)^2 + cos(0.2)^2'],
     seealso: ['acos', 'sin', 'tan']
   };

   var coshDocs = {
     name: 'cosh',
     category: 'Trigonometry',
     syntax: ['cosh(x)'],
     description: 'Compute the hyperbolic cosine of x in radians.',
     examples: ['cosh(0.5)'],
     seealso: ['sinh', 'tanh', 'coth']
   };

   var cotDocs = {
     name: 'cot',
     category: 'Trigonometry',
     syntax: ['cot(x)'],
     description: 'Compute the cotangent of x in radians. Defined as 1/tan(x)',
     examples: ['cot(2)', '1 / tan(2)'],
     seealso: ['sec', 'csc', 'tan']
   };

   var cothDocs = {
     name: 'coth',
     category: 'Trigonometry',
     syntax: ['coth(x)'],
     description: 'Compute the hyperbolic cotangent of x in radians.',
     examples: ['coth(2)', '1 / tanh(2)'],
     seealso: ['sech', 'csch', 'tanh']
   };

   var cscDocs = {
     name: 'csc',
     category: 'Trigonometry',
     syntax: ['csc(x)'],
     description: 'Compute the cosecant of x in radians. Defined as 1/sin(x)',
     examples: ['csc(2)', '1 / sin(2)'],
     seealso: ['sec', 'cot', 'sin']
   };

   var cschDocs = {
     name: 'csch',
     category: 'Trigonometry',
     syntax: ['csch(x)'],
     description: 'Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)',
     examples: ['csch(2)', '1 / sinh(2)'],
     seealso: ['sech', 'coth', 'sinh']
   };

   var secDocs = {
     name: 'sec',
     category: 'Trigonometry',
     syntax: ['sec(x)'],
     description: 'Compute the secant of x in radians. Defined as 1/cos(x)',
     examples: ['sec(2)', '1 / cos(2)'],
     seealso: ['cot', 'csc', 'cos']
   };

   var sechDocs = {
     name: 'sech',
     category: 'Trigonometry',
     syntax: ['sech(x)'],
     description: 'Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)',
     examples: ['sech(2)', '1 / cosh(2)'],
     seealso: ['coth', 'csch', 'cosh']
   };

   var sinDocs = {
     name: 'sin',
     category: 'Trigonometry',
     syntax: ['sin(x)'],
     description: 'Compute the sine of x in radians.',
     examples: ['sin(2)', 'sin(pi / 4) ^ 2', 'sin(90 deg)', 'sin(30 deg)', 'sin(0.2)^2 + cos(0.2)^2'],
     seealso: ['asin', 'cos', 'tan']
   };

   var sinhDocs = {
     name: 'sinh',
     category: 'Trigonometry',
     syntax: ['sinh(x)'],
     description: 'Compute the hyperbolic sine of x in radians.',
     examples: ['sinh(0.5)'],
     seealso: ['cosh', 'tanh']
   };

   var tanDocs = {
     name: 'tan',
     category: 'Trigonometry',
     syntax: ['tan(x)'],
     description: 'Compute the tangent of x in radians.',
     examples: ['tan(0.5)', 'sin(0.5) / cos(0.5)', 'tan(pi / 4)', 'tan(45 deg)'],
     seealso: ['atan', 'sin', 'cos']
   };

   var tanhDocs = {
     name: 'tanh',
     category: 'Trigonometry',
     syntax: ['tanh(x)'],
     description: 'Compute the hyperbolic tangent of x in radians.',
     examples: ['tanh(0.5)', 'sinh(0.5) / cosh(0.5)'],
     seealso: ['sinh', 'cosh']
   };

   var toDocs = {
     name: 'to',
     category: 'Units',
     syntax: ['x to unit', 'to(x, unit)'],
     description: 'Change the unit of a value.',
     examples: ['5 inch to cm', '3.2kg to g', '16 bytes in bits'],
     seealso: []
   };

   var binDocs = {
     name: 'bin',
     category: 'Utils',
     syntax: ['bin(value)'],
     description: 'Format a number as binary',
     examples: ['bin(2)'],
     seealso: ['oct', 'hex']
   };

   var cloneDocs = {
     name: 'clone',
     category: 'Utils',
     syntax: ['clone(x)'],
     description: 'Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices',
     examples: ['clone(3.5)', 'clone(2 - 4i)', 'clone(45 deg)', 'clone([1, 2; 3, 4])', 'clone("hello world")'],
     seealso: []
   };

   var formatDocs = {
     name: 'format',
     category: 'Utils',
     syntax: ['format(value)', 'format(value, precision)'],
     description: 'Format a value of any type as string.',
     examples: ['format(2.3)', 'format(3 - 4i)', 'format([])', 'format(pi, 3)'],
     seealso: ['print']
   };

   var hasNumericValueDocs = {
     name: 'hasNumericValue',
     category: 'Utils',
     syntax: ['hasNumericValue(x)'],
     description: 'Test whether a value is an numeric value. ' + 'In case of a string, true is returned if the string contains a numeric value.',
     examples: ['hasNumericValue(2)', 'hasNumericValue("2")', 'isNumeric("2")', 'hasNumericValue(0)', 'hasNumericValue(bignumber(500))', 'hasNumericValue(fraction(0.125))', 'hasNumericValue(2 + 3i)', 'hasNumericValue([2.3, "foo", false])'],
     seealso: ['isInteger', 'isZero', 'isNegative', 'isPositive', 'isNaN', 'isNumeric']
   };

   var hexDocs = {
     name: 'hex',
     category: 'Utils',
     syntax: ['hex(value)'],
     description: 'Format a number as hexadecimal',
     examples: ['hex(240)'],
     seealso: ['bin', 'oct']
   };

   var isIntegerDocs = {
     name: 'isInteger',
     category: 'Utils',
     syntax: ['isInteger(x)'],
     description: 'Test whether a value is an integer number.',
     examples: ['isInteger(2)', 'isInteger(3.5)', 'isInteger([3, 0.5, -2])'],
     seealso: ['isNegative', 'isNumeric', 'isPositive', 'isZero']
   };

   var isNaNDocs = {
     name: 'isNaN',
     category: 'Utils',
     syntax: ['isNaN(x)'],
     description: 'Test whether a value is NaN (not a number)',
     examples: ['isNaN(2)', 'isNaN(0 / 0)', 'isNaN(NaN)', 'isNaN(Infinity)'],
     seealso: ['isNegative', 'isNumeric', 'isPositive', 'isZero']
   };

   var isNegativeDocs = {
     name: 'isNegative',
     category: 'Utils',
     syntax: ['isNegative(x)'],
     description: 'Test whether a value is negative: smaller than zero.',
     examples: ['isNegative(2)', 'isNegative(0)', 'isNegative(-4)', 'isNegative([3, 0.5, -2])'],
     seealso: ['isInteger', 'isNumeric', 'isPositive', 'isZero']
   };

   var isNumericDocs = {
     name: 'isNumeric',
     category: 'Utils',
     syntax: ['isNumeric(x)'],
     description: 'Test whether a value is a numeric value. ' + 'Returns true when the input is a number, BigNumber, Fraction, or boolean.',
     examples: ['isNumeric(2)', 'isNumeric("2")', 'hasNumericValue("2")', 'isNumeric(0)', 'isNumeric(bignumber(500))', 'isNumeric(fraction(0.125))', 'isNumeric(2 + 3i)', 'isNumeric([2.3, "foo", false])'],
     seealso: ['isInteger', 'isZero', 'isNegative', 'isPositive', 'isNaN', 'hasNumericValue']
   };

   var isPositiveDocs = {
     name: 'isPositive',
     category: 'Utils',
     syntax: ['isPositive(x)'],
     description: 'Test whether a value is positive: larger than zero.',
     examples: ['isPositive(2)', 'isPositive(0)', 'isPositive(-4)', 'isPositive([3, 0.5, -2])'],
     seealso: ['isInteger', 'isNumeric', 'isNegative', 'isZero']
   };

   var isPrimeDocs = {
     name: 'isPrime',
     category: 'Utils',
     syntax: ['isPrime(x)'],
     description: 'Test whether a value is prime: has no divisors other than itself and one.',
     examples: ['isPrime(3)', 'isPrime(-2)', 'isPrime([2, 17, 100])'],
     seealso: ['isInteger', 'isNumeric', 'isNegative', 'isZero']
   };

   var isZeroDocs = {
     name: 'isZero',
     category: 'Utils',
     syntax: ['isZero(x)'],
     description: 'Test whether a value is zero.',
     examples: ['isZero(2)', 'isZero(0)', 'isZero(-4)', 'isZero([3, 0, -2, 0])'],
     seealso: ['isInteger', 'isNumeric', 'isNegative', 'isPositive']
   };

   var numericDocs = {
     name: 'numeric',
     category: 'Utils',
     syntax: ['numeric(x)'],
     description: 'Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.',
     examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
     seealso: ['number', 'fraction', 'bignumber', 'string', 'format']
   };

   var octDocs = {
     name: 'oct',
     category: 'Utils',
     syntax: ['oct(value)'],
     description: 'Format a number as octal',
     examples: ['oct(56)'],
     seealso: ['bin', 'hex']
   };

   var printDocs = {
     name: 'print',
     category: 'Utils',
     syntax: ['print(template, values)', 'print(template, values, precision)'],
     description: 'Interpolate values into a string template.',
     examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
     seealso: ['format']
   };

   var typeOfDocs = {
     name: 'typeOf',
     category: 'Utils',
     syntax: ['typeOf(x)'],
     description: 'Get the type of a variable.',
     examples: ['typeOf(3.5)', 'typeOf(2 - 4i)', 'typeOf(45 deg)', 'typeOf("hello world")'],
     seealso: ['getMatrixDataType']
   };

   var solveODEDocs = {
     name: 'solveODE',
     category: 'Numeric',
     syntax: ['solveODE(func, tspan, y0)', 'solveODE(func, tspan, y0, options)'],
     description: 'Numerical Integration of Ordinary Differential Equations.',
     examples: ['f(t,y) = y', 'tspan = [0, 4]', 'solveODE(f, tspan, 1)', 'solveODE(f, tspan, [1, 2])', 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
     seealso: ['derivative', 'simplifyCore']
   };

   var embeddedDocs = {
     // construction functions
     bignumber: bignumberDocs,
     boolean: booleanDocs,
     complex: complexDocs,
     createUnit: createUnitDocs,
     fraction: fractionDocs,
     index: indexDocs,
     matrix: matrixDocs,
     number: numberDocs,
     sparse: sparseDocs,
     splitUnit: splitUnitDocs,
     string: stringDocs,
     unit: unitDocs,
     // constants
     e: eDocs,
     E: eDocs,
     false: falseDocs,
     i: iDocs,
     Infinity: InfinityDocs,
     LN2: LN2Docs,
     LN10: LN10Docs,
     LOG2E: LOG2EDocs,
     LOG10E: LOG10EDocs,
     NaN: NaNDocs,
     null: nullDocs,
     pi: piDocs,
     PI: piDocs,
     phi: phiDocs,
     SQRT1_2: SQRT12Docs,
     SQRT2: SQRT2Docs,
     tau: tauDocs,
     true: trueDocs,
     version: versionDocs,
     // physical constants
     // TODO: more detailed docs for physical constants
     speedOfLight: {
       description: 'Speed of light in vacuum',
       examples: ['speedOfLight']
     },
     gravitationConstant: {
       description: 'Newtonian constant of gravitation',
       examples: ['gravitationConstant']
     },
     planckConstant: {
       description: 'Planck constant',
       examples: ['planckConstant']
     },
     reducedPlanckConstant: {
       description: 'Reduced Planck constant',
       examples: ['reducedPlanckConstant']
     },
     magneticConstant: {
       description: 'Magnetic constant (vacuum permeability)',
       examples: ['magneticConstant']
     },
     electricConstant: {
       description: 'Electric constant (vacuum permeability)',
       examples: ['electricConstant']
     },
     vacuumImpedance: {
       description: 'Characteristic impedance of vacuum',
       examples: ['vacuumImpedance']
     },
     coulomb: {
       description: 'Coulomb\'s constant',
       examples: ['coulomb']
     },
     elementaryCharge: {
       description: 'Elementary charge',
       examples: ['elementaryCharge']
     },
     bohrMagneton: {
       description: 'Borh magneton',
       examples: ['bohrMagneton']
     },
     conductanceQuantum: {
       description: 'Conductance quantum',
       examples: ['conductanceQuantum']
     },
     inverseConductanceQuantum: {
       description: 'Inverse conductance quantum',
       examples: ['inverseConductanceQuantum']
     },
     // josephson: {description: 'Josephson constant', examples: ['josephson']},
     magneticFluxQuantum: {
       description: 'Magnetic flux quantum',
       examples: ['magneticFluxQuantum']
     },
     nuclearMagneton: {
       description: 'Nuclear magneton',
       examples: ['nuclearMagneton']
     },
     klitzing: {
       description: 'Von Klitzing constant',
       examples: ['klitzing']
     },
     bohrRadius: {
       description: 'Borh radius',
       examples: ['bohrRadius']
     },
     classicalElectronRadius: {
       description: 'Classical electron radius',
       examples: ['classicalElectronRadius']
     },
     electronMass: {
       description: 'Electron mass',
       examples: ['electronMass']
     },
     fermiCoupling: {
       description: 'Fermi coupling constant',
       examples: ['fermiCoupling']
     },
     fineStructure: {
       description: 'Fine-structure constant',
       examples: ['fineStructure']
     },
     hartreeEnergy: {
       description: 'Hartree energy',
       examples: ['hartreeEnergy']
     },
     protonMass: {
       description: 'Proton mass',
       examples: ['protonMass']
     },
     deuteronMass: {
       description: 'Deuteron Mass',
       examples: ['deuteronMass']
     },
     neutronMass: {
       description: 'Neutron mass',
       examples: ['neutronMass']
     },
     quantumOfCirculation: {
       description: 'Quantum of circulation',
       examples: ['quantumOfCirculation']
     },
     rydberg: {
       description: 'Rydberg constant',
       examples: ['rydberg']
     },
     thomsonCrossSection: {
       description: 'Thomson cross section',
       examples: ['thomsonCrossSection']
     },
     weakMixingAngle: {
       description: 'Weak mixing angle',
       examples: ['weakMixingAngle']
     },
     efimovFactor: {
       description: 'Efimov factor',
       examples: ['efimovFactor']
     },
     atomicMass: {
       description: 'Atomic mass constant',
       examples: ['atomicMass']
     },
     avogadro: {
       description: 'Avogadro\'s number',
       examples: ['avogadro']
     },
     boltzmann: {
       description: 'Boltzmann constant',
       examples: ['boltzmann']
     },
     faraday: {
       description: 'Faraday constant',
       examples: ['faraday']
     },
     firstRadiation: {
       description: 'First radiation constant',
       examples: ['firstRadiation']
     },
     loschmidt: {
       description: 'Loschmidt constant at T=273.15 K and p=101.325 kPa',
       examples: ['loschmidt']
     },
     gasConstant: {
       description: 'Gas constant',
       examples: ['gasConstant']
     },
     molarPlanckConstant: {
       description: 'Molar Planck constant',
       examples: ['molarPlanckConstant']
     },
     molarVolume: {
       description: 'Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa',
       examples: ['molarVolume']
     },
     sackurTetrode: {
       description: 'Sackur-Tetrode constant at T=1 K and p=101.325 kPa',
       examples: ['sackurTetrode']
     },
     secondRadiation: {
       description: 'Second radiation constant',
       examples: ['secondRadiation']
     },
     stefanBoltzmann: {
       description: 'Stefan-Boltzmann constant',
       examples: ['stefanBoltzmann']
     },
     wienDisplacement: {
       description: 'Wien displacement law constant',
       examples: ['wienDisplacement']
     },
     // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},

     molarMass: {
       description: 'Molar mass constant',
       examples: ['molarMass']
     },
     molarMassC12: {
       description: 'Molar mass constant of carbon-12',
       examples: ['molarMassC12']
     },
     gravity: {
       description: 'Standard acceleration of gravity (standard acceleration of free-fall on Earth)',
       examples: ['gravity']
     },
     planckLength: {
       description: 'Planck length',
       examples: ['planckLength']
     },
     planckMass: {
       description: 'Planck mass',
       examples: ['planckMass']
     },
     planckTime: {
       description: 'Planck time',
       examples: ['planckTime']
     },
     planckCharge: {
       description: 'Planck charge',
       examples: ['planckCharge']
     },
     planckTemperature: {
       description: 'Planck temperature',
       examples: ['planckTemperature']
     },
     // functions - algebra
     derivative: derivativeDocs,
     lsolve: lsolveDocs,
     lsolveAll: lsolveAllDocs,
     lup: lupDocs,
     lusolve: lusolveDocs,
     leafCount: leafCountDocs,
     polynomialRoot: polynomialRootDocs,
     resolve: resolveDocs,
     simplify: simplifyDocs,
     simplifyConstant: simplifyConstantDocs,
     simplifyCore: simplifyCoreDocs,
     symbolicEqual: symbolicEqualDocs,
     rationalize: rationalizeDocs,
     slu: sluDocs,
     usolve: usolveDocs,
     usolveAll: usolveAllDocs,
     qr: qrDocs,
     // functions - arithmetic
     abs: absDocs,
     add: addDocs,
     cbrt: cbrtDocs,
     ceil: ceilDocs,
     cube: cubeDocs,
     divide: divideDocs,
     dotDivide: dotDivideDocs,
     dotMultiply: dotMultiplyDocs,
     dotPow: dotPowDocs,
     exp: expDocs,
     expm: expmDocs,
     expm1: expm1Docs,
     fix: fixDocs,
     floor: floorDocs,
     gcd: gcdDocs,
     hypot: hypotDocs,
     lcm: lcmDocs,
     log: logDocs,
     log2: log2Docs,
     log1p: log1pDocs,
     log10: log10Docs,
     mod: modDocs,
     multiply: multiplyDocs,
     norm: normDocs,
     nthRoot: nthRootDocs,
     nthRoots: nthRootsDocs,
     pow: powDocs,
     round: roundDocs,
     sign: signDocs,
     sqrt: sqrtDocs,
     sqrtm: sqrtmDocs,
     square: squareDocs,
     subtract: subtractDocs,
     unaryMinus: unaryMinusDocs,
     unaryPlus: unaryPlusDocs,
     xgcd: xgcdDocs,
     invmod: invmodDocs,
     // functions - bitwise
     bitAnd: bitAndDocs,
     bitNot: bitNotDocs,
     bitOr: bitOrDocs,
     bitXor: bitXorDocs,
     leftShift: leftShiftDocs,
     rightArithShift: rightArithShiftDocs,
     rightLogShift: rightLogShiftDocs,
     // functions - combinatorics
     bellNumbers: bellNumbersDocs,
     catalan: catalanDocs,
     composition: compositionDocs,
     stirlingS2: stirlingS2Docs,
     // functions - core
     config: configDocs,
     import: importDocs,
     typed: typedDocs,
     // functions - complex
     arg: argDocs,
     conj: conjDocs,
     re: reDocs,
     im: imDocs,
     // functions - expression
     evaluate: evaluateDocs,
     help: helpDocs,
     // functions - geometry
     distance: distanceDocs,
     intersect: intersectDocs,
     // functions - logical
     and: andDocs,
     not: notDocs,
     or: orDocs,
     xor: xorDocs,
     // functions - matrix
     concat: concatDocs,
     count: countDocs,
     cross: crossDocs,
     column: columnDocs,
     ctranspose: ctransposeDocs,
     det: detDocs,
     diag: diagDocs,
     diff: diffDocs,
     dot: dotDocs,
     getMatrixDataType: getMatrixDataTypeDocs,
     identity: identityDocs,
     filter: filterDocs,
     flatten: flattenDocs,
     forEach: forEachDocs,
     inv: invDocs,
     pinv: pinvDocs,
     eigs: eigsDocs,
     kron: kronDocs,
     matrixFromFunction: matrixFromFunctionDocs,
     matrixFromRows: matrixFromRowsDocs,
     matrixFromColumns: matrixFromColumnsDocs,
     map: mapDocs,
     ones: onesDocs,
     partitionSelect: partitionSelectDocs,
     range: rangeDocs,
     resize: resizeDocs,
     reshape: reshapeDocs,
     rotate: rotateDocs,
     rotationMatrix: rotationMatrixDocs,
     row: rowDocs,
     size: sizeDocs,
     sort: sortDocs,
     squeeze: squeezeDocs,
     subset: subsetDocs,
     trace: traceDocs,
     transpose: transposeDocs,
     zeros: zerosDocs,
     fft: fftDocs,
     ifft: ifftDocs,
     sylvester: sylvesterDocs,
     schur: schurDocs,
     lyap: lyapDocs,
     // functions - numeric
     solveODE: solveODEDocs,
     // functions - probability
     combinations: combinationsDocs,
     combinationsWithRep: combinationsWithRepDocs,
     // distribution: distributionDocs,
     factorial: factorialDocs,
     gamma: gammaDocs,
     kldivergence: kldivergenceDocs,
     lgamma: lgammaDocs,
     multinomial: multinomialDocs,
     permutations: permutationsDocs,
     pickRandom: pickRandomDocs,
     random: randomDocs,
     randomInt: randomIntDocs,
     // functions - relational
     compare: compareDocs,
     compareNatural: compareNaturalDocs,
     compareText: compareTextDocs,
     deepEqual: deepEqualDocs,
     equal: equalDocs,
     equalText: equalTextDocs,
     larger: largerDocs,
     largerEq: largerEqDocs,
     smaller: smallerDocs,
     smallerEq: smallerEqDocs,
     unequal: unequalDocs,
     // functions - set
     setCartesian: setCartesianDocs,
     setDifference: setDifferenceDocs,
     setDistinct: setDistinctDocs,
     setIntersect: setIntersectDocs,
     setIsSubset: setIsSubsetDocs,
     setMultiplicity: setMultiplicityDocs,
     setPowerset: setPowersetDocs,
     setSize: setSizeDocs,
     setSymDifference: setSymDifferenceDocs,
     setUnion: setUnionDocs,
     // functions - signal
     zpk2tf: zpk2tfDocs,
     freqz: freqzDocs,
     // functions - special
     erf: erfDocs,
     zeta: zetaDocs,
     // functions - statistics
     cumsum: cumSumDocs,
     mad: madDocs,
     max: maxDocs,
     mean: meanDocs,
     median: medianDocs,
     min: minDocs,
     mode: modeDocs,
     prod: prodDocs,
     quantileSeq: quantileSeqDocs,
     std: stdDocs,
     sum: sumDocs,
     variance: varianceDocs,
     corr: corrDocs,
     // functions - trigonometry
     acos: acosDocs,
     acosh: acoshDocs,
     acot: acotDocs,
     acoth: acothDocs,
     acsc: acscDocs,
     acsch: acschDocs,
     asec: asecDocs,
     asech: asechDocs,
     asin: asinDocs,
     asinh: asinhDocs,
     atan: atanDocs,
     atanh: atanhDocs,
     atan2: atan2Docs,
     cos: cosDocs,
     cosh: coshDocs,
     cot: cotDocs,
     coth: cothDocs,
     csc: cscDocs,
     csch: cschDocs,
     sec: secDocs,
     sech: sechDocs,
     sin: sinDocs,
     sinh: sinhDocs,
     tan: tanDocs,
     tanh: tanhDocs,
     // functions - units
     to: toDocs,
     // functions - utils
     clone: cloneDocs,
     format: formatDocs,
     bin: binDocs,
     oct: octDocs,
     hex: hexDocs,
     isNaN: isNaNDocs,
     isInteger: isIntegerDocs,
     isNegative: isNegativeDocs,
     isNumeric: isNumericDocs,
     hasNumericValue: hasNumericValueDocs,
     isPositive: isPositiveDocs,
     isPrime: isPrimeDocs,
     isZero: isZeroDocs,
     print: printDocs,
     typeOf: typeOfDocs,
     numeric: numericDocs
   };

   var name$15 = 'help';
   var dependencies$15 = ['typed', 'mathWithTransform', 'Help'];
   var createHelp = /* #__PURE__ */factory(name$15, dependencies$15, _ref => {
     var {
       typed,
       mathWithTransform,
       Help
     } = _ref;
     /**
      * Retrieve help on a function or data type.
      * Help files are retrieved from the embedded documentation in math.docs.
      *
      * Syntax:
      *
      *    math.help(search)
      *
      * Examples:
      *
      *    console.log(math.help('sin').toString())
      *    console.log(math.help(math.add).toString())
      *    console.log(math.help(math.add).toJSON())
      *
      * @param {Function | string | Object} search   A function or function name
      *                                              for which to get help
      * @return {Help} A help object
      */
     return typed(name$15, {
       any: function any(search) {
         var prop;
         var searchName = search;
         if (typeof search !== 'string') {
           for (prop in mathWithTransform) {
             // search in functions and constants
             if (hasOwnProperty(mathWithTransform, prop) && search === mathWithTransform[prop]) {
               searchName = prop;
               break;
             }
           }

           /* TODO: implement help for data types
            if (!text) {
            // search data type
            for (prop in math.type) {
            if (hasOwnProperty(math, prop)) {
            if (search === math.type[prop]) {
            text = prop
            break
            }
            }
            }
            }
            */
         }

         var doc = getSafeProperty(embeddedDocs, searchName);
         if (!doc) {
           var searchText = typeof searchName === 'function' ? searchName.name : searchName;
           throw new Error('No documentation found on "' + searchText + '"');
         }
         return new Help(doc);
       }
     });
   });

   var name$14 = 'chain';
   var dependencies$14 = ['typed', 'Chain'];
   var createChain = /* #__PURE__ */factory(name$14, dependencies$14, _ref => {
     var {
       typed,
       Chain
     } = _ref;
     /**
      * Wrap any value in a chain, allowing to perform chained operations on
      * the value.
      *
      * All methods available in the math.js library can be called upon the chain,
      * and then will be evaluated with the value itself as first argument.
      * The chain can be closed by executing `chain.done()`, which returns
      * the final value.
      *
      * The chain has a number of special functions:
      *
      * - `done()`     Finalize the chain and return the chain's value.
      * - `valueOf()`  The same as `done()`
      * - `toString()` Executes `math.format()` onto the chain's value, returning
      *                a string representation of the value.
      *
      * Syntax:
      *
      *    math.chain(value)
      *
      * Examples:
      *
      *     math.chain(3)
      *         .add(4)
      *         .subtract(2)
      *         .done()     // 5
      *
      *     math.chain( [[1, 2], [3, 4]] )
      *         .subset(math.index(0, 0), 8)
      *         .multiply(3)
      *         .done()     // [[24, 6], [9, 12]]
      *
      * @param {*} [value]   A value of any type on which to start a chained operation.
      * @return {math.Chain} The created chain
      */
     return typed(name$14, {
       '': function _() {
         return new Chain();
       },
       any: function any(value) {
         return new Chain(value);
       }
     });
   });

   var name$13 = 'det';
   var dependencies$13 = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];
   var createDet = /* #__PURE__ */factory(name$13, dependencies$13, _ref => {
     var {
       typed,
       matrix,
       subtract,
       multiply,
       divideScalar,
       isZero,
       unaryMinus
     } = _ref;
     /**
      * Calculate the determinant of a matrix.
      *
      * Syntax:
      *
      *    math.det(x)
      *
      * Examples:
      *
      *    math.det([[1, 2], [3, 4]]) // returns -2
      *
      *    const A = [
      *      [-2, 2, 3],
      *      [-1, 1, 3],
      *      [2, 0, -1]
      *    ]
      *    math.det(A) // returns 6
      *
      * See also:
      *
      *    inv
      *
      * @param {Array | Matrix} x  A matrix
      * @return {number} The determinant of `x`
      */
     return typed(name$13, {
       any: function any(x) {
         return clone$3(x);
       },
       'Array | Matrix': function det(x) {
         var size;
         if (isMatrix(x)) {
           size = x.size();
         } else if (Array.isArray(x)) {
           x = matrix(x);
           size = x.size();
         } else {
           // a scalar
           size = [];
         }
         switch (size.length) {
           case 0:
             // scalar
             return clone$3(x);
           case 1:
             // vector
             if (size[0] === 1) {
               return clone$3(x.valueOf()[0]);
             }
             if (size[0] === 0) {
               return 1; // det of an empty matrix is per definition 1
             } else {
               throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
             }
           case 2:
             {
               // two-dimensional array
               var rows = size[0];
               var cols = size[1];
               if (rows === cols) {
                 return _det(x.clone().valueOf(), rows);
               }
               if (cols === 0) {
                 return 1; // det of an empty matrix is per definition 1
               } else {
                 throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
               }
             }
           default:
             // multi dimensional array
             throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format$1(size) + ')');
         }
       }
     });

     /**
      * Calculate the determinant of a matrix
      * @param {Array[]} matrix  A square, two dimensional matrix
      * @param {number} rows     Number of rows of the matrix (zero-based)
      * @param {number} cols     Number of columns of the matrix (zero-based)
      * @returns {number} det
      * @private
      */
     function _det(matrix, rows, cols) {
       if (rows === 1) {
         // this is a 1 x 1 matrix
         return clone$3(matrix[0][0]);
       } else if (rows === 2) {
         // this is a 2 x 2 matrix
         // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
         return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
       } else {
         // Bareiss algorithm
         // this algorithm have same complexity as LUP decomposition (O(n^3))
         // but it preserve precision of floating point more relative to the LUP decomposition
         var negated = false;
         var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i
         for (var k = 0; k < rows; k++) {
           var k_ = rowIndices[k];
           if (isZero(matrix[k_][k])) {
             var _k = void 0;
             for (_k = k + 1; _k < rows; _k++) {
               if (!isZero(matrix[rowIndices[_k]][k])) {
                 k_ = rowIndices[_k];
                 rowIndices[_k] = rowIndices[k];
                 rowIndices[k] = k_;
                 negated = !negated;
                 break;
               }
             }
             if (_k === rows) return matrix[k_][k]; // some zero of the type
           }

           var piv = matrix[k_][k];
           var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];
           for (var i = k + 1; i < rows; i++) {
             var i_ = rowIndices[i];
             for (var j = k + 1; j < rows; j++) {
               matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);
             }
           }
         }
         var det = matrix[rowIndices[rows - 1]][rows - 1];
         return negated ? unaryMinus(det) : det;
       }
     }
   });

   var name$12 = 'inv';
   var dependencies$12 = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];
   var createInv = /* #__PURE__ */factory(name$12, dependencies$12, _ref => {
     var {
       typed,
       matrix,
       divideScalar,
       addScalar,
       multiply,
       unaryMinus,
       det,
       identity,
       abs
     } = _ref;
     /**
      * Calculate the inverse of a square matrix.
      *
      * Syntax:
      *
      *     math.inv(x)
      *
      * Examples:
      *
      *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
      *     math.inv(4)                 // returns 0.25
      *     1 / 4                       // returns 0.25
      *
      * See also:
      *
      *     det, transpose
      *
      * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
      * @return {number | Complex | Array | Matrix} The inverse of `x`.
      */
     return typed(name$12, {
       'Array | Matrix': function ArrayMatrix(x) {
         var size = isMatrix(x) ? x.size() : arraySize(x);
         switch (size.length) {
           case 1:
             // vector
             if (size[0] === 1) {
               if (isMatrix(x)) {
                 return matrix([divideScalar(1, x.valueOf()[0])]);
               } else {
                 return [divideScalar(1, x[0])];
               }
             } else {
               throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
             }
           case 2:
             // two dimensional array
             {
               var rows = size[0];
               var cols = size[1];
               if (rows === cols) {
                 if (isMatrix(x)) {
                   return matrix(_inv(x.valueOf(), rows, cols), x.storage());
                 } else {
                   // return an Array
                   return _inv(x, rows, cols);
                 }
               } else {
                 throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
               }
             }
           default:
             // multi dimensional array
             throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format$1(size) + ')');
         }
       },
       any: function any(x) {
         // scalar
         return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
       }
     });

     /**
      * Calculate the inverse of a square matrix
      * @param {Array[]} mat     A square matrix
      * @param {number} rows     Number of rows
      * @param {number} cols     Number of columns, must equal rows
      * @return {Array[]} inv    Inverse matrix
      * @private
      */
     function _inv(mat, rows, cols) {
       var r, s, f, value, temp;
       if (rows === 1) {
         // this is a 1 x 1 matrix
         value = mat[0][0];
         if (value === 0) {
           throw Error('Cannot calculate inverse, determinant is zero');
         }
         return [[divideScalar(1, value)]];
       } else if (rows === 2) {
         // this is a 2 x 2 matrix
         var d = det(mat);
         if (d === 0) {
           throw Error('Cannot calculate inverse, determinant is zero');
         }
         return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
       } else {
         // this is a matrix of 3 x 3 or larger
         // calculate inverse using gauss-jordan elimination
         //      https://en.wikipedia.org/wiki/Gaussian_elimination
         //      http://mathworld.wolfram.com/MatrixInverse.html
         //      http://math.uww.edu/~mcfarlat/inverse.htm

         // make a copy of the matrix (only the arrays, not of the elements)
         var A = mat.concat();
         for (r = 0; r < rows; r++) {
           A[r] = A[r].concat();
         }

         // create an identity matrix which in the end will contain the
         // matrix inverse
         var B = identity(rows).valueOf();

         // loop over all columns, and perform row reductions
         for (var c = 0; c < cols; c++) {
           // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
           var ABig = abs(A[c][c]);
           var rBig = c;
           r = c + 1;
           while (r < rows) {
             if (abs(A[r][c]) > ABig) {
               ABig = abs(A[r][c]);
               rBig = r;
             }
             r++;
           }
           if (ABig === 0) {
             throw Error('Cannot calculate inverse, determinant is zero');
           }
           r = rBig;
           if (r !== c) {
             temp = A[c];
             A[c] = A[r];
             A[r] = temp;
             temp = B[c];
             B[c] = B[r];
             B[r] = temp;
           }

           // eliminate non-zero values on the other rows at column c
           var Ac = A[c];
           var Bc = B[c];
           for (r = 0; r < rows; r++) {
             var Ar = A[r];
             var Br = B[r];
             if (r !== c) {
               // eliminate value at column c and row r
               if (Ar[c] !== 0) {
                 f = divideScalar(unaryMinus(Ar[c]), Ac[c]);

                 // add (f * row c) to row r to eliminate the value
                 // at column c
                 for (s = c; s < cols; s++) {
                   Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                 }
                 for (s = 0; s < cols; s++) {
                   Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                 }
               }
             } else {
               // normalize value at Acc to 1,
               // divide each value on row r with the value at Acc
               f = Ac[c];
               for (s = c; s < cols; s++) {
                 Ar[s] = divideScalar(Ar[s], f);
               }
               for (s = 0; s < cols; s++) {
                 Br[s] = divideScalar(Br[s], f);
               }
             }
           }
         }
         return B;
       }
     }
   });

   var name$11 = 'pinv';
   var dependencies$11 = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];
   var createPinv = /* #__PURE__ */factory(name$11, dependencies$11, _ref => {
     var {
       typed,
       matrix,
       inv,
       deepEqual,
       equal,
       dotDivide,
       dot,
       ctranspose,
       divideScalar,
       multiply,
       add,
       Complex
     } = _ref;
     /**
      * Calculate the Moore–Penrose inverse of a matrix.
      *
      * Syntax:
      *
      *     math.pinv(x)
      *
      * Examples:
      *
      *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]
      *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]
      *     math.pinv(4)                         // returns 0.25
      *
      * See also:
      *
      *     inv
      *
      * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
      * @return {number | Complex | Array | Matrix} The inverse of `x`.
      */
     return typed(name$11, {
       'Array | Matrix': function ArrayMatrix(x) {
         var size = isMatrix(x) ? x.size() : arraySize(x);
         switch (size.length) {
           case 1:
             // vector
             if (_isZeros(x)) return ctranspose(x); // null vector
             if (size[0] === 1) {
               return inv(x); // invertible matrix
             } else {
               return dotDivide(ctranspose(x), dot(x, x));
             }
           case 2:
             // two dimensional array
             {
               if (_isZeros(x)) return ctranspose(x); // zero matrixx
               var rows = size[0];
               var cols = size[1];
               if (rows === cols) {
                 try {
                   return inv(x); // invertible matrix
                 } catch (err) {
                   if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) ; else {
                     throw err;
                   }
                 }
               }
               if (isMatrix(x)) {
                 return matrix(_pinv(x.valueOf(), rows, cols), x.storage());
               } else {
                 // return an Array
                 return _pinv(x, rows, cols);
               }
             }
           default:
             // multi dimensional array
             throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format$1(size) + ')');
         }
       },
       any: function any(x) {
         // scalar
         if (equal(x, 0)) return clone$3(x); // zero
         return divideScalar(1, x);
       }
     });

     /**
      * Calculate the Moore–Penrose inverse of a matrix
      * @param {Array[]} mat     A matrix
      * @param {number} rows     Number of rows
      * @param {number} cols     Number of columns
      * @return {Array[]} pinv    Pseudoinverse matrix
      * @private
      */
     function _pinv(mat, rows, cols) {
       var {
         C,
         F
       } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)
       var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));
       var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
       return multiply(Fpinv, Cpinv);
     }

     /**
      * Calculate the reduced row echelon form of a matrix
      *
      * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form
      *
      * @param {Array[]} mat     A matrix
      * @param {number} rows     Number of rows
      * @param {number} cols     Number of columns
      * @return {Array[]}        Reduced row echelon form
      * @private
      */
     function _rref(mat, rows, cols) {
       var M = clone$3(mat);
       var lead = 0;
       for (var r = 0; r < rows; r++) {
         if (cols <= lead) {
           return M;
         }
         var i = r;
         while (_isZero(M[i][lead])) {
           i++;
           if (rows === i) {
             i = r;
             lead++;
             if (cols === lead) {
               return M;
             }
           }
         }
         [M[i], M[r]] = [M[r], M[i]];
         var val = M[r][lead];
         for (var j = 0; j < cols; j++) {
           M[r][j] = dotDivide(M[r][j], val);
         }
         for (var _i = 0; _i < rows; _i++) {
           if (_i === r) continue;
           val = M[_i][lead];
           for (var _j = 0; _j < cols; _j++) {
             M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));
           }
         }
         lead++;
       }
       return M;
     }

     /**
      * Calculate the rank factorization of a matrix
      *
      * @param {Array[]} mat                  A matrix (M)
      * @param {number} rows                  Number of rows
      * @param {number} cols                  Number of columns
      * @return {{C: Array, F: Array}}        rank factorization where M = C F
      * @private
      */
     function _rankFact(mat, rows, cols) {
       var rref = _rref(mat, rows, cols);
       var C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));
       var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));
       return {
         C,
         F
       };
     }
     function _isZero(x) {
       return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));
     }
     function _isZeros(arr) {
       return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));
     }
   });

   function createComplexEigs(_ref) {
     var {
       addScalar,
       subtract,
       flatten,
       multiply,
       multiplyScalar,
       divideScalar,
       sqrt,
       abs,
       bignumber,
       diag,
       inv,
       qr,
       usolve,
       usolveAll,
       equal,
       complex,
       larger,
       smaller,
       matrixFromColumns,
       dot
     } = _ref;
     /**
      * @param {number[][]} arr the matrix to find eigenvalues of
      * @param {number} N size of the matrix
      * @param {number|BigNumber} prec precision, anything lower will be considered zero
      * @param {'number'|'BigNumber'|'Complex'} type
      * @param {boolean} findVectors should we find eigenvectors?
      *
      * @returns {{ values: number[], vectors: number[][] }}
      */
     function complexEigs(arr, N, prec, type, findVectors) {
       if (findVectors === undefined) {
         findVectors = true;
       }

       // TODO check if any row/col are zero except the diagonal

       // make sure corresponding rows and columns have similar magnitude
       // important because of numerical stability
       // MODIFIES arr by side effect!
       var R = balance(arr, N, prec, type, findVectors);

       // R is the row transformation matrix
       // arr = A' = R A R⁻¹, A is the original matrix
       // (if findVectors is false, R is undefined)
       // (And so to return to original matrix: A = R⁻¹ arr R)

       // TODO if magnitudes of elements vary over many orders,
       // move greatest elements to the top left corner

       // using similarity transformations, reduce the matrix
       // to Hessenberg form (upper triangular plus one subdiagonal row)
       // updates the transformation matrix R with new row operationsq
       // MODIFIES arr by side effect!
       reduceToHessenberg(arr, N, prec, type, findVectors, R);
       // still true that original A = R⁻¹ arr R)

       // find eigenvalues
       var {
         values,
         C
       } = iterateUntilTriangular(arr, N, prec, type, findVectors);

       // values is the list of eigenvalues, C is the column
       // transformation matrix that transforms arr, the hessenberg
       // matrix, to upper triangular
       // (So U = C⁻¹ arr C and the relationship between current arr
       // and original A is unchanged.)

       var vectors;
       if (findVectors) {
         vectors = findEigenvectors(arr, N, C, R, values, prec, type);
         vectors = matrixFromColumns(...vectors);
       }
       return {
         values,
         vectors
       };
     }

     /**
      * @param {number[][]} arr
      * @param {number} N
      * @param {number} prec
      * @param {'number'|'BigNumber'|'Complex'} type
      * @returns {number[][]}
      */
     function balance(arr, N, prec, type, findVectors) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var realzero = big ? bignumber(0) : 0;
       var one = big ? bignumber(1) : cplx ? complex(1) : 1;
       var realone = big ? bignumber(1) : 1;

       // base of the floating-point arithmetic
       var radix = big ? bignumber(10) : 2;
       var radixSq = multiplyScalar(radix, radix);

       // the diagonal transformation matrix R
       var Rdiag;
       if (findVectors) {
         Rdiag = Array(N).fill(one);
       }

       // this isn't the only time we loop thru the matrix...
       var last = false;
       while (!last) {
         // ...haha I'm joking! unless...
         last = true;
         for (var i = 0; i < N; i++) {
           // compute the taxicab norm of i-th column and row
           // TODO optimize for complex numbers
           var colNorm = realzero;
           var rowNorm = realzero;
           for (var j = 0; j < N; j++) {
             if (i === j) continue;
             var c = abs(arr[i][j]); // should be real
             colNorm = addScalar(colNorm, c);
             rowNorm = addScalar(rowNorm, c);
           }
           if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
             // find integer power closest to balancing the matrix
             // (we want to scale only by integer powers of radix,
             // so that we don't lose any precision due to round-off)

             var f = realone;
             var _c = colNorm;
             var rowDivRadix = divideScalar(rowNorm, radix);
             var rowMulRadix = multiplyScalar(rowNorm, radix);
             while (smaller(_c, rowDivRadix)) {
               _c = multiplyScalar(_c, radixSq);
               f = multiplyScalar(f, radix);
             }
             while (larger(_c, rowMulRadix)) {
               _c = divideScalar(_c, radixSq);
               f = divideScalar(f, radix);
             }

             // check whether balancing is needed
             // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)
             var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));

             // apply balancing similarity transformation
             if (condition) {
               // we should loop once again to check whether
               // another rebalancing is needed
               last = false;
               var g = divideScalar(1, f);
               for (var _j = 0; _j < N; _j++) {
                 if (i === _j) {
                   continue;
                 }
                 arr[i][_j] = multiplyScalar(arr[i][_j], f);
                 arr[_j][i] = multiplyScalar(arr[_j][i], g);
               }

               // keep track of transformations
               if (findVectors) {
                 Rdiag[i] = multiplyScalar(Rdiag[i], f);
               }
             }
           }
         }
       }

       // return the diagonal row transformation matrix
       return diag(Rdiag);
     }

     /**
      * @param {number[][]} arr
      * @param {number} N
      * @param {number} prec
      * @param {'number'|'BigNumber'|'Complex'} type
      * @param {boolean} findVectors
      * @param {number[][]} R the row transformation matrix that will be modified
      */
     function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
       if (big) {
         prec = bignumber(prec);
       }
       for (var i = 0; i < N - 2; i++) {
         // Find the largest subdiag element in the i-th col

         var maxIndex = 0;
         var max = zero;
         for (var j = i + 1; j < N; j++) {
           var el = arr[j][i];
           if (smaller(abs(max), abs(el))) {
             max = el;
             maxIndex = j;
           }
         }

         // This col is pivoted, no need to do anything
         if (smaller(abs(max), prec)) {
           continue;
         }
         if (maxIndex !== i + 1) {
           // Interchange maxIndex-th and (i+1)-th row
           var tmp1 = arr[maxIndex];
           arr[maxIndex] = arr[i + 1];
           arr[i + 1] = tmp1;

           // Interchange maxIndex-th and (i+1)-th column
           for (var _j2 = 0; _j2 < N; _j2++) {
             var tmp2 = arr[_j2][maxIndex];
             arr[_j2][maxIndex] = arr[_j2][i + 1];
             arr[_j2][i + 1] = tmp2;
           }

           // keep track of transformations
           if (findVectors) {
             var tmp3 = R[maxIndex];
             R[maxIndex] = R[i + 1];
             R[i + 1] = tmp3;
           }
         }

         // Reduce following rows and columns
         for (var _j3 = i + 2; _j3 < N; _j3++) {
           var n = divideScalar(arr[_j3][i], max);
           if (n === 0) {
             continue;
           }

           // from j-th row subtract n-times (i+1)th row
           for (var k = 0; k < N; k++) {
             arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
           }

           // to (i+1)th column add n-times j-th column
           for (var _k = 0; _k < N; _k++) {
             arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
           }

           // keep track of transformations
           if (findVectors) {
             for (var _k2 = 0; _k2 < N; _k2++) {
               R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
             }
           }
         }
       }
       return R;
     }

     /**
      * @returns {{values: values, C: Matrix}}
      * @see Press, Wiliams: Numerical recipes in Fortran 77
      * @see https://en.wikipedia.org/wiki/QR_algorithm
      */
     function iterateUntilTriangular(A, N, prec, type, findVectors) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var one = big ? bignumber(1) : cplx ? complex(1) : 1;
       if (big) {
         prec = bignumber(prec);
       }

       // The Francis Algorithm
       // The core idea of this algorithm is that doing successive
       // A' = Q⁺AQ transformations will eventually converge to block-
       // upper-triangular with diagonal blocks either 1x1 or 2x2.
       // The Q here is the one from the QR decomposition, A = QR.
       // Since the eigenvalues of a block-upper-triangular matrix are
       // the eigenvalues of its diagonal blocks and we know how to find
       // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.

       var arr = clone$3(A);

       // the list of converged eigenvalues
       var lambdas = [];

       // size of arr, which will get smaller as eigenvalues converge
       var n = N;

       // the diagonal of the block-diagonal matrix that turns
       // converged 2x2 matrices into upper triangular matrices
       var Sdiag = [];

       // N×N matrix describing the overall transformation done during the QR algorithm
       var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;

       // n×n matrix describing the QR transformations done since last convergence
       var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;

       // last eigenvalue converged before this many steps
       var lastConvergenceBefore = 0;
       while (lastConvergenceBefore <= 100) {
         lastConvergenceBefore += 1;

         // TODO if the convergence is slow, do something clever

         // Perform the factorization

         var k = 0; // TODO set close to an eigenvalue

         for (var i = 0; i < n; i++) {
           arr[i][i] = subtract(arr[i][i], k);
         }

         // TODO do an implicit QR transformation
         var {
           Q,
           R
         } = qr(arr);
         arr = multiply(R, Q);
         for (var _i = 0; _i < n; _i++) {
           arr[_i][_i] = addScalar(arr[_i][_i], k);
         }

         // keep track of transformations
         if (findVectors) {
           Qpartial = multiply(Qpartial, Q);
         }

         // The rightmost diagonal element converged to an eigenvalue
         if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
           lastConvergenceBefore = 0;
           lambdas.push(arr[n - 1][n - 1]);

           // keep track of transformations
           if (findVectors) {
             Sdiag.unshift([[1]]);
             inflateMatrix(Qpartial, N);
             Qtotal = multiply(Qtotal, Qpartial);
             if (n > 1) {
               Qpartial = diag(Array(n - 1).fill(one));
             }
           }

           // reduce the matrix size
           n -= 1;
           arr.pop();
           for (var _i2 = 0; _i2 < n; _i2++) {
             arr[_i2].pop();
           }

           // The rightmost diagonal 2x2 block converged
         } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
           lastConvergenceBefore = 0;
           var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
           lambdas.push(...ll);

           // keep track of transformations
           if (findVectors) {
             Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
             inflateMatrix(Qpartial, N);
             Qtotal = multiply(Qtotal, Qpartial);
             if (n > 2) {
               Qpartial = diag(Array(n - 2).fill(one));
             }
           }

           // reduce the matrix size
           n -= 2;
           arr.pop();
           arr.pop();
           for (var _i3 = 0; _i3 < n; _i3++) {
             arr[_i3].pop();
             arr[_i3].pop();
           }
         }
         if (n === 0) {
           break;
         }
       }

       // standard sorting
       lambdas.sort((a, b) => +subtract(abs(a), abs(b)));

       // the algorithm didn't converge
       if (lastConvergenceBefore > 100) {
         var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));
         err.values = lambdas;
         err.vectors = [];
         throw err;
       }

       // combine the overall QR transformation Qtotal with the subsequent
       // transformation S that turns the diagonal 2x2 blocks to upper triangular
       var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
       return {
         values: lambdas,
         C
       };
     }

     /**
      * @param {Matrix} A hessenberg-form matrix
      * @param {number} N size of A
      * @param {Matrix} C column transformation matrix that turns A into upper triangular
      * @param {Matrix} R similarity that turns original matrix into A
      * @param {number[]} values array of eigenvalues of A
      * @param {'number'|'BigNumber'|'Complex'} type
      * @returns {number[][]} eigenvalues
      */
     function findEigenvectors(A, N, C, R, values, prec, type) {
       var Cinv = inv(C);
       var U = multiply(Cinv, A, C);
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
       var one = big ? bignumber(1) : cplx ? complex(1) : 1;

       // turn values into a kind of "multiset"
       // this way it is easier to find eigenvectors
       var uniqueValues = [];
       var multiplicities = [];
       for (var λ of values) {
         var i = indexOf(uniqueValues, λ, equal);
         if (i === -1) {
           uniqueValues.push(λ);
           multiplicities.push(1);
         } else {
           multiplicities[i] += 1;
         }
       }

       // find eigenvectors by solving U − λE = 0
       // TODO replace with an iterative eigenvector algorithm
       // (this one might fail for imprecise eigenvalues)

       var vectors = [];
       var len = uniqueValues.length;
       var b = Array(N).fill(zero);
       var E = diag(Array(N).fill(one));

       // eigenvalues for which usolve failed (due to numerical error)
       var failedLambdas = [];
       var _loop = function _loop() {
         var λ = uniqueValues[_i4];
         var S = subtract(U, multiply(λ, E)); // the characteristic matrix

         var solutions = usolveAll(S, b);
         solutions.shift(); // ignore the null vector

         // looks like we missed something, try inverse iteration
         while (solutions.length < multiplicities[_i4]) {
           var approxVec = inverseIterate(S, N, solutions, prec, type);
           if (approxVec == null) {
             // no more vectors were found
             failedLambdas.push(λ);
             break;
           }
           solutions.push(approxVec);
         }

         // Transform back into original array coordinates
         var correction = multiply(inv(R), C);
         solutions = solutions.map(v => multiply(correction, v));
         vectors.push(...solutions.map(v => flatten(v)));
       };
       for (var _i4 = 0; _i4 < len; _i4++) {
         _loop();
       }
       if (failedLambdas.length !== 0) {
         var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));
         err.values = values;
         err.vectors = vectors;
         throw err;
       }
       return vectors;
     }

     /**
      * Compute the eigenvalues of an 2x2 matrix
      * @return {[number,number]}
      */
     function eigenvalues2x2(a, b, c, d) {
       // λ± = ½ trA ± ½ √( tr²A - 4 detA )
       var trA = addScalar(a, d);
       var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
       var x = multiplyScalar(trA, 0.5);
       var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
       return [addScalar(x, y), subtract(x, y)];
     }

     /**
      * For an 2x2 matrix compute the transformation matrix S,
      * so that SAS⁻¹ is an upper triangular matrix
      * @return {[[number,number],[number,number]]}
      * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
      * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
      */
     function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
       var one = big ? bignumber(1) : cplx ? complex(1) : 1;

       // matrix is already upper triangular
       // return an identity matrix
       if (smaller(abs(c), prec)) {
         return [[one, zero], [zero, one]];
       }

       // matrix is diagonalizable
       // return its eigenvectors as columns
       if (larger(abs(subtract(l1, l2)), prec)) {
         return [[subtract(l1, d), subtract(l2, d)], [c, c]];
       }

       // matrix is not diagonalizable
       // compute off-diagonal elements of N = A - λI
       // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )
       // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )

       var na = subtract(a, l1);
       var nb = subtract(b, l1);
       var nc = subtract(c, l1);
       var nd = subtract(d, l1);
       if (smaller(abs(nb), prec)) {
         return [[na, one], [nc, zero]];
       } else {
         return [[nb, zero], [nd, one]];
       }
     }

     /**
      * Enlarge the matrix from n×n to N×N, setting the new
      * elements to 1 on diagonal and 0 elsewhere
      */
     function inflateMatrix(arr, N) {
       // add columns
       for (var i = 0; i < arr.length; i++) {
         arr[i].push(...Array(N - arr[i].length).fill(0));
       }

       // add rows
       for (var _i5 = arr.length; _i5 < N; _i5++) {
         arr.push(Array(N).fill(0));
         arr[_i5][_i5] = 1;
       }
       return arr;
     }

     /**
      * Create a block-diagonal matrix with the given square matrices on the diagonal
      * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
      * @param {number} N the size of the resulting matrix
      */
     function blockDiag(arr, N) {
       var M = [];
       for (var i = 0; i < N; i++) {
         M[i] = Array(N).fill(0);
       }
       var I = 0;
       for (var sub of arr) {
         var n = sub.length;
         for (var _i6 = 0; _i6 < n; _i6++) {
           for (var j = 0; j < n; j++) {
             M[I + _i6][I + j] = sub[_i6][j];
           }
         }
         I += n;
       }
       return M;
     }

     /**
      * Finds the index of an element in an array using a custom equality function
      * @template T
      * @param {Array<T>} arr array in which to search
      * @param {T} el the element to find
      * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
      * @returns {number} the index of `el`, or -1 when it's not in `arr`
      */
     function indexOf(arr, el, fn) {
       for (var i = 0; i < arr.length; i++) {
         if (fn(arr[i], el)) {
           return i;
         }
       }
       return -1;
     }

     /**
      * Provided a near-singular upper-triangular matrix A and a list of vectors,
      * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
      * to each vector in the list
      * @template T
      * @param {T[][]} A near-singular square matrix
      * @param {number} N dimension
      * @param {T[][]} orthog list of vectors
      * @param {number} prec epsilon
      * @param {'number'|'BigNumber'|'Complex'} type
      * @return {T[] | null} eigenvector
      *
      * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration
      */
     function inverseIterate(A, N, orthog, prec, type) {
       var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;
       var b; // the vector

       // you better choose a random vector before I count to five
       var i = 0;
       while (true) {
         b = randomOrthogonalVector(N, orthog, type);
         b = usolve(A, b);
         if (larger(norm(b), largeNum)) {
           break;
         }
         if (++i >= 5) {
           return null;
         }
       }

       // you better converge before I count to ten
       i = 0;
       while (true) {
         var c = usolve(A, b);
         if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
           break;
         }
         if (++i >= 10) {
           return null;
         }
         b = normalize(c);
       }
       return b;
     }

     /**
      * Generates a random unit vector of dimension N, orthogonal to each vector in the list
      * @template T
      * @param {number} N dimension
      * @param {T[][]} orthog list of vectors
      * @param {'number'|'BigNumber'|'Complex'} type
      * @returns {T[]} random vector
      */
     function randomOrthogonalVector(N, orthog, type) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';

       // generate random vector with the correct type
       var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);
       if (big) {
         v = v.map(n => bignumber(n));
       }
       if (cplx) {
         v = v.map(n => complex(n));
       }

       // project to orthogonal complement
       v = orthogonalComplement(v, orthog);

       // normalize
       return normalize(v, type);
     }

     /**
      * Project vector v to the orthogonal complement of an array of vectors
      */
     function orthogonalComplement(v, orthog) {
       for (var w of orthog) {
         // v := v − (w, v)/∥w∥² w
         v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
       }
       return v;
     }

     /**
      * Calculate the norm of a vector.
      * We can't use math.norm because factory can't handle circular dependency.
      * Seriously, I'm really fed up with factory.
      */
     function norm(v) {
       return abs(sqrt(dot(v, v)));
     }

     /**
      * Normalize a vector
      * @template T
      * @param {T[]} v
      * @param {'number'|'BigNumber'|'Complex'} type
      * @returns {T[]} normalized vec
      */
     function normalize(v, type) {
       var big = type === 'BigNumber';
       var cplx = type === 'Complex';
       var one = big ? bignumber(1) : cplx ? complex(1) : 1;
       return multiply(divideScalar(one, norm(v)), v);
     }
     return complexEigs;
   }

   function createRealSymmetric(_ref) {
     var {
       config,
       addScalar,
       subtract,
       abs,
       atan,
       cos,
       sin,
       multiplyScalar,
       inv,
       bignumber,
       multiply,
       add
     } = _ref;
     /**
      * @param {number[] | BigNumber[]} arr
      * @param {number} N
      * @param {number} prec
      * @param {'number' | 'BigNumber'} type
      */
     function main(arr, N) {
       var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.epsilon;
       var type = arguments.length > 3 ? arguments[3] : undefined;
       if (type === 'number') {
         return diag(arr, prec);
       }
       if (type === 'BigNumber') {
         return diagBig(arr, prec);
       }
       throw TypeError('Unsupported data type: ' + type);
     }

     // diagonalization implementation for number (efficient)
     function diag(x, precision) {
       var N = x.length;
       var e0 = Math.abs(precision / N);
       var psi;
       var Sij = new Array(N);
       // Sij is Identity Matrix
       for (var i = 0; i < N; i++) {
         Sij[i] = createArray(N, 0);
         Sij[i][i] = 1.0;
       }
       // initial error
       var Vab = getAij(x);
       while (Math.abs(Vab[1]) >= Math.abs(e0)) {
         var _i = Vab[0][0];
         var j = Vab[0][1];
         psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
         x = x1(x, psi, _i, j);
         Sij = Sij1(Sij, psi, _i, j);
         Vab = getAij(x);
       }
       var Ei = createArray(N, 0); // eigenvalues
       for (var _i2 = 0; _i2 < N; _i2++) {
         Ei[_i2] = x[_i2][_i2];
       }
       return sorting(clone$3(Ei), clone$3(Sij));
     }

     // diagonalization implementation for bigNumber
     function diagBig(x, precision) {
       var N = x.length;
       var e0 = abs(precision / N);
       var psi;
       var Sij = new Array(N);
       // Sij is Identity Matrix
       for (var i = 0; i < N; i++) {
         Sij[i] = createArray(N, 0);
         Sij[i][i] = 1.0;
       }
       // initial error
       var Vab = getAijBig(x);
       while (abs(Vab[1]) >= abs(e0)) {
         var _i3 = Vab[0][0];
         var j = Vab[0][1];
         psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
         x = x1Big(x, psi, _i3, j);
         Sij = Sij1Big(Sij, psi, _i3, j);
         Vab = getAijBig(x);
       }
       var Ei = createArray(N, 0); // eigenvalues
       for (var _i4 = 0; _i4 < N; _i4++) {
         Ei[_i4] = x[_i4][_i4];
       }
       // return [clone(Ei), clone(Sij)]
       return sorting(clone$3(Ei), clone$3(Sij));
     }

     // get angle
     function getTheta(aii, ajj, aij) {
       var denom = ajj - aii;
       if (Math.abs(denom) <= config.epsilon) {
         return Math.PI / 4.0;
       } else {
         return 0.5 * Math.atan(2.0 * aij / (ajj - aii));
       }
     }

     // get angle
     function getThetaBig(aii, ajj, aij) {
       var denom = subtract(ajj, aii);
       if (abs(denom) <= config.epsilon) {
         return bignumber(-1).acos().div(4);
       } else {
         return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));
       }
     }

     // update eigvec
     function Sij1(Sij, theta, i, j) {
       var N = Sij.length;
       var c = Math.cos(theta);
       var s = Math.sin(theta);
       var Ski = createArray(N, 0);
       var Skj = createArray(N, 0);
       for (var k = 0; k < N; k++) {
         Ski[k] = c * Sij[k][i] - s * Sij[k][j];
         Skj[k] = s * Sij[k][i] + c * Sij[k][j];
       }
       for (var _k = 0; _k < N; _k++) {
         Sij[_k][i] = Ski[_k];
         Sij[_k][j] = Skj[_k];
       }
       return Sij;
     }
     // update eigvec for overlap
     function Sij1Big(Sij, theta, i, j) {
       var N = Sij.length;
       var c = cos(theta);
       var s = sin(theta);
       var Ski = createArray(N, bignumber(0));
       var Skj = createArray(N, bignumber(0));
       for (var k = 0; k < N; k++) {
         Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
         Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
       }
       for (var _k2 = 0; _k2 < N; _k2++) {
         Sij[_k2][i] = Ski[_k2];
         Sij[_k2][j] = Skj[_k2];
       }
       return Sij;
     }

     // update matrix
     function x1Big(Hij, theta, i, j) {
       var N = Hij.length;
       var c = bignumber(cos(theta));
       var s = bignumber(sin(theta));
       var c2 = multiplyScalar(c, c);
       var s2 = multiplyScalar(s, s);
       var Aki = createArray(N, bignumber(0));
       var Akj = createArray(N, bignumber(0));
       // 2cs Hij
       var csHij = multiply(bignumber(2), c, s, Hij[i][j]);
       //  Aii
       var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
       var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));
       // 0  to i
       for (var k = 0; k < N; k++) {
         Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
         Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
       }
       // Modify Hij
       Hij[i][i] = Aii;
       Hij[j][j] = Ajj;
       Hij[i][j] = bignumber(0);
       Hij[j][i] = bignumber(0);
       // 0  to i
       for (var _k3 = 0; _k3 < N; _k3++) {
         if (_k3 !== i && _k3 !== j) {
           Hij[i][_k3] = Aki[_k3];
           Hij[_k3][i] = Aki[_k3];
           Hij[j][_k3] = Akj[_k3];
           Hij[_k3][j] = Akj[_k3];
         }
       }
       return Hij;
     }

     // update matrix
     function x1(Hij, theta, i, j) {
       var N = Hij.length;
       var c = Math.cos(theta);
       var s = Math.sin(theta);
       var c2 = c * c;
       var s2 = s * s;
       var Aki = createArray(N, 0);
       var Akj = createArray(N, 0);
       //  Aii
       var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
       var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
       // 0  to i
       for (var k = 0; k < N; k++) {
         Aki[k] = c * Hij[i][k] - s * Hij[j][k];
         Akj[k] = s * Hij[i][k] + c * Hij[j][k];
       }
       // Modify Hij
       Hij[i][i] = Aii;
       Hij[j][j] = Ajj;
       Hij[i][j] = 0;
       Hij[j][i] = 0;
       // 0  to i
       for (var _k4 = 0; _k4 < N; _k4++) {
         if (_k4 !== i && _k4 !== j) {
           Hij[i][_k4] = Aki[_k4];
           Hij[_k4][i] = Aki[_k4];
           Hij[j][_k4] = Akj[_k4];
           Hij[_k4][j] = Akj[_k4];
         }
       }
       return Hij;
     }

     // get max off-diagonal value from Upper Diagonal
     function getAij(Mij) {
       var N = Mij.length;
       var maxMij = 0;
       var maxIJ = [0, 1];
       for (var i = 0; i < N; i++) {
         for (var j = i + 1; j < N; j++) {
           if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
             maxMij = Math.abs(Mij[i][j]);
             maxIJ = [i, j];
           }
         }
       }
       return [maxIJ, maxMij];
     }

     // get max off-diagonal value from Upper Diagonal
     function getAijBig(Mij) {
       var N = Mij.length;
       var maxMij = 0;
       var maxIJ = [0, 1];
       for (var i = 0; i < N; i++) {
         for (var j = i + 1; j < N; j++) {
           if (abs(maxMij) < abs(Mij[i][j])) {
             maxMij = abs(Mij[i][j]);
             maxIJ = [i, j];
           }
         }
       }
       return [maxIJ, maxMij];
     }

     // sort results
     function sorting(E, S) {
       var N = E.length;
       var values = Array(N);
       var vectors = Array(N);
       for (var k = 0; k < N; k++) {
         vectors[k] = Array(N);
       }
       for (var i = 0; i < N; i++) {
         var minID = 0;
         var minE = E[0];
         for (var j = 0; j < E.length; j++) {
           if (abs(E[j]) < abs(minE)) {
             minID = j;
             minE = E[minID];
           }
         }
         values[i] = E.splice(minID, 1)[0];
         for (var _k5 = 0; _k5 < N; _k5++) {
           vectors[_k5][i] = S[_k5][minID];
           S[_k5].splice(minID, 1);
         }
       }
       return {
         values,
         vectors
       };
     }

     /**
      * Create an array of a certain size and fill all items with an initial value
      * @param {number} size
      * @param {number} value
      * @return {number[]}
      */
     function createArray(size, value) {
       // TODO: as soon as all browsers support Array.fill, use that instead (IE doesn't support it)
       var array = new Array(size);
       for (var i = 0; i < size; i++) {
         array[i] = value;
       }
       return array;
     }
     return main;
   }

   var name$10 = 'eigs';

   // The absolute state of math.js's dependency system:
   var dependencies$10 = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];
   var createEigs = /* #__PURE__ */factory(name$10, dependencies$10, _ref => {
     var {
       config,
       typed,
       matrix,
       addScalar,
       subtract,
       equal,
       abs,
       atan,
       cos,
       sin,
       multiplyScalar,
       divideScalar,
       inv,
       bignumber,
       multiply,
       add,
       larger,
       column,
       flatten,
       number,
       complex,
       sqrt,
       diag,
       qr,
       usolve,
       usolveAll,
       im,
       re,
       smaller,
       matrixFromColumns,
       dot
     } = _ref;
     var doRealSymetric = createRealSymmetric({
       config,
       addScalar,
       subtract,
       column,
       flatten,
       equal,
       abs,
       atan,
       cos,
       sin,
       multiplyScalar,
       inv,
       bignumber,
       complex,
       multiply,
       add
     });
     var doComplexEigs = createComplexEigs({
       config,
       addScalar,
       subtract,
       multiply,
       multiplyScalar,
       flatten,
       divideScalar,
       sqrt,
       abs,
       bignumber,
       diag,
       qr,
       inv,
       usolve,
       usolveAll,
       equal,
       complex,
       larger,
       smaller,
       matrixFromColumns,
       dot
     });

     /**
      * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.
      * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –
      * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).
      * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information
      * in `err.values` and `err.vectors`.
      *
      * Syntax:
      *
      *     math.eigs(x, [prec])
      *
      * Examples:
      *
      *     const { eigs, multiply, column, transpose } = math
      *     const H = [[5, 2.3], [2.3, 1]]
      *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}
      *     const E = ans.values
      *     const U = ans.vectors
      *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))
      *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H
      *     E[0] == UTxHxU[0][0]  // returns true
      *
      * See also:
      *
      *     inv
      *
      * @param {Array | Matrix} x  Matrix to be diagonalized
      *
      * @param {number | BigNumber} [prec] Precision, default value: 1e-15
      * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.
      *
      */
     return typed('eigs', {
       Array: function Array(x) {
         var mat = matrix(x);
         return computeValuesAndVectors(mat);
       },
       'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {
         var mat = matrix(x);
         return computeValuesAndVectors(mat, prec);
       },
       Matrix: function Matrix(mat) {
         var {
           values,
           vectors
         } = computeValuesAndVectors(mat);
         return {
           values: matrix(values),
           vectors: matrix(vectors)
         };
       },
       'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {
         var {
           values,
           vectors
         } = computeValuesAndVectors(mat, prec);
         return {
           values: matrix(values),
           vectors: matrix(vectors)
         };
       }
     });
     function computeValuesAndVectors(mat, prec) {
       if (prec === undefined) {
         prec = config.epsilon;
       }
       var size = mat.size();
       if (size.length !== 2 || size[0] !== size[1]) {
         throw new RangeError('Matrix must be square (size: ' + format$1(size) + ')');
       }
       var arr = mat.toArray();
       var N = size[0];
       if (isReal(arr, N, prec)) {
         coerceReal(arr, N);
         if (isSymmetric(arr, N, prec)) {
           var _type = coerceTypes(mat, arr, N);
           return doRealSymetric(arr, N, prec, _type);
         }
       }
       var type = coerceTypes(mat, arr, N);
       return doComplexEigs(arr, N, prec, type);
     }

     /** @return {boolean} */
     function isSymmetric(arr, N, prec) {
       for (var i = 0; i < N; i++) {
         for (var j = i; j < N; j++) {
           // TODO proper comparison of bignum and frac
           if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
             return false;
           }
         }
       }
       return true;
     }

     /** @return {boolean} */
     function isReal(arr, N, prec) {
       for (var i = 0; i < N; i++) {
         for (var j = 0; j < N; j++) {
           // TODO proper comparison of bignum and frac
           if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
             return false;
           }
         }
       }
       return true;
     }
     function coerceReal(arr, N) {
       for (var i = 0; i < N; i++) {
         for (var j = 0; j < N; j++) {
           arr[i][j] = re(arr[i][j]);
         }
       }
     }

     /** @return {'number' | 'BigNumber' | 'Complex'} */
     function coerceTypes(mat, arr, N) {
       /** @type {string} */
       var type = mat.datatype();
       if (type === 'number' || type === 'BigNumber' || type === 'Complex') {
         return type;
       }
       var hasNumber = false;
       var hasBig = false;
       var hasComplex = false;
       for (var i = 0; i < N; i++) {
         for (var j = 0; j < N; j++) {
           var el = arr[i][j];
           if (isNumber(el) || isFraction(el)) {
             hasNumber = true;
           } else if (isBigNumber(el)) {
             hasBig = true;
           } else if (isComplex(el)) {
             hasComplex = true;
           } else {
             throw TypeError('Unsupported type in Matrix: ' + typeOf$1(el));
           }
         }
       }
       if (hasBig && hasComplex) {
         console.warn('Complex BigNumbers not supported, this operation will lose precission.');
       }
       if (hasComplex) {
         for (var _i = 0; _i < N; _i++) {
           for (var _j = 0; _j < N; _j++) {
             arr[_i][_j] = complex(arr[_i][_j]);
           }
         }
         return 'Complex';
       }
       if (hasBig) {
         for (var _i2 = 0; _i2 < N; _i2++) {
           for (var _j2 = 0; _j2 < N; _j2++) {
             arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
           }
         }
         return 'BigNumber';
       }
       if (hasNumber) {
         for (var _i3 = 0; _i3 < N; _i3++) {
           for (var _j3 = 0; _j3 < N; _j3++) {
             arr[_i3][_j3] = number(arr[_i3][_j3]);
           }
         }
         return 'number';
       } else {
         throw TypeError('Matrix contains unsupported types only.');
       }
     }
   });

   var name$$ = 'expm';
   var dependencies$$ = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];
   var createExpm = /* #__PURE__ */factory(name$$, dependencies$$, _ref => {
     var {
       typed,
       abs,
       add,
       identity,
       inv,
       multiply
     } = _ref;
     /**
      * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.
      * Not to be confused with exp(a), which performs element-wise
      * exponentiation.
      *
      * The exponential is calculated using the Padé approximant with scaling and
      * squaring; see "Nineteen Dubious Ways to Compute the Exponential of a
      * Matrix," by Moler and Van Loan.
      *
      * Syntax:
      *
      *     math.expm(x)
      *
      * Examples:
      *
      *     const A = [[0,2],[0,0]]
      *     math.expm(A)        // returns [[1,2],[0,1]]
      *
      * See also:
      *
      *     exp
      *
      * @param {Matrix} x  A square Matrix
      * @return {Matrix}   The exponential of x
      */
     return typed(name$$, {
       Matrix: function Matrix(A) {
         // Check matrix size
         var size = A.size();
         if (size.length !== 2 || size[0] !== size[1]) {
           throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
         }
         var n = size[0];

         // Desired accuracy of the approximant (The actual accuracy
         // will be affected by round-off error)
         var eps = 1e-15;

         // The Padé approximant is not so accurate when the values of A
         // are "large", so scale A by powers of two. Then compute the
         // exponential, and square the result repeatedly according to
         // the identity e^A = (e^(A/m))^m

         // Compute infinity-norm of A, ||A||, to see how "big" it is
         var infNorm = infinityNorm(A);

         // Find the optimal scaling factor and number of terms in the
         // Padé approximant to reach the desired accuracy
         var params = findParams(infNorm, eps);
         var q = params.q;
         var j = params.j;

         // The Pade approximation to e^A is:
         // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)
         // where
         // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i
         // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i

         // Scale A by 1 / 2^j
         var Apos = multiply(A, Math.pow(2, -j));

         // The i=0 term is just the identity matrix
         var N = identity(n);
         var D = identity(n);

         // Initialization (i=0)
         var factor = 1;

         // Initialization (i=1)
         var AposToI = Apos; // Cloning not necessary
         var alternate = -1;
         for (var i = 1; i <= q; i++) {
           if (i > 1) {
             AposToI = multiply(AposToI, Apos);
             alternate = -alternate;
           }
           factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
           N = add(N, multiply(factor, AposToI));
           D = add(D, multiply(factor * alternate, AposToI));
         }
         var R = multiply(inv(D), N);

         // Square j times
         for (var _i = 0; _i < j; _i++) {
           R = multiply(R, R);
         }
         return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
       }
     });
     function infinityNorm(A) {
       var n = A.size()[0];
       var infNorm = 0;
       for (var i = 0; i < n; i++) {
         var rowSum = 0;
         for (var j = 0; j < n; j++) {
           rowSum += abs(A.get([i, j]));
         }
         infNorm = Math.max(rowSum, infNorm);
       }
       return infNorm;
     }

     /**
      * Find the best parameters for the Pade approximant given
      * the matrix norm and desired accuracy. Returns the first acceptable
      * combination in order of increasing computational load.
      */
     function findParams(infNorm, eps) {
       var maxSearchSize = 30;
       for (var k = 0; k < maxSearchSize; k++) {
         for (var q = 0; q <= k; q++) {
           var j = k - q;
           if (errorEstimate(infNorm, q, j) < eps) {
             return {
               q,
               j
             };
           }
         }
       }
       throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');
     }

     /**
      * Returns the estimated error of the Pade approximant for the given
      * parameters.
      */
     function errorEstimate(infNorm, q, j) {
       var qfac = 1;
       for (var i = 2; i <= q; i++) {
         qfac *= i;
       }
       var twoqfac = qfac;
       for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
         twoqfac *= _i2;
       }
       var twoqp1fac = twoqfac * (2 * q + 1);
       return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
     }
   });

   var name$_ = 'sqrtm';
   var dependencies$_ = ['typed', 'abs', 'add', 'multiply', 'map', 'sqrt', 'subtract', 'inv', 'size', 'max', 'identity'];
   var createSqrtm = /* #__PURE__ */factory(name$_, dependencies$_, _ref => {
     var {
       typed,
       abs,
       add,
       multiply,
       map,
       sqrt,
       subtract,
       inv,
       size,
       max,
       identity
     } = _ref;
     var _maxIterations = 1e3;
     var _tolerance = 1e-6;

     /**
      * Calculate the principal square root matrix using the Denman–Beavers iterative method
      *
      * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration
      *
      * @param  {Array | Matrix} A   The square matrix `A`
      * @return {Array | Matrix}     The principal square root of matrix `A`
      * @private
      */
     function _denmanBeavers(A) {
       var error;
       var iterations = 0;
       var Y = A;
       var Z = identity(size(A));
       do {
         var Yk = Y;
         Y = multiply(0.5, add(Yk, inv(Z)));
         Z = multiply(0.5, add(Z, inv(Yk)));
         error = max(abs(subtract(Y, Yk)));
         if (error > _tolerance && ++iterations > _maxIterations) {
           throw new Error('computing square root of matrix: iterative method could not converge');
         }
       } while (error > _tolerance);
       return Y;
     }

     /**
      * Calculate the principal square root of a square matrix.
      * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.
      *
      * https://en.wikipedia.org/wiki/Square_root_of_a_matrix
      *
      * Syntax:
      *
      *     math.sqrtm(A)
      *
      * Examples:
      *
      *     math.sqrtm([[33, 24], [48, 57]]) // returns [[5, 2], [4, 7]]
      *
      * See also:
      *
      *     sqrt, pow
      *
      * @param  {Array | Matrix} A   The square matrix `A`
      * @return {Array | Matrix}     The principal square root of matrix `A`
      */
     return typed(name$_, {
       'Array | Matrix': function ArrayMatrix(A) {
         var size = isMatrix(A) ? A.size() : arraySize(A);
         switch (size.length) {
           case 1:
             // Single element Array | Matrix
             if (size[0] === 1) {
               return map(A, sqrt);
             } else {
               throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
             }
           case 2:
             {
               // Two-dimensional Array | Matrix
               var rows = size[0];
               var cols = size[1];
               if (rows === cols) {
                 return _denmanBeavers(A);
               } else {
                 throw new RangeError('Matrix must be square ' + '(size: ' + format$1(size) + ')');
               }
             }
           default:
             // Multi dimensional array
             throw new RangeError('Matrix must be at most two dimensional ' + '(size: ' + format$1(size) + ')');
         }
       }
     });
   });

   var name$Z = 'sylvester';
   var dependencies$Z = ['typed', 'schur', 'matrixFromColumns', 'matrix', 'multiply', 'range', 'concat', 'transpose', 'index', 'subset', 'add', 'subtract', 'identity', 'lusolve', 'abs'];
   var createSylvester = /* #__PURE__ */factory(name$Z, dependencies$Z, _ref => {
     var {
       typed,
       schur,
       matrixFromColumns,
       matrix,
       multiply,
       range,
       concat,
       transpose,
       index,
       subset,
       add,
       subtract,
       identity,
       lusolve,
       abs
     } = _ref;
     /**
      *
      * Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are
      * matrices of appropriate dimensions, being A and B squared. Notice that other
      * equivalent definitions for the Sylvester equation exist and this function
      * assumes the one presented in the original publication of the the Bartels-
      * Stewart algorithm, which is implemented by this function.
      * https://en.wikipedia.org/wiki/Sylvester_equation
      *
      * Syntax:
      *
      *     math.sylvester(A, B, C)
      *
      * Examples:
      *
      *     const A = [[-1, -2], [1, 1]]
      *     const B = [[2, -1], [1, -2]]
      *     const C = [[-3, 2], [3, 0]]
      *     math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]
      *
      * See also:
      *
      *     schur, lyap
      *
      * @param {Matrix | Array} A  Matrix A
      * @param {Matrix | Array} B  Matrix B
      * @param {Matrix | Array} C  Matrix C
      * @return {Matrix | Array}   Matrix X, solving the Sylvester equation
      */
     return typed(name$Z, {
       'Matrix, Matrix, Matrix': _sylvester,
       'Array, Matrix, Matrix': function ArrayMatrixMatrix(A, B, C) {
         return _sylvester(matrix(A), B, C);
       },
       'Array, Array, Matrix': function ArrayArrayMatrix(A, B, C) {
         return _sylvester(matrix(A), matrix(B), C);
       },
       'Array, Matrix, Array': function ArrayMatrixArray(A, B, C) {
         return _sylvester(matrix(A), B, matrix(C));
       },
       'Matrix, Array, Matrix': function MatrixArrayMatrix(A, B, C) {
         return _sylvester(A, matrix(B), C);
       },
       'Matrix, Array, Array': function MatrixArrayArray(A, B, C) {
         return _sylvester(A, matrix(B), matrix(C));
       },
       'Matrix, Matrix, Array': function MatrixMatrixArray(A, B, C) {
         return _sylvester(A, B, matrix(C));
       },
       'Array, Array, Array': function ArrayArrayArray(A, B, C) {
         return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();
       }
     });
     function _sylvester(A, B, C) {
       var n = B.size()[0];
       var m = A.size()[0];
       var sA = schur(A);
       var F = sA.T;
       var U = sA.U;
       var sB = schur(multiply(-1, B));
       var G = sB.T;
       var V = sB.U;
       var D = multiply(multiply(transpose(U), C), V);
       var all = range(0, m);
       var y = [];
       var hc = (a, b) => concat(a, b, 1);
       var vc = (a, b) => concat(a, b, 0);
       for (var k = 0; k < n; k++) {
         if (k < n - 1 && abs(subset(G, index(k + 1, k))) > 1e-5) {
           var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));
           for (var j = 0; j < k; j++) {
             RHS = add(RHS, vc(multiply(y[j], subset(G, index(j, k))), multiply(y[j], subset(G, index(j, k + 1)))));
           }
           var gkk = multiply(identity(m), multiply(-1, subset(G, index(k, k))));
           var gmk = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k))));
           var gkm = multiply(identity(m), multiply(-1, subset(G, index(k, k + 1))));
           var gmm = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k + 1))));
           var LHS = vc(hc(add(F, gkk), gmk), hc(gkm, add(F, gmm)));
           var yAux = lusolve(LHS, RHS);
           y[k] = yAux.subset(index(range(0, m), 0));
           y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));
           k++;
         } else {
           var _RHS = subset(D, index(all, k));
           for (var _j = 0; _j < k; _j++) {
             _RHS = add(_RHS, multiply(y[_j], subset(G, index(_j, k))));
           }
           var _gkk = subset(G, index(k, k));
           var _LHS = subtract(F, multiply(_gkk, identity(m)));
           y[k] = lusolve(_LHS, _RHS);
         }
       }
       var Y = matrix(matrixFromColumns(...y));
       var X = multiply(U, multiply(Y, transpose(V)));
       return X;
     }
   });

   var name$Y = 'schur';
   var dependencies$Y = ['typed', 'matrix', 'identity', 'multiply', 'qr', 'norm', 'subtract'];
   var createSchur = /* #__PURE__ */factory(name$Y, dependencies$Y, _ref => {
     var {
       typed,
       matrix,
       identity,
       multiply,
       qr,
       norm,
       subtract
     } = _ref;
     /**
      *
      * Performs a real Schur decomposition of the real matrix A = UTU' where U is orthogonal
      * and T is upper quasi-triangular.
      * https://en.wikipedia.org/wiki/Schur_decomposition
      *
      * Syntax:
      *
      *     math.schur(A)
      *
      * Examples:
      *
      *     const A = [[1, 0], [-4, 3]]
      *     math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}
      *
      * See also:
      *
      *     sylvester, lyap, qr
      *
      * @param {Array | Matrix} A  Matrix A
      * @return {{U: Array | Matrix, T: Array | Matrix}} Object containing both matrix U and T of the Schur Decomposition A=UTU'
      */
     return typed(name$Y, {
       Array: function Array(X) {
         var r = _schur(matrix(X));
         return {
           U: r.U.valueOf(),
           T: r.T.valueOf()
         };
       },
       Matrix: function Matrix(X) {
         return _schur(X);
       }
     });
     function _schur(X) {
       var n = X.size()[0];
       var A = X;
       var U = identity(n);
       var k = 0;
       var A0;
       do {
         A0 = A;
         var QR = qr(A);
         var Q = QR.Q;
         var R = QR.R;
         A = multiply(R, Q);
         U = multiply(U, Q);
         if (k++ > 100) {
           break;
         }
       } while (norm(subtract(A, A0)) > 1e-4);
       return {
         U,
         T: A
       };
     }
   });

   var name$X = 'lyap';
   var dependencies$X = ['typed', 'matrix', 'sylvester', 'multiply', 'transpose'];
   var createLyap = /* #__PURE__ */factory(name$X, dependencies$X, _ref => {
     var {
       typed,
       matrix,
       sylvester,
       multiply,
       transpose
     } = _ref;
     /**
      *
      * Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P, where
      * Q is an input matrix. When Q is symmetric, P is also symmetric. Notice
      * that different equivalent definitions exist for the Continuous-time
      * Lyapunov equation.
      * https://en.wikipedia.org/wiki/Lyapunov_equation
      *
      * Syntax:
      *
      *     math.lyap(A, Q)
      *
      * Examples:
      *
      *     const A = [[-2, 0], [1, -4]]
      *     const Q = [[3, 1], [1, 3]]
      *     const P = math.lyap(A, Q)
      *
      * See also:
      *
      *     sylvester, schur
      *
      * @param {Matrix | Array} A  Matrix A
      * @param {Matrix | Array} Q  Matrix Q
      * @return {Matrix | Array} Matrix P solution to the Continuous-time Lyapunov equation AP+PA'=Q
      */
     return typed(name$X, {
       'Matrix, Matrix': function MatrixMatrix(A, Q) {
         return sylvester(A, transpose(A), multiply(-1, Q));
       },
       'Array, Matrix': function ArrayMatrix(A, Q) {
         return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q));
       },
       'Matrix, Array': function MatrixArray(A, Q) {
         return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q)));
       },
       'Array, Array': function ArrayArray(A, Q) {
         return sylvester(matrix(A), transpose(matrix(A)), matrix(multiply(-1, Q))).toArray();
       }
     });
   });

   var name$W = 'divide';
   var dependencies$W = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];
   var createDivide = /* #__PURE__ */factory(name$W, dependencies$W, _ref => {
     var {
       typed,
       matrix,
       multiply,
       equalScalar,
       divideScalar,
       inv
     } = _ref;
     var matAlgo11xS0s = createMatAlgo11xS0s({
       typed,
       equalScalar
     });
     var matAlgo14xDs = createMatAlgo14xDs({
       typed
     });

     /**
      * Divide two values, `x / y`.
      * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
      *
      * Syntax:
      *
      *    math.divide(x, y)
      *
      * Examples:
      *
      *    math.divide(2, 3)            // returns number 0.6666666666666666
      *
      *    const a = math.complex(5, 14)
      *    const b = math.complex(4, 1)
      *    math.divide(a, b)            // returns Complex 2 + 3i
      *
      *    const c = [[7, -6], [13, -4]]
      *    const d = [[1, 2], [4, 3]]
      *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
      *
      *    const e = math.unit('18 km')
      *    math.divide(e, 4.5)          // returns Unit 4 km
      *
      * See also:
      *
      *    multiply
      *
      * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
      * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
      * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
      */
     return typed('divide', extend({
       // we extend the signatures of divideScalar with signatures dealing with matrices

       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(x, y) {
         // TODO: implement matrix right division using pseudo inverse
         // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
         // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
         // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
         return multiply(x, inv(y));
       },
       'DenseMatrix, any': function DenseMatrixAny(x, y) {
         return matAlgo14xDs(x, y, divideScalar, false);
       },
       'SparseMatrix, any': function SparseMatrixAny(x, y) {
         return matAlgo11xS0s(x, y, divideScalar, false);
       },
       'Array, any': function ArrayAny(x, y) {
         // use matrix implementation
         return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();
       },
       'any, Array | Matrix': function anyArrayMatrix(x, y) {
         return multiply(x, inv(y));
       }
     }, divideScalar.signatures));
   });

   var name$V = 'distance';
   var dependencies$V = ['typed', 'addScalar', 'subtract', 'divideScalar', 'multiplyScalar', 'deepEqual', 'sqrt', 'abs'];
   var createDistance = /* #__PURE__ */factory(name$V, dependencies$V, _ref => {
     var {
       typed,
       addScalar,
       subtract,
       multiplyScalar,
       divideScalar,
       deepEqual,
       sqrt,
       abs
     } = _ref;
     /**
       * Calculates:
       *    The eucledian distance between two points in N-dimensional spaces.
       *    Distance between point and a line in 2 and 3 dimensional spaces.
       *    Pairwise distance between a set of 2D or 3D points
       * NOTE:
       *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
       *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (x−x0, y−y0, z−z0) = t(a, b, c)
       *
       * Syntax:
       *
       *    math.distance([x1,y1], [x2,y2])
       *    math.distance({pointOneX, pointOneY}, {pointTwoX, pointTwoY})
       *    math.distance([x1,y1,z1], [x2,y2,z2])
       *    math.distance({pointOneX, pointOneY, pointOneZ}, {pointTwoX, pointTwoY, pointTwoZ})
       *    math.distance([x1,y1,z1,a1], [x2,y2,z2,a2])
       *    math.distance([[x1,y1], [x2,y2], [x3,y3]])
       *    math.distance([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])
       *    math.distance([pointX,pointY], [a,b,c])
       *    math.distance([pointX,pointY], [lineOnePtX,lineOnePtY], [lineTwoPtX,lineTwoPtY])
       *    math.distance({pointX, pointY}, {lineOnePtX, lineOnePtY}, {lineTwoPtX, lineTwoPtY})
       *    math.distance([pointX,pointY,pointZ], [x0, y0, z0, a, b, c])
       *    math.distance({pointX, pointY, pointZ}, {x0, y0, z0, a, b, c})
       *
       * Examples:
       *    math.distance([0,0], [4,4])                     // Returns 5.656854249492381
       *    math.distance(
       *     {pointOneX: 0, pointOneY: 0},
       *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
       *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.7416573867739413
       *    math.distance(
       *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
       *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
       *    math.distance([1, 0, 1, 0], [0, -1, 0, -1])     // Returns 2
       *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
       *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
       *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
       *    math.distance([0, 0], [3, 0], [0, 4])        // Returns 2.4
       *    math.distance(
       *     {pointX: 0, pointY: 0},
       *     {lineOnePtX: 3, lineOnePtY: 0},
       *     {lineTwoPtX: 0, lineTwoPtY: 4})                // Returns 2.4
       *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
       *    math.distance(
       *     {pointX: 2, pointY: 3, pointZ: 1},
       *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1})       // Returns 2.3204774044612857
       *
       * @param {Array | Matrix | Object} x    Co-ordinates of first point
       * @param {Array | Matrix | Object} y    Co-ordinates of second point
       * @return {Number | BigNumber} Returns the distance from two/three points
     */
     return typed(name$V, {
       'Array, Array, Array': function ArrayArrayArray(x, y, z) {
         // Point to Line 2D (x=Point, y=LinePoint1, z=LinePoint2)
         if (x.length === 2 && y.length === 2 && z.length === 2) {
           if (!_2d(x)) {
             throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
           }
           if (!_2d(y)) {
             throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
           }
           if (!_2d(z)) {
             throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
           }
           if (deepEqual(y, z)) {
             throw new TypeError('LinePoint1 should not be same with LinePoint2');
           }
           var xCoeff = subtract(z[1], y[1]);
           var yCoeff = subtract(y[0], z[0]);
           var constant = subtract(multiplyScalar(z[0], y[1]), multiplyScalar(y[0], z[1]));
           return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
         } else {
           throw new TypeError('Invalid Arguments: Try again');
         }
       },
       'Object, Object, Object': function ObjectObjectObject(x, y, z) {
         if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
           if (!_2d(x)) {
             throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
           }
           if (!_2d(y)) {
             throw new TypeError('Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers');
           }
           if (!_2d(z)) {
             throw new TypeError('Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers');
           }
           if (deepEqual(_objectToArray(y), _objectToArray(z))) {
             throw new TypeError('LinePoint1 should not be same with LinePoint2');
           }
           if ('pointX' in x && 'pointY' in x && 'lineOnePtX' in y && 'lineOnePtY' in y && 'lineTwoPtX' in z && 'lineTwoPtY' in z) {
             var xCoeff = subtract(z.lineTwoPtY, y.lineOnePtY);
             var yCoeff = subtract(y.lineOnePtX, z.lineTwoPtX);
             var constant = subtract(multiplyScalar(z.lineTwoPtX, y.lineOnePtY), multiplyScalar(y.lineOnePtX, z.lineTwoPtY));
             return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
           } else {
             throw new TypeError('Key names do not match');
           }
         } else {
           throw new TypeError('Invalid Arguments: Try again');
         }
       },
       'Array, Array': function ArrayArray(x, y) {
         // Point to Line 2D (x=[pointX, pointY], y=[x-coeff, y-coeff, const])
         if (x.length === 2 && y.length === 3) {
           if (!_2d(x)) {
             throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
           }
           if (!_3d(y)) {
             throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
           }
           return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
         } else if (x.length === 3 && y.length === 6) {
           // Point to Line 3D
           if (!_3d(x)) {
             throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
           }
           if (!_parametricLine(y)) {
             throw new TypeError('Array with 6 numbers or BigNumbers expected for second argument');
           }
           return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
         } else if (x.length === y.length && x.length > 0) {
           // Point to Point N-dimensions
           if (!_containsOnlyNumbers(x)) {
             throw new TypeError('All values of an array should be numbers or BigNumbers');
           }
           if (!_containsOnlyNumbers(y)) {
             throw new TypeError('All values of an array should be numbers or BigNumbers');
           }
           return _euclideanDistance(x, y);
         } else {
           throw new TypeError('Invalid Arguments: Try again');
         }
       },
       'Object, Object': function ObjectObject(x, y) {
         if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
           if (!_2d(x)) {
             throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
           }
           if (!_3d(y)) {
             throw new TypeError('Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers');
           }
           if ('pointX' in x && 'pointY' in x && 'xCoeffLine' in y && 'yCoeffLine' in y && 'constant' in y) {
             return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
           } else {
             throw new TypeError('Key names do not match');
           }
         } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
           // Point to Line 3D
           if (!_3d(x)) {
             throw new TypeError('Values of pointX, pointY and pointZ should be numbers or BigNumbers');
           }
           if (!_parametricLine(y)) {
             throw new TypeError('Values of x0, y0, z0, a, b and c should be numbers or BigNumbers');
           }
           if ('pointX' in x && 'pointY' in x && 'x0' in y && 'y0' in y && 'z0' in y && 'a' in y && 'b' in y && 'c' in y) {
             return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
           } else {
             throw new TypeError('Key names do not match');
           }
         } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
           // Point to Point 2D
           if (!_2d(x)) {
             throw new TypeError('Values of pointOneX and pointOneY should be numbers or BigNumbers');
           }
           if (!_2d(y)) {
             throw new TypeError('Values of pointTwoX and pointTwoY should be numbers or BigNumbers');
           }
           if ('pointOneX' in x && 'pointOneY' in x && 'pointTwoX' in y && 'pointTwoY' in y) {
             return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
           } else {
             throw new TypeError('Key names do not match');
           }
         } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
           // Point to Point 3D
           if (!_3d(x)) {
             throw new TypeError('Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers');
           }
           if (!_3d(y)) {
             throw new TypeError('Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers');
           }
           if ('pointOneX' in x && 'pointOneY' in x && 'pointOneZ' in x && 'pointTwoX' in y && 'pointTwoY' in y && 'pointTwoZ' in y) {
             return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
           } else {
             throw new TypeError('Key names do not match');
           }
         } else {
           throw new TypeError('Invalid Arguments: Try again');
         }
       },
       Array: function Array(arr) {
         if (!_pairwise(arr)) {
           throw new TypeError('Incorrect array format entered for pairwise distance calculation');
         }
         return _distancePairwise(arr);
       }
     });
     function _isNumber(a) {
       // distance supports numbers and bignumbers
       return typeof a === 'number' || isBigNumber(a);
     }
     function _2d(a) {
       // checks if the number of arguments are correct in count and are valid (should be numbers)
       if (a.constructor !== Array) {
         a = _objectToArray(a);
       }
       return _isNumber(a[0]) && _isNumber(a[1]);
     }
     function _3d(a) {
       // checks if the number of arguments are correct in count and are valid (should be numbers)
       if (a.constructor !== Array) {
         a = _objectToArray(a);
       }
       return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
     }
     function _containsOnlyNumbers(a) {
       // checks if the number of arguments are correct in count and are valid (should be numbers)
       if (!Array.isArray(a)) {
         a = _objectToArray(a);
       }
       return a.every(_isNumber);
     }
     function _parametricLine(a) {
       if (a.constructor !== Array) {
         a = _objectToArray(a);
       }
       return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
     }
     function _objectToArray(o) {
       var keys = Object.keys(o);
       var a = [];
       for (var i = 0; i < keys.length; i++) {
         a.push(o[keys[i]]);
       }
       return a;
     }
     function _pairwise(a) {
       // checks for valid arguments passed to _distancePairwise(Array)
       if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
         if (a.some(aI => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
           return false;
         }
       } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
         if (a.some(aI => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
           return false;
         }
       } else {
         return false;
       }
       return true;
     }
     function _distancePointLine2D(x, y, a, b, c) {
       var num = abs(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
       var den = sqrt(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
       return divideScalar(num, den);
     }
     function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
       var num = [subtract(multiplyScalar(subtract(y0, y), c), multiplyScalar(subtract(z0, z), b)), subtract(multiplyScalar(subtract(z0, z), a), multiplyScalar(subtract(x0, x), c)), subtract(multiplyScalar(subtract(x0, x), b), multiplyScalar(subtract(y0, y), a))];
       num = sqrt(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
       var den = sqrt(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
       return divideScalar(num, den);
     }
     function _euclideanDistance(x, y) {
       var vectorSize = x.length;
       var result = 0;
       var diff = 0;
       for (var i = 0; i < vectorSize; i++) {
         diff = subtract(x[i], y[i]);
         result = addScalar(multiplyScalar(diff, diff), result);
       }
       return sqrt(result);
     }
     function _distancePairwise(a) {
       var result = [];
       var pointA = [];
       var pointB = [];
       for (var i = 0; i < a.length - 1; i++) {
         for (var j = i + 1; j < a.length; j++) {
           if (a[0].length === 2) {
             pointA = [a[i][0], a[i][1]];
             pointB = [a[j][0], a[j][1]];
           } else if (a[0].length === 3) {
             pointA = [a[i][0], a[i][1], a[i][2]];
             pointB = [a[j][0], a[j][1], a[j][2]];
           }
           result.push(_euclideanDistance(pointA, pointB));
         }
       }
       return result;
     }
   });

   var name$U = 'intersect';
   var dependencies$U = ['typed', 'config', 'abs', 'add', 'addScalar', 'matrix', 'multiply', 'multiplyScalar', 'divideScalar', 'subtract', 'smaller', 'equalScalar', 'flatten', 'isZero', 'isNumeric'];
   var createIntersect = /* #__PURE__ */factory(name$U, dependencies$U, _ref => {
     var {
       typed,
       config,
       abs,
       add,
       addScalar,
       matrix,
       multiply,
       multiplyScalar,
       divideScalar,
       subtract,
       smaller,
       equalScalar,
       flatten,
       isZero,
       isNumeric
     } = _ref;
     /**
      * Calculates the point of intersection of two lines in two or three dimensions
      * and of a line and a plane in three dimensions. The inputs are in the form of
      * arrays or 1 dimensional matrices. The line intersection functions return null
      * if the lines do not meet.
      *
      * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
      *
      * Syntax:
      *
      *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      *    math.intersect(endPoint1, endPoint2, planeCoefficients)
      *
      * Examples:
      *
      *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10])              // Returns [5, 5]
      *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0])  // Returns [5, 5, 0]
      *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])            // Returns [7, -4, 3]
      *
      * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
      * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
      * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
      *                              OR Co-efficients of the plane's equation
      * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
      *                              OR undefined if the calculation is for line and plane
      * @return {Array}              Returns the point of intersection of lines/lines-planes
      */
     return typed('intersect', {
       'Array, Array, Array': _AAA,
       'Array, Array, Array, Array': _AAAA,
       'Matrix, Matrix, Matrix': function MatrixMatrixMatrix(x, y, plane) {
         var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
         return arr === null ? null : matrix(arr);
       },
       'Matrix, Matrix, Matrix, Matrix': function MatrixMatrixMatrixMatrix(w, x, y, z) {
         // TODO: output matrix type should match input matrix type
         var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
         return arr === null ? null : matrix(arr);
       }
     });
     function _AAA(x, y, plane) {
       x = _coerceArr(x);
       y = _coerceArr(y);
       plane = _coerceArr(plane);
       if (!_3d(x)) {
         throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
       }
       if (!_3d(y)) {
         throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
       }
       if (!_4d(plane)) {
         throw new TypeError('Array with 4 numbers expected as third argument');
       }
       return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
     }
     function _AAAA(w, x, y, z) {
       w = _coerceArr(w);
       x = _coerceArr(x);
       y = _coerceArr(y);
       z = _coerceArr(z);
       if (w.length === 2) {
         if (!_2d(w)) {
           throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
         }
         if (!_2d(x)) {
           throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
         }
         if (!_2d(y)) {
           throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
         }
         if (!_2d(z)) {
           throw new TypeError('Array with 2 numbers or BigNumbers expected for fourth argument');
         }
         return _intersect2d(w, x, y, z);
       } else if (w.length === 3) {
         if (!_3d(w)) {
           throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
         }
         if (!_3d(x)) {
           throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
         }
         if (!_3d(y)) {
           throw new TypeError('Array with 3 numbers or BigNumbers expected for third argument');
         }
         if (!_3d(z)) {
           throw new TypeError('Array with 3 numbers or BigNumbers expected for fourth argument');
         }
         return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
       } else {
         throw new TypeError('Arrays with two or thee dimensional points expected');
       }
     }

     /** Coerce row and column 2-dim arrays to 1-dim array */
     function _coerceArr(arr) {
       // row matrix
       if (arr.length === 1) return arr[0];

       // column matrix
       if (arr.length > 1 && Array.isArray(arr[0])) {
         if (arr.every(el => Array.isArray(el) && el.length === 1)) return flatten(arr);
       }
       return arr;
     }
     function _2d(x) {
       return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
     }
     function _3d(x) {
       return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
     }
     function _4d(x) {
       return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
     }
     function _intersect2d(p1a, p1b, p2a, p2b) {
       var o1 = p1a;
       var o2 = p2a;
       var d1 = subtract(o1, p1b);
       var d2 = subtract(o2, p2b);
       var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
       if (isZero(det)) return null;
       if (smaller(abs(det), config.epsilon)) {
         return null;
       }
       var d20o11 = multiplyScalar(d2[0], o1[1]);
       var d21o10 = multiplyScalar(d2[1], o1[0]);
       var d20o21 = multiplyScalar(d2[0], o2[1]);
       var d21o20 = multiplyScalar(d2[1], o2[0]);
       var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
       return add(multiply(d1, t), o1);
     }
     function _intersect3dHelper(a, b, c, d, e, f, g, h, i, j, k, l) {
       // (a - b)*(c - d) + (e - f)*(g - h) + (i - j)*(k - l)
       var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
       var add2 = multiplyScalar(subtract(e, f), subtract(g, h));
       var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
       return addScalar(addScalar(add1, add2), add3);
     }
     function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
       var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
       var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
       var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
       var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
       var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
       var numerator = subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
       var denominator = subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
       if (isZero(denominator)) return null;
       var ta = divideScalar(numerator, denominator);
       var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
       var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
       var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
       var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
       var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
       var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
       var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
       if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
         return [pax, pay, paz];
       } else {
         return null;
       }
     }
     function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
       var x1x = multiplyScalar(x1, x);
       var x2x = multiplyScalar(x2, x);
       var y1y = multiplyScalar(y1, y);
       var y2y = multiplyScalar(y2, y);
       var z1z = multiplyScalar(z1, z);
       var z2z = multiplyScalar(z2, z);
       var numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
       var denominator = subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
       var t = divideScalar(numerator, denominator);
       var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
       var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
       var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
       return [px, py, pz];
       // TODO: Add cases when line is parallel to the plane:
       //       (a) no intersection,
       //       (b) line contained in plane
     }
   });

   var name$T = 'sum';
   var dependencies$T = ['typed', 'config', 'add', 'numeric'];
   var createSum = /* #__PURE__ */factory(name$T, dependencies$T, _ref => {
     var {
       typed,
       config,
       add,
       numeric
     } = _ref;
     /**
      * Compute the sum of a matrix or a list with values.
      * In case of a multidimensional array or matrix, the sum of all
      * elements will be calculated.
      *
      * Syntax:
      *
      *     math.sum(a, b, c, ...)
      *     math.sum(A)
      *     math.sum(A, dimension)
      *
      * Examples:
      *
      *     math.sum(2, 1, 4, 3)               // returns 10
      *     math.sum([2, 1, 4, 3])             // returns 10
      *     math.sum([[2, 5], [4, 3], [1, 7]]) // returns 22
      *
      * See also:
      *
      *    mean, median, min, max, prod, std, variance, cumsum
      *
      * @param {... *} args  A single matrix or multiple scalar values
      * @return {*} The sum of all values
      */
     return typed(name$T, {
       // sum([a, b, c, d, ...])
       'Array | Matrix': _sum,
       // sum([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': _nsumDim,
       // sum(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('Scalar values expected in function sum');
         }
         return _sum(args);
       }
     });

     /**
      * Recursively calculate the sum of an n-dimensional array
      * @param {Array | Matrix} array
      * @return {number} sum
      * @private
      */
     function _sum(array) {
       var sum;
       deepForEach(array, function (value) {
         try {
           sum = sum === undefined ? value : add(sum, value);
         } catch (err) {
           throw improveErrorMessage(err, 'sum', value);
         }
       });

       // make sure returning numeric value: parse a string into a numeric value
       if (sum === undefined) {
         sum = numeric(0, config.number);
       }
       if (typeof sum === 'string') {
         sum = numeric(sum, config.number);
       }
       return sum;
     }
     function _nsumDim(array, dim) {
       try {
         var sum = reduce(array, dim, add);
         return sum;
       } catch (err) {
         throw improveErrorMessage(err, 'sum');
       }
     }
   });

   var name$S = 'cumsum';
   var dependencies$S = ['typed', 'add', 'unaryPlus'];
   var createCumSum = /* #__PURE__ */factory(name$S, dependencies$S, _ref => {
     var {
       typed,
       add,
       unaryPlus
     } = _ref;
     /**
      * Compute the cumulative sum of a matrix or a list with values.
      * In case of a (multi dimensional) array or matrix, the cumulative sums
      * along a specified dimension (defaulting to the first) will be calculated.
      *
      * Syntax:
      *
      *     math.cumsum(a, b, c, ...)
      *     math.cumsum(A)
      *
      * Examples:
      *
      *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]
      *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]
      *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]
      *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]
      *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]
      *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]
      *
      * See also:
      *
      *    mean, median, min, max, prod, std, variance, sum
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The cumulative sum of all values
      */
     return typed(name$S, {
       // sum([a, b, c, d, ...])
       Array: _cumsum,
       Matrix: function Matrix(matrix) {
         return matrix.create(_cumsum(matrix.valueOf()));
       },
       // sum([a, b, c, d, ...], dim)
       'Array, number | BigNumber': _ncumSumDim,
       'Matrix, number | BigNumber': function MatrixNumberBigNumber(matrix, dim) {
         return matrix.create(_ncumSumDim(matrix.valueOf(), dim));
       },
       // cumsum(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('All values expected to be scalar in function cumsum');
         }
         return _cumsum(args);
       }
     });

     /**
        * Recursively calculate the cumulative sum of an n-dimensional array
        * @param {Array} array
        * @return {number} cumsum
        * @private
        */
     function _cumsum(array) {
       try {
         return _cumsummap(array);
       } catch (err) {
         throw improveErrorMessage(err, name$S);
       }
     }
     function _cumsummap(array) {
       if (array.length === 0) {
         return [];
       }
       var sums = [unaryPlus(array[0])]; // unaryPlus converts to number if need be
       for (var i = 1; i < array.length; ++i) {
         // Must use add below and not addScalar for the case of summing a
         // 2+-dimensional array along the 0th dimension (the row vectors,
         // or higher-d analogues, are literally added to each other).
         sums.push(add(sums[i - 1], array[i]));
       }
       return sums;
     }
     function _ncumSumDim(array, dim) {
       var size = arraySize(array);
       if (dim < 0 || dim >= size.length) {
         // TODO: would be more clear when throwing a DimensionError here
         throw new IndexError(dim, size.length);
       }
       try {
         return _cumsumDimensional(array, dim);
       } catch (err) {
         throw improveErrorMessage(err, name$S);
       }
     }

     /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */
     function _cumsumDimensional(mat, dim) {
       var i, ret, tran;
       if (dim <= 0) {
         var initialValue = mat[0][0];
         if (!Array.isArray(initialValue)) {
           return _cumsummap(mat);
         } else {
           tran = _switch$1(mat);
           ret = [];
           for (i = 0; i < tran.length; i++) {
             ret[i] = _cumsumDimensional(tran[i], dim - 1);
           }
           return ret;
         }
       } else {
         ret = [];
         for (i = 0; i < mat.length; i++) {
           ret[i] = _cumsumDimensional(mat[i], dim - 1);
         }
         return ret;
       }
     }
   });

   var name$R = 'mean';
   var dependencies$R = ['typed', 'add', 'divide'];
   var createMean = /* #__PURE__ */factory(name$R, dependencies$R, _ref => {
     var {
       typed,
       add,
       divide
     } = _ref;
     /**
      * Compute the mean value of matrix or a list with values.
      * In case of a multidimensional array, the mean of the flattened array
      * will be calculated. When `dim` is provided, the maximum over the selected
      * dimension will be calculated. Parameter `dim` is zero-based.
      *
      * Syntax:
      *
      *     math.mean(a, b, c, ...)
      *     math.mean(A)
      *     math.mean(A, dimension)
      *
      * Examples:
      *
      *     math.mean(2, 1, 4, 3)                     // returns 2.5
      *     math.mean([1, 2.7, 3.2, 4])               // returns 2.725
      *
      *     math.mean([[2, 5], [6, 3], [1, 7]], 0)    // returns [3, 5]
      *     math.mean([[2, 5], [6, 3], [1, 7]], 1)    // returns [3.5, 4.5, 4]
      *
      * See also:
      *
      *     median, min, max, sum, prod, std, variance
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The mean of all values
      */
     return typed(name$R, {
       // mean([a, b, c, d, ...])
       'Array | Matrix': _mean,
       // mean([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': _nmeanDim,
       // mean(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('Scalar values expected in function mean');
         }
         return _mean(args);
       }
     });

     /**
      * Calculate the mean value in an n-dimensional array, returning a
      * n-1 dimensional array
      * @param {Array} array
      * @param {number} dim
      * @return {number} mean
      * @private
      */
     function _nmeanDim(array, dim) {
       try {
         var sum = reduce(array, dim, add);
         var s = Array.isArray(array) ? arraySize(array) : array.size();
         return divide(sum, s[dim]);
       } catch (err) {
         throw improveErrorMessage(err, 'mean');
       }
     }

     /**
      * Recursively calculate the mean value in an n-dimensional array
      * @param {Array} array
      * @return {number} mean
      * @private
      */
     function _mean(array) {
       var sum;
       var num = 0;
       deepForEach(array, function (value) {
         try {
           sum = sum === undefined ? value : add(sum, value);
           num++;
         } catch (err) {
           throw improveErrorMessage(err, 'mean', value);
         }
       });
       if (num === 0) {
         throw new Error('Cannot calculate the mean of an empty array');
       }
       return divide(sum, num);
     }
   });

   var name$Q = 'median';
   var dependencies$Q = ['typed', 'add', 'divide', 'compare', 'partitionSelect'];
   var createMedian = /* #__PURE__ */factory(name$Q, dependencies$Q, _ref => {
     var {
       typed,
       add,
       divide,
       compare,
       partitionSelect
     } = _ref;
     /**
      * Recursively calculate the median of an n-dimensional array
      * @param {Array} array
      * @return {Number} median
      * @private
      */
     function _median(array) {
       try {
         array = flatten$1(array.valueOf());
         var num = array.length;
         if (num === 0) {
           throw new Error('Cannot calculate median of an empty array');
         }
         if (num % 2 === 0) {
           // even: return the average of the two middle values
           var mid = num / 2 - 1;
           var right = partitionSelect(array, mid + 1);

           // array now partitioned at mid + 1, take max of left part
           var left = array[mid];
           for (var i = 0; i < mid; ++i) {
             if (compare(array[i], left) > 0) {
               left = array[i];
             }
           }
           return middle2(left, right);
         } else {
           // odd: return the middle value
           var m = partitionSelect(array, (num - 1) / 2);
           return middle(m);
         }
       } catch (err) {
         throw improveErrorMessage(err, 'median');
       }
     }

     // helper function to type check the middle value of the array
     var middle = typed({
       'number | BigNumber | Complex | Unit': function numberBigNumberComplexUnit(value) {
         return value;
       }
     });

     // helper function to type check the two middle value of the array
     var middle2 = typed({
       'number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit': function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
         return divide(add(left, right), 2);
       }
     });

     /**
      * Compute the median of a matrix or a list with values. The values are
      * sorted and the middle value is returned. In case of an even number of
      * values, the average of the two middle values is returned.
      * Supported types of values are: Number, BigNumber, Unit
      *
      * In case of a (multi dimensional) array or matrix, the median of all
      * elements will be calculated.
      *
      * Syntax:
      *
      *     math.median(a, b, c, ...)
      *     math.median(A)
      *
      * Examples:
      *
      *     math.median(5, 2, 7)        // returns 5
      *     math.median([3, -1, 5, 7])  // returns 4
      *
      * See also:
      *
      *     mean, min, max, sum, prod, std, variance, quantileSeq
      *
      * @param {... *} args  A single matrix or or multiple scalar values
      * @return {*} The median
      */
     return typed(name$Q, {
       // median([a, b, c, d, ...])
       'Array | Matrix': _median,
       // median([a, b, c, d, ...], dim)
       'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
         // TODO: implement median(A, dim)
         throw new Error('median(A, dim) is not yet supported');
         // return reduce(arguments[0], arguments[1], ...)
       },

       // median(a, b, c, d, ...)
       '...': function _(args) {
         if (containsCollections(args)) {
           throw new TypeError('Scalar values expected in function median');
         }
         return _median(args);
       }
     });
   });

   var name$P = 'mad';
   var dependencies$P = ['typed', 'abs', 'map', 'median', 'subtract'];
   var createMad = /* #__PURE__ */factory(name$P, dependencies$P, _ref => {
     var {
       typed,
       abs,
       map,
       median,
       subtract
     } = _ref;
     /**
      * Compute the median absolute deviation of a matrix or a list with values.
      * The median absolute deviation is defined as the median of the absolute
      * deviations from the median.
      *
      * Syntax:
      *
      *     math.mad(a, b, c, ...)
      *     math.mad(A)
      *
      * Examples:
      *
      *     math.mad(10, 20, 30)             // returns 10
      *     math.mad([1, 2, 3])              // returns 1
      *     math.mad([[1, 2, 3], [4, 5, 6]]) // returns 1.5
      *
      * See also:
      *
      *     median, mean, std, abs
      *
      * @param {Array | Matrix} array
      *                        A single matrix or multiple scalar values.
      * @return {*} The median absolute deviation.
      */
     return typed(name$P, {
       // mad([a, b, c, d, ...])
       'Array | Matrix': _mad,
       // mad(a, b, c, d, ...)
       '...': function _(args) {
         return _mad(args);
       }
     });
     function _mad(array) {
       array = flatten$1(array.valueOf());
       if (array.length === 0) {
         throw new Error('Cannot calculate median absolute deviation (mad) of an empty array');
       }
       try {
         var med = median(array);
         return median(map(array, function (value) {
           return abs(subtract(value, med));
         }));
       } catch (err) {
         if (err instanceof TypeError && err.message.indexOf('median') !== -1) {
           throw new TypeError(err.message.replace('median', 'mad'));
         } else {
           throw improveErrorMessage(err, 'mad');
         }
       }
     }
   });

   var DEFAULT_NORMALIZATION = 'unbiased';
   var name$O = 'variance';
   var dependencies$O = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];
   var createVariance = /* #__PURE__ */factory(name$O, dependencies$O, _ref => {
     var {
       typed,
       add,
       subtract,
       multiply,
       divide,
       apply,
       isNaN
     } = _ref;
     /**
      * Compute the variance of a matrix or a  list with values.
      * In case of a multidimensional array or matrix, the variance over all
      * elements will be calculated.
      *
      * Additionally, it is possible to compute the variance along the rows
      * or columns of a matrix by specifying the dimension as the second argument.
      *
      * Optionally, the type of normalization can be specified as the final
      * parameter. The parameter `normalization` can be one of the following values:
      *
      * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
      * - 'uncorrected'        The sum of squared errors is divided by n
      * - 'biased'             The sum of squared errors is divided by (n + 1)
      *
      *
      * Note that older browser may not like the variable name `var`. In that
      * case, the function can be called as `math['var'](...)` instead of
      * `math.var(...)`.
      *
      * Syntax:
      *
      *     math.variance(a, b, c, ...)
      *     math.variance(A)
      *     math.variance(A, normalization)
      *     math.variance(A, dimension)
      *     math.variance(A, dimension, normalization)
      *
      * Examples:
      *
      *     math.variance(2, 4, 6)                     // returns 4
      *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667
      *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5
      *     math.variance([2, 4, 6, 8], 'biased')      // returns 4
      *
      *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5
      *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]
      *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]
      *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]
      *
      * See also:
      *
      *    mean, median, max, min, prod, std, sum
      *
      * @param {Array | Matrix} array
      *                        A single matrix or or multiple scalar values
      * @param {string} [normalization='unbiased']
      *                        Determines how to normalize the variance.
      *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
      * @param dimension {number | BigNumber}
      *                        Determines the axis to compute the variance for a matrix
      * @return {*} The variance
      */
     return typed(name$O, {
       // variance([a, b, c, d, ...])
       'Array | Matrix': function ArrayMatrix(array) {
         return _var(array, DEFAULT_NORMALIZATION);
       },
       // variance([a, b, c, d, ...], normalization)
       'Array | Matrix, string': _var,
       // variance([a, b, c, c, ...], dim)
       'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
         return _varDim(array, dim, DEFAULT_NORMALIZATION);
       },
       // variance([a, b, c, c, ...], dim, normalization)
       'Array | Matrix, number | BigNumber, string': _varDim,
       // variance(a, b, c, d, ...)
       '...': function _(args) {
         return _var(args, DEFAULT_NORMALIZATION);
       }
     });

     /**
      * Recursively calculate the variance of an n-dimensional array
      * @param {Array} array
      * @param {string} normalization
      *                        Determines how to normalize the variance:
      *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
      *                        - 'uncorrected' The sum of squared errors is divided by n
      *                        - 'biased'      The sum of squared errors is divided by (n + 1)
      * @return {number | BigNumber} variance
      * @private
      */
     function _var(array, normalization) {
       var sum;
       var num = 0;
       if (array.length === 0) {
         throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
       }

       // calculate the mean and number of elements
       deepForEach(array, function (value) {
         try {
           sum = sum === undefined ? value : add(sum, value);
           num++;
         } catch (err) {
           throw improveErrorMessage(err, 'variance', value);
         }
       });
       if (num === 0) throw new Error('Cannot calculate variance of an empty array');
       var mean = divide(sum, num);

       // calculate the variance
       sum = undefined;
       deepForEach(array, function (value) {
         var diff = subtract(value, mean);
         sum = sum === undefined ? multiply(diff, diff) : add(sum, multiply(diff, diff));
       });
       if (isNaN(sum)) {
         return sum;
       }
       switch (normalization) {
         case 'uncorrected':
           return divide(sum, num);
         case 'biased':
           return divide(sum, num + 1);
         case 'unbiased':
           {
             var zero = isBigNumber(sum) ? sum.mul(0) : 0;
             return num === 1 ? zero : divide(sum, num - 1);
           }
         default:
           throw new Error('Unknown normalization "' + normalization + '". ' + 'Choose "unbiased" (default), "uncorrected", or "biased".');
       }
     }
     function _varDim(array, dim, normalization) {
       try {
         if (array.length === 0) {
           throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
         }
         return apply(array, dim, x => _var(x, normalization));
       } catch (err) {
         throw improveErrorMessage(err, 'variance');
       }
     }
   });

   var name$N = 'quantileSeq';
   var dependencies$N = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];
   var createQuantileSeq = /* #__PURE__ */factory(name$N, dependencies$N, _ref => {
     var {
       typed,
       add,
       multiply,
       partitionSelect,
       compare,
       isInteger
     } = _ref;
     /**
      * Compute the prob order quantile of a matrix or a list with values.
      * The sequence is sorted and the middle value is returned.
      * Supported types of sequence values are: Number, BigNumber, Unit
      * Supported types of probability are: Number, BigNumber
      *
      * In case of a multidimensional array or matrix, the prob order quantile
      * of all elements will be calculated.
      *
      * Syntax:
      *
      *     math.quantileSeq(A, prob[, sorted])
      *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
      *     math.quantileSeq(A, N[, sorted])
      *
      * Examples:
      *
      *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4
      *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]
      *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]
      *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4
      *
      * See also:
      *
      *     median, mean, min, max, sum, prod, std, variance
      *
      * @param {Array, Matrix} data                A single matrix or Array
      * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
      *                                            the amount of evenly distributed steps of
      *                                            probabilities; only one of these options can
      *                                            be provided
      * @param {Boolean} sorted=false              is data sorted in ascending order
      * @return {Number, BigNumber, Unit, Array}   Quantile(s)
      */

     var apply = createApply({
       typed,
       isInteger
     });
     /**
      * Check if array value types are valid, throw error otherwise.
      * @param {number | BigNumber | Unit} x
      * @param {number | BigNumber | Unit} x
      * @private
      */
     var validate = typed({
       'number | BigNumber | Unit': function numberBigNumberUnit(x) {
         return x;
       }
     });
     return typed(name$N, {
       'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),
       'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,
       'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),
       'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)
     });
     function _quantileSeqDim(data, prob, sorted, dim) {
       // return [1.3, 1.2]
       return apply(data, dim, x => quantileSeq(x, prob, sorted));
     }
     function quantileSeq(data, probOrN, sorted) {
       var probArr, dataArr, one;
       if (arguments.length < 2 || arguments.length > 3) {
         throw new SyntaxError('Function quantileSeq requires two or three parameters');
       }
       if (isCollection(data)) {
         sorted = sorted || false;
         if (typeof sorted === 'boolean') {
           dataArr = data.valueOf();
           if (isNumber(probOrN)) {
             if (probOrN < 0) {
               throw new Error('N/prob must be non-negative');
             }
             if (probOrN <= 1) {
               // quantileSeq([a, b, c, d, ...], prob[,sorted])
               return _quantileSeq(dataArr, probOrN, sorted);
             }
             if (probOrN > 1) {
               // quantileSeq([a, b, c, d, ...], N[,sorted])
               if (!isInteger(probOrN)) {
                 throw new Error('N must be a positive integer');
               }
               var nPlusOne = probOrN + 1;
               probArr = new Array(probOrN);
               for (var i = 0; i < probOrN;) {
                 probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);
               }
               return probArr;
             }
           }
           if (isBigNumber(probOrN)) {
             var BigNumber = probOrN.constructor;
             if (probOrN.isNegative()) {
               throw new Error('N/prob must be non-negative');
             }
             one = new BigNumber(1);
             if (probOrN.lte(one)) {
               // quantileSeq([a, b, c, d, ...], prob[,sorted])
               return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));
             }
             if (probOrN.gt(one)) {
               // quantileSeq([a, b, c, d, ...], N[,sorted])
               if (!probOrN.isInteger()) {
                 throw new Error('N must be a positive integer');
               }

               // largest possible Array length is 2^32-1
               // 2^32 < 10^15, thus safe conversion guaranteed
               var intN = probOrN.toNumber();
               if (intN > 4294967295) {
                 throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
               }
               var _nPlusOne = new BigNumber(intN + 1);
               probArr = new Array(intN);
               for (var _i = 0; _i < intN;) {
                 probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));
               }
               return probArr;
             }
           }
           if (isCollection(probOrN)) {
             // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
             var probOrNArr = probOrN.valueOf();
             probArr = new Array(probOrNArr.length);
             for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
               var currProb = probOrNArr[_i2];
               if (isNumber(currProb)) {
                 if (currProb < 0 || currProb > 1) {
                   throw new Error('Probability must be between 0 and 1, inclusive');
                 }
               } else if (isBigNumber(currProb)) {
                 one = new currProb.constructor(1);
                 if (currProb.isNegative() || currProb.gt(one)) {
                   throw new Error('Probability must be between 0 and 1, inclusive');
                 }
               } else {
                 throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
               }

               probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
             }
             return probArr;
           }
           throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
         }

         throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
       }

       throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
     }

     /**
      * Calculate the prob order quantile of an n-dimensional array.
      *
      * @param {Array} array
      * @param {Number, BigNumber} prob
      * @param {Boolean} sorted
      * @return {Number, BigNumber, Unit} prob order quantile
      * @private
      */
     function _quantileSeq(array, prob, sorted) {
       var flat = flatten$1(array);
       var len = flat.length;
       if (len === 0) {
         throw new Error('Cannot calculate quantile of an empty sequence');
       }
       if (isNumber(prob)) {
         var _index = prob * (len - 1);
         var _fracPart = _index % 1;
         if (_fracPart === 0) {
           var value = sorted ? flat[_index] : partitionSelect(flat, _index);
           validate(value);
           return value;
         }
         var _integerPart = Math.floor(_index);
         var _left;
         var _right;
         if (sorted) {
           _left = flat[_integerPart];
           _right = flat[_integerPart + 1];
         } else {
           _right = partitionSelect(flat, _integerPart + 1);

           // max of partition is kth largest
           _left = flat[_integerPart];
           for (var i = 0; i < _integerPart; ++i) {
             if (compare(flat[i], _left) > 0) {
               _left = flat[i];
             }
           }
         }
         validate(_left);
         validate(_right);

         // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
         return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));
       }

       // If prob is a BigNumber
       var index = prob.times(len - 1);
       if (index.isInteger()) {
         index = index.toNumber();
         var _value = sorted ? flat[index] : partitionSelect(flat, index);
         validate(_value);
         return _value;
       }
       var integerPart = index.floor();
       var fracPart = index.minus(integerPart);
       var integerPartNumber = integerPart.toNumber();
       var left;
       var right;
       if (sorted) {
         left = flat[integerPartNumber];
         right = flat[integerPartNumber + 1];
       } else {
         right = partitionSelect(flat, integerPartNumber + 1);

         // max of partition is kth largest
         left = flat[integerPartNumber];
         for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
           if (compare(flat[_i3], left) > 0) {
             left = flat[_i3];
           }
         }
       }
       validate(left);
       validate(right);

       // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
       var one = new fracPart.constructor(1);
       return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));
     }
   });

   var name$M = 'std';
   var dependencies$M = ['typed', 'map', 'sqrt', 'variance'];
   var createStd = /* #__PURE__ */factory(name$M, dependencies$M, _ref => {
     var {
       typed,
       map,
       sqrt,
       variance
     } = _ref;
     /**
      * Compute the standard deviation of a matrix or a  list with values.
      * The standard deviations is defined as the square root of the variance:
      * `std(A) = sqrt(variance(A))`.
      * In case of a (multi dimensional) array or matrix, the standard deviation
      * over all elements will be calculated by default, unless an axis is specified
      * in which case the standard deviation will be computed along that axis.
      *
      * Additionally, it is possible to compute the standard deviation along the rows
      * or columns of a matrix by specifying the dimension as the second argument.
      *
      * Optionally, the type of normalization can be specified as the final
      * parameter. The parameter `normalization` can be one of the following values:
      *
      * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
      * - 'uncorrected'        The sum of squared errors is divided by n
      * - 'biased'             The sum of squared errors is divided by (n + 1)
      *
      *
      * Syntax:
      *
      *     math.std(a, b, c, ...)
      *     math.std(A)
      *     math.std(A, normalization)
      *     math.std(A, dimension)
      *     math.std(A, dimension, normalization)
      *
      * Examples:
      *
      *     math.std(2, 4, 6)                     // returns 2
      *     math.std([2, 4, 6, 8])                // returns 2.581988897471611
      *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979
      *     math.std([2, 4, 6, 8], 'biased')      // returns 2
      *
      *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707
      *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]
      *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]
      *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]
      *
      * See also:
      *
      *    mean, median, max, min, prod, sum, variance
      *
      * @param {Array | Matrix} array
      *                        A single matrix or or multiple scalar values
      * @param {string} [normalization='unbiased']
      *                        Determines how to normalize the variance.
      *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
      * @param dimension {number | BigNumber}
      *                        Determines the axis to compute the standard deviation for a matrix
      * @return {*} The standard deviation
      */
     return typed(name$M, {
       // std([a, b, c, d, ...])
       'Array | Matrix': _std,
       // std([a, b, c, d, ...], normalization)
       'Array | Matrix, string': _std,
       // std([a, b, c, c, ...], dim)
       'Array | Matrix, number | BigNumber': _std,
       // std([a, b, c, c, ...], dim, normalization)
       'Array | Matrix, number | BigNumber, string': _std,
       // std(a, b, c, d, ...)
       '...': function _(args) {
         return _std(args);
       }
     });
     function _std(array, normalization) {
       if (array.length === 0) {
         throw new SyntaxError('Function std requires one or more parameters (0 provided)');
       }
       try {
         var v = variance.apply(null, arguments);
         if (isCollection(v)) {
           return map(v, sqrt);
         } else {
           return sqrt(v);
         }
       } catch (err) {
         if (err instanceof TypeError && err.message.indexOf(' variance') !== -1) {
           throw new TypeError(err.message.replace(' variance', ' std'));
         } else {
           throw err;
         }
       }
     }
   });

   var name$L = 'corr';
   var dependencies$L = ['typed', 'matrix', 'mean', 'sqrt', 'sum', 'add', 'subtract', 'multiply', 'pow', 'divide'];
   var createCorr = /* #__PURE__ */factory(name$L, dependencies$L, _ref => {
     var {
       typed,
       matrix,
       sqrt,
       sum,
       add,
       subtract,
       multiply,
       pow,
       divide
     } = _ref;
     /**
      * Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
      *
      * Syntax:
      *
      *     math.corr(A, B)
      *
      * Examples:
      *
      *     math.corr([1, 2, 3, 4, 5], [4, 5, 6, 7, 8])     // returns 1
      *     math.corr([1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8])     // returns 0.9569941688503644
      *     math.corr(math.matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), math.matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]])) // returns DenseMatrix [0.9569941688503644, 1]
      *
      * See also:
      *
      *     median, mean, min, max, sum, prod, std, variance
      *
      * @param {Array | Matrix} A The first array or matrix to compute correlation coefficient
      * @param {Array | Matrix} B The second array or matrix to compute correlation coefficient
      * @return {*} The correlation coefficient
      */
     return typed(name$L, {
       'Array, Array': function ArrayArray(A, B) {
         return _corr(A, B);
       },
       'Matrix, Matrix': function MatrixMatrix(xMatrix, yMatrix) {
         return matrix(_corr(xMatrix.toArray(), yMatrix.toArray()));
       }
     });
     /**
      * Calculate the correlation coefficient between two arrays or matrices.
      * @param {Array | Matrix} A
      * @param {Array | Matrix} B
      * @return {*} correlation coefficient
      * @private
      */
     function _corr(A, B) {
       if (Array.isArray(A[0]) && Array.isArray(B[0])) {
         var correlations = [];
         for (var i = 0; i < A.length; i++) {
           correlations.push(correlation(A[i], B[i]));
         }
         return correlations;
       } else {
         return correlation(A, B);
       }
     }
     function correlation(A, B) {
       var n = A.length;
       var sumX = sum(A);
       var sumY = sum(B);
       var sumXY = A.reduce((acc, x, index) => add(acc, multiply(x, B[index])), 0);
       var sumXSquare = sum(A.map(x => pow(x, 2)));
       var sumYSquare = sum(B.map(y => pow(y, 2)));
       var numerator = subtract(multiply(n, sumXY), multiply(sumX, sumY));
       var denominator = sqrt(multiply(subtract(multiply(n, sumXSquare), pow(sumX, 2)), subtract(multiply(n, sumYSquare), pow(sumY, 2))));
       return divide(numerator, denominator);
     }
   });

   var name$K = 'combinations';
   var dependencies$K = ['typed'];
   var createCombinations = /* #__PURE__ */factory(name$K, dependencies$K, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the number of ways of picking `k` unordered outcomes from `n`
      * possibilities.
      *
      * Combinations only takes integer arguments.
      * The following condition must be enforced: k <= n.
      *
      * Syntax:
      *
      *     math.combinations(n, k)
      *
      * Examples:
      *
      *    math.combinations(7, 5) // returns 21
      *
      * See also:
      *
      *    combinationsWithRep, permutations, factorial
      *
      * @param {number | BigNumber} n    Total number of objects in the set
      * @param {number | BigNumber} k    Number of objects in the subset
      * @return {number | BigNumber}     Number of possible combinations.
      */
     return typed(name$K, {
       'number, number': combinationsNumber,
       'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
         var BigNumber = n.constructor;
         var result, i;
         var nMinusk = n.minus(k);
         var one = new BigNumber(1);
         if (!isPositiveInteger$2(n) || !isPositiveInteger$2(k)) {
           throw new TypeError('Positive integer value expected in function combinations');
         }
         if (k.gt(n)) {
           throw new TypeError('k must be less than n in function combinations');
         }
         result = one;
         if (k.lt(nMinusk)) {
           for (i = one; i.lte(nMinusk); i = i.plus(one)) {
             result = result.times(k.plus(i)).dividedBy(i);
           }
         } else {
           for (i = one; i.lte(k); i = i.plus(one)) {
             result = result.times(nMinusk.plus(i)).dividedBy(i);
           }
         }
         return result;
       }

       // TODO: implement support for collection in combinations
     });
   });

   /**
    * Test whether BigNumber n is a positive integer
    * @param {BigNumber} n
    * @returns {boolean} isPositiveInteger
    */
   function isPositiveInteger$2(n) {
     return n.isInteger() && n.gte(0);
   }

   var name$J = 'combinationsWithRep';
   var dependencies$J = ['typed'];
   var createCombinationsWithRep = /* #__PURE__ */factory(name$J, dependencies$J, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Compute the number of ways of picking `k` unordered outcomes from `n`
      * possibilities, allowing individual outcomes to be repeated more than once.
      *
      * CombinationsWithRep only takes integer arguments.
      * The following condition must be enforced: k <= n + k -1.
      *
      * Syntax:
      *
      *     math.combinationsWithRep(n, k)
      *
      * Examples:
      *
      *    math.combinationsWithRep(7, 5) // returns 462
      *
      * See also:
      *
      *    combinations, permutations, factorial
      *
      * @param {number | BigNumber} n    Total number of objects in the set
      * @param {number | BigNumber} k    Number of objects in the subset
      * @return {number | BigNumber}     Number of possible combinations with replacement.
      */
     return typed(name$J, {
       'number, number': function numberNumber(n, k) {
         if (!isInteger$1(n) || n < 0) {
           throw new TypeError('Positive integer value expected in function combinationsWithRep');
         }
         if (!isInteger$1(k) || k < 0) {
           throw new TypeError('Positive integer value expected in function combinationsWithRep');
         }
         if (n < 1) {
           throw new TypeError('k must be less than or equal to n + k - 1');
         }
         if (k < n - 1) {
           var _prodrange = product(n, n + k - 1);
           return _prodrange / product(1, k);
         }
         var prodrange = product(k + 1, n + k - 1);
         return prodrange / product(1, n - 1);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
         var BigNumber = n.constructor;
         var result, i;
         var one = new BigNumber(1);
         var nMinusOne = n.minus(one);
         if (!isPositiveInteger$1(n) || !isPositiveInteger$1(k)) {
           throw new TypeError('Positive integer value expected in function combinationsWithRep');
         }
         if (n.lt(one)) {
           throw new TypeError('k must be less than or equal to n + k - 1 in function combinationsWithRep');
         }
         result = one;
         if (k.lt(nMinusOne)) {
           for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
             result = result.times(k.plus(i)).dividedBy(i);
           }
         } else {
           for (i = one; i.lte(k); i = i.plus(one)) {
             result = result.times(nMinusOne.plus(i)).dividedBy(i);
           }
         }
         return result;
       }
     });
   });

   /**
    * Test whether BigNumber n is a positive integer
    * @param {BigNumber} n
    * @returns {boolean} isPositiveInteger
    */
   function isPositiveInteger$1(n) {
     return n.isInteger() && n.gte(0);
   }

   var name$I = 'gamma';
   var dependencies$I = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];
   var createGamma = /* #__PURE__ */factory(name$I, dependencies$I, _ref => {
     var {
       typed,
       config,
       multiplyScalar,
       pow,
       BigNumber: _BigNumber,
       Complex
     } = _ref;
     /**
      * Compute the gamma function of a value using Lanczos approximation for
      * small values, and an extended Stirling approximation for large values.
      *
      * To avoid confusion with the matrix Gamma function, this function does
      * not apply to matrices.
      *
      * Syntax:
      *
      *    math.gamma(n)
      *
      * Examples:
      *
      *    math.gamma(5)       // returns 24
      *    math.gamma(-0.5)    // returns -3.5449077018110335
      *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i
      *
      * See also:
      *
      *    combinations, factorial, permutations
      *
      * @param {number | BigNumber | Complex} n   A real or complex number
      * @return {number | BigNumber | Complex}    The gamma of `n`
      */

     function gammaComplex(n) {
       if (n.im === 0) {
         return gammaNumber(n.re);
       }

       // Lanczos approximation doesn't work well with real part lower than 0.5
       // So reflection formula is required
       if (n.re < 0.5) {
         // Euler's reflection formula
         // gamma(1-z) * gamma(z) = PI / sin(PI * z)
         // real part of Z should not be integer [sin(PI) == 0 -> 1/0 - undefined]
         // thanks to imperfect sin implementation sin(PI * n) != 0
         // we can safely use it anyway
         var _t = new Complex(1 - n.re, -n.im);
         var r = new Complex(Math.PI * n.re, Math.PI * n.im);
         return new Complex(Math.PI).div(r.sin()).div(gammaComplex(_t));
       }

       // Lanczos approximation
       // z -= 1
       n = new Complex(n.re - 1, n.im);

       // x = gammaPval[0]
       var x = new Complex(gammaP[0], 0);
       // for (i, gammaPval) in enumerate(gammaP):
       for (var i = 1; i < gammaP.length; ++i) {
         // x += gammaPval / (z + i)
         var gammaPval = new Complex(gammaP[i], 0);
         x = x.add(gammaPval.div(n.add(i)));
       }
       // t = z + gammaG + 0.5
       var t = new Complex(n.re + gammaG + 0.5, n.im);

       // y = sqrt(2 * pi) * t ** (z + 0.5) * exp(-t) * x
       var twoPiSqrt = Math.sqrt(2 * Math.PI);
       var tpow = t.pow(n.add(0.5));
       var expt = t.neg().exp();

       // y = [x] * [sqrt(2 * pi)] * [t ** (z + 0.5)] * [exp(-t)]
       return x.mul(twoPiSqrt).mul(tpow).mul(expt);
     }
     return typed(name$I, {
       number: gammaNumber,
       Complex: gammaComplex,
       BigNumber: function BigNumber(n) {
         if (n.isInteger()) {
           return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
         }
         if (!n.isFinite()) {
           return new _BigNumber(n.isNegative() ? NaN : Infinity);
         }
         throw new Error('Integer BigNumber expected');
       }
     });

     /**
      * Calculate factorial for a BigNumber
      * @param {BigNumber} n
      * @returns {BigNumber} Returns the factorial of n
      */
     function bigFactorial(n) {
       if (n < 8) {
         return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
       }
       var precision = config.precision + (Math.log(n.toNumber()) | 0);
       var Big = _BigNumber.clone({
         precision
       });
       if (n % 2 === 1) {
         return n.times(bigFactorial(new _BigNumber(n - 1)));
       }
       var p = n;
       var prod = new Big(n);
       var sum = n.toNumber();
       while (p > 2) {
         p -= 2;
         sum += p;
         prod = prod.times(sum);
       }
       return new _BigNumber(prod.toPrecision(_BigNumber.precision));
     }
   });

   /* eslint-disable no-loss-of-precision */

   var name$H = 'lgamma';
   var dependencies$H = ['Complex', 'typed'];
   var createLgamma = /* #__PURE__ */factory(name$H, dependencies$H, _ref => {
     var {
       Complex,
       typed
     } = _ref;
     // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get
     // sufficient accuracy.
     //
     // These two values are copied from Scipy implementation:
     // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37
     var SMALL_RE = 7;
     var SMALL_IM = 7;

     /**
      * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].
      *
      * If you cannot access the paper, can also get these values from the formula in [2].
      *
      *    1 /     12 = 0.00833333333333333333333333333333
      *    1 /    360 = 0.00277777777777777777777777777778
      * ...
      * 3617 / 133400 = 0.02955065359477124183006535947712
      */
     var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];

     /**
      * Logarithm of the gamma function for real, positive numbers and complex numbers,
      * using Lanczos approximation for numbers and Stirling series for complex numbers.
      *
      * Syntax:
      *
      *    math.lgamma(n)
      *
      * Examples:
      *
      *    math.lgamma(5)       // returns 3.178053830347945
      *    math.lgamma(0)       // returns Infinity
      *    math.lgamma(-0.5)    // returns NaN
      *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i
      *
      * See also:
      *
      *    gamma
      *
      * @param {number | Complex} n   A real or complex number
      * @return {number | Complex}    The log gamma of `n`
      */
     return typed(name$H, {
       number: lgammaNumber,
       Complex: lgammaComplex,
       BigNumber: function BigNumber() {
         throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
       }
     });
     function lgammaComplex(n) {
       var TWOPI = 6.2831853071795864769252842; // 2*pi
       var LOGPI = 1.1447298858494001741434262; // log(pi)

       var REFLECTION = 0.1;
       if (n.isNaN()) {
         return new Complex(NaN, NaN);
       } else if (n.im === 0) {
         return new Complex(lgammaNumber(n.re), 0);
       } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
         return lgammaStirling(n);
       } else if (n.re <= REFLECTION) {
         // Reflection formula. see Proposition 3.1 in [1]
         var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
         var a = n.mul(Math.PI).sin().log();
         var b = lgammaComplex(new Complex(1 - n.re, -n.im));
         return new Complex(LOGPI, tmp).sub(a).sub(b);
       } else if (n.im >= 0) {
         return lgammaRecurrence(n);
       } else {
         return lgammaRecurrence(n.conjugate()).conjugate();
       }
     }
     function lgammaStirling(z) {
       // formula ref in [2]
       // computation ref:
       // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101

       // left part

       // x (log(x) - 1) + 1/2 (log(2PI) - log(x))
       // => (x - 0.5) * log(x) - x + log(2PI) / 2
       var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);

       // right part

       var rz = new Complex(1, 0).div(z);
       var rzz = rz.div(z);
       var a = coeffs[0];
       var b = coeffs[1];
       var r = 2 * rzz.re;
       var s = rzz.re * rzz.re + rzz.im * rzz.im;
       for (var i = 2; i < 8; i++) {
         var tmp = b;
         b = -s * a + coeffs[i];
         a = r * a + tmp;
       }
       var rightPart = rz.mul(rzz.mul(a).add(b));

       // plus left and right

       return leftPart.add(rightPart);
     }
     function lgammaRecurrence(z) {
       // computation ref:
       // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78

       var signflips = 0;
       var sb = 0;
       var shiftprod = z;
       z = z.add(1);
       while (z.re <= SMALL_RE) {
         shiftprod = shiftprod.mul(z);
         var nsb = shiftprod.im < 0 ? 1 : 0;
         if (nsb !== 0 && sb === 0) signflips++;
         sb = nsb;
         z = z.add(1);
       }
       return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));
     }
   });

   var name$G = 'factorial';
   var dependencies$G = ['typed', 'gamma'];
   var createFactorial = /* #__PURE__ */factory(name$G, dependencies$G, _ref => {
     var {
       typed,
       gamma
     } = _ref;
     /**
      * Compute the factorial of a value
      *
      * Factorial only supports an integer value as argument.
      * For matrices, the function is evaluated element wise.
      *
      * Syntax:
      *
      *    math.factorial(n)
      *
      * Examples:
      *
      *    math.factorial(5)    // returns 120
      *    math.factorial(3)    // returns 6
      *
      * See also:
      *
      *    combinations, combinationsWithRep, gamma, permutations
      *
      * @param {number | BigNumber | Array | Matrix} n   An integer number
      * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
      */
     return typed(name$G, {
       number: function number(n) {
         if (n < 0) {
           throw new Error('Value must be non-negative');
         }
         return gamma(n + 1);
       },
       BigNumber: function BigNumber(n) {
         if (n.isNegative()) {
           throw new Error('Value must be non-negative');
         }
         return gamma(n.plus(1));
       },
       'Array | Matrix': typed.referToSelf(self => n => deepMap(n, self))
     });
   });

   var name$F = 'kldivergence';
   var dependencies$F = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'map', 'dotDivide', 'log', 'isNumeric'];
   var createKldivergence = /* #__PURE__ */factory(name$F, dependencies$F, _ref => {
     var {
       typed,
       matrix,
       divide,
       sum,
       multiply,
       map,
       dotDivide,
       log,
       isNumeric
     } = _ref;
     /**
        * Calculate the Kullback-Leibler (KL) divergence  between two distributions
        *
        * Syntax:
        *
        *     math.kldivergence(x, y)
        *
        * Examples:
        *
        *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153
        *
        *
        * @param  {Array | Matrix} q    First vector
        * @param  {Array | Matrix} p    Second vector
        * @return {number}              Returns distance between q and p
        */
     return typed(name$F, {
       'Array, Array': function ArrayArray(q, p) {
         return _kldiv(matrix(q), matrix(p));
       },
       'Matrix, Array': function MatrixArray(q, p) {
         return _kldiv(q, matrix(p));
       },
       'Array, Matrix': function ArrayMatrix(q, p) {
         return _kldiv(matrix(q), p);
       },
       'Matrix, Matrix': function MatrixMatrix(q, p) {
         return _kldiv(q, p);
       }
     });
     function _kldiv(q, p) {
       var plength = p.size().length;
       var qlength = q.size().length;
       if (plength > 1) {
         throw new Error('first object must be one dimensional');
       }
       if (qlength > 1) {
         throw new Error('second object must be one dimensional');
       }
       if (plength !== qlength) {
         throw new Error('Length of two vectors must be equal');
       }

       // Before calculation, apply normalization
       var sumq = sum(q);
       if (sumq === 0) {
         throw new Error('Sum of elements in first object must be non zero');
       }
       var sump = sum(p);
       if (sump === 0) {
         throw new Error('Sum of elements in second object must be non zero');
       }
       var qnorm = divide(q, sum(q));
       var pnorm = divide(p, sum(p));
       var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), x => log(x))));
       if (isNumeric(result)) {
         return result;
       } else {
         return Number.NaN;
       }
     }
   });

   var name$E = 'multinomial';
   var dependencies$E = ['typed', 'add', 'divide', 'multiply', 'factorial', 'isInteger', 'isPositive'];
   var createMultinomial = /* #__PURE__ */factory(name$E, dependencies$E, _ref => {
     var {
       typed,
       add,
       divide,
       multiply,
       factorial,
       isInteger,
       isPositive
     } = _ref;
     /**
      * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
      *
      * multinomial takes one array of integers as an argument.
      * The following condition must be enforced: every ai <= 0
      *
      * Syntax:
      *
      *     math.multinomial(a) // a is an array type
      *
      * Examples:
      *
      *    math.multinomial([1,2,1]) // returns 12
      *
      * See also:
      *
      *    combinations, factorial
      *
      * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
      * @return {Number | BigNumber}         Multinomial coefficient.
      */
     return typed(name$E, {
       'Array | Matrix': function ArrayMatrix(a) {
         var sum = 0;
         var denom = 1;
         deepForEach(a, function (ai) {
           if (!isInteger(ai) || !isPositive(ai)) {
             throw new TypeError('Positive integer value expected in function multinomial');
           }
           sum = add(sum, ai);
           denom = multiply(denom, factorial(ai));
         });
         return divide(factorial(sum), denom);
       }
     });
   });

   var name$D = 'permutations';
   var dependencies$D = ['typed', 'factorial'];
   var createPermutations = /* #__PURE__ */factory(name$D, dependencies$D, _ref => {
     var {
       typed,
       factorial
     } = _ref;
     /**
      * Compute the number of ways of obtaining an ordered subset of `k` elements
      * from a set of `n` elements.
      *
      * Permutations only takes integer arguments.
      * The following condition must be enforced: k <= n.
      *
      * Syntax:
      *
      *     math.permutations(n)
      *     math.permutations(n, k)
      *
      * Examples:
      *
      *    math.permutations(5)     // 120
      *    math.permutations(5, 3)  // 60
      *
      * See also:
      *
      *    combinations, combinationsWithRep, factorial
      *
      * @param {number | BigNumber} n   The number of objects in total
      * @param {number | BigNumber} [k] The number of objects in the subset
      * @return {number | BigNumber}    The number of permutations
      */
     return typed(name$D, {
       'number | BigNumber': factorial,
       'number, number': function numberNumber(n, k) {
         if (!isInteger$1(n) || n < 0) {
           throw new TypeError('Positive integer value expected in function permutations');
         }
         if (!isInteger$1(k) || k < 0) {
           throw new TypeError('Positive integer value expected in function permutations');
         }
         if (k > n) {
           throw new TypeError('second argument k must be less than or equal to first argument n');
         }
         // Permute n objects, k at a time
         return product(n - k + 1, n);
       },
       'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
         var result, i;
         if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
           throw new TypeError('Positive integer value expected in function permutations');
         }
         if (k.gt(n)) {
           throw new TypeError('second argument k must be less than or equal to first argument n');
         }
         var one = n.mul(0).add(1);
         result = one;
         for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
           result = result.times(i);
         }
         return result;
       }

       // TODO: implement support for collection in permutations
     });
   });

   /**
    * Test whether BigNumber n is a positive integer
    * @param {BigNumber} n
    * @returns {boolean} isPositiveInteger
    */
   function isPositiveInteger(n) {
     return n.isInteger() && n.gte(0);
   }

   var alea$1 = {exports: {}};

   alea$1.exports;

   (function (module) {
   	// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
   	// http://baagoe.com/en/RandomMusings/javascript/
   	// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
   	// Original work is under MIT license -

   	// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
   	//
   	// Permission is hereby granted, free of charge, to any person obtaining a copy
   	// of this software and associated documentation files (the "Software"), to deal
   	// in the Software without restriction, including without limitation the rights
   	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   	// copies of the Software, and to permit persons to whom the Software is
   	// furnished to do so, subject to the following conditions:
   	//
   	// The above copyright notice and this permission notice shall be included in
   	// all copies or substantial portions of the Software.
   	//
   	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   	// THE SOFTWARE.



   	(function(global, module, define) {

   	function Alea(seed) {
   	  var me = this, mash = Mash();

   	  me.next = function() {
   	    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
   	    me.s0 = me.s1;
   	    me.s1 = me.s2;
   	    return me.s2 = t - (me.c = t | 0);
   	  };

   	  // Apply the seeding algorithm from Baagoe.
   	  me.c = 1;
   	  me.s0 = mash(' ');
   	  me.s1 = mash(' ');
   	  me.s2 = mash(' ');
   	  me.s0 -= mash(seed);
   	  if (me.s0 < 0) { me.s0 += 1; }
   	  me.s1 -= mash(seed);
   	  if (me.s1 < 0) { me.s1 += 1; }
   	  me.s2 -= mash(seed);
   	  if (me.s2 < 0) { me.s2 += 1; }
   	  mash = null;
   	}

   	function copy(f, t) {
   	  t.c = f.c;
   	  t.s0 = f.s0;
   	  t.s1 = f.s1;
   	  t.s2 = f.s2;
   	  return t;
   	}

   	function impl(seed, opts) {
   	  var xg = new Alea(seed),
   	      state = opts && opts.state,
   	      prng = xg.next;
   	  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
   	  prng.double = function() {
   	    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
   	  };
   	  prng.quick = prng;
   	  if (state) {
   	    if (typeof(state) == 'object') copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	function Mash() {
   	  var n = 0xefc8249d;

   	  var mash = function(data) {
   	    data = String(data);
   	    for (var i = 0; i < data.length; i++) {
   	      n += data.charCodeAt(i);
   	      var h = 0.02519603282416938 * n;
   	      n = h >>> 0;
   	      h -= n;
   	      h *= n;
   	      n = h >>> 0;
   	      h -= n;
   	      n += h * 0x100000000; // 2^32
   	    }
   	    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
   	  };

   	  return mash;
   	}


   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.alea = impl;
   	}

   	})(
   	  commonjsGlobal,
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (alea$1));

   var aleaExports = alea$1.exports;

   var xor128$1 = {exports: {}};

   xor128$1.exports;

   (function (module) {
   	// A Javascript implementaion of the "xor128" prng algorithm by
   	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

   	(function(global, module, define) {

   	function XorGen(seed) {
   	  var me = this, strseed = '';

   	  me.x = 0;
   	  me.y = 0;
   	  me.z = 0;
   	  me.w = 0;

   	  // Set up generator function.
   	  me.next = function() {
   	    var t = me.x ^ (me.x << 11);
   	    me.x = me.y;
   	    me.y = me.z;
   	    me.z = me.w;
   	    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
   	  };

   	  if (seed === (seed | 0)) {
   	    // Integer seed.
   	    me.x = seed;
   	  } else {
   	    // String seed.
   	    strseed += seed;
   	  }

   	  // Mix in string seed, then discard an initial batch of 64 values.
   	  for (var k = 0; k < strseed.length + 64; k++) {
   	    me.x ^= strseed.charCodeAt(k) | 0;
   	    me.next();
   	  }
   	}

   	function copy(f, t) {
   	  t.x = f.x;
   	  t.y = f.y;
   	  t.z = f.z;
   	  t.w = f.w;
   	  return t;
   	}

   	function impl(seed, opts) {
   	  var xg = new XorGen(seed),
   	      state = opts && opts.state,
   	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
   	  prng.double = function() {
   	    do {
   	      var top = xg.next() >>> 11,
   	          bot = (xg.next() >>> 0) / 0x100000000,
   	          result = (top + bot) / (1 << 21);
   	    } while (result === 0);
   	    return result;
   	  };
   	  prng.int32 = xg.next;
   	  prng.quick = prng;
   	  if (state) {
   	    if (typeof(state) == 'object') copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.xor128 = impl;
   	}

   	})(
   	  commonjsGlobal,
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (xor128$1));

   var xor128Exports = xor128$1.exports;

   var xorwow$1 = {exports: {}};

   xorwow$1.exports;

   (function (module) {
   	// A Javascript implementaion of the "xorwow" prng algorithm by
   	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

   	(function(global, module, define) {

   	function XorGen(seed) {
   	  var me = this, strseed = '';

   	  // Set up generator function.
   	  me.next = function() {
   	    var t = (me.x ^ (me.x >>> 2));
   	    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
   	    return (me.d = (me.d + 362437 | 0)) +
   	       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
   	  };

   	  me.x = 0;
   	  me.y = 0;
   	  me.z = 0;
   	  me.w = 0;
   	  me.v = 0;

   	  if (seed === (seed | 0)) {
   	    // Integer seed.
   	    me.x = seed;
   	  } else {
   	    // String seed.
   	    strseed += seed;
   	  }

   	  // Mix in string seed, then discard an initial batch of 64 values.
   	  for (var k = 0; k < strseed.length + 64; k++) {
   	    me.x ^= strseed.charCodeAt(k) | 0;
   	    if (k == strseed.length) {
   	      me.d = me.x << 10 ^ me.x >>> 4;
   	    }
   	    me.next();
   	  }
   	}

   	function copy(f, t) {
   	  t.x = f.x;
   	  t.y = f.y;
   	  t.z = f.z;
   	  t.w = f.w;
   	  t.v = f.v;
   	  t.d = f.d;
   	  return t;
   	}

   	function impl(seed, opts) {
   	  var xg = new XorGen(seed),
   	      state = opts && opts.state,
   	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
   	  prng.double = function() {
   	    do {
   	      var top = xg.next() >>> 11,
   	          bot = (xg.next() >>> 0) / 0x100000000,
   	          result = (top + bot) / (1 << 21);
   	    } while (result === 0);
   	    return result;
   	  };
   	  prng.int32 = xg.next;
   	  prng.quick = prng;
   	  if (state) {
   	    if (typeof(state) == 'object') copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.xorwow = impl;
   	}

   	})(
   	  commonjsGlobal,
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (xorwow$1));

   var xorwowExports = xorwow$1.exports;

   var xorshift7$1 = {exports: {}};

   xorshift7$1.exports;

   (function (module) {
   	// A Javascript implementaion of the "xorshift7" algorithm by
   	// François Panneton and Pierre L'ecuyer:
   	// "On the Xorgshift Random Number Generators"
   	// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

   	(function(global, module, define) {

   	function XorGen(seed) {
   	  var me = this;

   	  // Set up generator function.
   	  me.next = function() {
   	    // Update xor generator.
   	    var X = me.x, i = me.i, t, v;
   	    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
   	    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
   	    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
   	    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
   	    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
   	    X[i] = v;
   	    me.i = (i + 1) & 7;
   	    return v;
   	  };

   	  function init(me, seed) {
   	    var j, X = [];

   	    if (seed === (seed | 0)) {
   	      // Seed state array using a 32-bit integer.
   	      X[0] = seed;
   	    } else {
   	      // Seed state using a string.
   	      seed = '' + seed;
   	      for (j = 0; j < seed.length; ++j) {
   	        X[j & 7] = (X[j & 7] << 15) ^
   	            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
   	      }
   	    }
   	    // Enforce an array length of 8, not all zeroes.
   	    while (X.length < 8) X.push(0);
   	    for (j = 0; j < 8 && X[j] === 0; ++j);
   	    if (j == 8) X[7] = -1; else X[j];

   	    me.x = X;
   	    me.i = 0;

   	    // Discard an initial 256 values.
   	    for (j = 256; j > 0; --j) {
   	      me.next();
   	    }
   	  }

   	  init(me, seed);
   	}

   	function copy(f, t) {
   	  t.x = f.x.slice();
   	  t.i = f.i;
   	  return t;
   	}

   	function impl(seed, opts) {
   	  if (seed == null) seed = +(new Date);
   	  var xg = new XorGen(seed),
   	      state = opts && opts.state,
   	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
   	  prng.double = function() {
   	    do {
   	      var top = xg.next() >>> 11,
   	          bot = (xg.next() >>> 0) / 0x100000000,
   	          result = (top + bot) / (1 << 21);
   	    } while (result === 0);
   	    return result;
   	  };
   	  prng.int32 = xg.next;
   	  prng.quick = prng;
   	  if (state) {
   	    if (state.x) copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.xorshift7 = impl;
   	}

   	})(
   	  commonjsGlobal,
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (xorshift7$1));

   var xorshift7Exports = xorshift7$1.exports;

   var xor4096$1 = {exports: {}};

   xor4096$1.exports;

   (function (module) {
   	// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
   	//
   	// This fast non-cryptographic random number generator is designed for
   	// use in Monte-Carlo algorithms. It combines a long-period xorshift
   	// generator with a Weyl generator, and it passes all common batteries
   	// of stasticial tests for randomness while consuming only a few nanoseconds
   	// for each prng generated.  For background on the generator, see Brent's
   	// paper: "Some long-period random number generators using shifts and xors."
   	// http://arxiv.org/pdf/1004.3115v1.pdf
   	//
   	// Usage:
   	//
   	// var xor4096 = require('xor4096');
   	// random = xor4096(1);                        // Seed with int32 or string.
   	// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
   	// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
   	//
   	// For nonzero numeric keys, this impelementation provides a sequence
   	// identical to that by Brent's xorgens 3 implementaion in C.  This
   	// implementation also provides for initalizing the generator with
   	// string seeds, or for saving and restoring the state of the generator.
   	//
   	// On Chrome, this prng benchmarks about 2.1 times slower than
   	// Javascript's built-in Math.random().

   	(function(global, module, define) {

   	function XorGen(seed) {
   	  var me = this;

   	  // Set up generator function.
   	  me.next = function() {
   	    var w = me.w,
   	        X = me.X, i = me.i, t, v;
   	    // Update Weyl generator.
   	    me.w = w = (w + 0x61c88647) | 0;
   	    // Update xor generator.
   	    v = X[(i + 34) & 127];
   	    t = X[i = ((i + 1) & 127)];
   	    v ^= v << 13;
   	    t ^= t << 17;
   	    v ^= v >>> 15;
   	    t ^= t >>> 12;
   	    // Update Xor generator array state.
   	    v = X[i] = v ^ t;
   	    me.i = i;
   	    // Result is the combination.
   	    return (v + (w ^ (w >>> 16))) | 0;
   	  };

   	  function init(me, seed) {
   	    var t, v, i, j, w, X = [], limit = 128;
   	    if (seed === (seed | 0)) {
   	      // Numeric seeds initialize v, which is used to generates X.
   	      v = seed;
   	      seed = null;
   	    } else {
   	      // String seeds are mixed into v and X one character at a time.
   	      seed = seed + '\0';
   	      v = 0;
   	      limit = Math.max(limit, seed.length);
   	    }
   	    // Initialize circular array and weyl value.
   	    for (i = 0, j = -32; j < limit; ++j) {
   	      // Put the unicode characters into the array, and shuffle them.
   	      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
   	      // After 32 shuffles, take v as the starting w value.
   	      if (j === 0) w = v;
   	      v ^= v << 10;
   	      v ^= v >>> 15;
   	      v ^= v << 4;
   	      v ^= v >>> 13;
   	      if (j >= 0) {
   	        w = (w + 0x61c88647) | 0;     // Weyl.
   	        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
   	        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
   	      }
   	    }
   	    // We have detected all zeroes; make the key nonzero.
   	    if (i >= 128) {
   	      X[(seed && seed.length || 0) & 127] = -1;
   	    }
   	    // Run the generator 512 times to further mix the state before using it.
   	    // Factoring this as a function slows the main generator, so it is just
   	    // unrolled here.  The weyl generator is not advanced while warming up.
   	    i = 127;
   	    for (j = 4 * 128; j > 0; --j) {
   	      v = X[(i + 34) & 127];
   	      t = X[i = ((i + 1) & 127)];
   	      v ^= v << 13;
   	      t ^= t << 17;
   	      v ^= v >>> 15;
   	      t ^= t >>> 12;
   	      X[i] = v ^ t;
   	    }
   	    // Storing state as object members is faster than using closure variables.
   	    me.w = w;
   	    me.X = X;
   	    me.i = i;
   	  }

   	  init(me, seed);
   	}

   	function copy(f, t) {
   	  t.i = f.i;
   	  t.w = f.w;
   	  t.X = f.X.slice();
   	  return t;
   	}
   	function impl(seed, opts) {
   	  if (seed == null) seed = +(new Date);
   	  var xg = new XorGen(seed),
   	      state = opts && opts.state,
   	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
   	  prng.double = function() {
   	    do {
   	      var top = xg.next() >>> 11,
   	          bot = (xg.next() >>> 0) / 0x100000000,
   	          result = (top + bot) / (1 << 21);
   	    } while (result === 0);
   	    return result;
   	  };
   	  prng.int32 = xg.next;
   	  prng.quick = prng;
   	  if (state) {
   	    if (state.X) copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.xor4096 = impl;
   	}

   	})(
   	  commonjsGlobal,                                     // window object or global
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (xor4096$1));

   var xor4096Exports = xor4096$1.exports;

   var tychei$1 = {exports: {}};

   tychei$1.exports;

   (function (module) {
   	// A Javascript implementaion of the "Tyche-i" prng algorithm by
   	// Samuel Neves and Filipe Araujo.
   	// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

   	(function(global, module, define) {

   	function XorGen(seed) {
   	  var me = this, strseed = '';

   	  // Set up generator function.
   	  me.next = function() {
   	    var b = me.b, c = me.c, d = me.d, a = me.a;
   	    b = (b << 25) ^ (b >>> 7) ^ c;
   	    c = (c - d) | 0;
   	    d = (d << 24) ^ (d >>> 8) ^ a;
   	    a = (a - b) | 0;
   	    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
   	    me.c = c = (c - d) | 0;
   	    me.d = (d << 16) ^ (c >>> 16) ^ a;
   	    return me.a = (a - b) | 0;
   	  };

   	  /* The following is non-inverted tyche, which has better internal
   	   * bit diffusion, but which is about 25% slower than tyche-i in JS.
   	  me.next = function() {
   	    var a = me.a, b = me.b, c = me.c, d = me.d;
   	    a = (me.a + me.b | 0) >>> 0;
   	    d = me.d ^ a; d = d << 16 ^ d >>> 16;
   	    c = me.c + d | 0;
   	    b = me.b ^ c; b = b << 12 ^ d >>> 20;
   	    me.a = a = a + b | 0;
   	    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
   	    me.c = c = c + d | 0;
   	    b = b ^ c;
   	    return me.b = (b << 7 ^ b >>> 25);
   	  }
   	  */

   	  me.a = 0;
   	  me.b = 0;
   	  me.c = 2654435769 | 0;
   	  me.d = 1367130551;

   	  if (seed === Math.floor(seed)) {
   	    // Integer seed.
   	    me.a = (seed / 0x100000000) | 0;
   	    me.b = seed | 0;
   	  } else {
   	    // String seed.
   	    strseed += seed;
   	  }

   	  // Mix in string seed, then discard an initial batch of 64 values.
   	  for (var k = 0; k < strseed.length + 20; k++) {
   	    me.b ^= strseed.charCodeAt(k) | 0;
   	    me.next();
   	  }
   	}

   	function copy(f, t) {
   	  t.a = f.a;
   	  t.b = f.b;
   	  t.c = f.c;
   	  t.d = f.d;
   	  return t;
   	}
   	function impl(seed, opts) {
   	  var xg = new XorGen(seed),
   	      state = opts && opts.state,
   	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
   	  prng.double = function() {
   	    do {
   	      var top = xg.next() >>> 11,
   	          bot = (xg.next() >>> 0) / 0x100000000,
   	          result = (top + bot) / (1 << 21);
   	    } while (result === 0);
   	    return result;
   	  };
   	  prng.int32 = xg.next;
   	  prng.quick = prng;
   	  if (state) {
   	    if (typeof(state) == 'object') copy(state, xg);
   	    prng.state = function() { return copy(xg, {}); };
   	  }
   	  return prng;
   	}

   	if (module && module.exports) {
   	  module.exports = impl;
   	} else if (define && define.amd) {
   	  define(function() { return impl; });
   	} else {
   	  this.tychei = impl;
   	}

   	})(
   	  commonjsGlobal,
   	  module,    // present in node.js
   	  (typeof undefined) == 'function'    // present with an AMD loader
   	); 
   } (tychei$1));

   var tycheiExports = tychei$1.exports;

   var seedrandom$2 = {exports: {}};

   var _nodeResolve_empty = {};

   var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      default: _nodeResolve_empty
   });

   var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

   /*
   Copyright 2019 David Bau.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   */

   (function (module) {
   	(function (global, pool, math) {
   	//
   	// The following constants are related to IEEE 754 limits.
   	//

   	var width = 256,        // each RC4 output is 0 <= x < 256
   	    chunks = 6,         // at least six RC4 outputs for each double
   	    digits = 52,        // there are 52 significant digits in a double
   	    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
   	    startdenom = math.pow(width, chunks),
   	    significance = math.pow(2, digits),
   	    overflow = significance * 2,
   	    mask = width - 1,
   	    nodecrypto;         // node.js crypto module, initialized at the bottom.

   	//
   	// seedrandom()
   	// This is the seedrandom function described above.
   	//
   	function seedrandom(seed, options, callback) {
   	  var key = [];
   	  options = (options == true) ? { entropy: true } : (options || {});

   	  // Flatten the seed string or build one from local entropy if needed.
   	  var shortseed = mixkey(flatten(
   	    options.entropy ? [seed, tostring(pool)] :
   	    (seed == null) ? autoseed() : seed, 3), key);

   	  // Use the seed to initialize an ARC4 generator.
   	  var arc4 = new ARC4(key);

   	  // This function returns a random double in [0, 1) that contains
   	  // randomness in every bit of the mantissa of the IEEE 754 value.
   	  var prng = function() {
   	    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
   	        d = startdenom,                 //   and denominator d = 2 ^ 48.
   	        x = 0;                          //   and no 'extra last byte'.
   	    while (n < significance) {          // Fill up all significant digits by
   	      n = (n + x) * width;              //   shifting numerator and
   	      d *= width;                       //   denominator and generating a
   	      x = arc4.g(1);                    //   new least-significant-byte.
   	    }
   	    while (n >= overflow) {             // To avoid rounding up, before adding
   	      n /= 2;                           //   last byte, shift everything
   	      d /= 2;                           //   right using integer math until
   	      x >>>= 1;                         //   we have exactly the desired bits.
   	    }
   	    return (n + x) / d;                 // Form the number within [0, 1).
   	  };

   	  prng.int32 = function() { return arc4.g(4) | 0; };
   	  prng.quick = function() { return arc4.g(4) / 0x100000000; };
   	  prng.double = prng;

   	  // Mix the randomness into accumulated entropy.
   	  mixkey(tostring(arc4.S), pool);

   	  // Calling convention: what to return as a function of prng, seed, is_math.
   	  return (options.pass || callback ||
   	      function(prng, seed, is_math_call, state) {
   	        if (state) {
   	          // Load the arc4 state from the given state if it has an S array.
   	          if (state.S) { copy(state, arc4); }
   	          // Only provide the .state method if requested via options.state.
   	          prng.state = function() { return copy(arc4, {}); };
   	        }

   	        // If called as a method of Math (Math.seedrandom()), mutate
   	        // Math.random because that is how seedrandom.js has worked since v1.0.
   	        if (is_math_call) { math[rngname] = prng; return seed; }

   	        // Otherwise, it is a newer calling convention, so return the
   	        // prng directly.
   	        else return prng;
   	      })(
   	  prng,
   	  shortseed,
   	  'global' in options ? options.global : (this == math),
   	  options.state);
   	}

   	//
   	// ARC4
   	//
   	// An ARC4 implementation.  The constructor takes a key in the form of
   	// an array of at most (width) integers that should be 0 <= x < (width).
   	//
   	// The g(count) method returns a pseudorandom integer that concatenates
   	// the next (count) outputs from ARC4.  Its return value is a number x
   	// that is in the range 0 <= x < (width ^ count).
   	//
   	function ARC4(key) {
   	  var t, keylen = key.length,
   	      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

   	  // The empty key [] is treated as [0].
   	  if (!keylen) { key = [keylen++]; }

   	  // Set up S using the standard key scheduling algorithm.
   	  while (i < width) {
   	    s[i] = i++;
   	  }
   	  for (i = 0; i < width; i++) {
   	    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
   	    s[j] = t;
   	  }

   	  // The "g" method returns the next (count) outputs as one number.
   	  (me.g = function(count) {
   	    // Using instance members instead of closure state nearly doubles speed.
   	    var t, r = 0,
   	        i = me.i, j = me.j, s = me.S;
   	    while (count--) {
   	      t = s[i = mask & (i + 1)];
   	      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
   	    }
   	    me.i = i; me.j = j;
   	    return r;
   	    // For robust unpredictability, the function call below automatically
   	    // discards an initial batch of values.  This is called RC4-drop[256].
   	    // See http://google.com/search?q=rsa+fluhrer+response&btnI
   	  })(width);
   	}

   	//
   	// copy()
   	// Copies internal state of ARC4 to or from a plain object.
   	//
   	function copy(f, t) {
   	  t.i = f.i;
   	  t.j = f.j;
   	  t.S = f.S.slice();
   	  return t;
   	}
   	//
   	// flatten()
   	// Converts an object tree to nested arrays of strings.
   	//
   	function flatten(obj, depth) {
   	  var result = [], typ = (typeof obj), prop;
   	  if (depth && typ == 'object') {
   	    for (prop in obj) {
   	      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
   	    }
   	  }
   	  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
   	}

   	//
   	// mixkey()
   	// Mixes a string seed into a key that is an array of integers, and
   	// returns a shortened string seed that is equivalent to the result key.
   	//
   	function mixkey(seed, key) {
   	  var stringseed = seed + '', smear, j = 0;
   	  while (j < stringseed.length) {
   	    key[mask & j] =
   	      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
   	  }
   	  return tostring(key);
   	}

   	//
   	// autoseed()
   	// Returns an object for autoseeding, using window.crypto and Node crypto
   	// module if available.
   	//
   	function autoseed() {
   	  try {
   	    var out;
   	    if (nodecrypto && (out = nodecrypto.randomBytes)) {
   	      // The use of 'out' to remember randomBytes makes tight minified code.
   	      out = out(width);
   	    } else {
   	      out = new Uint8Array(width);
   	      (global.crypto || global.msCrypto).getRandomValues(out);
   	    }
   	    return tostring(out);
   	  } catch (e) {
   	    var browser = global.navigator,
   	        plugins = browser && browser.plugins;
   	    return [+new Date, global, plugins, global.screen, tostring(pool)];
   	  }
   	}

   	//
   	// tostring()
   	// Converts an array of charcodes to a string
   	//
   	function tostring(a) {
   	  return String.fromCharCode.apply(0, a);
   	}

   	//
   	// When seedrandom.js is loaded, we immediately mix a few bits
   	// from the built-in RNG into the entropy pool.  Because we do
   	// not want to interfere with deterministic PRNG state later,
   	// seedrandom will not call math.random on its own again after
   	// initialization.
   	//
   	mixkey(math.random(), pool);

   	//
   	// Nodejs and AMD support: export the implementation as a module using
   	// either convention.
   	//
   	if (module.exports) {
   	  module.exports = seedrandom;
   	  // When in node.js, try using crypto package for autoseeding.
   	  try {
   	    nodecrypto = require$$0;
   	  } catch (ex) {}
   	} else {
   	  // When included as a plain script, set up Math.seedrandom global.
   	  math['seed' + rngname] = seedrandom;
   	}


   	// End anonymous scope, and pass initial values.
   	})(
   	  // global: `self` in browsers (including strict mode and web workers),
   	  // otherwise `this` in Node and other environments
   	  (typeof self !== 'undefined') ? self : commonjsGlobal,
   	  [],     // pool: entropy pool starts empty
   	  Math    // math: package containing random, pow, and seedrandom
   	); 
   } (seedrandom$2));

   var seedrandomExports = seedrandom$2.exports;

   // A library of seedable RNGs implemented in Javascript.
   //
   // Usage:
   //
   // var seedrandom = require('seedrandom');
   // var random = seedrandom(1); // or any seed.
   // var x = random();       // 0 <= x < 1.  Every bit is random.
   // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

   // alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
   // Period: ~2^116
   // Reported to pass all BigCrush tests.
   var alea = aleaExports;

   // xor128, a pure xor-shift generator by George Marsaglia.
   // Period: 2^128-1.
   // Reported to fail: MatrixRank and LinearComp.
   var xor128 = xor128Exports;

   // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
   // Period: 2^192-2^32
   // Reported to fail: CollisionOver, SimpPoker, and LinearComp.
   var xorwow = xorwowExports;

   // xorshift7, by François Panneton and Pierre L'ecuyer, takes
   // a different approach: it adds robustness by allowing more shifts
   // than Marsaglia's original three.  It is a 7-shift generator
   // with 256 bits, that passes BigCrush with no systmatic failures.
   // Period 2^256-1.
   // No systematic BigCrush failures reported.
   var xorshift7 = xorshift7Exports;

   // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
   // very long period that also adds a Weyl generator. It also passes
   // BigCrush with no systematic failures.  Its long period may
   // be useful if you have many generators and need to avoid
   // collisions.
   // Period: 2^4128-2^32.
   // No systematic BigCrush failures reported.
   var xor4096 = xor4096Exports;

   // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
   // number generator derived from ChaCha, a modern stream cipher.
   // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
   // Period: ~2^127
   // No systematic BigCrush failures reported.
   var tychei = tycheiExports;

   // The original ARC4-based prng included in this library.
   // Period: ~2^1600
   var sr = seedrandomExports;

   sr.alea = alea;
   sr.xor128 = xor128;
   sr.xorwow = xorwow;
   sr.xorshift7 = xorshift7;
   sr.xor4096 = xor4096;
   sr.tychei = tychei;

   var seedrandom = sr;

   var seedrandom$1 = /*@__PURE__*/getDefaultExportFromCjs(seedrandom);

   var singletonRandom = /* #__PURE__ */seedrandom$1(Date.now());
   function createRng(randomSeed) {
     var random;

     // create a new random generator with given seed
     function setSeed(seed) {
       random = seed === null ? singletonRandom : seedrandom$1(String(seed));
     }

     // initialize a seeded pseudo random number generator with config's random seed
     setSeed(randomSeed);

     // wrapper function so the rng can be updated via generator
     function rng() {
       return random();
     }
     return rng;
   }

   var name$C = 'pickRandom';
   var dependencies$C = ['typed', 'config', '?on'];
   var createPickRandom = /* #__PURE__ */factory(name$C, dependencies$C, _ref => {
     var {
       typed,
       config,
       on
     } = _ref;
     // seeded pseudo random number generator
     var rng = createRng(config.randomSeed);
     if (on) {
       on('config', function (curr, prev) {
         if (curr.randomSeed !== prev.randomSeed) {
           rng = createRng(curr.randomSeed);
         }
       });
     }

     /**
      * Random pick one or more values from a one dimensional array.
      * Array elements are picked using a random function with uniform or weighted distribution.
      *
      * Syntax:
      *
      *     math.pickRandom(array)
      *     math.pickRandom(array, number)
      *     math.pickRandom(array, weights)
      *     math.pickRandom(array, number, weights)
      *     math.pickRandom(array, weights, number)
      *     math.pickRandom(array, { weights, number, elementWise })
      *
      * Examples:
      *
      *     math.pickRandom([3, 6, 12, 2])                  // returns one of the values in the array
      *     math.pickRandom([3, 6, 12, 2], 2)               // returns an array of two of the values in the array
      *     math.pickRandom([3, 6, 12, 2], { number: 2 })   // returns an array of two of the values in the array
      *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1])    // returns one of the values in the array with weighted distribution
      *     math.pickRandom([3, 6, 12, 2], 2, [1, 3, 2, 1]) // returns an array of two of the values in the array with weighted distribution
      *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1], 2) // returns an array of two of the values in the array with weighted distribution
      *
      *     math.pickRandom([{x: 1.0, y: 2.0}, {x: 1.1, y: 2.0}], { elementWise: false })
      *         // returns one of the items in the array
      *
      * See also:
      *
      *     random, randomInt
      *
      * @param {Array | Matrix} array     A one dimensional array
      * @param {Int} number               An int or float
      * @param {Array | Matrix} weights   An array of ints or floats
      * @return {number | Array}          Returns a single random value from array when number is 1 or undefined.
      *                                   Returns an array with the configured number of elements when number is > 1.
      */
     return typed(name$C, {
       'Array | Matrix': function ArrayMatrix(possibles) {
         return _pickRandom(possibles, {});
       },
       'Array | Matrix, Object': function ArrayMatrixObject(possibles, options) {
         return _pickRandom(possibles, options);
       },
       'Array | Matrix, number': function ArrayMatrixNumber(possibles, number) {
         return _pickRandom(possibles, {
           number
         });
       },
       'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(possibles, weights) {
         return _pickRandom(possibles, {
           weights
         });
       },
       'Array | Matrix, Array | Matrix, number': function ArrayMatrixArrayMatrixNumber(possibles, weights, number) {
         return _pickRandom(possibles, {
           number,
           weights
         });
       },
       'Array | Matrix, number, Array | Matrix': function ArrayMatrixNumberArrayMatrix(possibles, number, weights) {
         return _pickRandom(possibles, {
           number,
           weights
         });
       }
     });

     /**
      * @param {Array | Matrix} possibles
      * @param {{
      *   number?: number,
      *   weights?: Array | Matrix,
      *   elementWise: boolean
      * }} options
      * @returns {number | Array}
      * @private
      */
     function _pickRandom(possibles, _ref2) {
       var {
         number,
         weights,
         elementWise = true
       } = _ref2;
       var single = typeof number === 'undefined';
       if (single) {
         number = 1;
       }
       var createMatrix = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
       possibles = possibles.valueOf(); // get Array
       if (weights) {
         weights = weights.valueOf(); // get Array
       }

       if (elementWise === true) {
         possibles = flatten$1(possibles);
         weights = flatten$1(weights);
       }
       var totalWeights = 0;
       if (typeof weights !== 'undefined') {
         if (weights.length !== possibles.length) {
           throw new Error('Weights must have the same length as possibles');
         }
         for (var i = 0, len = weights.length; i < len; i++) {
           if (!isNumber(weights[i]) || weights[i] < 0) {
             throw new Error('Weights must be an array of positive numbers');
           }
           totalWeights += weights[i];
         }
       }
       var length = possibles.length;
       var result = [];
       var pick;
       while (result.length < number) {
         if (typeof weights === 'undefined') {
           pick = possibles[Math.floor(rng() * length)];
         } else {
           var randKey = rng() * totalWeights;
           for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
             randKey -= weights[_i];
             if (randKey < 0) {
               pick = possibles[_i];
               break;
             }
           }
         }
         result.push(pick);
       }
       return single ? result[0] : createMatrix ? createMatrix(result) : result;
     }
   });

   /**
    * This is a util function for generating a random matrix recursively.
    * @param {number[]} size
    * @param {function} random
    * @returns {Array}
    */
   function randomMatrix(size, random) {
     var data = [];
     size = size.slice(0);
     if (size.length > 1) {
       for (var i = 0, length = size.shift(); i < length; i++) {
         data.push(randomMatrix(size, random));
       }
     } else {
       for (var _i = 0, _length = size.shift(); _i < _length; _i++) {
         data.push(random());
       }
     }
     return data;
   }

   var name$B = 'random';
   var dependencies$B = ['typed', 'config', '?on'];
   var createRandom = /* #__PURE__ */factory(name$B, dependencies$B, _ref => {
     var {
       typed,
       config,
       on
     } = _ref;
     // seeded pseudo random number generator
     var rng = createRng(config.randomSeed);
     if (on) {
       on('config', function (curr, prev) {
         if (curr.randomSeed !== prev.randomSeed) {
           rng = createRng(curr.randomSeed);
         }
       });
     }

     /**
      * Return a random number larger or equal to `min` and smaller than `max`
      * using a uniform distribution.
      *
      * Syntax:
      *
      *     math.random()                // generate a random number between 0 and 1
      *     math.random(max)             // generate a random number between 0 and max
      *     math.random(min, max)        // generate a random number between min and max
      *     math.random(size)            // generate a matrix with random numbers between 0 and 1
      *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
      *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
      *
      * Examples:
      *
      *     math.random()       // returns a random number between 0 and 1
      *     math.random(100)    // returns a random number between 0 and 100
      *     math.random(30, 40) // returns a random number between 30 and 40
      *     math.random([2, 3]) // returns a 2x3 matrix with random numbers between 0 and 1
      *
      * See also:
      *
      *     randomInt, pickRandom
      *
      * @param {Array | Matrix} [size] If provided, an array or matrix with given
      *                                size and filled with random values is returned
      * @param {number} [min]  Minimum boundary for the random value, included
      * @param {number} [max]  Maximum boundary for the random value, excluded
      * @return {number | Array | Matrix} A random number
      */
     return typed(name$B, {
       '': () => _random(0, 1),
       number: max => _random(0, max),
       'number, number': (min, max) => _random(min, max),
       'Array | Matrix': size => _randomMatrix(size, 0, 1),
       'Array | Matrix, number': (size, max) => _randomMatrix(size, 0, max),
       'Array | Matrix, number, number': (size, min, max) => _randomMatrix(size, min, max)
     });
     function _randomMatrix(size, min, max) {
       var res = randomMatrix(size.valueOf(), () => _random(min, max));
       return isMatrix(size) ? size.create(res) : res;
     }
     function _random(min, max) {
       return min + rng() * (max - min);
     }
   });

   var name$A = 'randomInt';
   var dependencies$A = ['typed', 'config', '?on'];
   var createRandomInt = /* #__PURE__ */factory(name$A, dependencies$A, _ref => {
     var {
       typed,
       config,
       on
     } = _ref;
     // seeded pseudo random number generator
     var rng = createRng(config.randomSeed);
     if (on) {
       on('config', function (curr, prev) {
         if (curr.randomSeed !== prev.randomSeed) {
           rng = createRng(curr.randomSeed);
         }
       });
     }

     /**
      * Return a random integer number larger or equal to `min` and smaller than `max`
      * using a uniform distribution.
      *
      * Syntax:
      *
      *     math.randomInt()                // generate a random integer between 0 and 1
      *     math.randomInt(max)             // generate a random integer between 0 and max
      *     math.randomInt(min, max)        // generate a random integer between min and max
      *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
      *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
      *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
      *
      * Examples:
      *
      *     math.randomInt(100)    // returns a random integer between 0 and 100
      *     math.randomInt(30, 40) // returns a random integer between 30 and 40
      *     math.randomInt([2, 3]) // returns a 2x3 matrix with random integers between 0 and 1
      *
      * See also:
      *
      *     random, pickRandom
      *
      * @param {Array | Matrix} [size] If provided, an array or matrix with given
      *                                size and filled with random values is returned
      * @param {number} [min]  Minimum boundary for the random value, included
      * @param {number} [max]  Maximum boundary for the random value, excluded
      * @return {number | Array | Matrix} A random integer value
      */
     return typed(name$A, {
       '': () => _randomInt(0, 1),
       number: max => _randomInt(0, max),
       'number, number': (min, max) => _randomInt(min, max),
       'Array | Matrix': size => _randomIntMatrix(size, 0, 1),
       'Array | Matrix, number': (size, max) => _randomIntMatrix(size, 0, max),
       'Array | Matrix, number, number': (size, min, max) => _randomIntMatrix(size, min, max)
     });
     function _randomIntMatrix(size, min, max) {
       var res = randomMatrix(size.valueOf(), () => _randomInt(min, max));
       return isMatrix(size) ? size.create(res) : res;
     }
     function _randomInt(min, max) {
       return Math.floor(min + rng() * (max - min));
     }
   });

   var name$z = 'stirlingS2';
   var dependencies$z = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'number', '?bignumber', 'larger'];
   var createStirlingS2 = /* #__PURE__ */factory(name$z, dependencies$z, _ref => {
     var {
       typed,
       addScalar,
       subtract,
       multiplyScalar,
       divideScalar,
       pow,
       factorial,
       combinations,
       isNegative,
       isInteger,
       number,
       bignumber,
       larger
     } = _ref;
     var smallCache = [];
     var bigCache = [];
     /**
      * The Stirling numbers of the second kind, counts the number of ways to partition
      * a set of n labelled objects into k nonempty unlabelled subsets.
      * stirlingS2 only takes integer arguments.
      * The following condition must be enforced: k <= n.
      *
      *  If n = k or k = 1 <= n, then s(n,k) = 1
      *  If k = 0 < n, then s(n,k) = 0
      *
      * Note that if either n or k is supplied as a BigNumber, the result will be
      * as well.
      *
      * Syntax:
      *
      *   math.stirlingS2(n, k)
      *
      * Examples:
      *
      *    math.stirlingS2(5, 3) //returns 25
      *
      * See also:
      *
      *    bellNumbers
      *
      * @param {Number | BigNumber} n    Total number of objects in the set
      * @param {Number | BigNumber} k    Number of objects in the subset
      * @return {Number | BigNumber}     S(n,k)
      */
     return typed(name$z, {
       'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {
         if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {
           throw new TypeError('Non-negative integer value expected in function stirlingS2');
         } else if (larger(k, n)) {
           throw new TypeError('k must be less than or equal to n in function stirlingS2');
         }
         var big = !(isNumber(n) && isNumber(k));
         var cache = big ? bigCache : smallCache;
         var make = big ? bignumber : number;
         var nn = number(n);
         var nk = number(k);
         /* See if we already have the value: */
         if (cache[nn] && cache[nn].length > nk) {
           return cache[nn][nk];
         }
         /* Fill the cache */
         for (var m = 0; m <= nn; ++m) {
           if (!cache[m]) {
             cache[m] = [m === 0 ? make(1) : make(0)];
           }
           if (m === 0) continue;
           var row = cache[m];
           var prev = cache[m - 1];
           for (var i = row.length; i <= m && i <= nk; ++i) {
             if (i === m) {
               row[i] = 1;
             } else {
               row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
             }
           }
         }
         return cache[nn][nk];
       }
     });
   });

   var name$y = 'bellNumbers';
   var dependencies$y = ['typed', 'addScalar', 'isNegative', 'isInteger', 'stirlingS2'];
   var createBellNumbers = /* #__PURE__ */factory(name$y, dependencies$y, _ref => {
     var {
       typed,
       addScalar,
       isNegative,
       isInteger,
       stirlingS2
     } = _ref;
     /**
      * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
      * bellNumbers only takes integer arguments.
      * The following condition must be enforced: n >= 0
      *
      * Syntax:
      *
      *   math.bellNumbers(n)
      *
      * Examples:
      *
      *    math.bellNumbers(3) // returns 5
      *    math.bellNumbers(8) // returns 4140
      *
      * See also:
      *
      *    stirlingS2
      *
      * @param {Number | BigNumber} n    Total number of objects in the set
      * @return {Number | BigNumber}     B(n)
      */
     return typed(name$y, {
       'number | BigNumber': function numberBigNumber(n) {
         if (!isInteger(n) || isNegative(n)) {
           throw new TypeError('Non-negative integer value expected in function bellNumbers');
         }

         // Sum (k=0, n) S(n,k).
         var result = 0;
         for (var i = 0; i <= n; i++) {
           result = addScalar(result, stirlingS2(n, i));
         }
         return result;
       }
     });
   });

   var name$x = 'catalan';
   var dependencies$x = ['typed', 'addScalar', 'divideScalar', 'multiplyScalar', 'combinations', 'isNegative', 'isInteger'];
   var createCatalan = /* #__PURE__ */factory(name$x, dependencies$x, _ref => {
     var {
       typed,
       addScalar,
       divideScalar,
       multiplyScalar,
       combinations,
       isNegative,
       isInteger
     } = _ref;
     /**
      * The Catalan Numbers enumerate combinatorial structures of many different types.
      * catalan only takes integer arguments.
      * The following condition must be enforced: n >= 0
      *
      * Syntax:
      *
      *   math.catalan(n)
      *
      * Examples:
      *
      *    math.catalan(3) // returns 5
      *    math.catalan(8) // returns 1430
      *
      * See also:
      *
      *    bellNumbers
      *
      * @param {Number | BigNumber} n    nth Catalan number
      * @return {Number | BigNumber}     Cn(n)
      */
     return typed(name$x, {
       'number | BigNumber': function numberBigNumber(n) {
         if (!isInteger(n) || isNegative(n)) {
           throw new TypeError('Non-negative integer value expected in function catalan');
         }
         return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
       }
     });
   });

   var name$w = 'composition';
   var dependencies$w = ['typed', 'addScalar', 'combinations', 'isNegative', 'isPositive', 'isInteger', 'larger'];
   var createComposition = /* #__PURE__ */factory(name$w, dependencies$w, _ref => {
     var {
       typed,
       addScalar,
       combinations,
       isPositive,
       isNegative,
       isInteger,
       larger
     } = _ref;
     /**
      * The composition counts of n into k parts.
      *
      * composition only takes integer arguments.
      * The following condition must be enforced: k <= n.
      *
      * Syntax:
      *
      *   math.composition(n, k)
      *
      * Examples:
      *
      *    math.composition(5, 3) // returns 6
      *
      * See also:
      *
      *    combinations
      *
      * @param {Number | BigNumber} n    Total number of objects in the set
      * @param {Number | BigNumber} k    Number of objects in the subset
      * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
      */
     return typed(name$w, {
       'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {
         if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {
           throw new TypeError('Positive integer value expected in function composition');
         } else if (larger(k, n)) {
           throw new TypeError('k must be less than or equal to n in function composition');
         }
         return combinations(addScalar(n, -1), addScalar(k, -1));
       }
     });
   });

   var name$v = 'leafCount';
   var dependencies$v = ['parse', 'typed'];
   var createLeafCount = /* #__PURE__ */factory(name$v, dependencies$v, _ref => {
     var {
       parse,
       typed
     } = _ref;
     // This does the real work, but we don't have to recurse through
     // a typed call if we separate it out
     function countLeaves(node) {
       var count = 0;
       node.forEach(n => {
         count += countLeaves(n);
       });
       return count || 1;
     }

     /**
      * Gives the number of "leaf nodes" in the parse tree of the given expression
      * A leaf node is one that has no subexpressions, essentially either a
      * symbol or a constant. Note that `5!` has just one leaf, the '5'; the
      * unary factorial operator does not add a leaf. On the other hand,
      * function symbols do add leaves, so `sin(x)/cos(x)` has four leaves.
      *
      * The `simplify()` function should generally not increase the `leafCount()`
      * of an expression, although currently there is no guarantee that it never
      * does so. In many cases, `simplify()` reduces the leaf count.
      *
      * Syntax:
      *
      *     math.leafCount(expr)
      *
      * Examples:
      *
      *     math.leafCount('x') // 1
      *     math.leafCount(math.parse('a*d-b*c')) // 4
      *     math.leafCount('[a,b;c,d][0,1]') // 6
      *
      * See also:
      *
      *     simplify
      *
      * @param {Node|string} expr    The expression to count the leaves of
      *
      * @return {number}  The number of leaves of `expr`
      *
      */
     return typed(name$v, {
       Node: function Node(expr) {
         return countLeaves(expr);
       }
     });
   });

   function isNumericNode(x) {
     return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
   }
   function isConstantExpression(x) {
     if (isConstantNode(x)) {
       // Basic Constant types
       return true;
     }
     if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
       // Can be constant depending on arguments
       return true;
     }
     if (isParenthesisNode(x) && isConstantExpression(x.content)) {
       // Parenthesis are transparent
       return true;
     }
     return false; // Probably missing some edge cases
   }

   function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
   function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
   var name$u = 'simplifyUtil';
   var dependencies$u = ['FunctionNode', 'OperatorNode', 'SymbolNode'];
   var createUtil = /* #__PURE__ */factory(name$u, dependencies$u, _ref => {
     var {
       FunctionNode,
       OperatorNode,
       SymbolNode
     } = _ref;
     // TODO commutative/associative properties rely on the arguments
     // e.g. multiply is not commutative for matrices
     // The properties should be calculated from an argument to simplify, or possibly something in math.config
     // the other option is for typed() to specify a return type so that we can evaluate the type of arguments

     /* So that properties of an operator fit on one line: */
     var T = true;
     var F = false;
     var defaultName = 'defaultF';
     var defaultContext = {
       /*      */add: {
         trivial: T,
         total: T,
         commutative: T,
         associative: T
       },
       /**/unaryPlus: {
         trivial: T,
         total: T,
         commutative: T,
         associative: T
       },
       /* */subtract: {
         trivial: F,
         total: T,
         commutative: F,
         associative: F
       },
       /* */multiply: {
         trivial: T,
         total: T,
         commutative: T,
         associative: T
       },
       /*   */divide: {
         trivial: F,
         total: T,
         commutative: F,
         associative: F
       },
       /*    */paren: {
         trivial: T,
         total: T,
         commutative: T,
         associative: F
       },
       /* */defaultF: {
         trivial: F,
         total: T,
         commutative: F,
         associative: F
       }
     };
     var realContext = {
       divide: {
         total: F
       },
       log: {
         total: F
       }
     };
     var positiveContext = {
       subtract: {
         total: F
       },
       abs: {
         trivial: T
       },
       log: {
         total: T
       }
     };
     function hasProperty(nodeOrName, property) {
       var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;
       var name = defaultName;
       if (typeof nodeOrName === 'string') {
         name = nodeOrName;
       } else if (isOperatorNode(nodeOrName)) {
         name = nodeOrName.fn.toString();
       } else if (isFunctionNode(nodeOrName)) {
         name = nodeOrName.name;
       } else if (isParenthesisNode(nodeOrName)) {
         name = 'paren';
       }
       if (hasOwnProperty(context, name)) {
         var properties = context[name];
         if (hasOwnProperty(properties, property)) {
           return properties[property];
         }
         if (hasOwnProperty(defaultContext, name)) {
           return defaultContext[name][property];
         }
       }
       if (hasOwnProperty(context, defaultName)) {
         var _properties = context[defaultName];
         if (hasOwnProperty(_properties, property)) {
           return _properties[property];
         }
         return defaultContext[defaultName][property];
       }
       /* name not found in context and context has no global default */
       /* So use default context. */
       if (hasOwnProperty(defaultContext, name)) {
         var _properties2 = defaultContext[name];
         if (hasOwnProperty(_properties2, property)) {
           return _properties2[property];
         }
       }
       return defaultContext[defaultName][property];
     }
     function isCommutative(node) {
       var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
       return hasProperty(node, 'commutative', context);
     }
     function isAssociative(node) {
       var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
       return hasProperty(node, 'associative', context);
     }

     /**
      * Merge the given contexts, with primary overriding secondary
      * wherever they might conflict
      */
     function mergeContext(primary, secondary) {
       var merged = _objectSpread({}, primary);
       for (var prop in secondary) {
         if (hasOwnProperty(primary, prop)) {
           merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);
         } else {
           merged[prop] = secondary[prop];
         }
       }
       return merged;
     }

     /**
      * Flatten all associative operators in an expression tree.
      * Assumes parentheses have already been removed.
      */
     function flatten(node, context) {
       if (!node.args || node.args.length === 0) {
         return node;
       }
       node.args = allChildren(node, context);
       for (var i = 0; i < node.args.length; i++) {
         flatten(node.args[i], context);
       }
     }

     /**
      * Get the children of a node as if it has been flattened.
      * TODO implement for FunctionNodes
      */
     function allChildren(node, context) {
       var op;
       var children = [];
       var findChildren = function findChildren(node) {
         for (var i = 0; i < node.args.length; i++) {
           var child = node.args[i];
           if (isOperatorNode(child) && op === child.op) {
             findChildren(child);
           } else {
             children.push(child);
           }
         }
       };
       if (isAssociative(node, context)) {
         op = node.op;
         findChildren(node);
         return children;
       } else {
         return node.args;
       }
     }

     /**
      *  Unflatten all flattened operators to a right-heavy binary tree.
      */
     function unflattenr(node, context) {
       if (!node.args || node.args.length === 0) {
         return;
       }
       var makeNode = createMakeNodeFunction(node);
       var l = node.args.length;
       for (var i = 0; i < l; i++) {
         unflattenr(node.args[i], context);
       }
       if (l > 2 && isAssociative(node, context)) {
         var curnode = node.args.pop();
         while (node.args.length > 0) {
           curnode = makeNode([node.args.pop(), curnode]);
         }
         node.args = curnode.args;
       }
     }

     /**
      *  Unflatten all flattened operators to a left-heavy binary tree.
      */
     function unflattenl(node, context) {
       if (!node.args || node.args.length === 0) {
         return;
       }
       var makeNode = createMakeNodeFunction(node);
       var l = node.args.length;
       for (var i = 0; i < l; i++) {
         unflattenl(node.args[i], context);
       }
       if (l > 2 && isAssociative(node, context)) {
         var curnode = node.args.shift();
         while (node.args.length > 0) {
           curnode = makeNode([curnode, node.args.shift()]);
         }
         node.args = curnode.args;
       }
     }
     function createMakeNodeFunction(node) {
       if (isOperatorNode(node)) {
         return function (args) {
           try {
             return new OperatorNode(node.op, node.fn, args, node.implicit);
           } catch (err) {
             console.error(err);
             return [];
           }
         };
       } else {
         return function (args) {
           return new FunctionNode(new SymbolNode(node.name), args);
         };
       }
     }
     return {
       createMakeNodeFunction,
       hasProperty,
       isCommutative,
       isAssociative,
       mergeContext,
       flatten,
       allChildren,
       unflattenr,
       unflattenl,
       defaultContext,
       realContext,
       positiveContext
     };
   });

   var name$t = 'simplify';
   var dependencies$t = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];
   var createSimplify = /* #__PURE__ */factory(name$t, dependencies$t, _ref => {
     var {
       config,
       typed,
       parse,
       add,
       subtract,
       multiply,
       divide,
       pow,
       isZero,
       equal,
       resolve,
       simplifyConstant,
       simplifyCore,
       fraction,
       bignumber,
       mathWithTransform,
       matrix,
       AccessorNode,
       ArrayNode,
       ConstantNode,
       FunctionNode,
       IndexNode,
       ObjectNode,
       OperatorNode,
       ParenthesisNode,
       SymbolNode
     } = _ref;
     var {
       hasProperty,
       isCommutative,
       isAssociative,
       mergeContext,
       flatten,
       unflattenr,
       unflattenl,
       createMakeNodeFunction,
       defaultContext,
       realContext,
       positiveContext
     } = createUtil({
       FunctionNode,
       OperatorNode,
       SymbolNode
     });

     /**
      * Simplify an expression tree.
      *
      * A list of rules are applied to an expression, repeating over the list until
      * no further changes are made.
      * It's possible to pass a custom set of rules to the function as second
      * argument. A rule can be specified as an object, string, or function:
      *
      *     const rules = [
      *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
      *       'n1*n3 + n2*n3 -> (n1+n2)*n3',
      *       function (node) {
      *         // ... return a new node or return the node unchanged
      *         return node
      *       }
      *     ]
      *
      * String and object rules consist of a left and right pattern. The left is
      * used to match against the expression and the right determines what matches
      * are replaced with. The main difference between a pattern and a normal
      * expression is that variables starting with the following characters are
      * interpreted as wildcards:
      *
      * - 'n' - Matches any node [Node]
      * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]
      * - 'cl' - Matches a constant literal; same as c [ConstantNode]
      * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]
      * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]
      * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]
      * - 'vl' - Matches a variable literal (x or y) [SymbolNode]
      * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]
      * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]
      *
      * The default list of rules is exposed on the function as `simplify.rules`
      * and can be used as a basis to built a set of custom rules. Note that since
      * the `simplifyCore` function is in the default list of rules, by default
      * simplify will convert any function calls in the expression that have
      * operator equivalents to their operator forms.
      *
      * To specify a rule as a string, separate the left and right pattern by '->'
      * When specifying a rule as an object, the following keys are meaningful:
      * - l - the left pattern
      * - r - the right pattern
      * - s - in lieu of l and r, the string form that is broken at -> to give them
      * - repeat - whether to repeat this rule until the expression stabilizes
      * - assuming - gives a context object, as in the 'context' option to
      *     simplify. Every property in the context object must match the current
      *     context in order, or else the rule will not be applied.
      * - imposeContext - gives a context object, as in the 'context' option to
      *     simplify. Any settings specified will override the incoming context
      *     for all matches of this rule.
      *
      * For more details on the theory, see:
      *
      * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)
      * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)
      *
      *  An optional `options` argument can be passed as last argument of `simplify`.
      *  Currently available options (defaults in parentheses):
      *  - `consoleDebug` (false): whether to write the expression being simplified
      *    and any changes to it, along with the rule responsible, to console
      *  - `context` (simplify.defaultContext): an object giving properties of
      *    each operator, which determine what simplifications are allowed. The
      *    currently meaningful properties are commutative, associative,
      *    total (whether the operation is defined for all arguments), and
      *    trivial (whether the operation applied to a single argument leaves
      *    that argument unchanged). The default context is very permissive and
      *    allows almost all simplifications. Only properties differing from
      *    the default need to be specified; the default context is used as a
      *    fallback. Additional contexts `simplify.realContext` and
      *    `simplify.positiveContext` are supplied to cause simplify to perform
      *    just simplifications guaranteed to preserve all values of the expression
      *    assuming all variables and subexpressions are real numbers or
      *    positive real numbers, respectively. (Note that these are in some cases
      *    more restrictive than the default context; for example, the default
      *    context will allow `x/x` to simplify to 1, whereas
      *    `simplify.realContext` will not, as `0/0` is not equal to 1.)
      *  - `exactFractions` (true): whether to try to convert all constants to
      *    exact rational numbers.
      *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will
      *    be expressed as fractions only when both numerator and denominator
      *    are smaller than `fractionsLimit`.
      *
      * Syntax:
      *
      *     math.simplify(expr)
      *     math.simplify(expr, rules)
      *     math.simplify(expr, rules)
      *     math.simplify(expr, rules, scope)
      *     math.simplify(expr, rules, scope, options)
      *     math.simplify(expr, scope)
      *     math.simplify(expr, scope, options)
      *
      * Examples:
      *
      *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node "2 * x"
      *     math.simplify('2 * 3 * x', {x: 4})        // Node "24"
      *     const f = math.parse('2 * 1 * x ^ (2 - 1)')
      *     math.simplify(f)                          // Node "2 * x"
      *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node "x * 2 / 5"
      *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node "0.4 * x"
      *
      * See also:
      *
      *     simplifyCore, derivative, evaluate, parse, rationalize, resolve
      *
      * @param {Node | string} expr
      *            The expression to be simplified
      * @param {SimplifyRule[]} [rules]
      *            Optional list with custom rules
      * @param {Object} [scope] Optional scope with variables
      * @param {SimplifyOptions} [options] Optional configuration settings
      * @return {Node} Returns the simplified form of `expr`
      */
     typed.addConversion({
       from: 'Object',
       to: 'Map',
       convert: createMap$1
     });
     var simplify = typed('simplify', {
       Node: _simplify,
       'Node, Map': (expr, scope) => _simplify(expr, false, scope),
       'Node, Map, Object': (expr, scope, options) => _simplify(expr, false, scope, options),
       'Node, Array': _simplify,
       'Node, Array, Map': _simplify,
       'Node, Array, Map, Object': _simplify
     });
     typed.removeConversion({
       from: 'Object',
       to: 'Map',
       convert: createMap$1
     });
     simplify.defaultContext = defaultContext;
     simplify.realContext = realContext;
     simplify.positiveContext = positiveContext;
     function removeParens(node) {
       return node.transform(function (node, path, parent) {
         return isParenthesisNode(node) ? removeParens(node.content) : node;
       });
     }

     // All constants that are allowed in rules
     var SUPPORTED_CONSTANTS = {
       true: true,
       false: true,
       e: true,
       i: true,
       Infinity: true,
       LN2: true,
       LN10: true,
       LOG2E: true,
       LOG10E: true,
       NaN: true,
       phi: true,
       pi: true,
       SQRT1_2: true,
       SQRT2: true,
       tau: true
       // null: false,
       // undefined: false,
       // version: false,
     };

     // Array of strings, used to build the ruleSet.
     // Each l (left side) and r (right side) are parsed by
     // the expression parser into a node tree.
     // Left hand sides are matched to subtrees within the
     // expression to be parsed and replaced with the right
     // hand side.
     // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])
     // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.
     // It is possible to get into an infinite loop with conflicting rules
     simplify.rules = [simplifyCore,
     // { l: 'n+0', r: 'n' },     // simplifyCore
     // { l: 'n^0', r: '1' },     // simplifyCore
     // { l: '0*n', r: '0' },     // simplifyCore
     // { l: 'n/n', r: '1'},      // simplifyCore
     // { l: 'n^1', r: 'n' },     // simplifyCore
     // { l: '+n1', r:'n1' },     // simplifyCore
     // { l: 'n--n1', r:'n+n1' }, // simplifyCore
     {
       l: 'log(e)',
       r: '1'
     },
     // temporary rules
     // Note initially we tend constants to the right because like-term
     // collection prefers the left, and we would rather collect nonconstants
     {
       s: 'n-n1 -> n+-n1',
       // temporarily replace 'subtract' so we can further flatten the 'add' operator
       assuming: {
         subtract: {
           total: true
         }
       }
     }, {
       s: 'n-n -> 0',
       // partial alternative when we can't always subtract
       assuming: {
         subtract: {
           total: false
         }
       }
     }, {
       s: '-(cl*v) -> v * (-cl)',
       // make non-constant terms positive
       assuming: {
         multiply: {
           commutative: true
         },
         subtract: {
           total: true
         }
       }
     }, {
       s: '-(cl*v) -> (-cl) * v',
       // non-commutative version, part 1
       assuming: {
         multiply: {
           commutative: false
         },
         subtract: {
           total: true
         }
       }
     }, {
       s: '-(v*cl) -> v * (-cl)',
       // non-commutative version, part 2
       assuming: {
         multiply: {
           commutative: false
         },
         subtract: {
           total: true
         }
       }
     }, {
       l: '-(n1/n2)',
       r: '-n1/n2'
     }, {
       l: '-v',
       r: 'v * (-1)'
     },
     // finish making non-constant terms positive
     {
       l: '(n1 + n2)*(-1)',
       r: 'n1*(-1) + n2*(-1)',
       repeat: true
     },
     // expand negations to achieve as much sign cancellation as possible
     {
       l: 'n/n1^n2',
       r: 'n*n1^-n2'
     },
     // temporarily replace 'divide' so we can further flatten the 'multiply' operator
     {
       l: 'n/n1',
       r: 'n*n1^-1'
     }, {
       s: '(n1*n2)^n3 -> n1^n3 * n2^n3',
       assuming: {
         multiply: {
           commutative: true
         }
       }
     }, {
       s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     },
     // expand nested exponentiation
     {
       s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',
       assuming: {
         divide: {
           total: true
         }
       } // 1/(1/n) = n needs 1/n to exist
     },
     // collect like factors; into a sum, only do this for nonconstants
     {
       l: ' vd   * ( vd   * n1 + n2)',
       r: 'vd^2       * n1 +  vd   * n2'
     }, {
       s: ' vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2',
       assuming: {
         divide: {
           total: true
         }
       } // v*1/v = v^(1+-1) needs 1/v
     }, {
       s: 'vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2',
       assuming: {
         divide: {
           total: true
         }
       }
     }, {
       s: 'vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2',
       assuming: {
         divide: {
           total: true
         }
       }
     }, {
       l: 'n*n',
       r: 'n^2'
     }, {
       s: 'n * n^n1 -> n^(n1+1)',
       assuming: {
         divide: {
           total: true
         }
       } // n*1/n = n^(-1+1) needs 1/n
     }, {
       s: 'n^n1 * n^n2 -> n^(n1+n2)',
       assuming: {
         divide: {
           total: true
         }
       } // ditto for n^2*1/n^2
     },
     // Unfortunately, to deal with more complicated cancellations, it
     // becomes necessary to simplify constants twice per pass. It's not
     // terribly expensive compared to matching rules, so this should not
     // pose a performance problem.
     simplifyConstant,
     // First: before collecting like terms

     // collect like terms
     {
       s: 'n+n -> 2*n',
       assuming: {
         add: {
           total: true
         }
       } // 2 = 1 + 1 needs to exist
     }, {
       l: 'n+-n',
       r: '0'
     }, {
       l: 'vd*n + vd',
       r: 'vd*(n+1)'
     },
     // NOTE: leftmost position is special:
     {
       l: 'n3*n1 + n3*n2',
       r: 'n3*(n1+n2)'
     },
     // All sub-monomials tried there.
     {
       l: 'n3^(-n4)*n1 +   n3  * n2',
       r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'
     }, {
       l: 'n3^(-n4)*n1 + n3^n5 * n2',
       r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'
     },
     // noncommutative additional cases (term collection & factoring)
     {
       s: 'n*vd + vd -> (n+1)*vd',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'vd + n*vd -> (1+n)*vd',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'n^n1 * n -> n^(n1+1)',
       assuming: {
         divide: {
           total: true
         },
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       l: 'n*cd + cd',
       r: '(n+1)*cd'
     }, {
       s: 'cd*n + cd -> cd*(n+1)',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, {
       s: 'cd + cd*n -> cd*(1+n)',
       assuming: {
         multiply: {
           commutative: false
         }
       }
     }, simplifyConstant,
     // Second: before returning expressions to "standard form"

     // make factors positive (and undo 'make non-constant terms positive')
     {
       s: '(-n)*n1 -> -(n*n1)',
       assuming: {
         subtract: {
           total: true
         }
       }
     }, {
       s: 'n1*(-n) -> -(n1*n)',
       // in case * non-commutative
       assuming: {
         subtract: {
           total: true
         },
         multiply: {
           commutative: false
         }
       }
     },
     // final ordering of constants
     {
       s: 'ce+ve -> ve+ce',
       assuming: {
         add: {
           commutative: true
         }
       },
       imposeContext: {
         add: {
           commutative: false
         }
       }
     }, {
       s: 'vd*cd -> cd*vd',
       assuming: {
         multiply: {
           commutative: true
         }
       },
       imposeContext: {
         multiply: {
           commutative: false
         }
       }
     },
     // undo temporary rules
     // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
     {
       l: 'n+-n1',
       r: 'n-n1'
     },
     // undo replace 'subtract'
     {
       l: 'n+-(n1)',
       r: 'n-(n1)'
     }, {
       s: 'n*(n1^-1) -> n/n1',
       // undo replace 'divide'; for * commutative
       assuming: {
         multiply: {
           commutative: true
         }
       } // o.w. / not conventional
     }, {
       s: 'n*n1^-n2 -> n/n1^n2',
       assuming: {
         multiply: {
           commutative: true
         }
       } // o.w. / not conventional
     }, {
       s: 'n^-1 -> 1/n',
       assuming: {
         multiply: {
           commutative: true
         }
       } // o.w. / not conventional
     }, {
       l: 'n^1',
       r: 'n'
     },
     // can be produced by power cancellation
     {
       s: 'n*(n1/n2) -> (n*n1)/n2',
       // '*' before '/'
       assuming: {
         multiply: {
           associative: true
         }
       }
     }, {
       s: 'n-(n1+n2) -> n-n1-n2',
       // '-' before '+'
       assuming: {
         addition: {
           associative: true,
           commutative: true
         }
       }
     },
     // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
     // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },

     // simplifyConstant can leave an extra factor of 1, which can always
     // be eliminated, since the identity always commutes
     {
       l: '1*n',
       r: 'n',
       imposeContext: {
         multiply: {
           commutative: true
         }
       }
     }, {
       s: 'n1/(n2/n3) -> (n1*n3)/n2',
       assuming: {
         multiply: {
           associative: true
         }
       }
     }, {
       l: 'n1/(-n2)',
       r: '-n1/n2'
     }];

     /**
      * Takes any rule object as allowed by the specification in simplify
      * and puts it in a standard form used by applyRule
      */
     function _canonicalizeRule(ruleObject, context) {
       var newRule = {};
       if (ruleObject.s) {
         var lr = ruleObject.s.split('->');
         if (lr.length === 2) {
           newRule.l = lr[0];
           newRule.r = lr[1];
         } else {
           throw SyntaxError('Could not parse rule: ' + ruleObject.s);
         }
       } else {
         newRule.l = ruleObject.l;
         newRule.r = ruleObject.r;
       }
       newRule.l = removeParens(parse(newRule.l));
       newRule.r = removeParens(parse(newRule.r));
       for (var prop of ['imposeContext', 'repeat', 'assuming']) {
         if (prop in ruleObject) {
           newRule[prop] = ruleObject[prop];
         }
       }
       if (ruleObject.evaluate) {
         newRule.evaluate = parse(ruleObject.evaluate);
       }
       if (isAssociative(newRule.l, context)) {
         var nonCommutative = !isCommutative(newRule.l, context);
         var leftExpandsym;
         // Gen. the LHS placeholder used in this NC-context specific expansion rules
         if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();
         var makeNode = createMakeNodeFunction(newRule.l);
         var expandsym = _getExpandPlaceholderSymbol();
         newRule.expanded = {};
         newRule.expanded.l = makeNode([newRule.l, expandsym]);
         // Push the expandsym into the deepest possible branch.
         // This helps to match the newRule against nodes returned from getSplits() later on.
         flatten(newRule.expanded.l, context);
         unflattenr(newRule.expanded.l, context);
         newRule.expanded.r = makeNode([newRule.r, expandsym]);

         // In and for a non-commutative context, attempting with yet additional expansion rules makes
         // way for more matches cases of multi-arg expressions; such that associative rules (such as
         // 'n*n -> n^2') can be applied to exprs. such as 'a * b * b' and 'a * b * b * a'.
         if (nonCommutative) {
           // 'Non-commutative' 1: LHS (placeholder) only
           newRule.expandedNC1 = {};
           newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
           newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
           // 'Non-commutative' 2: farmost LHS and RHS placeholders
           newRule.expandedNC2 = {};
           newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
           newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
         }
       }
       return newRule;
     }

     /**
      * Parse the string array of rules into nodes
      *
      * Example syntax for rules:
      *
      * Position constants to the left in a product:
      * { l: 'n1 * c1', r: 'c1 * n1' }
      * n1 is any Node, and c1 is a ConstantNode.
      *
      * Apply difference of squares formula:
      * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }
      * n1, n2 mean any Node.
      *
      * Short hand notation:
      * 'n1 * c1 -> c1 * n1'
      */
     function _buildRules(rules, context) {
       // Array of rules to be used to simplify expressions
       var ruleSet = [];
       for (var i = 0; i < rules.length; i++) {
         var rule = rules[i];
         var newRule = void 0;
         var ruleType = typeof rule;
         switch (ruleType) {
           case 'string':
             rule = {
               s: rule
             };
           /* falls through */
           case 'object':
             newRule = _canonicalizeRule(rule, context);
             break;
           case 'function':
             newRule = rule;
             break;
           default:
             throw TypeError('Unsupported type of rule: ' + ruleType);
         }
         // console.log('Adding rule: ' + rules[i])
         // console.log(newRule)
         ruleSet.push(newRule);
       }
       return ruleSet;
     }
     var _lastsym = 0;
     function _getExpandPlaceholderSymbol() {
       return new SymbolNode('_p' + _lastsym++);
     }
     function _simplify(expr, rules) {
       var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();
       var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
       var debug = options.consoleDebug;
       rules = _buildRules(rules || simplify.rules, options.context);
       var res = resolve(expr, scope);
       res = removeParens(res);
       var visited = {};
       var str = res.toString({
         parenthesis: 'all'
       });
       while (!visited[str]) {
         visited[str] = true;
         _lastsym = 0; // counter for placeholder symbols
         var laststr = str;
         if (debug) console.log('Working on: ', str);
         for (var i = 0; i < rules.length; i++) {
           var rulestr = '';
           if (typeof rules[i] === 'function') {
             res = rules[i](res, options);
             if (debug) rulestr = rules[i].name;
           } else {
             flatten(res, options.context);
             res = applyRule(res, rules[i], options.context);
             if (debug) {
               rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
             }
           }
           if (debug) {
             var newstr = res.toString({
               parenthesis: 'all'
             });
             if (newstr !== laststr) {
               console.log('Applying', rulestr, 'produced', newstr);
               laststr = newstr;
             }
           }
           /* Use left-heavy binary tree internally,
            * since custom rule functions may expect it
            */
           unflattenl(res, options.context);
         }
         str = res.toString({
           parenthesis: 'all'
         });
       }
       return res;
     }
     function mapRule(nodes, rule, context) {
       var resNodes = nodes;
       if (nodes) {
         for (var i = 0; i < nodes.length; ++i) {
           var newNode = applyRule(nodes[i], rule, context);
           if (newNode !== nodes[i]) {
             if (resNodes === nodes) {
               resNodes = nodes.slice();
             }
             resNodes[i] = newNode;
           }
         }
       }
       return resNodes;
     }

     /**
      * Returns a simplfied form of node, or the original node if no simplification was possible.
      *
      * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
      * @param  {Object | Function} rule
      * @param  {Object} context -- information about assumed properties of operators
      * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.
      */
     function applyRule(node, rule, context) {
       //    console.log('Entering applyRule("', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '",', node.toString({parenthesis:'all'}),')')

       // check that the assumptions for this rule are satisfied by the current
       // context:
       if (rule.assuming) {
         for (var symbol in rule.assuming) {
           for (var property in rule.assuming[symbol]) {
             if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
               return node;
             }
           }
         }
       }
       var mergedContext = mergeContext(rule.imposeContext, context);

       // Do not clone node unless we find a match
       var res = node;

       // First replace our child nodes with their simplified versions
       // If a child could not be simplified, applying the rule to it
       // will have no effect since the node is returned unchanged
       if (res instanceof OperatorNode || res instanceof FunctionNode) {
         var newArgs = mapRule(res.args, rule, context);
         if (newArgs !== res.args) {
           res = res.clone();
           res.args = newArgs;
         }
       } else if (res instanceof ParenthesisNode) {
         if (res.content) {
           var newContent = applyRule(res.content, rule, context);
           if (newContent !== res.content) {
             res = new ParenthesisNode(newContent);
           }
         }
       } else if (res instanceof ArrayNode) {
         var newItems = mapRule(res.items, rule, context);
         if (newItems !== res.items) {
           res = new ArrayNode(newItems);
         }
       } else if (res instanceof AccessorNode) {
         var newObj = res.object;
         if (res.object) {
           newObj = applyRule(res.object, rule, context);
         }
         var newIndex = res.index;
         if (res.index) {
           newIndex = applyRule(res.index, rule, context);
         }
         if (newObj !== res.object || newIndex !== res.index) {
           res = new AccessorNode(newObj, newIndex);
         }
       } else if (res instanceof IndexNode) {
         var newDims = mapRule(res.dimensions, rule, context);
         if (newDims !== res.dimensions) {
           res = new IndexNode(newDims);
         }
       } else if (res instanceof ObjectNode) {
         var changed = false;
         var newProps = {};
         for (var prop in res.properties) {
           newProps[prop] = applyRule(res.properties[prop], rule, context);
           if (newProps[prop] !== res.properties[prop]) {
             changed = true;
           }
         }
         if (changed) {
           res = new ObjectNode(newProps);
         }
       }

       // Try to match a rule against this node
       var repl = rule.r;
       var matches = _ruleMatch(rule.l, res, mergedContext)[0];

       // If the rule is associative operator, we can try matching it while allowing additional terms.
       // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.
       if (!matches && rule.expanded) {
         repl = rule.expanded.r;
         matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
       }
       // Additional, non-commutative context expansion-rules
       if (!matches && rule.expandedNC1) {
         repl = rule.expandedNC1.r;
         matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
         if (!matches) {
           // Existence of NC1 implies NC2
           repl = rule.expandedNC2.r;
           matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
         }
       }
       if (matches) {
         // const before = res.toString({parenthesis: 'all'})

         // Create a new node by cloning the rhs of the matched rule
         // we keep any implicit multiplication state if relevant
         var implicit = res.implicit;
         res = repl.clone();
         if (implicit && 'implicit' in repl) {
           res.implicit = true;
         }

         // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes
         res = res.transform(function (node) {
           if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {
             return matches.placeholders[node.name].clone();
           } else {
             return node;
           }
         });

         // const after = res.toString({parenthesis: 'all'})
         // console.log('Simplified ' + before + ' to ' + after)
       }

       if (rule.repeat && res !== node) {
         res = applyRule(res, rule, context);
       }
       return res;
     }

     /**
      * Get (binary) combinations of a flattened binary node
      * e.g. +(node1, node2, node3) -> [
      *        +(node1,  +(node2, node3)),
      *        +(node2,  +(node1, node3)),
      *        +(node3,  +(node1, node2))]
      *
      */
     function getSplits(node, context) {
       var res = [];
       var right, rightArgs;
       var makeNode = createMakeNodeFunction(node);
       if (isCommutative(node, context)) {
         for (var i = 0; i < node.args.length; i++) {
           rightArgs = node.args.slice(0);
           rightArgs.splice(i, 1);
           right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
           res.push(makeNode([node.args[i], right]));
         }
       } else {
         // Keep order, but try all parenthesizations
         for (var _i = 1; _i < node.args.length; _i++) {
           var left = node.args[0];
           if (_i > 1) {
             left = makeNode(node.args.slice(0, _i));
           }
           rightArgs = node.args.slice(_i);
           right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
           res.push(makeNode([left, right]));
         }
       }
       return res;
     }

     /**
      * Returns the set union of two match-placeholders or null if there is a conflict.
      */
     function mergeMatch(match1, match2) {
       var res = {
         placeholders: {}
       };

       // Some matches may not have placeholders; this is OK
       if (!match1.placeholders && !match2.placeholders) {
         return res;
       } else if (!match1.placeholders) {
         return match2;
       } else if (!match2.placeholders) {
         return match1;
       }

       // Placeholders with the same key must match exactly
       for (var key in match1.placeholders) {
         if (hasOwnProperty(match1.placeholders, key)) {
           res.placeholders[key] = match1.placeholders[key];
           if (hasOwnProperty(match2.placeholders, key)) {
             if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
               return null;
             }
           }
         }
       }
       for (var _key in match2.placeholders) {
         if (hasOwnProperty(match2.placeholders, _key)) {
           res.placeholders[_key] = match2.placeholders[_key];
         }
       }
       return res;
     }

     /**
      * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
      * Each list represents matches found in one child of a node.
      */
     function combineChildMatches(list1, list2) {
       var res = [];
       if (list1.length === 0 || list2.length === 0) {
         return res;
       }
       var merged;
       for (var i1 = 0; i1 < list1.length; i1++) {
         for (var i2 = 0; i2 < list2.length; i2++) {
           merged = mergeMatch(list1[i1], list2[i2]);
           if (merged) {
             res.push(merged);
           }
         }
       }
       return res;
     }

     /**
      * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
      * Each list represents matches found in one child of a node.
      * Returns a list of unique matches.
      */
     function mergeChildMatches(childMatches) {
       if (childMatches.length === 0) {
         return childMatches;
       }
       var sets = childMatches.reduce(combineChildMatches);
       var uniqueSets = [];
       var unique = {};
       for (var i = 0; i < sets.length; i++) {
         var s = JSON.stringify(sets[i]);
         if (!unique[s]) {
           unique[s] = true;
           uniqueSets.push(sets[i]);
         }
       }
       return uniqueSets;
     }

     /**
      * Determines whether node matches rule.
      *
      * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule
      * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
      * @param {Object} context -- provides assumed properties of operators
      * @param {Boolean} isSplit -- whether we are in process of splitting an
      *                    n-ary operator node into possible binary combinations.
      *                    Defaults to false.
      * @return {Object} Information about the match, if it exists.
      */
     function _ruleMatch(rule, node, context, isSplit) {
       //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')
       //    console.log('rule = ' + rule)
       //    console.log('node = ' + node)

       //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')
       var res = [{
         placeholders: {}
       }];
       if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
         // If the rule is an OperatorNode or a FunctionNode, then node must match exactly
         if (rule instanceof OperatorNode) {
           if (rule.op !== node.op || rule.fn !== node.fn) {
             return [];
           }
         } else if (rule instanceof FunctionNode) {
           if (rule.name !== node.name) {
             return [];
           }
         }

         // rule and node match. Search the children of rule and node.
         if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
           // Expect non-associative operators to match exactly,
           // except in any order if operator is commutative
           var childMatches = [];
           for (var i = 0; i < rule.args.length; i++) {
             var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
             if (childMatch.length === 0) {
               // Child did not match, so stop searching immediately
               break;
             }
             // The child matched, so add the information returned from the child to our result
             childMatches.push(childMatch);
           }
           if (childMatches.length !== rule.args.length) {
             if (!isCommutative(node, context) ||
             // exact match in order needed
             rule.args.length === 1) {
               // nothing to commute
               return [];
             }
             if (rule.args.length > 2) {
               /* Need to generate all permutations and try them.
                * It's a bit complicated, and unlikely to come up since there
                * are very few ternary or higher operators. So punt for now.
                */
               throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');
             }
             /* Exactly two arguments, try them reversed */
             var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
             if (leftMatch.length === 0) {
               return [];
             }
             var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
             if (rightMatch.length === 0) {
               return [];
             }
             childMatches = [leftMatch, rightMatch];
           }
           res = mergeChildMatches(childMatches);
         } else if (node.args.length >= 2 && rule.args.length === 2) {
           // node is flattened, rule is not
           // Associative operators/functions can be split in different ways so we check if the rule
           // matches for each of them and return their union.
           var splits = getSplits(node, context);
           var splitMatches = [];
           for (var _i2 = 0; _i2 < splits.length; _i2++) {
             var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here
             splitMatches = splitMatches.concat(matchSet);
           }
           return splitMatches;
         } else if (rule.args.length > 2) {
           throw Error('Unexpected non-binary associative function: ' + rule.toString());
         } else {
           // Incorrect number of arguments in rule and node, so no match
           return [];
         }
       } else if (rule instanceof SymbolNode) {
         // If the rule is a SymbolNode, then it carries a special meaning
         // according to the first one or two characters of the symbol node name.
         // These meanings are expalined in the documentation for simplify()
         if (rule.name.length === 0) {
           throw new Error('Symbol in rule has 0 length...!?');
         }
         if (SUPPORTED_CONSTANTS[rule.name]) {
           // built-in constant must match exactly
           if (rule.name !== node.name) {
             return [];
           }
         } else {
           // wildcards are composed of up to two alphabetic or underscore characters
           switch (rule.name[1] >= 'a' && rule.name[1] <= 'z' ? rule.name.substring(0, 2) : rule.name[0]) {
             case 'n':
             case '_p':
               // rule matches _anything_, so assign this node to the rule.name placeholder
               // Assign node to the rule.name placeholder.
               // Our parent will check for matches among placeholders.
               res[0].placeholders[rule.name] = node;
               break;
             case 'c':
             case 'cl':
               // rule matches a ConstantNode
               if (isConstantNode(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 'v':
               // rule matches anything other than a ConstantNode
               if (!isConstantNode(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 'vl':
               // rule matches VariableNode
               if (isSymbolNode(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 'cd':
               // rule matches a ConstantNode or unaryMinus-wrapped ConstantNode
               if (isNumericNode(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 'vd':
               // rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode
               if (!isNumericNode(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 'ce':
               // rule matches expressions that have a constant value
               if (isConstantExpression(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             case 've':
               // rule matches expressions that do not have a constant value
               if (!isConstantExpression(node)) {
                 res[0].placeholders[rule.name] = node;
               } else {
                 // mis-match: rule does not encompass current node
                 return [];
               }
               break;
             default:
               throw new Error('Invalid symbol in rule: ' + rule.name);
           }
         }
       } else if (rule instanceof ConstantNode) {
         // Literal constant must match exactly
         if (!equal(rule.value, node.value)) {
           return [];
         }
       } else {
         // Some other node was encountered which we aren't prepared for, so no match
         return [];
       }

       // It's a match!

       // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')
       return res;
     }

     /**
      * Determines whether p and q (and all their children nodes) are identical.
      *
      * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p
      * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q
      * @return {Object} Information about the match, if it exists.
      */
     function _exactMatch(p, q) {
       if (p instanceof ConstantNode && q instanceof ConstantNode) {
         if (!equal(p.value, q.value)) {
           return false;
         }
       } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
         if (p.name !== q.name) {
           return false;
         }
       } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
         if (p instanceof OperatorNode) {
           if (p.op !== q.op || p.fn !== q.fn) {
             return false;
           }
         } else if (p instanceof FunctionNode) {
           if (p.name !== q.name) {
             return false;
           }
         }
         if (p.args.length !== q.args.length) {
           return false;
         }
         for (var i = 0; i < p.args.length; i++) {
           if (!_exactMatch(p.args[i], q.args[i])) {
             return false;
           }
         }
       } else {
         return false;
       }
       return true;
     }
     return simplify;
   });

   var name$s = 'simplifyConstant';
   var dependencies$s = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];
   var createSimplifyConstant = /* #__PURE__ */factory(name$s, dependencies$s, _ref => {
     var {
       typed,
       config,
       mathWithTransform,
       matrix,
       fraction,
       bignumber,
       AccessorNode,
       ArrayNode,
       ConstantNode,
       FunctionNode,
       IndexNode,
       ObjectNode,
       OperatorNode,
       SymbolNode
     } = _ref;
     var {
       isCommutative,
       isAssociative,
       allChildren,
       createMakeNodeFunction
     } = createUtil({
       FunctionNode,
       OperatorNode,
       SymbolNode
     });

     /**
      * simplifyConstant() takes a mathjs expression (either a Node representing
      * a parse tree or a string which it parses to produce a node), and replaces
      * any subexpression of it consisting entirely of constants with the computed
      * value of that subexpression.
      *
      * Syntax:
      *
      *     math.simplifyConstant(expr)
      *     math.simplifyConstant(expr, options)
      *
      * Examples:
      *
      *     math.simplifyConstant('x + 4*3/6')  // Node "x + 2"
      *     math.simplifyConstant('z cos(0)')   // Node "z 1"
      *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node "6.28 t"
      *
      * See also:
      *
      *     simplify, simplifyCore, resolve, derivative
      *
      * @param {Node | string} node
      *     The expression to be simplified
      * @param {Object} options
      *     Simplification options, as per simplify()
      * @return {Node} Returns expression with constant subexpressions evaluated
      */
     var simplifyConstant = typed('simplifyConstant', {
       Node: node => _ensureNode(foldFraction(node, {})),
       'Node, Object': function NodeObject(expr, options) {
         return _ensureNode(foldFraction(expr, options));
       }
     });
     function _removeFractions(thing) {
       if (isFraction(thing)) {
         return thing.valueOf();
       }
       if (thing instanceof Array) {
         return thing.map(_removeFractions);
       }
       if (isMatrix(thing)) {
         return matrix(_removeFractions(thing.valueOf()));
       }
       return thing;
     }
     function _eval(fnname, args, options) {
       try {
         return mathWithTransform[fnname].apply(null, args);
       } catch (ignore) {
         // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions
         args = args.map(_removeFractions);
         return _toNumber(mathWithTransform[fnname].apply(null, args), options);
       }
     }
     var _toNode = typed({
       Fraction: _fractionToNode,
       number: function number(n) {
         if (n < 0) {
           return unaryMinusNode(new ConstantNode(-n));
         }
         return new ConstantNode(n);
       },
       BigNumber: function BigNumber(n) {
         if (n < 0) {
           return unaryMinusNode(new ConstantNode(-n));
         }
         return new ConstantNode(n); // old parameters: (n.toString(), 'number')
       },

       Complex: function Complex(s) {
         throw new Error('Cannot convert Complex number to Node');
       },
       string: function string(s) {
         return new ConstantNode(s);
       },
       Matrix: function Matrix(m) {
         return new ArrayNode(m.valueOf().map(e => _toNode(e)));
       }
     });
     function _ensureNode(thing) {
       if (isNode(thing)) {
         return thing;
       }
       return _toNode(thing);
     }

     // convert a number to a fraction only if it can be expressed exactly,
     // and when both numerator and denominator are small enough
     function _exactFraction(n, options) {
       var exactFractions = options && options.exactFractions !== false;
       if (exactFractions && isFinite(n) && fraction) {
         var f = fraction(n);
         var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default

         if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
           return f;
         }
       }
       return n;
     }

     // Convert numbers to a preferred number type in preference order: Fraction, number, Complex
     // BigNumbers are left alone
     var _toNumber = typed({
       'string, Object': function stringObject(s, options) {
         if (config.number === 'BigNumber') {
           if (bignumber === undefined) {
             noBignumber();
           }
           return bignumber(s);
         } else if (config.number === 'Fraction') {
           if (fraction === undefined) {
             noFraction();
           }
           return fraction(s);
         } else {
           var n = parseFloat(s);
           return _exactFraction(n, options);
         }
       },
       'Fraction, Object': function FractionObject(s, options) {
         return s;
       },
       // we don't need options here

       'BigNumber, Object': function BigNumberObject(s, options) {
         return s;
       },
       // we don't need options here

       'number, Object': function numberObject(s, options) {
         return _exactFraction(s, options);
       },
       'Complex, Object': function ComplexObject(s, options) {
         if (s.im !== 0) {
           return s;
         }
         return _exactFraction(s.re, options);
       },
       'Matrix, Object': function MatrixObject(s, options) {
         return matrix(_exactFraction(s.valueOf()));
       },
       'Array, Object': function ArrayObject(s, options) {
         return s.map(_exactFraction);
       }
     });
     function unaryMinusNode(n) {
       return new OperatorNode('-', 'unaryMinus', [n]);
     }
     function _fractionToNode(f) {
       var n;
       var vn = f.s * f.n;
       if (vn < 0) {
         n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);
       } else {
         n = new ConstantNode(vn);
       }
       if (f.d === 1) {
         return n;
       }
       return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);
     }

     /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */
     function _foldAccessor(obj, index, options) {
       if (!isIndexNode(index)) {
         // don't know what to do with that...
         return new AccessorNode(_ensureNode(obj), _ensureNode(index));
       }
       if (isArrayNode(obj) || isMatrix(obj)) {
         var remainingDims = Array.from(index.dimensions);
         /* We will resolve constant indices one at a time, looking
          * just in the first or second dimensions because (a) arrays
          * of more than two dimensions are likely rare, and (b) pulling
          * out the third or higher dimension would be pretty intricate.
          * The price is that we miss simplifying [..3d array][x,y,1]
          */
         while (remainingDims.length > 0) {
           if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {
             var first = _toNumber(remainingDims.shift().value, options);
             if (isArrayNode(obj)) {
               obj = obj.items[first - 1];
             } else {
               // matrix
               obj = obj.valueOf()[first - 1];
               if (obj instanceof Array) {
                 obj = matrix(obj);
               }
             }
           } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {
             var second = _toNumber(remainingDims[1].value, options);
             var tryItems = [];
             var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
             for (var item of fromItems) {
               if (isArrayNode(item)) {
                 tryItems.push(item.items[second - 1]);
               } else if (isMatrix(obj)) {
                 tryItems.push(item[second - 1]);
               } else {
                 break;
               }
             }
             if (tryItems.length === fromItems.length) {
               if (isArrayNode(obj)) {
                 obj = new ArrayNode(tryItems);
               } else {
                 // matrix
                 obj = matrix(tryItems);
               }
               remainingDims.splice(1, 1);
             } else {
               // extracting slice along 2nd dimension failed, give up
               break;
             }
           } else {
             // neither 1st or 2nd dimension is constant, give up
             break;
           }
         }
         if (remainingDims.length === index.dimensions.length) {
           /* No successful constant indexing */
           return new AccessorNode(_ensureNode(obj), index);
         }
         if (remainingDims.length > 0) {
           /* Indexed some but not all dimensions */
           index = new IndexNode(remainingDims);
           return new AccessorNode(_ensureNode(obj), index);
         }
         /* All dimensions were constant, access completely resolved */
         return obj;
       }
       if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
         var key = index.dimensions[0].value;
         if (key in obj.properties) {
           return obj.properties[key];
         }
         return new ConstantNode(); // undefined
       }
       /* Don't know how to index this sort of obj, at least not with this index */
       return new AccessorNode(_ensureNode(obj), index);
     }

     /*
      * Create a binary tree from a list of Fractions and Nodes.
      * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so
      * `args` should be sorted to have the Fractions at the start (if the operator is commutative).
      * @param args - list of Fractions and Nodes
      * @param fn - evaluator for the binary operation evaluator that accepts two Fractions
      * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes
      * if args.length is 1, returns args[0]
      * @return - Either a Node representing a binary expression or Fraction
      */
     function foldOp(fn, args, makeNode, options) {
       var first = args.shift();

       // In the following reduction, sofar always has one of the three following
       // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]
       var reduction = args.reduce((sofar, next) => {
         if (!isNode(next)) {
           var last = sofar.pop();
           if (isNode(last)) {
             return [last, next];
           }
           // Two constants in a row, try to fold them into one
           try {
             sofar.push(_eval(fn, [last, next], options));
             return sofar;
           } catch (ignoreandcontinue) {
             sofar.push(last);
             // fall through to Node case
           }
         }

         // Encountered a Node, or failed folding --
         // collapse everything so far into a single tree:
         sofar.push(_ensureNode(sofar.pop()));
         var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
         return [makeNode([newtree, _ensureNode(next)])];
       }, [first]);
       if (reduction.length === 1) {
         return reduction[0];
       }
       // Might end up with a tree and a constant at the end:
       return makeNode([reduction[0], _toNode(reduction[1])]);
     }

     // destroys the original node and returns a folded one
     function foldFraction(node, options) {
       switch (node.type) {
         case 'SymbolNode':
           return node;
         case 'ConstantNode':
           switch (typeof node.value) {
             case 'number':
               return _toNumber(node.value, options);
             case 'string':
               return node.value;
             default:
               if (!isNaN(node.value)) return _toNumber(node.value, options);
           }
           return node;
         case 'FunctionNode':
           if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
             return node;
           }
           {
             // Process operators as OperatorNode
             var operatorFunctions = ['add', 'multiply'];
             if (operatorFunctions.indexOf(node.name) === -1) {
               var args = node.args.map(arg => foldFraction(arg, options));

               // If all args are numbers
               if (!args.some(isNode)) {
                 try {
                   return _eval(node.name, args, options);
                 } catch (ignoreandcontinue) {}
               }

               // Size of a matrix does not depend on entries
               if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {
                 var sz = [];
                 var section = args[0];
                 while (isArrayNode(section)) {
                   sz.push(section.items.length);
                   section = section.items[0];
                 }
                 return matrix(sz);
               }

               // Convert all args to nodes and construct a symbolic function call
               return new FunctionNode(node.name, args.map(_ensureNode));
             }
           }
         /* falls through */
         case 'OperatorNode':
           {
             var fn = node.fn.toString();
             var _args;
             var res;
             var makeNode = createMakeNodeFunction(node);
             if (isOperatorNode(node) && node.isUnary()) {
               _args = [foldFraction(node.args[0], options)];
               if (!isNode(_args[0])) {
                 res = _eval(fn, _args, options);
               } else {
                 res = makeNode(_args);
               }
             } else if (isAssociative(node, options.context)) {
               _args = allChildren(node, options.context);
               _args = _args.map(arg => foldFraction(arg, options));
               if (isCommutative(fn, options.context)) {
                 // commutative binary operator
                 var consts = [];
                 var vars = [];
                 for (var i = 0; i < _args.length; i++) {
                   if (!isNode(_args[i])) {
                     consts.push(_args[i]);
                   } else {
                     vars.push(_args[i]);
                   }
                 }
                 if (consts.length > 1) {
                   res = foldOp(fn, consts, makeNode, options);
                   vars.unshift(res);
                   res = foldOp(fn, vars, makeNode, options);
                 } else {
                   // we won't change the children order since it's not neccessary
                   res = foldOp(fn, _args, makeNode, options);
                 }
               } else {
                 // non-commutative binary operator
                 res = foldOp(fn, _args, makeNode, options);
               }
             } else {
               // non-associative binary operator
               _args = node.args.map(arg => foldFraction(arg, options));
               res = foldOp(fn, _args, makeNode, options);
             }
             return res;
           }
         case 'ParenthesisNode':
           // remove the uneccessary parenthesis
           return foldFraction(node.content, options);
         case 'AccessorNode':
           return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
         case 'ArrayNode':
           {
             var foldItems = node.items.map(item => foldFraction(item, options));
             if (foldItems.some(isNode)) {
               return new ArrayNode(foldItems.map(_ensureNode));
             }
             /* All literals -- return a Matrix so we can operate on it */
             return matrix(foldItems);
           }
         case 'IndexNode':
           {
             return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));
           }
         case 'ObjectNode':
           {
             var foldProps = {};
             for (var prop in node.properties) {
               foldProps[prop] = simplifyConstant(node.properties[prop], options);
             }
             return new ObjectNode(foldProps);
           }
         case 'AssignmentNode':
         /* falls through */
         case 'BlockNode':
         /* falls through */
         case 'FunctionAssignmentNode':
         /* falls through */
         case 'RangeNode':
         /* falls through */
         case 'ConditionalNode':
         /* falls through */
         default:
           throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
       }
     }
     return simplifyConstant;
   });

   var name$r = 'simplifyCore';
   var dependencies$r = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];
   var createSimplifyCore = /* #__PURE__ */factory(name$r, dependencies$r, _ref => {
     var {
       typed,
       parse,
       equal,
       isZero,
       add,
       subtract,
       multiply,
       divide,
       pow,
       AccessorNode,
       ArrayNode,
       ConstantNode,
       FunctionNode,
       IndexNode,
       ObjectNode,
       OperatorNode,
       ParenthesisNode,
       SymbolNode
     } = _ref;
     var node0 = new ConstantNode(0);
     var node1 = new ConstantNode(1);
     var nodeT = new ConstantNode(true);
     var nodeF = new ConstantNode(false);
     // test if a node will always have a boolean value (true/false)
     // not sure if this list is complete
     function isAlwaysBoolean(node) {
       return isOperatorNode(node) && ['and', 'not', 'or'].includes(node.op);
     }
     var {
       hasProperty,
       isCommutative
     } = createUtil({
       FunctionNode,
       OperatorNode,
       SymbolNode
     });
     /**
      * simplifyCore() performs single pass simplification suitable for
      * applications requiring ultimate performance. To roughly summarize,
      * it handles cases along the lines of simplifyConstant() but where
      * knowledge of a single argument is sufficient to determine the value.
      * In contrast, simplify() extends simplifyCore() with additional passes
      * to provide deeper simplification (such as gathering like terms).
      *
      * Specifically, simplifyCore:
      *
      * * Converts all function calls with operator equivalents to their
      *   operator forms.
      * * Removes operators or function calls that are guaranteed to have no
      *   effect (such as unary '+').
      * * Removes double unary '-', '~', and 'not'
      * * Eliminates addition/subtraction of 0 and multiplication/division/powers
      *   by 1 or 0.
      * * Converts addition of a negation into subtraction.
      * * Eliminates logical operations with constant true or false leading
      *   arguments.
      * * Puts constants on the left of a product, if multiplication is
      *   considered commutative by the options (which is the default)
      *
      * Syntax:
      *
      *     math.simplifyCore(expr)
      *     math.simplifyCore(expr, options)
      *
      * Examples:
      *
      *     const f = math.parse('2 * 1 * x ^ (1 - 0)')
      *     math.simplifyCore(f)                          // Node "2 * x"
      *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node "2 * x"
      *
      * See also:
      *
      *     simplify, simplifyConstant, resolve, derivative
      *
      * @param {Node | string} node
      *     The expression to be simplified
      * @param {Object} options
      *     Simplification options, as per simplify()
      * @return {Node} Returns expression with basic simplifications applied
      */
     function _simplifyCore(nodeToSimplify) {
       var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
       var context = options ? options.context : undefined;
       if (hasProperty(nodeToSimplify, 'trivial', context)) {
         // This node does nothing if it has only one argument, so if so,
         // return that argument simplified
         if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
           return _simplifyCore(nodeToSimplify.args[0], options);
         }
         // For other node types, we try the generic methods
         var simpChild = false;
         var childCount = 0;
         nodeToSimplify.forEach(c => {
           ++childCount;
           if (childCount === 1) {
             simpChild = _simplifyCore(c, options);
           }
         });
         if (childCount === 1) {
           return simpChild;
         }
       }
       var node = nodeToSimplify;
       if (isFunctionNode(node)) {
         var op = getOperator(node.name);
         if (op) {
           // Replace FunctionNode with a new OperatorNode
           if (node.args.length > 2 && hasProperty(node, 'associative', context)) {
             // unflatten into binary operations since that's what simplifyCore handles
             while (node.args.length > 2) {
               var last = node.args.pop();
               var seclast = node.args.pop();
               node.args.push(new OperatorNode(op, node.name, [last, seclast]));
             }
           }
           node = new OperatorNode(op, node.name, node.args);
         } else {
           return new FunctionNode(_simplifyCore(node.fn), node.args.map(n => _simplifyCore(n, options)));
         }
       }
       if (isOperatorNode(node) && node.isUnary()) {
         var a0 = _simplifyCore(node.args[0], options);
         if (node.op === '~') {
           // bitwise not
           if (isOperatorNode(a0) && a0.isUnary() && a0.op === '~') {
             return a0.args[0];
           }
         }
         if (node.op === 'not') {
           // logical not
           if (isOperatorNode(a0) && a0.isUnary() && a0.op === 'not') {
             // Has the effect of turning the argument into a boolean
             // So can only eliminate the double negation if
             // the inside is already boolean
             if (isAlwaysBoolean(a0.args[0])) {
               return a0.args[0];
             }
           }
         }
         var finish = true;
         if (node.op === '-') {
           // unary minus
           if (isOperatorNode(a0)) {
             if (a0.isBinary() && a0.fn === 'subtract') {
               node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);
               finish = false; // continue to process the new binary node
             }

             if (a0.isUnary() && a0.op === '-') {
               return a0.args[0];
             }
           }
         }
         if (finish) return new OperatorNode(node.op, node.fn, [a0]);
       }
       if (isOperatorNode(node) && node.isBinary()) {
         var _a = _simplifyCore(node.args[0], options);
         var a1 = _simplifyCore(node.args[1], options);
         if (node.op === '+') {
           if (isConstantNode(_a) && isZero(_a.value)) {
             return a1;
           }
           if (isConstantNode(a1) && isZero(a1.value)) {
             return _a;
           }
           if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {
             a1 = a1.args[0];
             node = new OperatorNode('-', 'subtract', [_a, a1]);
           }
         }
         if (node.op === '-') {
           if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {
             return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);
           }
           if (isConstantNode(_a) && isZero(_a.value)) {
             return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));
           }
           if (isConstantNode(a1) && isZero(a1.value)) {
             return _a;
           }
           return new OperatorNode(node.op, node.fn, [_a, a1]);
         }
         if (node.op === '*') {
           if (isConstantNode(_a)) {
             if (isZero(_a.value)) {
               return node0;
             } else if (equal(_a.value, 1)) {
               return a1;
             }
           }
           if (isConstantNode(a1)) {
             if (isZero(a1.value)) {
               return node0;
             } else if (equal(a1.value, 1)) {
               return _a;
             }
             if (isCommutative(node, context)) {
               return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left
             }
           }

           return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
         }
         if (node.op === '/') {
           if (isConstantNode(_a) && isZero(_a.value)) {
             return node0;
           }
           if (isConstantNode(a1) && equal(a1.value, 1)) {
             return _a;
           }
           return new OperatorNode(node.op, node.fn, [_a, a1]);
         }
         if (node.op === '^') {
           if (isConstantNode(a1)) {
             if (isZero(a1.value)) {
               return node1;
             } else if (equal(a1.value, 1)) {
               return _a;
             }
           }
         }
         if (node.op === 'and') {
           if (isConstantNode(_a)) {
             if (_a.value) {
               if (isAlwaysBoolean(a1)) return a1;
             } else {
               return nodeF;
             }
           }
           if (isConstantNode(a1)) {
             if (a1.value) {
               if (isAlwaysBoolean(_a)) return _a;
             } else {
               return nodeF;
             }
           }
         }
         if (node.op === 'or') {
           if (isConstantNode(_a)) {
             if (_a.value) {
               return nodeT;
             } else {
               if (isAlwaysBoolean(a1)) return a1;
             }
           }
           if (isConstantNode(a1)) {
             if (a1.value) {
               return nodeT;
             } else {
               if (isAlwaysBoolean(_a)) return _a;
             }
           }
         }
         return new OperatorNode(node.op, node.fn, [_a, a1]);
       }
       if (isOperatorNode(node)) {
         return new OperatorNode(node.op, node.fn, node.args.map(a => _simplifyCore(a, options)));
       }
       if (isArrayNode(node)) {
         return new ArrayNode(node.items.map(n => _simplifyCore(n, options)));
       }
       if (isAccessorNode(node)) {
         return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
       }
       if (isIndexNode(node)) {
         return new IndexNode(node.dimensions.map(n => _simplifyCore(n, options)));
       }
       if (isObjectNode(node)) {
         var newProps = {};
         for (var prop in node.properties) {
           newProps[prop] = _simplifyCore(node.properties[prop], options);
         }
         return new ObjectNode(newProps);
       }
       // cannot simplify
       return node;
     }
     return typed(name$r, {
       Node: _simplifyCore,
       'Node,Object': _simplifyCore
     });
   });

   var name$q = 'resolve';
   var dependencies$q = ['typed', 'parse', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];
   var createResolve = /* #__PURE__ */factory(name$q, dependencies$q, _ref => {
     var {
       typed,
       parse,
       ConstantNode,
       FunctionNode,
       OperatorNode,
       ParenthesisNode
     } = _ref;
     /**
      * resolve(expr, scope) replaces variable nodes with their scoped values
      *
      * Syntax:
      *
      *     math.resolve(expr, scope)
      *
      * Examples:
      *
      *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'
      *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'
      *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // "6"
      *
      * See also:
      *
      *     simplify, evaluate
      *
      * @param {Node | Node[]} node
      *     The expression tree (or trees) to be simplified
      * @param {Object} scope
      *     Scope specifying variables to be resolved
      * @return {Node | Node[]} Returns `node` with variables recursively substituted.
      * @throws {ReferenceError}
      *     If there is a cyclic dependency among the variables in `scope`,
      *     resolution is impossible and a ReferenceError is thrown.
      */
     function _resolve(node, scope) {
       var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
       // note `within`:
       // `within` is not documented, since it is for internal cycle
       // detection only
       if (!scope) {
         return node;
       }
       if (isSymbolNode(node)) {
         if (within.has(node.name)) {
           var variables = Array.from(within).join(', ');
           throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
         }
         var value = scope.get(node.name);
         if (isNode(value)) {
           var nextWithin = new Set(within);
           nextWithin.add(node.name);
           return _resolve(value, scope, nextWithin);
         } else if (typeof value === 'number') {
           return parse(String(value));
         } else if (value !== undefined) {
           return new ConstantNode(value);
         } else {
           return node;
         }
       } else if (isOperatorNode(node)) {
         var args = node.args.map(function (arg) {
           return _resolve(arg, scope, within);
         });
         return new OperatorNode(node.op, node.fn, args, node.implicit);
       } else if (isParenthesisNode(node)) {
         return new ParenthesisNode(_resolve(node.content, scope, within));
       } else if (isFunctionNode(node)) {
         var _args = node.args.map(function (arg) {
           return _resolve(arg, scope, within);
         });
         return new FunctionNode(node.name, _args);
       }

       // Otherwise just recursively resolve any children (might also work
       // for some of the above special cases)
       return node.map(child => _resolve(child, scope, within));
     }
     return typed('resolve', {
       Node: _resolve,
       'Node, Map | null | undefined': _resolve,
       'Node, Object': (n, scope) => _resolve(n, createMap$1(scope)),
       // For arrays and matrices, we map `self` rather than `_resolve`
       // because resolve is fairly expensive anyway, and this way
       // we get nice error messages if one entry in the array has wrong type.
       'Array | Matrix': typed.referToSelf(self => A => A.map(n => self(n))),
       'Array | Matrix, null | undefined': typed.referToSelf(self => A => A.map(n => self(n))),
       'Array, Object': typed.referTo('Array,Map', selfAM => (A, scope) => selfAM(A, createMap$1(scope))),
       'Matrix, Object': typed.referTo('Matrix,Map', selfMM => (A, scope) => selfMM(A, createMap$1(scope))),
       'Array | Matrix, Map': typed.referToSelf(self => (A, scope) => A.map(n => self(n, scope)))
     });
   });

   var name$p = 'symbolicEqual';
   var dependencies$p = ['parse', 'simplify', 'typed', 'OperatorNode'];
   var createSymbolicEqual = /* #__PURE__ */factory(name$p, dependencies$p, _ref => {
     var {
       parse,
       simplify,
       typed,
       OperatorNode
     } = _ref;
     /**
      * Attempts to determine if two expressions are symbolically equal, i.e.
      * one is the result of valid algebraic manipulations on the other.
      * Currently, this simply checks if the difference of the two expressions
      * simplifies down to 0. So there are two important caveats:
      * 1. whether two expressions are symbolically equal depends on the
      *     manipulations allowed. Therefore, this function takes an optional
      *     third argument, which are the options that control the behavior
      *     as documented for the `simplify()` function.
      * 2. it is in general intractable to find the minimal simplification of
      *     an arbitrarily complicated expression. So while a `true` value
      *     of `symbolicEqual` ensures that the two expressions can be manipulated
      *     to match each other, a `false` value does not absolutely rule this out.
      *
      * Syntax:
      *
      *     math.symbolicEqual(expr1, expr2)
      *     math.symbolicEqual(expr1, expr2, options)
      *
      * Examples:
      *
      *     math.symbolicEqual('x*y', 'y*x') // Returns true
      *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false
      *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true
      *     math.symbolicEqual('abs(x)','x') // Returns false
      *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true
      *
      * See also:
      *
      *     simplify, evaluate
      *
      * @param {Node|string} expr1  The first expression to compare
      * @param {Node|string} expr2  The second expression to compare
      * @param {Object} [options] Optional option object, passed to simplify
      * @returns {boolean}
      *     Returns true if a valid manipulation making the expressions equal
      *     is found.
      */
     function _symbolicEqual(e1, e2) {
       var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
       var diff = new OperatorNode('-', 'subtract', [e1, e2]);
       var simplified = simplify(diff, {}, options);
       return isConstantNode(simplified) && !simplified.value;
     }
     return typed(name$p, {
       'Node, Node': _symbolicEqual,
       'Node, Node, Object': _symbolicEqual
     });
   });

   var name$o = 'derivative';
   var dependencies$o = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];
   var createDerivative = /* #__PURE__ */factory(name$o, dependencies$o, _ref => {
     var {
       typed,
       config,
       parse,
       simplify,
       equal,
       isZero,
       numeric,
       ConstantNode,
       FunctionNode,
       OperatorNode,
       ParenthesisNode,
       SymbolNode
     } = _ref;
     /**
      * Takes the derivative of an expression expressed in parser Nodes.
      * The derivative will be taken over the supplied variable in the
      * second parameter. If there are multiple variables in the expression,
      * it will return a partial derivative.
      *
      * This uses rules of differentiation which can be found here:
      *
      * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)
      *
      * Syntax:
      *
      *     math.derivative(expr, variable)
      *     math.derivative(expr, variable, options)
      *
      * Examples:
      *
      *     math.derivative('x^2', 'x')                     // Node '2 * x'
      *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'
      *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'
      *     math.derivative('2*x', 'x').evaluate()          // number 2
      *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8
      *     const f = math.parse('x^2')
      *     const x = math.parse('x')
      *     math.derivative(f, x)                           // Node {2 * x}
      *
      * See also:
      *
      *     simplify, parse, evaluate
      *
      * @param  {Node | string} expr           The expression to differentiate
      * @param  {SymbolNode | string} variable The variable over which to differentiate
      * @param  {{simplify: boolean}} [options]
      *                         There is one option available, `simplify`, which
      *                         is true by default. When false, output will not
      *                         be simplified.
      * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
      */
     function plainDerivative(expr, variable) {
       var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
         simplify: true
       };
       var constNodes = {};
       constTag(constNodes, expr, variable.name);
       var res = _derivative(expr, constNodes);
       return options.simplify ? simplify(res) : res;
     }
     typed.addConversion({
       from: 'identifier',
       to: 'SymbolNode',
       convert: parse
     });
     var derivative = typed(name$o, {
       'Node, SymbolNode': plainDerivative,
       'Node, SymbolNode, Object': plainDerivative

       /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
       'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
         let res = expr
         for (let i = 0; i < order; i++) {
           let constNodes = {}
           constTag(constNodes, expr, variable.name)
           res = _derivative(res, constNodes)
         }
         return res
       }
       */
     });

     typed.removeConversion({
       from: 'identifier',
       to: 'SymbolNode',
       convert: parse
     });
     derivative._simplify = true;
     derivative.toTex = function (deriv) {
       return _derivTex.apply(null, deriv.args);
     };

     // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.
     // NOTE: the optional "order" parameter here is currently unused
     var _derivTex = typed('_derivTex', {
       'Node, SymbolNode': function NodeSymbolNode(expr, x) {
         if (isConstantNode(expr) && typeOf$1(expr.value) === 'string') {
           return _derivTex(parse(expr.value).toString(), x.toString(), 1);
         } else {
           return _derivTex(expr.toTex(), x.toString(), 1);
         }
       },
       'Node, ConstantNode': function NodeConstantNode(expr, x) {
         if (typeOf$1(x.value) === 'string') {
           return _derivTex(expr, parse(x.value));
         } else {
           throw new Error("The second parameter to 'derivative' is a non-string constant");
         }
       },
       'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {
         return _derivTex(expr.toString(), x.name, order.value);
       },
       'string, string, number': function stringStringNumber(expr, x, order) {
         var d;
         if (order === 1) {
           d = '{d\\over d' + x + '}';
         } else {
           d = '{d^{' + order + '}\\over d' + x + '^{' + order + '}}';
         }
         return d + "\\left[".concat(expr, "\\right]");
       }
     });

     /**
      * Does a depth-first search on the expression tree to identify what Nodes
      * are constants (e.g. 2 + 2), and stores the ones that are constants in
      * constNodes. Classification is done as follows:
      *
      *   1. ConstantNodes are constants.
      *   2. If there exists a SymbolNode, of which we are differentiating over,
      *      in the subtree it is not constant.
      *
      * @param  {Object} constNodes  Holds the nodes that are constant
      * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
      * @param  {string} varName     Variable that we are differentiating
      * @return {boolean}  if node is constant
      */
     // TODO: can we rewrite constTag into a pure function?
     var constTag = typed('constTag', {
       'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {
         constNodes[node] = true;
         return true;
       },
       'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {
         // Treat other variables like constants. For reasoning, see:
         //   https://en.wikipedia.org/wiki/Partial_derivative
         if (node.name !== varName) {
           constNodes[node] = true;
           return true;
         }
         return false;
       },
       'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {
         return constTag(constNodes, node.content, varName);
       },
       'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
         if (node.params.indexOf(varName) === -1) {
           constNodes[node] = true;
           return true;
         }
         return constTag(constNodes, node.expr, varName);
       },
       'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
         if (node.args.length > 0) {
           var isConst = constTag(constNodes, node.args[0], varName);
           for (var i = 1; i < node.args.length; ++i) {
             isConst = constTag(constNodes, node.args[i], varName) && isConst;
           }
           if (isConst) {
             constNodes[node] = true;
             return true;
           }
         }
         return false;
       }
     });

     /**
      * Applies differentiation rules.
      *
      * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
      * @param  {Object} constNodes  Holds the nodes that are constant
      * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
      */
     var _derivative = typed('_derivative', {
       'ConstantNode, Object': function ConstantNodeObject(node) {
         return createConstantNode(0);
       },
       'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {
         if (constNodes[node] !== undefined) {
           return createConstantNode(0);
         }
         return createConstantNode(1);
       },
       'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {
         return new ParenthesisNode(_derivative(node.content, constNodes));
       },
       'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {
         if (constNodes[node] !== undefined) {
           return createConstantNode(0);
         }
         return _derivative(node.expr, constNodes);
       },
       'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {
         if (node.args.length !== 1) {
           funcArgsCheck(node);
         }
         if (constNodes[node] !== undefined) {
           return createConstantNode(0);
         }
         var arg0 = node.args[0];
         var arg1;
         var div = false; // is output a fraction?
         var negative = false; // is output negative?

         var funcDerivative;
         switch (node.name) {
           case 'cbrt':
             // d/dx(cbrt(x)) = 1 / (3x^(2/3))
             div = true;
             funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);
             break;
           case 'sqrt':
           case 'nthRoot':
             // d/dx(sqrt(x)) = 1 / (2*sqrt(x))
             if (node.args.length === 1) {
               div = true;
               funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);
             } else if (node.args.length === 2) {
               // Rearrange from nthRoot(x, a) -> x^(1/a)
               arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]);

               // Is a variable?
               constNodes[arg1] = constNodes[node.args[1]];
               return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);
             }
             break;
           case 'log10':
             arg1 = createConstantNode(10);
           /* fall through! */
           case 'log':
             if (!arg1 && node.args.length === 1) {
               // d/dx(log(x)) = 1 / x
               funcDerivative = arg0.clone();
               div = true;
             } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {
               // d/dx(log(x, c)) = 1 / (x*ln(c))
               funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);
               div = true;
             } else if (node.args.length === 2) {
               // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))
               return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);
             }
             break;
           case 'pow':
             constNodes[arg1] = constNodes[node.args[1]];
             // Pass to pow operator node parser
             return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);
           case 'exp':
             // d/dx(e^x) = e^x
             funcDerivative = new FunctionNode('exp', [arg0.clone()]);
             break;
           case 'sin':
             // d/dx(sin(x)) = cos(x)
             funcDerivative = new FunctionNode('cos', [arg0.clone()]);
             break;
           case 'cos':
             // d/dx(cos(x)) = -sin(x)
             funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);
             break;
           case 'tan':
             // d/dx(tan(x)) = sec(x)^2
             funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);
             break;
           case 'sec':
             // d/dx(sec(x)) = sec(x)tan(x)
             funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);
             break;
           case 'csc':
             // d/dx(csc(x)) = -csc(x)cot(x)
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);
             break;
           case 'cot':
             // d/dx(cot(x)) = -csc(x)^2
             negative = true;
             funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);
             break;
           case 'asin':
             // d/dx(asin(x)) = 1 / sqrt(1 - x^2)
             div = true;
             funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);
             break;
           case 'acos':
             // d/dx(acos(x)) = -1 / sqrt(1 - x^2)
             div = true;
             negative = true;
             funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);
             break;
           case 'atan':
             // d/dx(atan(x)) = 1 / (x^2 + 1)
             div = true;
             funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
             break;
           case 'asec':
             // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))
             div = true;
             funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
             break;
           case 'acsc':
             // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))
             div = true;
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
             break;
           case 'acot':
             // d/dx(acot(x)) = -1 / (x^2 + 1)
             div = true;
             negative = true;
             funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
             break;
           case 'sinh':
             // d/dx(sinh(x)) = cosh(x)
             funcDerivative = new FunctionNode('cosh', [arg0.clone()]);
             break;
           case 'cosh':
             // d/dx(cosh(x)) = sinh(x)
             funcDerivative = new FunctionNode('sinh', [arg0.clone()]);
             break;
           case 'tanh':
             // d/dx(tanh(x)) = sech(x)^2
             funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);
             break;
           case 'sech':
             // d/dx(sech(x)) = -sech(x)tanh(x)
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);
             break;
           case 'csch':
             // d/dx(csch(x)) = -csch(x)coth(x)
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);
             break;
           case 'coth':
             // d/dx(coth(x)) = -csch(x)^2
             negative = true;
             funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);
             break;
           case 'asinh':
             // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)
             div = true;
             funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
             break;
           case 'acosh':
             // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)
             div = true;
             funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
             break;
           case 'atanh':
             // d/dx(atanh(x)) = 1 / (1 - x^2)
             div = true;
             funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);
             break;
           case 'asech':
             // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))
             div = true;
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);
             break;
           case 'acsch':
             // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))
             div = true;
             negative = true;
             funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
             break;
           case 'acoth':
             // d/dx(acoth(x)) = -1 / (1 - x^2)
             div = true;
             negative = true;
             funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);
             break;
           case 'abs':
             // d/dx(abs(x)) = abs(x)/x
             funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);
             break;
           case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)
           default:
             throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
         }
         var op, func;
         if (div) {
           op = '/';
           func = 'divide';
         } else {
           op = '*';
           func = 'multiply';
         }

         /* Apply chain rule to all functions:
            F(x)  = f(g(x))
            F'(x) = g'(x)*f'(g(x)) */
         var chainDerivative = _derivative(arg0, constNodes);
         if (negative) {
           chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);
         }
         return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
       },
       'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {
         if (constNodes[node] !== undefined) {
           return createConstantNode(0);
         }
         if (node.op === '+') {
           // d/dx(sum(f(x)) = sum(f'(x))
           return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {
             return _derivative(arg, constNodes);
           }));
         }
         if (node.op === '-') {
           // d/dx(+/-f(x)) = +/-f'(x)
           if (node.isUnary()) {
             return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
           }

           // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)
           if (node.isBinary()) {
             return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
           }
         }
         if (node.op === '*') {
           // d/dx(c*f(x)) = c*f'(x)
           var constantTerms = node.args.filter(function (arg) {
             return constNodes[arg] !== undefined;
           });
           if (constantTerms.length > 0) {
             var nonConstantTerms = node.args.filter(function (arg) {
               return constNodes[arg] === undefined;
             });
             var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);
             var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
             return new OperatorNode('*', 'multiply', newArgs);
           }

           // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)
           return new OperatorNode('+', 'add', node.args.map(function (argOuter) {
             return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {
               return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
             }));
           }));
         }
         if (node.op === '/' && node.isBinary()) {
           var arg0 = node.args[0];
           var arg1 = node.args[1];

           // d/dx(f(x) / c) = f'(x) / c
           if (constNodes[arg1] !== undefined) {
             return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);
           }

           // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)
           if (constNodes[arg0] !== undefined) {
             return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);
           }

           // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2
           return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);
         }
         if (node.op === '^' && node.isBinary()) {
           var _arg = node.args[0];
           var _arg2 = node.args[1];
           if (constNodes[_arg] !== undefined) {
             // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1
             if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
               return createConstantNode(0);
             }

             // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)
             return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
           }
           if (constNodes[_arg2] !== undefined) {
             if (isConstantNode(_arg2)) {
               // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0
               if (isZero(_arg2.value)) {
                 return createConstantNode(0);
               }
               // Ignore exponent; f(x)^1 = f(x)
               if (equal(_arg2.value, 1)) {
                 return _derivative(_arg, constNodes);
               }
             }

             // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)
             var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);
             return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);
           }

           // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]
           return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);
         }
         throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
       }
     });

     /**
      * Ensures the number of arguments for a function are correct,
      * and will throw an error otherwise.
      *
      * @param {FunctionNode} node
      */
     function funcArgsCheck(node) {
       // TODO add min, max etc
       if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {
         return;
       }

       // There should be an incorrect number of arguments if we reach here

       // Change all args to constants to avoid unidentified
       // symbol error when compiling function
       for (var i = 0; i < node.args.length; ++i) {
         node.args[i] = createConstantNode(0);
       }
       node.compile().evaluate();
       throw new Error('Expected TypeError, but none found');
     }

     /**
      * Helper function to create a constant node with a specific type
      * (number, BigNumber, Fraction)
      * @param {number} value
      * @param {string} [valueType]
      * @return {ConstantNode}
      */
     function createConstantNode(value, valueType) {
       return new ConstantNode(numeric(value, valueType || config.number));
     }
     return derivative;
   });

   var name$n = 'rationalize';
   var dependencies$n = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplifyConstant', 'simplifyCore', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode', 'ParenthesisNode'];
   var createRationalize = /* #__PURE__ */factory(name$n, dependencies$n, _ref => {
     var {
       config,
       typed,
       equal,
       isZero,
       add,
       subtract,
       multiply,
       divide,
       pow,
       parse,
       simplifyConstant,
       simplifyCore,
       simplify,
       fraction,
       bignumber,
       mathWithTransform,
       matrix,
       AccessorNode,
       ArrayNode,
       ConstantNode,
       FunctionNode,
       IndexNode,
       ObjectNode,
       OperatorNode,
       SymbolNode,
       ParenthesisNode
     } = _ref;
     /**
      * Transform a rationalizable expression in a rational fraction.
      * If rational fraction is one variable polynomial then converts
      * the numerator and denominator in canonical form, with decreasing
      * exponents, returning the coefficients of numerator.
      *
      * Syntax:
      *
      *     math.rationalize(expr)
      *     math.rationalize(expr, detailed)
      *     math.rationalize(expr, scope)
      *     math.rationalize(expr, scope, detailed)
      *
      * Examples:
      *
      *     math.rationalize('sin(x)+y')
      *                   //  Error: There is an unsolved function call
      *     math.rationalize('2x/y - y/(x+1)')
      *                   // (2*x^2-y^2+2*x)/(x*y+y)
      *     math.rationalize('(2x+1)^6')
      *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
      *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
      *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)
      *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =
      *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/
      *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)
      *
      *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1
      *     math.rationalize('x+x+x+y',{})    // 3*x+y
      *
      *     const ret = math.rationalize('x+x+x+y',{},true)
      *                   // ret.expression=3*x+y, ret.variables = ["x","y"]
      *     const ret = math.rationalize('-2+5x^2',{},true)
      *                   // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]
      *
      * See also:
      *
      *     simplify
      *
      * @param  {Node|string} expr    The expression to check if is a polynomial expression
      * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input
      * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)
      *
      * @return {Object | Node}    The rational polynomial of `expr` or an object
      *            `{expression, numerator, denominator, variables, coefficients}`, where
      *              `expression` is a `Node` with the node simplified expression,
      *              `numerator` is a `Node` with the simplified numerator of expression,
      *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),
      *              `variables` is an array with variable names,
      *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent
      *           {Expression Node}  node simplified expression
      *
      */
     function _rationalize(expr) {
       var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
       var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
       var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form
       var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial
       var nVars = polyRet.variables.length;
       var noExactFractions = {
         exactFractions: false
       };
       var withExactFractions = {
         exactFractions: true
       };
       expr = polyRet.expression;
       if (nVars >= 1) {
         // If expression in not a constant
         expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)
         var sBefore; // Previous expression
         var rules;
         var eDistrDiv = true;
         var redoInic = false;
         // Apply the initial rules, including succ div rules:
         expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
         var s;
         while (true) {
           // Alternate applying successive division rules and distr.div.rules
           // until there are no more changes:
           rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
           expr = simplify(expr, rules, {}, withExactFractions);
           eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules

           s = expr.toString();
           if (s === sBefore) {
             break; // No changes : end of the loop
           }

           redoInic = true;
           sBefore = s;
         }
         if (redoInic) {
           // Apply first rules again without succ div rules (if there are changes)
           expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
         }
         // Apply final rules:
         expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
       } // NVars >= 1

       var coefficients = [];
       var retRationalize = {};
       if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {
         // Separate numerator from denominator
         if (nVars === 1) {
           expr.args[0] = polyToCanonical(expr.args[0], coefficients);
           expr.args[1] = polyToCanonical(expr.args[1]);
         }
         if (detailed) {
           retRationalize.numerator = expr.args[0];
           retRationalize.denominator = expr.args[1];
         }
       } else {
         if (nVars === 1) {
           expr = polyToCanonical(expr, coefficients);
         }
         if (detailed) {
           retRationalize.numerator = expr;
           retRationalize.denominator = null;
         }
       }
       // nVars

       if (!detailed) return expr;
       retRationalize.coefficients = coefficients;
       retRationalize.variables = polyRet.variables;
       retRationalize.expression = expr;
       return retRationalize;
     }
     return typed(name$n, {
       Node: _rationalize,
       'Node, boolean': (expr, detailed) => _rationalize(expr, {}, detailed),
       'Node, Object': _rationalize,
       'Node, Object, boolean': _rationalize
     }); // end of typed rationalize

     /**
      *  Function to simplify an expression using an optional scope and
      *  return it if the expression is a polynomial expression, i.e.
      *  an expression with one or more variables and the operators
      *  +, -, *, and ^, where the exponent can only be a positive integer.
      *
      * Syntax:
      *
      *     polynomial(expr,scope,extended, rules)
      *
      * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression
      * @param  {object} scope           Optional scope for expression simplification
      * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.
      * @param  {array}  rules           Optional. Default is no rule.
      *
      *
      * @return {Object}
      *            {Object} node:   node simplified expression
      *            {Array}  variables:  variable names
      */
     function polynomial(expr, scope, extended, rules) {
       var variables = [];
       var node = simplify(expr, rules, scope, {
         exactFractions: false
       }); // Resolves any variables and functions with all defined parameters
       extended = !!extended;
       var oper = '+-*' + (extended ? '/' : '');
       recPoly(node);
       var retFunc = {};
       retFunc.expression = node;
       retFunc.variables = variables;
       return retFunc;

       // -------------------------------------------------------------------------------------------------------

       /**
        *  Function to simplify an expression using an optional scope and
        *  return it if the expression is a polynomial expression, i.e.
        *  an expression with one or more variables and the operators
        *  +, -, *, and ^, where the exponent can only be a positive integer.
        *
        * Syntax:
        *
        *     recPoly(node)
        *
        *
        * @param  {Node} node               The current sub tree expression in recursion
        *
        * @return                           nothing, throw an exception if error
        */
       function recPoly(node) {
         var tp = node.type; // node type
         if (tp === 'FunctionNode') {
           // No function call in polynomial expression
           throw new Error('There is an unsolved function call');
         } else if (tp === 'OperatorNode') {
           if (node.op === '^') {
             // TODO: handle negative exponents like in '1/x^(-2)'
             if (node.args[1].type !== 'ConstantNode' || !isInteger$1(parseFloat(node.args[1].value))) {
               throw new Error('There is a non-integer exponent');
             } else {
               recPoly(node.args[0]);
             }
           } else {
             if (oper.indexOf(node.op) === -1) {
               throw new Error('Operator ' + node.op + ' invalid in polynomial expression');
             }
             for (var i = 0; i < node.args.length; i++) {
               recPoly(node.args[i]);
             }
           } // type of operator
         } else if (tp === 'SymbolNode') {
           var _name = node.name; // variable name
           var pos = variables.indexOf(_name);
           if (pos === -1) {
             // new variable in expression
             variables.push(_name);
           }
         } else if (tp === 'ParenthesisNode') {
           recPoly(node.content);
         } else if (tp !== 'ConstantNode') {
           throw new Error('type ' + tp + ' is not allowed in polynomial expression');
         }
       } // end of recPoly
     } // end of polynomial

     // ---------------------------------------------------------------------------------------
     /**
      * Return a rule set to rationalize an polynomial expression in rationalize
      *
      * Syntax:
      *
      *     rulesRationalize()
      *
      * @return {array}        rule set to rationalize an polynomial expression
      */
     function rulesRationalize() {
       var oldRules = [simplifyCore,
       // sCore
       {
         l: 'n+n',
         r: '2*n'
       }, {
         l: 'n+-n',
         r: '0'
       }, simplifyConstant,
       // sConstant
       {
         l: 'n*(n1^-1)',
         r: 'n/n1'
       }, {
         l: 'n*n1^-n2',
         r: 'n/n1^n2'
       }, {
         l: 'n1^-1',
         r: '1/n1'
       }, {
         l: 'n*(n1/n2)',
         r: '(n*n1)/n2'
       }, {
         l: '1*n',
         r: 'n'
       }];
       var rulesFirst = [{
         l: '(-n1)/(-n2)',
         r: 'n1/n2'
       },
       // Unary division
       {
         l: '(-n1)*(-n2)',
         r: 'n1*n2'
       },
       // Unary multiplication
       {
         l: 'n1--n2',
         r: 'n1+n2'
       },
       // '--' elimination
       {
         l: 'n1-n2',
         r: 'n1+(-n2)'
       },
       // Subtraction turn into add with un�ry minus
       {
         l: '(n1+n2)*n3',
         r: '(n1*n3 + n2*n3)'
       },
       // Distributive 1
       {
         l: 'n1*(n2+n3)',
         r: '(n1*n2+n1*n3)'
       },
       // Distributive 2
       {
         l: 'c1*n + c2*n',
         r: '(c1+c2)*n'
       },
       // Joining constants
       {
         l: 'c1*n + n',
         r: '(c1+1)*n'
       },
       // Joining constants
       {
         l: 'c1*n - c2*n',
         r: '(c1-c2)*n'
       },
       // Joining constants
       {
         l: 'c1*n - n',
         r: '(c1-1)*n'
       },
       // Joining constants
       {
         l: 'v/c',
         r: '(1/c)*v'
       },
       // variable/constant (new!)
       {
         l: 'v/-c',
         r: '-(1/c)*v'
       },
       // variable/constant (new!)
       {
         l: '-v*-c',
         r: 'c*v'
       },
       // Inversion constant and variable 1
       {
         l: '-v*c',
         r: '-c*v'
       },
       // Inversion constant and variable 2
       {
         l: 'v*-c',
         r: '-c*v'
       },
       // Inversion constant and variable 3
       {
         l: 'v*c',
         r: 'c*v'
       },
       // Inversion constant and variable 4
       {
         l: '-(-n1*n2)',
         r: '(n1*n2)'
       },
       // Unary propagation
       {
         l: '-(n1*n2)',
         r: '(-n1*n2)'
       },
       // Unary propagation
       {
         l: '-(-n1+n2)',
         r: '(n1-n2)'
       },
       // Unary propagation
       {
         l: '-(n1+n2)',
         r: '(-n1-n2)'
       },
       // Unary propagation
       {
         l: '(n1^n2)^n3',
         r: '(n1^(n2*n3))'
       },
       // Power to Power
       {
         l: '-(-n1/n2)',
         r: '(n1/n2)'
       },
       // Division and Unary
       {
         l: '-(n1/n2)',
         r: '(-n1/n2)'
       }]; // Divisao and Unary

       var rulesDistrDiv = [{
         l: '(n1/n2 + n3/n4)',
         r: '((n1*n4 + n3*n2)/(n2*n4))'
       },
       // Sum of fractions
       {
         l: '(n1/n2 + n3)',
         r: '((n1 + n3*n2)/n2)'
       },
       // Sum fraction with number 1
       {
         l: '(n1 + n2/n3)',
         r: '((n1*n3 + n2)/n3)'
       }]; // Sum fraction with number 1

       var rulesSucDiv = [{
         l: '(n1/(n2/n3))',
         r: '((n1*n3)/n2)'
       },
       // Division simplification
       {
         l: '(n1/n2/n3)',
         r: '(n1/(n2*n3))'
       }];
       var setRules = {}; // rules set in 4 steps.

       // All rules => infinite loop
       // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)

       setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set
       setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules
       setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules
       setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.

       // Division simplification

       // Second rule set.
       // There is no aggregate expression with parentesis, but the only variable can be scattered.
       setRules.finalRules = [simplifyCore,
       // simplify.rules[0]
       {
         l: 'n*-n',
         r: '-n^2'
       },
       // Joining multiply with power 1
       {
         l: 'n*n',
         r: 'n^2'
       },
       // Joining multiply with power 2
       simplifyConstant,
       // simplify.rules[14] old 3rd index in oldRules
       {
         l: 'n*-n^n1',
         r: '-n^(n1+1)'
       },
       // Joining multiply with power 3
       {
         l: 'n*n^n1',
         r: 'n^(n1+1)'
       },
       // Joining multiply with power 4
       {
         l: 'n^n1*-n^n2',
         r: '-n^(n1+n2)'
       },
       // Joining multiply with power 5
       {
         l: 'n^n1*n^n2',
         r: 'n^(n1+n2)'
       },
       // Joining multiply with power 6
       {
         l: 'n^n1*-n',
         r: '-n^(n1+1)'
       },
       // Joining multiply with power 7
       {
         l: 'n^n1*n',
         r: 'n^(n1+1)'
       },
       // Joining multiply with power 8
       {
         l: 'n^n1/-n',
         r: '-n^(n1-1)'
       },
       // Joining multiply with power 8
       {
         l: 'n^n1/n',
         r: 'n^(n1-1)'
       },
       // Joining division with power 1
       {
         l: 'n/-n^n1',
         r: '-n^(1-n1)'
       },
       // Joining division with power 2
       {
         l: 'n/n^n1',
         r: 'n^(1-n1)'
       },
       // Joining division with power 3
       {
         l: 'n^n1/-n^n2',
         r: 'n^(n1-n2)'
       },
       // Joining division with power 4
       {
         l: 'n^n1/n^n2',
         r: 'n^(n1-n2)'
       },
       // Joining division with power 5
       {
         l: 'n1+(-n2*n3)',
         r: 'n1-n2*n3'
       },
       // Solving useless parenthesis 1
       {
         l: 'v*(-c)',
         r: '-c*v'
       },
       // Solving useless unary 2
       {
         l: 'n1+-n2',
         r: 'n1-n2'
       },
       // Solving +- together (new!)
       {
         l: 'v*c',
         r: 'c*v'
       },
       // inversion constant with variable
       {
         l: '(n1^n2)^n3',
         r: '(n1^(n2*n3))'
       } // Power to Power
       ];

       return setRules;
     } // End rulesRationalize

     // ---------------------------------------------------------------------------------------
     /**
      *  Expand recursively a tree node for handling with expressions with exponents
      *  (it's not for constants, symbols or functions with exponents)
      *  PS: The other parameters are internal for recursion
      *
      * Syntax:
      *
      *     expandPower(node)
      *
      * @param  {Node} node         Current expression node
      * @param  {node} parent       Parent current node inside the recursion
      * @param  (int}               Parent number of chid inside the rercursion
      *
      * @return {node}        node expression with all powers expanded.
      */
     function expandPower(node, parent, indParent) {
       var tp = node.type;
       var internal = arguments.length > 1; // TRUE in internal calls

       if (tp === 'OperatorNode' && node.isBinary()) {
         var does = false;
         var val;
         if (node.op === '^') {
           // First operator: Parenthesis or UnaryMinus
           if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {
             // Second operator: Constant
             val = parseFloat(node.args[1].value);
             does = val >= 2 && isInteger$1(val);
           }
         }
         if (does) {
           // Exponent >= 2
           // Before:
           //            operator A --> Subtree
           // parent pow
           //            constant
           //
           if (val > 2) {
             // Exponent > 2,
             // AFTER:  (exponent > 2)
             //             operator A --> Subtree
             // parent  *
             //                 deep clone (operator A --> Subtree
             //             pow
             //                 constant - 1
             //
             var nEsqTopo = node.args[0];
             var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
             node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);
           } else {
             // Expo = 2 - no power
             // AFTER:  (exponent =  2)
             //             operator A --> Subtree
             // parent   oper
             //            deep clone (operator A --> Subtree)
             //
             node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);
           }
           if (internal) {
             // Change parent references in internal recursive calls
             if (indParent === 'content') {
               parent.content = node;
             } else {
               parent.args[indParent] = node;
             }
           }
         } // does
       } // binary OperatorNode

       if (tp === 'ParenthesisNode') {
         // Recursion
         expandPower(node.content, node, 'content');
       } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {
         for (var i = 0; i < node.args.length; i++) {
           expandPower(node.args[i], node, i);
         }
       }
       if (!internal) {
         // return the root node
         return node;
       }
     } // End expandPower

     // ---------------------------------------------------------------------------------------
     /**
      * Auxilary function for rationalize
      * Convert near canonical polynomial in one variable in a canonical polynomial
      * with one term for each exponent in decreasing order
      *
      * Syntax:
      *
      *     polyToCanonical(node [, coefficients])
      *
      * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression
      *
      *        The string or tree expression needs to be at below syntax, with free spaces:
      *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+
      *       Where 'var' is one variable with any valid name
      *             'cte' are real numeric constants with any value. It can be omitted if equal than 1
      *             'expo' are integers greater than 0. It can be omitted if equal than 1.
      *
      * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent
      *
      *
      * @return {node}        new node tree with one variable polynomial or string error.
      */
     function polyToCanonical(node, coefficients) {
       if (coefficients === undefined) {
         coefficients = [];
       } // coefficients.

       coefficients[0] = 0; // index is the exponent
       var o = {};
       o.cte = 1;
       o.oper = '+';

       // fire: mark with * or ^ when finds * or ^ down tree, reset to "" with + and -.
       //       It is used to deduce the exponent: 1 for *, 0 for "".
       o.fire = '';
       var maxExpo = 0; // maximum exponent
       var varname = ''; // variable name

       recurPol(node, null, o);
       maxExpo = coefficients.length - 1;
       var first = true;
       var no;
       for (var i = maxExpo; i >= 0; i--) {
         if (coefficients[i] === 0) continue;
         var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
         var op = coefficients[i] < 0 ? '-' : '+';
         if (i > 0) {
           // Is not a constant without variable
           var n2 = new SymbolNode(varname);
           if (i > 1) {
             var n3 = new ConstantNode(i);
             n2 = new OperatorNode('^', 'pow', [n2, n3]);
           }
           if (coefficients[i] === -1 && first) {
             n1 = new OperatorNode('-', 'unaryMinus', [n2]);
           } else if (Math.abs(coefficients[i]) === 1) {
             n1 = n2;
           } else {
             n1 = new OperatorNode('*', 'multiply', [n1, n2]);
           }
         }
         if (first) {
           no = n1;
         } else if (op === '+') {
           no = new OperatorNode('+', 'add', [no, n1]);
         } else {
           no = new OperatorNode('-', 'subtract', [no, n1]);
         }
         first = false;
       } // for

       if (first) {
         return new ConstantNode(0);
       } else {
         return no;
       }

       /**
        * Recursive auxilary function inside polyToCanonical for
        * converting expression in canonical form
        *
        * Syntax:
        *
        *     recurPol(node, noPai, obj)
        *
        * @param  {Node} node        The current subpolynomial expression
        * @param  {Node | Null}  noPai   The current parent node
        * @param  {object}    obj        Object with many internal flags
        *
        * @return {}                    No return. If error, throws an exception
        */
       function recurPol(node, noPai, o) {
         var tp = node.type;
         if (tp === 'FunctionNode') {
           // ***** FunctionName *****
           // No function call in polynomial expression
           throw new Error('There is an unsolved function call');
         } else if (tp === 'OperatorNode') {
           // ***** OperatorName *****
           if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');
           if (noPai !== null) {
             // -(unary),^  : children of *,+,-
             if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {
               throw new Error('Invalid ' + node.op + ' placing');
             }

             // -,+,* : children of +,-
             if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {
               throw new Error('Invalid ' + node.op + ' placing');
             }

             // -,+ : first child
             if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {
               throw new Error('Invalid ' + node.op + ' placing');
             }
           } // Has parent

           // Firers: ^,*       Old:   ^,&,-(unary): firers
           if (node.op === '^' || node.op === '*') {
             o.fire = node.op;
           }
           for (var _i = 0; _i < node.args.length; _i++) {
             // +,-: reset fire
             if (node.fn === 'unaryMinus') o.oper = '-';
             if (node.op === '+' || node.fn === 'subtract') {
               o.fire = '';
               o.cte = 1; // default if there is no constant
               o.oper = _i === 0 ? '+' : node.op;
             }
             o.noFil = _i; // number of son
             recurPol(node.args[_i], node, o);
           } // for in children
         } else if (tp === 'SymbolNode') {
           // ***** SymbolName *****
           if (node.name !== varname && varname !== '') {
             throw new Error('There is more than one variable');
           }
           varname = node.name;
           if (noPai === null) {
             coefficients[1] = 1;
             return;
           }

           // ^: Symbol is First child
           if (noPai.op === '^' && o.noFil !== 0) {
             throw new Error('In power the variable should be the first parameter');
           }

           // *: Symbol is Second child
           if (noPai.op === '*' && o.noFil !== 1) {
             throw new Error('In multiply the variable should be the second parameter');
           }

           // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)
           if (o.fire === '' || o.fire === '*') {
             if (maxExpo < 1) coefficients[1] = 0;
             coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);
             maxExpo = Math.max(1, maxExpo);
           }
         } else if (tp === 'ConstantNode') {
           var valor = parseFloat(node.value);
           if (noPai === null) {
             coefficients[0] = valor;
             return;
           }
           if (noPai.op === '^') {
             // cte: second  child of power
             if (o.noFil !== 1) throw new Error('Constant cannot be powered');
             if (!isInteger$1(valor) || valor <= 0) {
               throw new Error('Non-integer exponent is not allowed');
             }
             for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) coefficients[_i2] = 0;
             if (valor > maxExpo) coefficients[valor] = 0;
             coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);
             maxExpo = Math.max(valor, maxExpo);
             return;
           }
           o.cte = valor;

           // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.
           if (o.fire === '') {
             coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);
           }
         } else {
           throw new Error('Type ' + tp + ' is not allowed');
         }
       } // End of recurPol
     } // End of polyToCanonical
   });

   var name$m = 'zpk2tf';
   var dependencies$m = ['typed', 'add', 'multiply', 'Complex', 'number'];
   var createZpk2tf = /* #__PURE__ */factory(name$m, dependencies$m, _ref => {
     var {
       typed,
       add,
       multiply,
       Complex,
       number
     } = _ref;
     /**
        * Compute the transfer function of a zero-pole-gain model.
        *
        * Syntax:
        *      math.zpk2tf(z, p, k)
        *
        * Examples:
        *    math.zpk2tf([1, 2], [-1, -2], 1)    // returns [[1, -3, 2], [1, 3, 2]]
        *
        * See also:
        *   freqz
        *
        * @param {Array} z Array of zeros values
        * @param {Array} p Array of poles values
        * @param {number} k Gain value
        * @return {Array} Two dimensional array containing the numerator (first row) and denominator (second row) polynomials
        *
        */
     return typed(name$m, {
       'Array,Array,number': function ArrayArrayNumber(z, p, k) {
         return _zpk2tf(z, p, k);
       },
       'Array,Array': function ArrayArray(z, p) {
         return _zpk2tf(z, p, 1);
       },
       'Matrix,Matrix,number': function MatrixMatrixNumber(z, p, k) {
         return _zpk2tf(z.valueOf(), p.valueOf(), k);
       },
       'Matrix,Matrix': function MatrixMatrix(z, p) {
         return _zpk2tf(z.valueOf(), p.valueOf(), 1);
       }
     });
     function _zpk2tf(z, p, k) {
       // if z is bignumber, convert it to number
       if (z.some(el => el.type === 'BigNumber')) {
         z = z.map(el => number(el));
       }
       // if p is bignumber, convert it to number
       if (p.some(el => el.type === 'BigNumber')) {
         p = p.map(el => number(el));
       }
       var num = [Complex(1, 0)];
       var den = [Complex(1, 0)];
       for (var i = 0; i < z.length; i++) {
         var zero = z[i];
         if (typeof zero === 'number') zero = Complex(zero, 0);
         num = _multiply(num, [Complex(1, 0), Complex(-zero.re, -zero.im)]);
       }
       for (var _i = 0; _i < p.length; _i++) {
         var pole = p[_i];
         if (typeof pole === 'number') pole = Complex(pole, 0);
         den = _multiply(den, [Complex(1, 0), Complex(-pole.re, -pole.im)]);
       }
       for (var _i2 = 0; _i2 < num.length; _i2++) {
         num[_i2] = multiply(num[_i2], k);
       }
       return [num, den];
     }
     function _multiply(a, b) {
       var c = [];
       for (var i = 0; i < a.length + b.length - 1; i++) {
         c[i] = Complex(0, 0);
         for (var j = 0; j < a.length; j++) {
           if (i - j >= 0 && i - j < b.length) {
             c[i] = add(c[i], multiply(a[j], b[i - j]));
           }
         }
       }
       return c;
     }
   });

   var name$l = 'freqz';
   var dependencies$l = ['typed', 'add', 'multiply', 'Complex', 'divide', 'matrix'];
   var createFreqz = /* #__PURE__ */factory(name$l, dependencies$l, _ref => {
     var {
       typed,
       add,
       multiply,
       Complex,
       divide,
       matrix
     } = _ref;
     /**
        * Calculates the frequency response of a filter given its numerator and denominator coefficients.
        *
        * Syntax:
        *    math.freqz(b, a)
        *    math.freqz(b, a, w)
        *
        * Examples:
        *   math.freqz([1, 2], [1, 2, 3], 4) // returns { h: [0.5 + 0i, 0.4768589245763655 + 0.2861153547458193i, 0.25000000000000006 + 0.75i, -0.770976571635189 + 0.4625859429811135i], w: [0, 0.7853981633974483, 1.5707963267948966, 2.356194490192345 ] }
        *   math.freqz([1, 2], [1, 2, 3], [0, 1]) // returns { h: [0.5 + 0i, 0.45436781 + 0.38598051i], w: [0, 1] }
        *
        * See also:
        *  zpk2tf
        *
        * @param {Array.<number>} b The numerator coefficients of the filter.
        * @param {Array.<number>} a The denominator coefficients of the filter.
        * @param {Array.<number>} [w] A vector of frequencies (in radians/sample) at which the frequency response is to be computed or the number of points to compute (if a number is not provided, the default is 512 points)
        * @returns {Object} An object with two properties: h, a vector containing the complex frequency response, and w, a vector containing the normalized frequencies (in radians/sample) at which the response was computed.
        *
        *
        */
     return typed(name$l, {
       'Array, Array': function ArrayArray(b, a) {
         var w = createBins(512);
         return _freqz(b, a, w);
       },
       'Array, Array, Array': function ArrayArrayArray(b, a, w) {
         return _freqz(b, a, w);
       },
       'Array, Array, number': function ArrayArrayNumber(b, a, w) {
         if (w < 0) {
           throw new Error('w must be a positive number');
         }
         var w2 = createBins(w);
         return _freqz(b, a, w2);
       },
       'Matrix, Matrix': function MatrixMatrix(b, a) {
         // console.log('here')
         var _w = createBins(512);
         var {
           w,
           h
         } = _freqz(b.valueOf(), a.valueOf(), _w);
         return {
           w: matrix(w),
           h: matrix(h)
         };
       },
       'Matrix, Matrix, Matrix': function MatrixMatrixMatrix(b, a, w) {
         var {
           h
         } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
         return {
           h: matrix(h),
           w: matrix(w)
         };
       },
       'Matrix, Matrix, number': function MatrixMatrixNumber(b, a, w) {
         if (w < 0) {
           throw new Error('w must be a positive number');
         }
         var _w = createBins(w);
         var {
           h
         } = _freqz(b.valueOf(), a.valueOf(), _w);
         return {
           h: matrix(h),
           w: matrix(_w)
         };
       }
     });
     function _freqz(b, a, w) {
       var num = [];
       var den = [];
       for (var i = 0; i < w.length; i++) {
         var sumNum = Complex(0, 0);
         var sumDen = Complex(0, 0);
         for (var j = 0; j < b.length; j++) {
           sumNum = add(sumNum, multiply(b[j], Complex(Math.cos(-j * w[i]), Math.sin(-j * w[i]))));
         }
         for (var _j = 0; _j < a.length; _j++) {
           sumDen = add(sumDen, multiply(a[_j], Complex(Math.cos(-_j * w[i]), Math.sin(-_j * w[i]))));
         }
         num.push(sumNum);
         den.push(sumDen);
       }
       var h = [];
       for (var _i = 0; _i < num.length; _i++) {
         h.push(divide(num[_i], den[_i]));
       }
       return {
         h,
         w
       };
     }
     function createBins(n) {
       var bins = [];
       for (var i = 0; i < n; i++) {
         bins.push(i / n * Math.PI);
       }
       return bins;
     }
   });

   var name$k = 'reviver';
   var dependencies$k = ['classes'];
   var createReviver = /* #__PURE__ */factory(name$k, dependencies$k, _ref => {
     var {
       classes
     } = _ref;
     /**
      * Instantiate mathjs data types from their JSON representation
      * @param {string} key
      * @param {*} value
      * @returns {*} Returns the revived object
      */
     return function reviver(key, value) {
       var constructor = classes[value && value.mathjs];
       if (constructor && typeof constructor.fromJSON === 'function') {
         return constructor.fromJSON(value);
       }
       return value;
     };
   });

   var name$j = 'replacer';
   var dependencies$j = [];
   var createReplacer = /* #__PURE__ */factory(name$j, dependencies$j, () => {
     /**
      * Stringify data types into their JSON representation.
      * Most data types can be serialized using their `.toJSON` method,
      * but not all, for example the number `Infinity`. For these cases you have
      * to use the replacer. Example usage:
      *
      *     JSON.stringify([2, Infinity], math.replacer)
      *
      * @param {string} key
      * @param {*} value
      * @returns {*} Returns the replaced object
      */
     return function replacer(key, value) {
       // the numeric values Infinitiy, -Infinity, and NaN cannot be serialized to JSON
       if (typeof value === 'number' && (!isFinite(value) || isNaN(value))) {
         return {
           mathjs: 'number',
           value: String(value)
         };
       }
       return value;
     };
   });

   var version$1 = '11.11.0';
   // Note: This file is automatically generated when building math.js.
   // Changes made in this file will be overwritten.

   var createTrue = /* #__PURE__ */factory('true', [], () => true);
   var createFalse = /* #__PURE__ */factory('false', [], () => false);
   var createNull = /* #__PURE__ */factory('null', [], () => null);
   var createInfinity = /* #__PURE__ */recreateFactory('Infinity', ['config', '?BigNumber'], _ref => {
     var {
       config,
       BigNumber
     } = _ref;
     return config.number === 'BigNumber' ? new BigNumber(Infinity) : Infinity;
   });
   var createNaN = /* #__PURE__ */recreateFactory('NaN', ['config', '?BigNumber'], _ref2 => {
     var {
       config,
       BigNumber
     } = _ref2;
     return config.number === 'BigNumber' ? new BigNumber(NaN) : NaN;
   });
   var createPi = /* #__PURE__ */recreateFactory('pi', ['config', '?BigNumber'], _ref3 => {
     var {
       config,
       BigNumber
     } = _ref3;
     return config.number === 'BigNumber' ? createBigNumberPi(BigNumber) : pi$1;
   });
   var createTau = /* #__PURE__ */recreateFactory('tau', ['config', '?BigNumber'], _ref4 => {
     var {
       config,
       BigNumber
     } = _ref4;
     return config.number === 'BigNumber' ? createBigNumberTau(BigNumber) : tau$1;
   });
   var createE = /* #__PURE__ */recreateFactory('e', ['config', '?BigNumber'], _ref5 => {
     var {
       config,
       BigNumber
     } = _ref5;
     return config.number === 'BigNumber' ? createBigNumberE(BigNumber) : e$1;
   });

   // golden ratio, (1+sqrt(5))/2
   var createPhi = /* #__PURE__ */recreateFactory('phi', ['config', '?BigNumber'], _ref6 => {
     var {
       config,
       BigNumber
     } = _ref6;
     return config.number === 'BigNumber' ? createBigNumberPhi(BigNumber) : phi$1;
   });
   var createLN2 = /* #__PURE__ */recreateFactory('LN2', ['config', '?BigNumber'], _ref7 => {
     var {
       config,
       BigNumber
     } = _ref7;
     return config.number === 'BigNumber' ? new BigNumber(2).ln() : Math.LN2;
   });
   var createLN10 = /* #__PURE__ */recreateFactory('LN10', ['config', '?BigNumber'], _ref8 => {
     var {
       config,
       BigNumber
     } = _ref8;
     return config.number === 'BigNumber' ? new BigNumber(10).ln() : Math.LN10;
   });
   var createLOG2E = /* #__PURE__ */recreateFactory('LOG2E', ['config', '?BigNumber'], _ref9 => {
     var {
       config,
       BigNumber
     } = _ref9;
     return config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
   });
   var createLOG10E = /* #__PURE__ */recreateFactory('LOG10E', ['config', '?BigNumber'], _ref10 => {
     var {
       config,
       BigNumber
     } = _ref10;
     return config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
   });
   var createSQRT1_2 = /* #__PURE__ */recreateFactory(
   // eslint-disable-line camelcase
   'SQRT1_2', ['config', '?BigNumber'], _ref11 => {
     var {
       config,
       BigNumber
     } = _ref11;
     return config.number === 'BigNumber' ? new BigNumber('0.5').sqrt() : Math.SQRT1_2;
   });
   var createSQRT2 = /* #__PURE__ */recreateFactory('SQRT2', ['config', '?BigNumber'], _ref12 => {
     var {
       config,
       BigNumber
     } = _ref12;
     return config.number === 'BigNumber' ? new BigNumber(2).sqrt() : Math.SQRT2;
   });
   var createI = /* #__PURE__ */recreateFactory('i', ['Complex'], _ref13 => {
     var {
       Complex
     } = _ref13;
     return Complex.I;
   });
   var createVersion = /* #__PURE__ */factory('version', [], () => version$1);

   // helper function to create a factory with a flag recreateOnConfigChange
   // idea: allow passing optional properties to be attached to the factory function as 4th argument?
   function recreateFactory(name, dependencies, create) {
     return factory(name, dependencies, create, {
       recreateOnConfigChange: true
     });
   }

   // Source: https://en.wikipedia.org/wiki/Physical_constant

   // Universal constants
   var createSpeedOfLight = /* #__PURE__ */unitFactory('speedOfLight', '299792458', 'm s^-1');
   var createGravitationConstant = /* #__PURE__ */unitFactory('gravitationConstant', '6.67430e-11', 'm^3 kg^-1 s^-2');
   var createPlanckConstant = /* #__PURE__ */unitFactory('planckConstant', '6.62607015e-34', 'J s');
   var createReducedPlanckConstant = /* #__PURE__ */unitFactory('reducedPlanckConstant', '1.0545718176461565e-34', 'J s');

   // Electromagnetic constants
   var createMagneticConstant = /* #__PURE__ */unitFactory('magneticConstant', '1.25663706212e-6', 'N A^-2');
   var createElectricConstant = /* #__PURE__ */unitFactory('electricConstant', '8.8541878128e-12', 'F m^-1');
   var createVacuumImpedance = /* #__PURE__ */unitFactory('vacuumImpedance', '376.730313667', 'ohm');
   var createCoulomb = /* #__PURE__ */unitFactory('coulomb', '8.987551792261171e9', 'N m^2 C^-2');
   var createElementaryCharge = /* #__PURE__ */unitFactory('elementaryCharge', '1.602176634e-19', 'C');
   var createBohrMagneton = /* #__PURE__ */unitFactory('bohrMagneton', '9.2740100783e-24', 'J T^-1');
   var createConductanceQuantum = /* #__PURE__ */unitFactory('conductanceQuantum', '7.748091729863649e-5', 'S');
   var createInverseConductanceQuantum = /* #__PURE__ */unitFactory('inverseConductanceQuantum', '12906.403729652257', 'ohm');
   var createMagneticFluxQuantum = /* #__PURE__ */unitFactory('magneticFluxQuantum', '2.0678338484619295e-15', 'Wb');
   var createNuclearMagneton = /* #__PURE__ */unitFactory('nuclearMagneton', '5.0507837461e-27', 'J T^-1');
   var createKlitzing = /* #__PURE__ */unitFactory('klitzing', '25812.807459304513', 'ohm');

   // Atomic and nuclear constants
   var createBohrRadius = /* #__PURE__ */unitFactory('bohrRadius', '5.29177210903e-11', 'm');
   var createClassicalElectronRadius = /* #__PURE__ */unitFactory('classicalElectronRadius', '2.8179403262e-15', 'm');
   var createElectronMass = /* #__PURE__ */unitFactory('electronMass', '9.1093837015e-31', 'kg');
   var createFermiCoupling = /* #__PURE__ */unitFactory('fermiCoupling', '1.1663787e-5', 'GeV^-2');
   var createFineStructure = numberFactory('fineStructure', 7.2973525693e-3);
   var createHartreeEnergy = /* #__PURE__ */unitFactory('hartreeEnergy', '4.3597447222071e-18', 'J');
   var createProtonMass = /* #__PURE__ */unitFactory('protonMass', '1.67262192369e-27', 'kg');
   var createDeuteronMass = /* #__PURE__ */unitFactory('deuteronMass', '3.3435830926e-27', 'kg');
   var createNeutronMass = /* #__PURE__ */unitFactory('neutronMass', '1.6749271613e-27', 'kg');
   var createQuantumOfCirculation = /* #__PURE__ */unitFactory('quantumOfCirculation', '3.6369475516e-4', 'm^2 s^-1');
   var createRydberg = /* #__PURE__ */unitFactory('rydberg', '10973731.568160', 'm^-1');
   var createThomsonCrossSection = /* #__PURE__ */unitFactory('thomsonCrossSection', '6.6524587321e-29', 'm^2');
   var createWeakMixingAngle = numberFactory('weakMixingAngle', 0.22290);
   var createEfimovFactor = numberFactory('efimovFactor', 22.7);

   // Physico-chemical constants
   var createAtomicMass = /* #__PURE__ */unitFactory('atomicMass', '1.66053906660e-27', 'kg');
   var createAvogadro = /* #__PURE__ */unitFactory('avogadro', '6.02214076e23', 'mol^-1');
   var createBoltzmann = /* #__PURE__ */unitFactory('boltzmann', '1.380649e-23', 'J K^-1');
   var createFaraday = /* #__PURE__ */unitFactory('faraday', '96485.33212331001', 'C mol^-1');
   var createFirstRadiation = /* #__PURE__ */unitFactory('firstRadiation', '3.7417718521927573e-16', 'W m^2');

   var createLoschmidt = /* #__PURE__ */unitFactory('loschmidt', '2.686780111798444e25', 'm^-3');
   var createGasConstant = /* #__PURE__ */unitFactory('gasConstant', '8.31446261815324', 'J K^-1 mol^-1');
   var createMolarPlanckConstant = /* #__PURE__ */unitFactory('molarPlanckConstant', '3.990312712893431e-10', 'J s mol^-1');
   var createMolarVolume = /* #__PURE__ */unitFactory('molarVolume', '0.022413969545014137', 'm^3 mol^-1');
   var createSackurTetrode = numberFactory('sackurTetrode', -1.16487052358);
   var createSecondRadiation = /* #__PURE__ */unitFactory('secondRadiation', '0.014387768775039337', 'm K');
   var createStefanBoltzmann = /* #__PURE__ */unitFactory('stefanBoltzmann', '5.67037441918443e-8', 'W m^-2 K^-4');
   var createWienDisplacement = /* #__PURE__ */unitFactory('wienDisplacement', '2.897771955e-3', 'm K');

   // Adopted values
   var createMolarMass = /* #__PURE__ */unitFactory('molarMass', '0.99999999965e-3', 'kg mol^-1');
   var createMolarMassC12 = /* #__PURE__ */unitFactory('molarMassC12', '11.9999999958e-3', 'kg mol^-1');
   var createGravity = /* #__PURE__ */unitFactory('gravity', '9.80665', 'm s^-2');
   // atm is defined in Unit.js

   // Natural units
   var createPlanckLength = /* #__PURE__ */unitFactory('planckLength', '1.616255e-35', 'm');
   var createPlanckMass = /* #__PURE__ */unitFactory('planckMass', '2.176435e-8', 'kg');
   var createPlanckTime = /* #__PURE__ */unitFactory('planckTime', '5.391245e-44', 's');
   var createPlanckCharge = /* #__PURE__ */unitFactory('planckCharge', '1.87554603778e-18', 'C');
   var createPlanckTemperature = /* #__PURE__ */unitFactory('planckTemperature', '1.416785e+32', 'K');

   // helper function to create a factory function which creates a physical constant,
   // a Unit with either a number value or a BigNumber value depending on the configuration
   function unitFactory(name, valueStr, unitStr) {
     var dependencies = ['config', 'Unit', 'BigNumber'];
     return factory(name, dependencies, _ref => {
       var {
         config,
         Unit,
         BigNumber
       } = _ref;
       // Note that we can parse into number or BigNumber.
       // We do not parse into Fractions as that doesn't make sense: we would lose precision of the values
       // Therefore we dont use Unit.parse()
       var value = config.number === 'BigNumber' ? new BigNumber(valueStr) : parseFloat(valueStr);
       var unit = new Unit(value, unitStr);
       unit.fixPrefix = true;
       return unit;
     });
   }

   // helper function to create a factory function which creates a numeric constant,
   // either a number or BigNumber depending on the configuration
   function numberFactory(name, value) {
     var dependencies = ['config', 'BigNumber'];
     return factory(name, dependencies, _ref2 => {
       var {
         config,
         BigNumber
       } = _ref2;
       return config.number === 'BigNumber' ? new BigNumber(value) : value;
     });
   }

   var name$i = 'apply';
   var dependencies$i = ['typed', 'isInteger'];

   /**
    * Attach a transform function to math.apply
    * Adds a property transform containing the transform function.
    *
    * This transform changed the last `dim` parameter of function apply
    * from one-based to zero based
    */
   var createApplyTransform = /* #__PURE__ */factory(name$i, dependencies$i, _ref => {
     var {
       typed,
       isInteger
     } = _ref;
     var apply = createApply({
       typed,
       isInteger
     });

     // @see: comment of concat itself
     return typed('apply', {
       '...any': function any(args) {
         // change dim from one-based to zero-based
         var dim = args[1];
         if (isNumber(dim)) {
           args[1] = dim - 1;
         } else if (isBigNumber(dim)) {
           args[1] = dim.minus(1);
         }
         try {
           return apply.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$h = 'column';
   var dependencies$h = ['typed', 'Index', 'matrix', 'range'];

   /**
    * Attach a transform function to matrix.column
    * Adds a property transform containing the transform function.
    *
    * This transform changed the last `index` parameter of function column
    * from zero-based to one-based
    */
   var createColumnTransform = /* #__PURE__ */factory(name$h, dependencies$h, _ref => {
     var {
       typed,
       Index,
       matrix,
       range
     } = _ref;
     var column = createColumn({
       typed,
       Index,
       matrix,
       range
     });

     // @see: comment of column itself
     return typed('column', {
       '...any': function any(args) {
         // change last argument from zero-based to one-based
         var lastIndex = args.length - 1;
         var last = args[lastIndex];
         if (isNumber(last)) {
           args[lastIndex] = last - 1;
         }
         try {
           return column.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   /**
    * Compile an inline expression like "x > 0"
    * @param {Node} expression
    * @param {Object} math
    * @param {Object} scope
    * @return {function} Returns a function with one argument which fills in the
    *                    undefined variable (like "x") and evaluates the expression
    */
   function compileInlineExpression(expression, math, scope) {
     // find an undefined symbol
     var symbol = expression.filter(function (node) {
       return isSymbolNode(node) && !(node.name in math) && !scope.has(node.name);
     })[0];
     if (!symbol) {
       throw new Error('No undefined variable found in inline expression "' + expression + '"');
     }

     // create a test function for this equation
     var name = symbol.name; // variable name
     var subScope = createSubScope(scope);
     var eq = expression.compile();
     return function inlineExpression(x) {
       subScope.set(name, x);
       return eq.evaluate(subScope);
     };
   }

   var name$g = 'filter';
   var dependencies$g = ['typed'];
   var createFilterTransform = /* #__PURE__ */factory(name$g, dependencies$g, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Attach a transform function to math.filter
      * Adds a property transform containing the transform function.
      *
      * This transform adds support for equations as test function for math.filter,
      * so you can do something like 'filter([3, -2, 5], x > 0)'.
      */
     function filterTransform(args, math, scope) {
       var x, callback;
       if (args[0]) {
         x = args[0].compile().evaluate(scope);
       }
       if (args[1]) {
         if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
           // a function pointer, like filter([3, -2, 5], myTestFunction)
           callback = args[1].compile().evaluate(scope);
         } else {
           // an expression like filter([3, -2, 5], x > 0)
           callback = compileInlineExpression(args[1], math, scope);
         }
       }
       return filter(x, callback);
     }
     filterTransform.rawArgs = true;

     // one based version of function filter
     var filter = typed('filter', {
       'Array, function': _filter,
       'Matrix, function': function MatrixFunction(x, test) {
         return x.create(_filter(x.toArray(), test));
       },
       'Array, RegExp': filterRegExp,
       'Matrix, RegExp': function MatrixRegExp(x, test) {
         return x.create(filterRegExp(x.toArray(), test));
       }
     });
     return filterTransform;
   }, {
     isTransformFunction: true
   });

   /**
    * Filter values in a callback given a callback function
    *
    * !!! Passes a one-based index !!!
    *
    * @param {Array} x
    * @param {Function} callback
    * @return {Array} Returns the filtered array
    * @private
    */
   function _filter(x, callback) {
     return filter$1(x, function (value, index, array) {
       // invoke the callback function with the right number of arguments
       return applyCallback(callback, value, [index + 1], array, 'filter');
     });
   }

   var name$f = 'forEach';
   var dependencies$f = ['typed'];
   var createForEachTransform = /* #__PURE__ */factory(name$f, dependencies$f, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Attach a transform function to math.forEach
      * Adds a property transform containing the transform function.
      *
      * This transform creates a one-based index instead of a zero-based index
      */
     function forEachTransform(args, math, scope) {
       var x, callback;
       if (args[0]) {
         x = args[0].compile().evaluate(scope);
       }
       if (args[1]) {
         if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
           // a function pointer, like forEach([3, -2, 5], myTestFunction)
           callback = args[1].compile().evaluate(scope);
         } else {
           // an expression like forEach([3, -2, 5], x > 0 ? callback1(x) : callback2(x) )
           callback = compileInlineExpression(args[1], math, scope);
         }
       }
       return _forEach(x, callback);
     }
     forEachTransform.rawArgs = true;

     // one-based version of forEach
     var _forEach = typed('forEach', {
       'Array | Matrix, function': function ArrayMatrixFunction(array, callback) {
         var recurse = function recurse(value, index) {
           if (Array.isArray(value)) {
             forEach$1(value, function (child, i) {
               // we create a copy of the index array and append the new index value
               recurse(child, index.concat(i + 1)); // one based index, hence i+1
             });
           } else {
             // invoke the callback function with the right number of arguments
             return applyCallback(callback, value, index, array, 'forEach');
           }
         };
         recurse(array.valueOf(), []); // pass Array
       }
     });

     return forEachTransform;
   }, {
     isTransformFunction: true
   });

   var name$e = 'index';
   var dependencies$e = ['Index', 'getMatrixDataType'];
   var createIndexTransform = /* #__PURE__ */factory(name$e, dependencies$e, _ref => {
     var {
       Index,
       getMatrixDataType
     } = _ref;
     /**
      * Attach a transform function to math.index
      * Adds a property transform containing the transform function.
      *
      * This transform creates a one-based index instead of a zero-based index
      */
     return function indexTransform() {
       var args = [];
       for (var i = 0, ii = arguments.length; i < ii; i++) {
         var arg = arguments[i];

         // change from one-based to zero based, convert BigNumber to number and leave Array of Booleans as is
         if (isRange(arg)) {
           arg.start--;
           arg.end -= arg.step > 0 ? 0 : 2;
         } else if (arg && arg.isSet === true) {
           arg = arg.map(function (v) {
             return v - 1;
           });
         } else if (isArray(arg) || isMatrix(arg)) {
           if (getMatrixDataType(arg) !== 'boolean') {
             arg = arg.map(function (v) {
               return v - 1;
             });
           }
         } else if (isNumber(arg)) {
           arg--;
         } else if (isBigNumber(arg)) {
           arg = arg.toNumber() - 1;
         } else if (typeof arg === 'string') ; else {
           throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
         }
         args[i] = arg;
       }
       var res = new Index();
       Index.apply(res, args);
       return res;
     };
   }, {
     isTransformFunction: true
   });

   var name$d = 'map';
   var dependencies$d = ['typed'];
   var createMapTransform = /* #__PURE__ */factory(name$d, dependencies$d, _ref => {
     var {
       typed
     } = _ref;
     /**
      * Attach a transform function to math.map
      * Adds a property transform containing the transform function.
      *
      * This transform creates a one-based index instead of a zero-based index
      */
     function mapTransform(args, math, scope) {
       var x, callback;
       if (args[0]) {
         x = args[0].compile().evaluate(scope);
       }
       if (args[1]) {
         if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
           // a function pointer, like filter([3, -2, 5], myTestFunction)
           callback = args[1].compile().evaluate(scope);
         } else {
           // an expression like filter([3, -2, 5], x > 0)
           callback = compileInlineExpression(args[1], math, scope);
         }
       }
       return map(x, callback);
     }
     mapTransform.rawArgs = true;

     // one-based version of map function
     var map = typed('map', {
       'Array, function': function ArrayFunction(x, callback) {
         return _map(x, callback, x);
       },
       'Matrix, function': function MatrixFunction(x, callback) {
         return x.create(_map(x.valueOf(), callback, x));
       }
     });
     return mapTransform;
   }, {
     isTransformFunction: true
   });

   /**
    * Map for a multidimensional array. One-based indexes
    * @param {Array} array
    * @param {function} callback
    * @param {Array} orig
    * @return {Array}
    * @private
    */
   function _map(array, callback, orig) {
     function recurse(value, index) {
       if (Array.isArray(value)) {
         return map$1(value, function (child, i) {
           // we create a copy of the index array and append the new index value
           return recurse(child, index.concat(i + 1)); // one based index, hence i + 1
         });
       } else {
         // invoke the (typed) callback function with the right number of arguments
         return applyCallback(callback, value, index, orig, 'map');
       }
     }
     return recurse(array, []);
   }

   /**
    * Change last argument dim from one-based to zero-based.
    */
   function lastDimToZeroBase(args) {
     if (args.length === 2 && isCollection(args[0])) {
       args = args.slice();
       var dim = args[1];
       if (isNumber(dim)) {
         args[1] = dim - 1;
       } else if (isBigNumber(dim)) {
         args[1] = dim.minus(1);
       }
     }
     return args;
   }

   var name$c = 'max';
   var dependencies$c = ['typed', 'config', 'numeric', 'larger'];
   var createMaxTransform = /* #__PURE__ */factory(name$c, dependencies$c, _ref => {
     var {
       typed,
       config,
       numeric,
       larger
     } = _ref;
     var max = createMax({
       typed,
       config,
       numeric,
       larger
     });

     /**
      * Attach a transform function to math.max
      * Adds a property transform containing the transform function.
      *
      * This transform changed the last `dim` parameter of function max
      * from one-based to zero based
      */
     return typed('max', {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return max.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$b = 'mean';
   var dependencies$b = ['typed', 'add', 'divide'];
   var createMeanTransform = /* #__PURE__ */factory(name$b, dependencies$b, _ref => {
     var {
       typed,
       add,
       divide
     } = _ref;
     var mean = createMean({
       typed,
       add,
       divide
     });

     /**
      * Attach a transform function to math.mean
      * Adds a property transform containing the transform function.
      *
      * This transform changed the last `dim` parameter of function mean
      * from one-based to zero based
      */
     return typed('mean', {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return mean.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$a = 'min';
   var dependencies$a = ['typed', 'config', 'numeric', 'smaller'];
   var createMinTransform = /* #__PURE__ */factory(name$a, dependencies$a, _ref => {
     var {
       typed,
       config,
       numeric,
       smaller
     } = _ref;
     var min = createMin({
       typed,
       config,
       numeric,
       smaller
     });

     /**
      * Attach a transform function to math.min
      * Adds a property transform containing the transform function.
      *
      * This transform changed the last `dim` parameter of function min
      * from one-based to zero based
      */
     return typed('min', {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return min.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$9 = 'range';
   var dependencies$9 = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq', 'add', 'isPositive'];
   var createRangeTransform = /* #__PURE__ */factory(name$9, dependencies$9, _ref => {
     var {
       typed,
       config,
       matrix,
       bignumber,
       smaller,
       smallerEq,
       larger,
       largerEq,
       add,
       isPositive
     } = _ref;
     var range = createRange({
       typed,
       config,
       matrix,
       bignumber,
       smaller,
       smallerEq,
       larger,
       largerEq,
       add,
       isPositive
     });

     /**
      * Attach a transform function to math.range
      * Adds a property transform containing the transform function.
      *
      * This transform creates a range which includes the end value
      */
     return typed('range', {
       '...any': function any(args) {
         var lastIndex = args.length - 1;
         var last = args[lastIndex];
         if (typeof last !== 'boolean') {
           // append a parameter includeEnd=true
           args.push(true);
         }
         return range.apply(null, args);
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$8 = 'row';
   var dependencies$8 = ['typed', 'Index', 'matrix', 'range'];

   /**
    * Attach a transform function to matrix.column
    * Adds a property transform containing the transform function.
    *
    * This transform changed the last `index` parameter of function column
    * from zero-based to one-based
    */
   var createRowTransform = /* #__PURE__ */factory(name$8, dependencies$8, _ref => {
     var {
       typed,
       Index,
       matrix,
       range
     } = _ref;
     var row = createRow({
       typed,
       Index,
       matrix,
       range
     });

     // @see: comment of row itself
     return typed('row', {
       '...any': function any(args) {
         // change last argument from zero-based to one-based
         var lastIndex = args.length - 1;
         var last = args[lastIndex];
         if (isNumber(last)) {
           args[lastIndex] = last - 1;
         }
         try {
           return row.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$7 = 'subset';
   var dependencies$7 = ['typed', 'matrix', 'zeros', 'add'];
   var createSubsetTransform = /* #__PURE__ */factory(name$7, dependencies$7, _ref => {
     var {
       typed,
       matrix,
       zeros,
       add
     } = _ref;
     var subset = createSubset({
       typed,
       matrix,
       zeros,
       add
     });

     /**
      * Attach a transform function to math.subset
      * Adds a property transform containing the transform function.
      *
      * This transform creates a range which includes the end value
      */
     return typed('subset', {
       '...any': function any(args) {
         try {
           return subset.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$6 = 'concat';
   var dependencies$6 = ['typed', 'matrix', 'isInteger'];
   var createConcatTransform = /* #__PURE__ */factory(name$6, dependencies$6, _ref => {
     var {
       typed,
       matrix,
       isInteger
     } = _ref;
     var concat = createConcat({
       typed,
       matrix,
       isInteger
     });

     /**
      * Attach a transform function to math.range
      * Adds a property transform containing the transform function.
      *
      * This transform changed the last `dim` parameter of function concat
      * from one-based to zero based
      */
     return typed('concat', {
       '...any': function any(args) {
         // change last argument from one-based to zero-based
         var lastIndex = args.length - 1;
         var last = args[lastIndex];
         if (isNumber(last)) {
           args[lastIndex] = last - 1;
         } else if (isBigNumber(last)) {
           args[lastIndex] = last.minus(1);
         }
         try {
           return concat.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$5 = 'diff';
   var dependencies$5 = ['typed', 'matrix', 'subtract', 'number', 'bignumber'];
   var createDiffTransform = /* #__PURE__ */factory(name$5, dependencies$5, _ref => {
     var {
       typed,
       matrix,
       subtract,
       number,
       bignumber
     } = _ref;
     var diff = createDiff({
       typed,
       matrix,
       subtract,
       number,
       bignumber
     });

     /**
      * Attach a transform function to math.diff
      * Adds a property transform containing the transform function.
      *
      * This transform creates a range which includes the end value
      */
     return typed(name$5, {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return diff.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$4 = 'std';
   var dependencies$4 = ['typed', 'map', 'sqrt', 'variance'];

   /**
    * Attach a transform function to math.std
    * Adds a property transform containing the transform function.
    *
    * This transform changed the `dim` parameter of function std
    * from one-based to zero based
    */
   var createStdTransform = /* #__PURE__ */factory(name$4, dependencies$4, _ref => {
     var {
       typed,
       map,
       sqrt,
       variance
     } = _ref;
     var std = createStd({
       typed,
       map,
       sqrt,
       variance
     });
     return typed('std', {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return std.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   /**
    * Attach a transform function to math.sum
    * Adds a property transform containing the transform function.
    *
    * This transform changed the last `dim` parameter of function sum
    * from one-based to zero based
    */
   var name$3 = 'sum';
   var dependencies$3 = ['typed', 'config', 'add', 'numeric'];
   var createSumTransform = /* #__PURE__ */factory(name$3, dependencies$3, _ref => {
     var {
       typed,
       config,
       add,
       numeric
     } = _ref;
     var sum = createSum({
       typed,
       config,
       add,
       numeric
     });
     return typed(name$3, {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return sum.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name$2 = 'quantileSeq';
   var dependencies$2 = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];

   /**
    * Attach a transform function to math.quantileSeq
    * Adds a property transform containing the transform function.
    *
    * This transform changed the `dim` parameter of function std
    * from one-based to zero based
    */
   var createQuantileSeqTransform = /* #__PURE__ */factory(name$2, dependencies$2, _ref => {
     var {
       typed,
       add,
       multiply,
       partitionSelect,
       compare,
       isInteger
     } = _ref;
     var quantileSeq = createQuantileSeq({
       typed,
       add,
       multiply,
       partitionSelect,
       compare,
       isInteger
     });
     return typed('quantileSeq', {
       'Array|Matrix, number|BigNumber|Array, number': (arr, prob, dim) => quantileSeq(arr, prob, dimToZeroBase(dim)),
       'Array|Matrix, number|BigNumber|Array, boolean, number': (arr, prob, sorted, dim) => quantileSeq(arr, prob, sorted, dimToZeroBase(dim))
     });
     function dimToZeroBase(dim) {
       // TODO: find a better way, maybe lastDimToZeroBase could apply to more cases.
       return lastDimToZeroBase([[], dim])[1];
     }
   }, {
     isTransformFunction: true
   });

   /**
    * Attach a transform function to math.sum
    * Adds a property transform containing the transform function.
    *
    * This transform changed the last `dim` parameter of function sum
    * from one-based to zero based
    */
   var name$1 = 'cumsum';
   var dependencies$1 = ['typed', 'add', 'unaryPlus'];
   var createCumSumTransform = /* #__PURE__ */factory(name$1, dependencies$1, _ref => {
     var {
       typed,
       add,
       unaryPlus
     } = _ref;
     var cumsum = createCumSum({
       typed,
       add,
       unaryPlus
     });
     return typed(name$1, {
       '...any': function any(args) {
         // change last argument dim from one-based to zero-based
         if (args.length === 2 && isCollection(args[0])) {
           var dim = args[1];
           if (isNumber(dim)) {
             args[1] = dim - 1;
           } else if (isBigNumber(dim)) {
             args[1] = dim.minus(1);
           }
         }
         try {
           return cumsum.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   var name = 'variance';
   var dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];

   /**
    * Attach a transform function to math.var
    * Adds a property transform containing the transform function.
    *
    * This transform changed the `dim` parameter of function var
    * from one-based to zero based
    */
   var createVarianceTransform = /* #__PURE__ */factory(name, dependencies, _ref => {
     var {
       typed,
       add,
       subtract,
       multiply,
       divide,
       apply,
       isNaN
     } = _ref;
     var variance = createVariance({
       typed,
       add,
       subtract,
       multiply,
       divide,
       apply,
       isNaN
     });
     return typed(name, {
       '...any': function any(args) {
         args = lastDimToZeroBase(args);
         try {
           return variance.apply(null, args);
         } catch (err) {
           throw errorTransform(err);
         }
       }
     });
   }, {
     isTransformFunction: true
   });

   /**
    * THIS FILE IS AUTO-GENERATED
    * DON'T MAKE CHANGES HERE
    */
   var BigNumber = /* #__PURE__ */createBigNumberClass({
     config: config$1
   });
   var Complex = /* #__PURE__ */createComplexClass({});
   var e = /* #__PURE__ */createE({
     BigNumber,
     config: config$1
   });
   var _false = /* #__PURE__ */createFalse({});
   var fineStructure = /* #__PURE__ */createFineStructure({
     BigNumber,
     config: config$1
   });
   var Fraction = /* #__PURE__ */createFractionClass({});
   var i = /* #__PURE__ */createI({
     Complex
   });
   var _Infinity = /* #__PURE__ */createInfinity({
     BigNumber,
     config: config$1
   });
   var LN10 = /* #__PURE__ */createLN10({
     BigNumber,
     config: config$1
   });
   var LOG10E = /* #__PURE__ */createLOG10E({
     BigNumber,
     config: config$1
   });
   var Matrix = /* #__PURE__ */createMatrixClass({});
   var _NaN = /* #__PURE__ */createNaN({
     BigNumber,
     config: config$1
   });
   var _null = /* #__PURE__ */createNull({});
   var phi = /* #__PURE__ */createPhi({
     BigNumber,
     config: config$1
   });
   var Range = /* #__PURE__ */createRangeClass({});
   var ResultSet = /* #__PURE__ */createResultSet({});
   var SQRT1_2 = /* #__PURE__ */createSQRT1_2({
     BigNumber,
     config: config$1
   });
   var sackurTetrode = /* #__PURE__ */createSackurTetrode({
     BigNumber,
     config: config$1
   });
   var tau = /* #__PURE__ */createTau({
     BigNumber,
     config: config$1
   });
   var _true = /* #__PURE__ */createTrue({});
   var version = /* #__PURE__ */createVersion({});
   var DenseMatrix = /* #__PURE__ */createDenseMatrixClass({
     Matrix
   });
   var efimovFactor = /* #__PURE__ */createEfimovFactor({
     BigNumber,
     config: config$1
   });
   var LN2 = /* #__PURE__ */createLN2({
     BigNumber,
     config: config$1
   });
   var pi = /* #__PURE__ */createPi({
     BigNumber,
     config: config$1
   });
   var replacer = /* #__PURE__ */createReplacer({});
   var SQRT2 = /* #__PURE__ */createSQRT2({
     BigNumber,
     config: config$1
   });
   var typed = /* #__PURE__ */createTyped({
     BigNumber,
     Complex,
     DenseMatrix,
     Fraction
   });
   var unaryPlus = /* #__PURE__ */createUnaryPlus({
     BigNumber,
     config: config$1,
     typed
   });
   var weakMixingAngle = /* #__PURE__ */createWeakMixingAngle({
     BigNumber,
     config: config$1
   });
   var abs = /* #__PURE__ */createAbs({
     typed
   });
   var acos = /* #__PURE__ */createAcos({
     Complex,
     config: config$1,
     typed
   });
   var acot = /* #__PURE__ */createAcot({
     BigNumber,
     typed
   });
   var acsc = /* #__PURE__ */createAcsc({
     BigNumber,
     Complex,
     config: config$1,
     typed
   });
   var addScalar = /* #__PURE__ */createAddScalar({
     typed
   });
   var arg = /* #__PURE__ */createArg({
     typed
   });
   var asech = /* #__PURE__ */createAsech({
     BigNumber,
     Complex,
     config: config$1,
     typed
   });
   var asinh = /* #__PURE__ */createAsinh({
     typed
   });
   var atan = /* #__PURE__ */createAtan({
     typed
   });
   var atanh = /* #__PURE__ */createAtanh({
     Complex,
     config: config$1,
     typed
   });
   var bignumber = /* #__PURE__ */createBignumber({
     BigNumber,
     typed
   });
   var bitNot = /* #__PURE__ */createBitNot({
     typed
   });
   var boolean = /* #__PURE__ */createBoolean({
     typed
   });
   var clone = /* #__PURE__ */createClone({
     typed
   });
   var combinations = /* #__PURE__ */createCombinations({
     typed
   });
   var complex = /* #__PURE__ */createComplex({
     Complex,
     typed
   });
   var conj = /* #__PURE__ */createConj({
     typed
   });
   var cos = /* #__PURE__ */createCos({
     typed
   });
   var cot = /* #__PURE__ */createCot({
     BigNumber,
     typed
   });
   var csc = /* #__PURE__ */createCsc({
     BigNumber,
     typed
   });
   var cube = /* #__PURE__ */createCube({
     typed
   });
   var equalScalar = /* #__PURE__ */createEqualScalar({
     config: config$1,
     typed
   });
   var erf = /* #__PURE__ */createErf({
     typed
   });
   var exp = /* #__PURE__ */createExp({
     typed
   });
   var expm1 = /* #__PURE__ */createExpm1({
     Complex,
     typed
   });
   var filter = /* #__PURE__ */createFilter({
     typed
   });
   var forEach = /* #__PURE__ */createForEach({
     typed
   });
   var format = /* #__PURE__ */createFormat({
     typed
   });
   var getMatrixDataType = /* #__PURE__ */createGetMatrixDataType({
     typed
   });
   var hex = /* #__PURE__ */createHex({
     format,
     typed
   });
   var im = /* #__PURE__ */createIm({
     typed
   });
   var isInteger = /* #__PURE__ */createIsInteger({
     typed
   });
   var isNegative = /* #__PURE__ */createIsNegative({
     typed
   });
   var isPositive = /* #__PURE__ */createIsPositive({
     typed
   });
   var isZero = /* #__PURE__ */createIsZero({
     typed
   });
   var LOG2E = /* #__PURE__ */createLOG2E({
     BigNumber,
     config: config$1
   });
   var lgamma = /* #__PURE__ */createLgamma({
     Complex,
     typed
   });
   var log10 = /* #__PURE__ */createLog10({
     Complex,
     config: config$1,
     typed
   });
   var log2 = /* #__PURE__ */createLog2({
     Complex,
     config: config$1,
     typed
   });
   var map = /* #__PURE__ */createMap({
     typed
   });
   var multiplyScalar = /* #__PURE__ */createMultiplyScalar({
     typed
   });
   var not = /* #__PURE__ */createNot({
     typed
   });
   var number = /* #__PURE__ */createNumber({
     typed
   });
   var oct = /* #__PURE__ */createOct({
     format,
     typed
   });
   var pickRandom = /* #__PURE__ */createPickRandom({
     config: config$1,
     typed
   });
   var print = /* #__PURE__ */createPrint({
     typed
   });
   var random = /* #__PURE__ */createRandom({
     config: config$1,
     typed
   });
   var re = /* #__PURE__ */createRe({
     typed
   });
   var sec = /* #__PURE__ */createSec({
     BigNumber,
     typed
   });
   var sign = /* #__PURE__ */createSign({
     BigNumber,
     Fraction,
     complex,
     typed
   });
   var sin = /* #__PURE__ */createSin({
     typed
   });
   var SparseMatrix = /* #__PURE__ */createSparseMatrixClass({
     Matrix,
     equalScalar,
     typed
   });
   var splitUnit = /* #__PURE__ */createSplitUnit({
     typed
   });
   var square = /* #__PURE__ */createSquare({
     typed
   });
   var string = /* #__PURE__ */createString({
     typed
   });
   var tan = /* #__PURE__ */createTan({
     typed
   });
   var typeOf = /* #__PURE__ */createTypeOf({
     typed
   });
   var acosh = /* #__PURE__ */createAcosh({
     Complex,
     config: config$1,
     typed
   });
   var acsch = /* #__PURE__ */createAcsch({
     BigNumber,
     typed
   });
   var apply = /* #__PURE__ */createApply({
     isInteger,
     typed
   });
   var asec = /* #__PURE__ */createAsec({
     BigNumber,
     Complex,
     config: config$1,
     typed
   });
   var bin = /* #__PURE__ */createBin({
     format,
     typed
   });
   var combinationsWithRep = /* #__PURE__ */createCombinationsWithRep({
     typed
   });
   var cosh = /* #__PURE__ */createCosh({
     typed
   });
   var csch = /* #__PURE__ */createCsch({
     BigNumber,
     typed
   });
   var isNaN$1 = /* #__PURE__ */createIsNaN({
     typed
   });
   var isPrime = /* #__PURE__ */createIsPrime({
     typed
   });
   var randomInt = /* #__PURE__ */createRandomInt({
     config: config$1,
     typed
   });
   var sech = /* #__PURE__ */createSech({
     BigNumber,
     typed
   });
   var sinh = /* #__PURE__ */createSinh({
     typed
   });
   var sparse = /* #__PURE__ */createSparse({
     SparseMatrix,
     typed
   });
   var sqrt = /* #__PURE__ */createSqrt({
     Complex,
     config: config$1,
     typed
   });
   var tanh = /* #__PURE__ */createTanh({
     typed
   });
   var unaryMinus = /* #__PURE__ */createUnaryMinus({
     typed
   });
   var acoth = /* #__PURE__ */createAcoth({
     BigNumber,
     Complex,
     config: config$1,
     typed
   });
   var coth = /* #__PURE__ */createCoth({
     BigNumber,
     typed
   });
   var fraction = /* #__PURE__ */createFraction({
     Fraction,
     typed
   });
   var isNumeric = /* #__PURE__ */createIsNumeric({
     typed
   });
   var matrix = /* #__PURE__ */createMatrix({
     DenseMatrix,
     Matrix,
     SparseMatrix,
     typed
   });
   var matrixFromFunction = /* #__PURE__ */createMatrixFromFunction({
     isZero,
     matrix,
     typed
   });
   var mode = /* #__PURE__ */createMode({
     isNaN: isNaN$1,
     isNumeric,
     typed
   });
   var numeric = /* #__PURE__ */createNumeric({
     bignumber,
     fraction,
     number
   });
   var prod = /* #__PURE__ */createProd({
     config: config$1,
     multiplyScalar,
     numeric,
     typed
   });
   var reshape = /* #__PURE__ */createReshape({
     isInteger,
     matrix,
     typed
   });
   var size = /* #__PURE__ */createSize({
     matrix,
     config: config$1,
     typed
   });
   var squeeze = /* #__PURE__ */createSqueeze({
     matrix,
     typed
   });
   var transpose = /* #__PURE__ */createTranspose({
     matrix,
     typed
   });
   var xgcd = /* #__PURE__ */createXgcd({
     BigNumber,
     config: config$1,
     matrix,
     typed
   });
   var zeros = /* #__PURE__ */createZeros({
     BigNumber,
     config: config$1,
     matrix,
     typed
   });
   var asin = /* #__PURE__ */createAsin({
     Complex,
     config: config$1,
     typed
   });
   var cbrt = /* #__PURE__ */createCbrt({
     BigNumber,
     Complex,
     Fraction,
     config: config$1,
     isNegative,
     matrix,
     typed,
     unaryMinus
   });
   var concat = /* #__PURE__ */createConcat({
     isInteger,
     matrix,
     typed
   });
   var count = /* #__PURE__ */createCount({
     prod,
     size,
     typed
   });
   var ctranspose = /* #__PURE__ */createCtranspose({
     conj,
     transpose,
     typed
   });
   var diag = /* #__PURE__ */createDiag({
     DenseMatrix,
     SparseMatrix,
     matrix,
     typed
   });
   var divideScalar = /* #__PURE__ */createDivideScalar({
     numeric,
     typed
   });
   var dotDivide = /* #__PURE__ */createDotDivide({
     DenseMatrix,
     concat,
     divideScalar,
     equalScalar,
     matrix,
     typed
   });
   var equal = /* #__PURE__ */createEqual({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var flatten = /* #__PURE__ */createFlatten({
     matrix,
     typed
   });
   var gcd = /* #__PURE__ */createGcd({
     BigNumber,
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var hasNumericValue = /* #__PURE__ */createHasNumericValue({
     isNumeric,
     typed
   });
   var identity = /* #__PURE__ */createIdentity({
     BigNumber,
     DenseMatrix,
     SparseMatrix,
     config: config$1,
     matrix,
     typed
   });
   var kron = /* #__PURE__ */createKron({
     matrix,
     multiplyScalar,
     typed
   });
   var largerEq = /* #__PURE__ */createLargerEq({
     DenseMatrix,
     concat,
     config: config$1,
     matrix,
     typed
   });
   var leftShift = /* #__PURE__ */createLeftShift({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed,
     zeros
   });
   var matrixFromColumns = /* #__PURE__ */createMatrixFromColumns({
     flatten,
     matrix,
     size,
     typed
   });
   var mod = /* #__PURE__ */createMod({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var nthRoot = /* #__PURE__ */createNthRoot({
     BigNumber,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var ones = /* #__PURE__ */createOnes({
     BigNumber,
     config: config$1,
     matrix,
     typed
   });
   var resize = /* #__PURE__ */createResize({
     config: config$1,
     matrix
   });
   var rightArithShift = /* #__PURE__ */createRightArithShift({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed,
     zeros
   });
   var round = /* #__PURE__ */createRound({
     BigNumber,
     DenseMatrix,
     equalScalar,
     matrix,
     typed,
     zeros
   });
   var smaller = /* #__PURE__ */createSmaller({
     DenseMatrix,
     concat,
     config: config$1,
     matrix,
     typed
   });
   var subtract = /* #__PURE__ */createSubtract({
     DenseMatrix,
     addScalar,
     concat,
     equalScalar,
     matrix,
     typed,
     unaryMinus
   });
   var to = /* #__PURE__ */createTo({
     concat,
     matrix,
     typed
   });
   var unequal = /* #__PURE__ */createUnequal({
     DenseMatrix,
     concat,
     config: config$1,
     equalScalar,
     matrix,
     typed
   });
   var usolve = /* #__PURE__ */createUsolve({
     DenseMatrix,
     divideScalar,
     equalScalar,
     matrix,
     multiplyScalar,
     subtract,
     typed
   });
   var xor = /* #__PURE__ */createXor({
     DenseMatrix,
     concat,
     matrix,
     typed
   });
   var add = /* #__PURE__ */createAdd({
     DenseMatrix,
     SparseMatrix,
     addScalar,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var atan2 = /* #__PURE__ */createAtan2({
     BigNumber,
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var bitAnd = /* #__PURE__ */createBitAnd({
     concat,
     equalScalar,
     matrix,
     typed
   });
   var bitXor = /* #__PURE__ */createBitXor({
     DenseMatrix,
     concat,
     matrix,
     typed
   });
   var catalan = /* #__PURE__ */createCatalan({
     addScalar,
     combinations,
     divideScalar,
     isInteger,
     isNegative,
     multiplyScalar,
     typed
   });
   var compare = /* #__PURE__ */createCompare({
     BigNumber,
     DenseMatrix,
     Fraction,
     concat,
     config: config$1,
     equalScalar,
     matrix,
     typed
   });
   var compareText = /* #__PURE__ */createCompareText({
     concat,
     matrix,
     typed
   });
   var cumsum = /* #__PURE__ */createCumSum({
     add,
     typed,
     unaryPlus
   });
   var deepEqual = /* #__PURE__ */createDeepEqual({
     equal,
     typed
   });
   var diff = /* #__PURE__ */createDiff({
     matrix,
     number,
     subtract,
     typed
   });
   var distance = /* #__PURE__ */createDistance({
     abs,
     addScalar,
     deepEqual,
     divideScalar,
     multiplyScalar,
     sqrt,
     subtract,
     typed
   });
   var dot = /* #__PURE__ */createDot({
     addScalar,
     conj,
     multiplyScalar,
     size,
     typed
   });
   var equalText = /* #__PURE__ */createEqualText({
     compareText,
     isZero,
     typed
   });
   var floor = /* #__PURE__ */createFloor({
     DenseMatrix,
     config: config$1,
     equalScalar,
     matrix,
     round,
     typed,
     zeros
   });
   var hypot = /* #__PURE__ */createHypot({
     abs,
     addScalar,
     divideScalar,
     isPositive,
     multiplyScalar,
     smaller,
     sqrt,
     typed
   });
   var ImmutableDenseMatrix = /* #__PURE__ */createImmutableDenseMatrixClass({
     DenseMatrix,
     smaller
   });
   var Index = /* #__PURE__ */createIndexClass({
     ImmutableDenseMatrix,
     getMatrixDataType
   });
   var invmod = /* #__PURE__ */createInvmod({
     BigNumber,
     add,
     config: config$1,
     equal,
     isInteger,
     mod,
     smaller,
     typed,
     xgcd
   });
   var larger = /* #__PURE__ */createLarger({
     DenseMatrix,
     concat,
     config: config$1,
     matrix,
     typed
   });
   var log = /* #__PURE__ */createLog({
     Complex,
     config: config$1,
     divideScalar,
     typed
   });
   var lsolve = /* #__PURE__ */createLsolve({
     DenseMatrix,
     divideScalar,
     equalScalar,
     matrix,
     multiplyScalar,
     subtract,
     typed
   });
   var matrixFromRows = /* #__PURE__ */createMatrixFromRows({
     flatten,
     matrix,
     size,
     typed
   });
   var min = /* #__PURE__ */createMin({
     config: config$1,
     numeric,
     smaller,
     typed
   });
   var multiply = /* #__PURE__ */createMultiply({
     addScalar,
     dot,
     equalScalar,
     matrix,
     multiplyScalar,
     typed
   });
   var nthRoots = /* #__PURE__ */createNthRoots({
     Complex,
     config: config$1,
     divideScalar,
     typed
   });
   var or = /* #__PURE__ */createOr({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var partitionSelect = /* #__PURE__ */createPartitionSelect({
     compare,
     isNaN: isNaN$1,
     isNumeric,
     typed
   });
   var qr = /* #__PURE__ */createQr({
     addScalar,
     complex,
     conj,
     divideScalar,
     equal,
     identity,
     isZero,
     matrix,
     multiplyScalar,
     sign,
     sqrt,
     subtract,
     typed,
     unaryMinus,
     zeros
   });
   var rightLogShift = /* #__PURE__ */createRightLogShift({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed,
     zeros
   });
   var slu = /* #__PURE__ */createSlu({
     SparseMatrix,
     abs,
     add,
     divideScalar,
     larger,
     largerEq,
     multiply,
     subtract,
     transpose,
     typed
   });
   var subset = /* #__PURE__ */createSubset({
     add,
     matrix,
     typed,
     zeros
   });
   var sum = /* #__PURE__ */createSum({
     add,
     config: config$1,
     numeric,
     typed
   });
   var trace = /* #__PURE__ */createTrace({
     add,
     matrix,
     typed
   });
   var usolveAll = /* #__PURE__ */createUsolveAll({
     DenseMatrix,
     divideScalar,
     equalScalar,
     matrix,
     multiplyScalar,
     subtract,
     typed
   });
   var zpk2tf = /* #__PURE__ */createZpk2tf({
     Complex,
     add,
     multiply,
     number,
     typed
   });
   var bitOr = /* #__PURE__ */createBitOr({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     typed
   });
   var ceil = /* #__PURE__ */createCeil({
     DenseMatrix,
     config: config$1,
     equalScalar,
     matrix,
     round,
     typed,
     zeros
   });
   var compareNatural = /* #__PURE__ */createCompareNatural({
     compare,
     typed
   });
   var composition = /* #__PURE__ */createComposition({
     addScalar,
     combinations,
     isInteger,
     isNegative,
     isPositive,
     larger,
     typed
   });
   var cross = /* #__PURE__ */createCross({
     matrix,
     multiply,
     subtract,
     typed
   });
   var det = /* #__PURE__ */createDet({
     divideScalar,
     isZero,
     matrix,
     multiply,
     subtract,
     typed,
     unaryMinus
   });
   var dotMultiply = /* #__PURE__ */createDotMultiply({
     concat,
     equalScalar,
     matrix,
     multiplyScalar,
     typed
   });
   var FibonacciHeap = /* #__PURE__ */createFibonacciHeapClass({
     larger,
     smaller
   });
   var fix = /* #__PURE__ */createFix({
     Complex,
     DenseMatrix,
     ceil,
     equalScalar,
     floor,
     matrix,
     typed,
     zeros
   });
   var index = /* #__PURE__ */createIndex({
     Index,
     typed
   });
   var intersect = /* #__PURE__ */createIntersect({
     abs,
     add,
     addScalar,
     config: config$1,
     divideScalar,
     equalScalar,
     flatten,
     isNumeric,
     isZero,
     matrix,
     multiply,
     multiplyScalar,
     smaller,
     subtract,
     typed
   });
   var lcm = /* #__PURE__ */createLcm({
     concat,
     equalScalar,
     matrix,
     typed
   });
   var log1p = /* #__PURE__ */createLog1p({
     Complex,
     config: config$1,
     divideScalar,
     log,
     typed
   });
   var lsolveAll = /* #__PURE__ */createLsolveAll({
     DenseMatrix,
     divideScalar,
     equalScalar,
     matrix,
     multiplyScalar,
     subtract,
     typed
   });
   var max = /* #__PURE__ */createMax({
     config: config$1,
     larger,
     numeric,
     typed
   });
   var quantileSeq = /* #__PURE__ */createQuantileSeq({
     add,
     compare,
     isInteger,
     multiply,
     partitionSelect,
     typed
   });
   var setCartesian = /* #__PURE__ */createSetCartesian({
     DenseMatrix,
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setDistinct = /* #__PURE__ */createSetDistinct({
     DenseMatrix,
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setIsSubset = /* #__PURE__ */createSetIsSubset({
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setPowerset = /* #__PURE__ */createSetPowerset({
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var smallerEq = /* #__PURE__ */createSmallerEq({
     DenseMatrix,
     concat,
     config: config$1,
     matrix,
     typed
   });
   var sort = /* #__PURE__ */createSort({
     compare,
     compareNatural,
     matrix,
     typed
   });
   var and = /* #__PURE__ */createAnd({
     concat,
     equalScalar,
     matrix,
     not,
     typed,
     zeros
   });
   var range = /* #__PURE__ */createRange({
     bignumber,
     matrix,
     add,
     config: config$1,
     isPositive,
     larger,
     largerEq,
     smaller,
     smallerEq,
     typed
   });
   var row = /* #__PURE__ */createRow({
     Index,
     matrix,
     range,
     typed
   });
   var setDifference = /* #__PURE__ */createSetDifference({
     DenseMatrix,
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setMultiplicity = /* #__PURE__ */createSetMultiplicity({
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setSymDifference = /* #__PURE__ */createSetSymDifference({
     Index,
     concat,
     setDifference,
     size,
     subset,
     typed
   });
   var Spa = /* #__PURE__ */createSpaClass({
     FibonacciHeap,
     addScalar,
     equalScalar
   });
   var column = /* #__PURE__ */createColumn({
     Index,
     matrix,
     range,
     typed
   });
   var inv = /* #__PURE__ */createInv({
     abs,
     addScalar,
     det,
     divideScalar,
     identity,
     matrix,
     multiply,
     typed,
     unaryMinus
   });
   var lup = /* #__PURE__ */createLup({
     DenseMatrix,
     Spa,
     SparseMatrix,
     abs,
     addScalar,
     divideScalar,
     equalScalar,
     larger,
     matrix,
     multiplyScalar,
     subtract,
     typed,
     unaryMinus
   });
   var pinv = /* #__PURE__ */createPinv({
     Complex,
     add,
     ctranspose,
     deepEqual,
     divideScalar,
     dot,
     dotDivide,
     equal,
     inv,
     matrix,
     multiply,
     typed
   });
   var pow = /* #__PURE__ */createPow({
     Complex,
     config: config$1,
     fraction,
     identity,
     inv,
     matrix,
     multiply,
     number,
     typed
   });
   var setIntersect = /* #__PURE__ */createSetIntersect({
     DenseMatrix,
     Index,
     compareNatural,
     size,
     subset,
     typed
   });
   var setUnion = /* #__PURE__ */createSetUnion({
     Index,
     concat,
     setIntersect,
     setSymDifference,
     size,
     subset,
     typed
   });
   var sqrtm = /* #__PURE__ */createSqrtm({
     abs,
     add,
     identity,
     inv,
     map,
     max,
     multiply,
     size,
     sqrt,
     subtract,
     typed
   });
   var Unit = /* #__PURE__ */createUnitClass({
     BigNumber,
     Complex,
     Fraction,
     abs,
     addScalar,
     config: config$1,
     divideScalar,
     equal,
     fix,
     format,
     isNumeric,
     multiplyScalar,
     number,
     pow,
     round,
     subtract
   });
   var vacuumImpedance = /* #__PURE__ */createVacuumImpedance({
     BigNumber,
     Unit,
     config: config$1
   });
   var wienDisplacement = /* #__PURE__ */createWienDisplacement({
     BigNumber,
     Unit,
     config: config$1
   });
   var atomicMass = /* #__PURE__ */createAtomicMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var bohrMagneton = /* #__PURE__ */createBohrMagneton({
     BigNumber,
     Unit,
     config: config$1
   });
   var boltzmann = /* #__PURE__ */createBoltzmann({
     BigNumber,
     Unit,
     config: config$1
   });
   var conductanceQuantum = /* #__PURE__ */createConductanceQuantum({
     BigNumber,
     Unit,
     config: config$1
   });
   var coulomb = /* #__PURE__ */createCoulomb({
     BigNumber,
     Unit,
     config: config$1
   });
   var deuteronMass = /* #__PURE__ */createDeuteronMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var dotPow = /* #__PURE__ */createDotPow({
     DenseMatrix,
     concat,
     equalScalar,
     matrix,
     pow,
     typed
   });
   var electricConstant = /* #__PURE__ */createElectricConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var elementaryCharge = /* #__PURE__ */createElementaryCharge({
     BigNumber,
     Unit,
     config: config$1
   });
   var expm = /* #__PURE__ */createExpm({
     abs,
     add,
     identity,
     inv,
     multiply,
     typed
   });
   var faraday = /* #__PURE__ */createFaraday({
     BigNumber,
     Unit,
     config: config$1
   });
   var fft = /* #__PURE__ */createFft({
     addScalar,
     ceil,
     conj,
     divideScalar,
     dotDivide,
     exp,
     i,
     log2,
     matrix,
     multiplyScalar,
     pow,
     tau,
     typed
   });
   var gamma = /* #__PURE__ */createGamma({
     BigNumber,
     Complex,
     config: config$1,
     multiplyScalar,
     pow,
     typed
   });
   var gravitationConstant = /* #__PURE__ */createGravitationConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var hartreeEnergy = /* #__PURE__ */createHartreeEnergy({
     BigNumber,
     Unit,
     config: config$1
   });
   var ifft = /* #__PURE__ */createIfft({
     conj,
     dotDivide,
     fft,
     typed
   });
   var klitzing = /* #__PURE__ */createKlitzing({
     BigNumber,
     Unit,
     config: config$1
   });
   var loschmidt = /* #__PURE__ */createLoschmidt({
     BigNumber,
     Unit,
     config: config$1
   });
   var magneticConstant = /* #__PURE__ */createMagneticConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var molarMass = /* #__PURE__ */createMolarMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var molarPlanckConstant = /* #__PURE__ */createMolarPlanckConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var neutronMass = /* #__PURE__ */createNeutronMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var nuclearMagneton = /* #__PURE__ */createNuclearMagneton({
     BigNumber,
     Unit,
     config: config$1
   });
   var planckCharge = /* #__PURE__ */createPlanckCharge({
     BigNumber,
     Unit,
     config: config$1
   });
   var planckLength = /* #__PURE__ */createPlanckLength({
     BigNumber,
     Unit,
     config: config$1
   });
   var planckTemperature = /* #__PURE__ */createPlanckTemperature({
     BigNumber,
     Unit,
     config: config$1
   });
   var protonMass = /* #__PURE__ */createProtonMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var reducedPlanckConstant = /* #__PURE__ */createReducedPlanckConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var rydberg = /* #__PURE__ */createRydberg({
     BigNumber,
     Unit,
     config: config$1
   });
   var secondRadiation = /* #__PURE__ */createSecondRadiation({
     BigNumber,
     Unit,
     config: config$1
   });
   var speedOfLight = /* #__PURE__ */createSpeedOfLight({
     BigNumber,
     Unit,
     config: config$1
   });
   var stefanBoltzmann = /* #__PURE__ */createStefanBoltzmann({
     BigNumber,
     Unit,
     config: config$1
   });
   var thomsonCrossSection = /* #__PURE__ */createThomsonCrossSection({
     BigNumber,
     Unit,
     config: config$1
   });
   var avogadro = /* #__PURE__ */createAvogadro({
     BigNumber,
     Unit,
     config: config$1
   });
   var bohrRadius = /* #__PURE__ */createBohrRadius({
     BigNumber,
     Unit,
     config: config$1
   });
   var createUnit = /* #__PURE__ */createCreateUnit({
     Unit,
     typed
   });
   var divide = /* #__PURE__ */createDivide({
     divideScalar,
     equalScalar,
     inv,
     matrix,
     multiply,
     typed
   });
   var electronMass = /* #__PURE__ */createElectronMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var factorial = /* #__PURE__ */createFactorial({
     gamma,
     typed
   });
   var firstRadiation = /* #__PURE__ */createFirstRadiation({
     BigNumber,
     Unit,
     config: config$1
   });
   var gravity = /* #__PURE__ */createGravity({
     BigNumber,
     Unit,
     config: config$1
   });
   var inverseConductanceQuantum = /* #__PURE__ */createInverseConductanceQuantum({
     BigNumber,
     Unit,
     config: config$1
   });
   var lusolve = /* #__PURE__ */createLusolve({
     DenseMatrix,
     lsolve,
     lup,
     matrix,
     slu,
     typed,
     usolve
   });
   var magneticFluxQuantum = /* #__PURE__ */createMagneticFluxQuantum({
     BigNumber,
     Unit,
     config: config$1
   });
   var molarMassC12 = /* #__PURE__ */createMolarMassC12({
     BigNumber,
     Unit,
     config: config$1
   });
   var multinomial = /* #__PURE__ */createMultinomial({
     add,
     divide,
     factorial,
     isInteger,
     isPositive,
     multiply,
     typed
   });
   var permutations = /* #__PURE__ */createPermutations({
     factorial,
     typed
   });
   var planckMass = /* #__PURE__ */createPlanckMass({
     BigNumber,
     Unit,
     config: config$1
   });
   var polynomialRoot = /* #__PURE__ */createPolynomialRoot({
     add,
     cbrt,
     divide,
     equalScalar,
     im,
     isZero,
     multiply,
     re,
     sqrt,
     subtract,
     typeOf,
     typed,
     unaryMinus
   });
   var setSize = /* #__PURE__ */createSetSize({
     compareNatural,
     typed
   });
   var solveODE = /* #__PURE__ */createSolveODE({
     abs,
     add,
     bignumber,
     divide,
     isNegative,
     isPositive,
     larger,
     map,
     matrix,
     max,
     multiply,
     smaller,
     subtract,
     typed,
     unaryMinus
   });
   var stirlingS2 = /* #__PURE__ */createStirlingS2({
     bignumber,
     addScalar,
     combinations,
     divideScalar,
     factorial,
     isInteger,
     isNegative,
     larger,
     multiplyScalar,
     number,
     pow,
     subtract,
     typed
   });
   var unit = /* #__PURE__ */createUnitFunction({
     Unit,
     typed
   });
   var bellNumbers = /* #__PURE__ */createBellNumbers({
     addScalar,
     isInteger,
     isNegative,
     stirlingS2,
     typed
   });
   var eigs = /* #__PURE__ */createEigs({
     abs,
     add,
     addScalar,
     atan,
     bignumber,
     column,
     complex,
     config: config$1,
     cos,
     diag,
     divideScalar,
     dot,
     equal,
     flatten,
     im,
     inv,
     larger,
     matrix,
     matrixFromColumns,
     multiply,
     multiplyScalar,
     number,
     qr,
     re,
     sin,
     smaller,
     sqrt,
     subtract,
     typed,
     usolve,
     usolveAll
   });
   var fermiCoupling = /* #__PURE__ */createFermiCoupling({
     BigNumber,
     Unit,
     config: config$1
   });
   var gasConstant = /* #__PURE__ */createGasConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var mean = /* #__PURE__ */createMean({
     add,
     divide,
     typed
   });
   var molarVolume = /* #__PURE__ */createMolarVolume({
     BigNumber,
     Unit,
     config: config$1
   });
   var planckConstant = /* #__PURE__ */createPlanckConstant({
     BigNumber,
     Unit,
     config: config$1
   });
   var quantumOfCirculation = /* #__PURE__ */createQuantumOfCirculation({
     BigNumber,
     Unit,
     config: config$1
   });
   var variance = /* #__PURE__ */createVariance({
     add,
     apply,
     divide,
     isNaN: isNaN$1,
     multiply,
     subtract,
     typed
   });
   var classicalElectronRadius = /* #__PURE__ */createClassicalElectronRadius({
     BigNumber,
     Unit,
     config: config$1
   });
   var median = /* #__PURE__ */createMedian({
     add,
     compare,
     divide,
     partitionSelect,
     typed
   });
   var corr = /* #__PURE__ */createCorr({
     add,
     divide,
     matrix,
     mean,
     multiply,
     pow,
     sqrt,
     subtract,
     sum,
     typed
   });
   var freqz = /* #__PURE__ */createFreqz({
     Complex,
     add,
     divide,
     matrix,
     multiply,
     typed
   });
   var mad = /* #__PURE__ */createMad({
     abs,
     map,
     median,
     subtract,
     typed
   });
   var std = /* #__PURE__ */createStd({
     map,
     sqrt,
     typed,
     variance
   });
   var zeta = /* #__PURE__ */createZeta({
     BigNumber,
     Complex,
     add,
     config: config$1,
     divide,
     equal,
     factorial,
     gamma,
     isNegative,
     multiply,
     pi,
     pow,
     sin,
     smallerEq,
     subtract,
     typed
   });
   var norm = /* #__PURE__ */createNorm({
     abs,
     add,
     conj,
     ctranspose,
     eigs,
     equalScalar,
     larger,
     matrix,
     multiply,
     pow,
     smaller,
     sqrt,
     typed
   });
   var rotationMatrix = /* #__PURE__ */createRotationMatrix({
     BigNumber,
     DenseMatrix,
     SparseMatrix,
     addScalar,
     config: config$1,
     cos,
     matrix,
     multiplyScalar,
     norm,
     sin,
     typed,
     unaryMinus
   });
   var kldivergence = /* #__PURE__ */createKldivergence({
     divide,
     dotDivide,
     isNumeric,
     log,
     map,
     matrix,
     multiply,
     sum,
     typed
   });
   var planckTime = /* #__PURE__ */createPlanckTime({
     BigNumber,
     Unit,
     config: config$1
   });
   var schur = /* #__PURE__ */createSchur({
     identity,
     matrix,
     multiply,
     norm,
     qr,
     subtract,
     typed
   });
   var rotate = /* #__PURE__ */createRotate({
     multiply,
     rotationMatrix,
     typed
   });
   var sylvester = /* #__PURE__ */createSylvester({
     abs,
     add,
     concat,
     identity,
     index,
     lusolve,
     matrix,
     matrixFromColumns,
     multiply,
     range,
     schur,
     subset,
     subtract,
     transpose,
     typed
   });
   var lyap = /* #__PURE__ */createLyap({
     matrix,
     multiply,
     sylvester,
     transpose,
     typed
   });

   var math = {}; // NOT pure!
   var mathWithTransform = {}; // NOT pure!
   var classes = {}; // NOT pure!

   var Node = createNode({
     mathWithTransform
   });
   var ObjectNode = createObjectNode({
     Node
   });
   var OperatorNode = createOperatorNode({
     Node
   });
   var ParenthesisNode = createParenthesisNode({
     Node
   });
   var RelationalNode = createRelationalNode({
     Node
   });
   var ArrayNode = createArrayNode({
     Node
   });
   var BlockNode = createBlockNode({
     Node,
     ResultSet
   });
   var ConditionalNode = createConditionalNode({
     Node
   });
   var ConstantNode = createConstantNode({
     Node
   });
   var RangeNode = createRangeNode({
     Node
   });
   var reviver = createReviver({
     classes
   });
   var Chain = createChainClass({
     math,
     typed
   });
   var FunctionAssignmentNode = createFunctionAssignmentNode({
     Node,
     typed
   });
   var chain = createChain({
     Chain,
     typed
   });
   var IndexNode = createIndexNode({
     Node,
     size
   });
   var AccessorNode = createAccessorNode({
     Node,
     subset
   });
   var AssignmentNode = createAssignmentNode({
     matrix,
     Node,
     subset
   });
   var SymbolNode = createSymbolNode({
     Unit,
     Node,
     math
   });
   var FunctionNode = createFunctionNode({
     Node,
     SymbolNode,
     math
   });
   var parse = createParse({
     AccessorNode,
     ArrayNode,
     AssignmentNode,
     BlockNode,
     ConditionalNode,
     ConstantNode,
     FunctionAssignmentNode,
     FunctionNode,
     IndexNode,
     ObjectNode,
     OperatorNode,
     ParenthesisNode,
     RangeNode,
     RelationalNode,
     SymbolNode,
     config: config$1,
     numeric,
     typed
   });
   var resolve = createResolve({
     ConstantNode,
     FunctionNode,
     OperatorNode,
     ParenthesisNode,
     parse,
     typed
   });
   var simplifyConstant = createSimplifyConstant({
     bignumber,
     fraction,
     AccessorNode,
     ArrayNode,
     ConstantNode,
     FunctionNode,
     IndexNode,
     ObjectNode,
     OperatorNode,
     SymbolNode,
     config: config$1,
     mathWithTransform,
     matrix,
     typed
   });
   var compile = createCompile({
     parse,
     typed
   });
   var Help = createHelpClass({
     parse
   });
   var leafCount = createLeafCount({
     parse,
     typed
   });
   var simplifyCore = createSimplifyCore({
     AccessorNode,
     ArrayNode,
     ConstantNode,
     FunctionNode,
     IndexNode,
     ObjectNode,
     OperatorNode,
     ParenthesisNode,
     SymbolNode,
     add,
     divide,
     equal,
     isZero,
     multiply,
     parse,
     pow,
     subtract,
     typed
   });
   var evaluate = createEvaluate({
     parse,
     typed
   });
   var help = createHelp({
     Help,
     mathWithTransform,
     typed
   });
   var Parser = createParserClass({
     evaluate
   });
   var simplify = createSimplify({
     bignumber,
     fraction,
     AccessorNode,
     ArrayNode,
     ConstantNode,
     FunctionNode,
     IndexNode,
     ObjectNode,
     OperatorNode,
     ParenthesisNode,
     SymbolNode,
     add,
     config: config$1,
     divide,
     equal,
     isZero,
     mathWithTransform,
     matrix,
     multiply,
     parse,
     pow,
     resolve,
     simplifyConstant,
     simplifyCore,
     subtract,
     typed
   });
   var symbolicEqual = createSymbolicEqual({
     OperatorNode,
     parse,
     simplify,
     typed
   });
   var parser$1 = createParser({
     Parser,
     typed
   });
   var rationalize = createRationalize({
     bignumber,
     fraction,
     AccessorNode,
     ArrayNode,
     ConstantNode,
     FunctionNode,
     IndexNode,
     ObjectNode,
     OperatorNode,
     ParenthesisNode,
     SymbolNode,
     add,
     config: config$1,
     divide,
     equal,
     isZero,
     mathWithTransform,
     matrix,
     multiply,
     parse,
     pow,
     simplify,
     simplifyConstant,
     simplifyCore,
     subtract,
     typed
   });
   var derivative = createDerivative({
     ConstantNode,
     FunctionNode,
     OperatorNode,
     ParenthesisNode,
     SymbolNode,
     config: config$1,
     equal,
     isZero,
     numeric,
     parse,
     simplify,
     typed
   });
   _extends$1(math, {
     e,
     false: _false,
     fineStructure,
     i,
     Infinity: _Infinity,
     LN10,
     LOG10E,
     NaN: _NaN,
     null: _null,
     phi,
     SQRT1_2,
     sackurTetrode,
     tau,
     true: _true,
     'E': e,
     version,
     efimovFactor,
     LN2,
     pi,
     replacer,
     reviver,
     SQRT2,
     typed,
     unaryPlus,
     'PI': pi,
     weakMixingAngle,
     abs,
     acos,
     acot,
     acsc,
     addScalar,
     arg,
     asech,
     asinh,
     atan,
     atanh,
     bignumber,
     bitNot,
     boolean,
     clone,
     combinations,
     complex,
     conj,
     cos,
     cot,
     csc,
     cube,
     equalScalar,
     erf,
     exp,
     expm1,
     filter,
     forEach,
     format,
     getMatrixDataType,
     hex,
     im,
     isInteger,
     isNegative,
     isPositive,
     isZero,
     LOG2E,
     lgamma,
     log10,
     log2,
     map,
     multiplyScalar,
     not,
     number,
     oct,
     pickRandom,
     print,
     random,
     re,
     sec,
     sign,
     sin,
     splitUnit,
     square,
     string,
     tan,
     typeOf,
     acosh,
     acsch,
     apply,
     asec,
     bin,
     chain,
     combinationsWithRep,
     cosh,
     csch,
     isNaN: isNaN$1,
     isPrime,
     randomInt,
     sech,
     sinh,
     sparse,
     sqrt,
     tanh,
     unaryMinus,
     acoth,
     coth,
     fraction,
     isNumeric,
     matrix,
     matrixFromFunction,
     mode,
     numeric,
     prod,
     reshape,
     size,
     squeeze,
     transpose,
     xgcd,
     zeros,
     asin,
     cbrt,
     concat,
     count,
     ctranspose,
     diag,
     divideScalar,
     dotDivide,
     equal,
     flatten,
     gcd,
     hasNumericValue,
     identity,
     kron,
     largerEq,
     leftShift,
     matrixFromColumns,
     mod,
     nthRoot,
     ones,
     resize,
     rightArithShift,
     round,
     smaller,
     subtract,
     to,
     unequal,
     usolve,
     xor,
     add,
     atan2,
     bitAnd,
     bitXor,
     catalan,
     compare,
     compareText,
     cumsum,
     deepEqual,
     diff,
     distance,
     dot,
     equalText,
     floor,
     hypot,
     invmod,
     larger,
     log,
     lsolve,
     matrixFromRows,
     min,
     multiply,
     nthRoots,
     or,
     partitionSelect,
     qr,
     rightLogShift,
     slu,
     subset,
     sum,
     trace,
     usolveAll,
     zpk2tf,
     bitOr,
     ceil,
     compareNatural,
     composition,
     cross,
     det,
     dotMultiply,
     fix,
     index,
     intersect,
     lcm,
     log1p,
     lsolveAll,
     max,
     quantileSeq,
     setCartesian,
     setDistinct,
     setIsSubset,
     setPowerset,
     smallerEq,
     sort,
     and,
     range,
     row,
     setDifference,
     setMultiplicity,
     setSymDifference,
     column,
     inv,
     lup,
     pinv,
     pow,
     setIntersect,
     setUnion,
     sqrtm,
     vacuumImpedance,
     wienDisplacement,
     atomicMass,
     bohrMagneton,
     boltzmann,
     conductanceQuantum,
     coulomb,
     deuteronMass,
     dotPow,
     electricConstant,
     elementaryCharge,
     expm,
     faraday,
     fft,
     gamma,
     gravitationConstant,
     hartreeEnergy,
     ifft,
     klitzing,
     loschmidt,
     magneticConstant,
     molarMass,
     molarPlanckConstant,
     neutronMass,
     nuclearMagneton,
     planckCharge,
     planckLength,
     planckTemperature,
     protonMass,
     reducedPlanckConstant,
     rydberg,
     secondRadiation,
     speedOfLight,
     stefanBoltzmann,
     thomsonCrossSection,
     avogadro,
     bohrRadius,
     createUnit,
     divide,
     electronMass,
     factorial,
     firstRadiation,
     gravity,
     inverseConductanceQuantum,
     lusolve,
     magneticFluxQuantum,
     molarMassC12,
     multinomial,
     parse,
     permutations,
     planckMass,
     polynomialRoot,
     resolve,
     setSize,
     simplifyConstant,
     solveODE,
     stirlingS2,
     unit,
     bellNumbers,
     compile,
     eigs,
     fermiCoupling,
     gasConstant,
     leafCount,
     mean,
     molarVolume,
     planckConstant,
     quantumOfCirculation,
     simplifyCore,
     variance,
     classicalElectronRadius,
     evaluate,
     help,
     median,
     simplify,
     symbolicEqual,
     corr,
     freqz,
     mad,
     parser: parser$1,
     rationalize,
     std,
     zeta,
     derivative,
     norm,
     rotationMatrix,
     kldivergence,
     planckTime,
     schur,
     rotate,
     sylvester,
     lyap,
     config: config$1
   });
   _extends$1(mathWithTransform, math, {
     filter: createFilterTransform({
       typed
     }),
     forEach: createForEachTransform({
       typed
     }),
     map: createMapTransform({
       typed
     }),
     apply: createApplyTransform({
       isInteger,
       typed
     }),
     concat: createConcatTransform({
       isInteger,
       matrix,
       typed
     }),
     max: createMaxTransform({
       config: config$1,
       larger,
       numeric,
       typed
     }),
     quantileSeq: createQuantileSeqTransform({
       add,
       compare,
       isInteger,
       multiply,
       partitionSelect,
       typed
     }),
     diff: createDiffTransform({
       bignumber,
       matrix,
       number,
       subtract,
       typed
     }),
     min: createMinTransform({
       config: config$1,
       numeric,
       smaller,
       typed
     }),
     subset: createSubsetTransform({
       add,
       matrix,
       typed,
       zeros
     }),
     cumsum: createCumSumTransform({
       add,
       typed,
       unaryPlus
     }),
     index: createIndexTransform({
       Index,
       getMatrixDataType
     }),
     sum: createSumTransform({
       add,
       config: config$1,
       numeric,
       typed
     }),
     range: createRangeTransform({
       bignumber,
       matrix,
       add,
       config: config$1,
       isPositive,
       larger,
       largerEq,
       smaller,
       smallerEq,
       typed
     }),
     row: createRowTransform({
       Index,
       matrix,
       range,
       typed
     }),
     column: createColumnTransform({
       Index,
       matrix,
       range,
       typed
     }),
     mean: createMeanTransform({
       add,
       divide,
       typed
     }),
     variance: createVarianceTransform({
       add,
       apply,
       divide,
       isNaN: isNaN$1,
       multiply,
       subtract,
       typed
     }),
     std: createStdTransform({
       map,
       sqrt,
       typed,
       variance
     })
   });
   _extends$1(classes, {
     BigNumber,
     Complex,
     Fraction,
     Matrix,
     Node,
     ObjectNode,
     OperatorNode,
     ParenthesisNode,
     Range,
     RelationalNode,
     ResultSet,
     ArrayNode,
     BlockNode,
     ConditionalNode,
     ConstantNode,
     DenseMatrix,
     RangeNode,
     Chain,
     FunctionAssignmentNode,
     SparseMatrix,
     IndexNode,
     ImmutableDenseMatrix,
     Index,
     AccessorNode,
     AssignmentNode,
     FibonacciHeap,
     Spa,
     Unit,
     SymbolNode,
     FunctionNode,
     Help,
     Parser
   });
   Chain.createProxy(math);

   typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
       var e = new Error(message);
       return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
   };
   // Current state of the autosuggestion
   const InlineSuggestionState = StateField.define({
       create() {
           return { suggestion: null };
       },
       update(__, tr) {
           const inlineSuggestion = tr.effects.find((e) => e.is(InlineSuggestionEffect));
           if (tr.state.doc)
               if (inlineSuggestion && tr.state.doc == inlineSuggestion.value.doc) {
                   return { suggestion: inlineSuggestion.value.text };
               }
           return { suggestion: null };
       },
   });
   const InlineSuggestionEffect = StateEffect.define();
   /**
    * Provides a suggestion for the next word
    */
   function inlineSuggestionDecoration(view) {
       const scope = new Map();
       const widgets = [];
       for (let n = 1; n <= view.state.doc.lines; n++) {
           const line = view.state.doc.line(n);
           let result;
           try {
               // TODO add cache?
               // var cached = calque.cache[line.code];
               // if (!cached) {
               //   const parsed = math.parse(line.code);
               //   const compiled = parsed.compile();
               //   cached = { parsed, compiled };
               //   calque.cache[line.code] = cached;
               // }
               const parsed = parse(line.text);
               const compiled = parsed.compile();
               result = compiled.evaluate(scope);
           }
           catch (error) {
               result = error;
           }
           if (result !== undefined) {
               const widget = Decoration.widget({
                   widget: new InlineSuggestionWidget(result),
                   side: 1,
               });
               widgets.push(widget.range(line.to));
           }
       }
       // for (const {from, to} of view.visibleRanges) {
       //   for (let pos = from; pos <= to;) {
       //     const line = view.state.doc.lineAt(pos)
       //     const w = Decoration.widget({
       //       widget: new InlineSuggestionWidget(prefix),
       //       side: 1,
       //     });
       //     widgets.push(w.range(line.to));
       //     pos = line.to + 1;
       //   }
       // }
       return Decoration.set(widgets);
       // const pos = view.state.selection.main.head;
       // const widgets = [];
       // const w = Decoration.widget({
       //   widget: new InlineSuggestionWidget(prefix),
       //   side: 1,
       // });
       // widgets.push(w.range(pos));
       // return Decoration.set(widgets);
   }
   class InlineSuggestionWidget extends WidgetType {
       constructor(suggestion) {
           super();
           this.suggestion = suggestion;
       }
       toDOM() {
           const div = document.createElement('span');
           div.style.opacity = '0.4';
           div.className = 'cm-inline-suggestion';
           let prefix = ' = ';
           if (this.suggestion instanceof Error) {
               prefix = ' ';
               div.style.color = 'red';
           }
           div.textContent = `${prefix}${this.suggestion}`;
           return div;
       }
   }
   const renderInlineSuggestionPlugin = ViewPlugin.fromClass(class Plugin {
       constructor(editor) {
           this.decorations = inlineSuggestionDecoration(editor);
       }
       update(update) {
           if (update.docChanged || update.viewportChanged) {
               this.decorations = inlineSuggestionDecoration(update.view);
           }
       }
   }, {
       decorations: (v) => v.decorations,
   });
   Prec.highest(keymap.of([
       {
           key: 'Tab',
           run: (view) => {
               var _a;
               const suggestionText = (_a = view.state.field(InlineSuggestionState)) === null || _a === void 0 ? void 0 : _a.suggestion;
               // If there is no suggestion, do nothing and let the default keymap handle it
               if (!suggestionText) {
                   return false;
               }
               view.dispatch(Object.assign({}, insertCompletionText(view.state, suggestionText, view.state.selection.main.head, view.state.selection.main.head)));
               return true;
           },
       },
   ]));
   function insertCompletionText(state, text, from, to) {
       return Object.assign(Object.assign({}, state.changeByRange((range) => {
           if (range == state.selection.main)
               return {
                   changes: { from: from, to: to, insert: text },
                   range: EditorSelection.cursor(from + text.length),
               };
           const len = to - from;
           if (!range.empty ||
               (len &&
                   state.sliceDoc(range.from - len, range.from) !=
                       state.sliceDoc(from, to)))
               return { range };
           return {
               changes: { from: range.from - len, to: range.from, insert: text },
               range: EditorSelection.cursor(range.from - len + text.length),
           };
       })), { userEvent: 'input.complete' });
   }

   /**
   A parse stack. These are used internally by the parser to track
   parsing progress. They also provide some properties and methods
   that external code such as a tokenizer can use to get information
   about the parse state.
   */
   class Stack {
       /**
       @internal
       */
       constructor(
       /**
       The parse that this stack is part of @internal
       */
       p, 
       /**
       Holds state, input pos, buffer index triplets for all but the
       top state @internal
       */
       stack, 
       /**
       The current parse state @internal
       */
       state, 
       // The position at which the next reduce should take place. This
       // can be less than `this.pos` when skipped expressions have been
       // added to the stack (which should be moved outside of the next
       // reduction)
       /**
       @internal
       */
       reducePos, 
       /**
       The input position up to which this stack has parsed.
       */
       pos, 
       /**
       The dynamic score of the stack, including dynamic precedence
       and error-recovery penalties
       @internal
       */
       score, 
       // The output buffer. Holds (type, start, end, size) quads
       // representing nodes created by the parser, where `size` is
       // amount of buffer array entries covered by this node.
       /**
       @internal
       */
       buffer, 
       // The base offset of the buffer. When stacks are split, the split
       // instance shared the buffer history with its parent up to
       // `bufferBase`, which is the absolute offset (including the
       // offset of previous splits) into the buffer at which this stack
       // starts writing.
       /**
       @internal
       */
       bufferBase, 
       /**
       @internal
       */
       curContext, 
       /**
       @internal
       */
       lookAhead = 0, 
       // A parent stack from which this was split off, if any. This is
       // set up so that it always points to a stack that has some
       // additional buffer content, never to a stack with an equal
       // `bufferBase`.
       /**
       @internal
       */
       parent) {
           this.p = p;
           this.stack = stack;
           this.state = state;
           this.reducePos = reducePos;
           this.pos = pos;
           this.score = score;
           this.buffer = buffer;
           this.bufferBase = bufferBase;
           this.curContext = curContext;
           this.lookAhead = lookAhead;
           this.parent = parent;
       }
       /**
       @internal
       */
       toString() {
           return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
       }
       // Start an empty stack
       /**
       @internal
       */
       static start(p, state, pos = 0) {
           let cx = p.parser.context;
           return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
       }
       /**
       The stack's current [context](#lr.ContextTracker) value, if
       any. Its type will depend on the context tracker's type
       parameter, or it will be `null` if there is no context
       tracker.
       */
       get context() { return this.curContext ? this.curContext.context : null; }
       // Push a state onto the stack, tracking its start position as well
       // as the buffer base at that point.
       /**
       @internal
       */
       pushState(state, start) {
           this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
           this.state = state;
       }
       // Apply a reduce action
       /**
       @internal
       */
       reduce(action) {
           var _a;
           let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;
           let { parser } = this.p;
           let dPrec = parser.dynamicPrecedence(type);
           if (dPrec)
               this.score += dPrec;
           if (depth == 0) {
               this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
               // Zero-depth reductions are a special case—they add stuff to
               // the stack without popping anything off.
               if (type < parser.minRepeatTerm)
                   this.storeNode(type, this.reducePos, this.reducePos, 4, true);
               this.reduceContext(type, this.reducePos);
               return;
           }
           // Find the base index into `this.stack`, content after which will
           // be dropped. Note that with `StayFlag` reductions we need to
           // consume two extra frames (the dummy parent node for the skipped
           // expression and the state that we'll be staying in, which should
           // be moved to `this.state`).
           let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);
           let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
           // This is a kludge to try and detect overly deep left-associative
           // trees, which will not increase the parse stack depth and thus
           // won't be caught by the regular stack-depth limit check.
           if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
               if (start == this.p.lastBigReductionStart) {
                   this.p.bigReductionCount++;
                   this.p.lastBigReductionSize = size;
               }
               else if (this.p.lastBigReductionSize < size) {
                   this.p.bigReductionCount = 1;
                   this.p.lastBigReductionStart = start;
                   this.p.lastBigReductionSize = size;
               }
           }
           let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
           // Store normal terms or `R -> R R` repeat reductions
           if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {
               let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;
               this.storeNode(type, start, pos, count + 4, true);
           }
           if (action & 262144 /* Action.StayFlag */) {
               this.state = this.stack[base];
           }
           else {
               let baseStateID = this.stack[base - 3];
               this.state = parser.getGoto(baseStateID, type, true);
           }
           while (this.stack.length > base)
               this.stack.pop();
           this.reduceContext(type, start);
       }
       // Shift a value into the buffer
       /**
       @internal
       */
       storeNode(term, start, end, size = 4, isReduce = false) {
           if (term == 0 /* Term.Err */ &&
               (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
               // Try to omit/merge adjacent error nodes
               let cur = this, top = this.buffer.length;
               if (top == 0 && cur.parent) {
                   top = cur.bufferBase - cur.parent.bufferBase;
                   cur = cur.parent;
               }
               if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {
                   if (start == end)
                       return;
                   if (cur.buffer[top - 2] >= start) {
                       cur.buffer[top - 2] = end;
                       return;
                   }
               }
           }
           if (!isReduce || this.pos == end) { // Simple case, just append
               this.buffer.push(term, start, end, size);
           }
           else { // There may be skipped nodes that have to be moved forward
               let index = this.buffer.length;
               if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)
                   while (index > 0 && this.buffer[index - 2] > end) {
                       // Move this record forward
                       this.buffer[index] = this.buffer[index - 4];
                       this.buffer[index + 1] = this.buffer[index - 3];
                       this.buffer[index + 2] = this.buffer[index - 2];
                       this.buffer[index + 3] = this.buffer[index - 1];
                       index -= 4;
                       if (size > 4)
                           size -= 4;
                   }
               this.buffer[index] = term;
               this.buffer[index + 1] = start;
               this.buffer[index + 2] = end;
               this.buffer[index + 3] = size;
           }
       }
       // Apply a shift action
       /**
       @internal
       */
       shift(action, next, nextEnd) {
           let start = this.pos;
           if (action & 131072 /* Action.GotoFlag */) {
               this.pushState(action & 65535 /* Action.ValueMask */, this.pos);
           }
           else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift
               let nextState = action, { parser } = this.p;
               if (nextEnd > this.pos || next <= parser.maxNode) {
                   this.pos = nextEnd;
                   if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))
                       this.reducePos = nextEnd;
               }
               this.pushState(nextState, start);
               this.shiftContext(next, start);
               if (next <= parser.maxNode)
                   this.buffer.push(next, start, nextEnd, 4);
           }
           else { // Shift-and-stay, which means this is a skipped token
               this.pos = nextEnd;
               this.shiftContext(next, start);
               if (next <= this.p.parser.maxNode)
                   this.buffer.push(next, start, nextEnd, 4);
           }
       }
       // Apply an action
       /**
       @internal
       */
       apply(action, next, nextEnd) {
           if (action & 65536 /* Action.ReduceFlag */)
               this.reduce(action);
           else
               this.shift(action, next, nextEnd);
       }
       // Add a prebuilt (reused) node into the buffer.
       /**
       @internal
       */
       useNode(value, next) {
           let index = this.p.reused.length - 1;
           if (index < 0 || this.p.reused[index] != value) {
               this.p.reused.push(value);
               index++;
           }
           let start = this.pos;
           this.reducePos = this.pos = start + value.length;
           this.pushState(next, start);
           this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
           if (this.curContext)
               this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
       }
       // Split the stack. Due to the buffer sharing and the fact
       // that `this.stack` tends to stay quite shallow, this isn't very
       // expensive.
       /**
       @internal
       */
       split() {
           let parent = this;
           let off = parent.buffer.length;
           // Because the top of the buffer (after this.pos) may be mutated
           // to reorder reductions and skipped tokens, and shared buffers
           // should be immutable, this copies any outstanding skipped tokens
           // to the new buffer, and puts the base pointer before them.
           while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
               off -= 4;
           let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
           // Make sure parent points to an actual parent with content, if there is such a parent.
           while (parent && base == parent.bufferBase)
               parent = parent.parent;
           return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
       }
       // Try to recover from an error by 'deleting' (ignoring) one token.
       /**
       @internal
       */
       recoverByDelete(next, nextEnd) {
           let isNode = next <= this.p.parser.maxNode;
           if (isNode)
               this.storeNode(next, this.pos, nextEnd, 4);
           this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);
           this.pos = this.reducePos = nextEnd;
           this.score -= 190 /* Recover.Delete */;
       }
       /**
       Check if the given term would be able to be shifted (optionally
       after some reductions) on this stack. This can be useful for
       external tokenizers that want to make sure they only provide a
       given token when it applies.
       */
       canShift(term) {
           for (let sim = new SimulatedStack(this);;) {
               let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
               if (action == 0)
                   return false;
               if ((action & 65536 /* Action.ReduceFlag */) == 0)
                   return true;
               sim.reduce(action);
           }
       }
       // Apply up to Recover.MaxNext recovery actions that conceptually
       // inserts some missing token or rule.
       /**
       @internal
       */
       recoverByInsert(next) {
           if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)
               return [];
           let nextStates = this.p.parser.nextStates(this.state);
           if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {
               let best = [];
               for (let i = 0, s; i < nextStates.length; i += 2) {
                   if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                       best.push(nextStates[i], s);
               }
               if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)
                   for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {
                       let s = nextStates[i + 1];
                       if (!best.some((v, i) => (i & 1) && v == s))
                           best.push(nextStates[i], s);
                   }
               nextStates = best;
           }
           let result = [];
           for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {
               let s = nextStates[i + 1];
               if (s == this.state)
                   continue;
               let stack = this.split();
               stack.pushState(s, this.pos);
               stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);
               stack.shiftContext(nextStates[i], this.pos);
               stack.score -= 200 /* Recover.Insert */;
               result.push(stack);
           }
           return result;
       }
       // Force a reduce, if possible. Return false if that can't
       // be done.
       /**
       @internal
       */
       forceReduce() {
           let { parser } = this.p;
           let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);
           if ((reduce & 65536 /* Action.ReduceFlag */) == 0)
               return false;
           if (!parser.validAction(this.state, reduce)) {
               let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;
               let target = this.stack.length - depth * 3;
               if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
                   let backup = this.findForcedReduction();
                   if (backup == null)
                       return false;
                   reduce = backup;
               }
               this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
               this.score -= 100 /* Recover.Reduce */;
           }
           this.reducePos = this.pos;
           this.reduce(reduce);
           return true;
       }
       /**
       Try to scan through the automaton to find some kind of reduction
       that can be applied. Used when the regular ForcedReduce field
       isn't a valid action. @internal
       */
       findForcedReduction() {
           let { parser } = this.p, seen = [];
           let explore = (state, depth) => {
               if (seen.includes(state))
                   return;
               seen.push(state);
               return parser.allActions(state, (action) => {
                   if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;
                   else if (action & 65536 /* Action.ReduceFlag */) {
                       let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;
                       if (rDepth > 1) {
                           let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;
                           if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)
                               return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;
                       }
                   }
                   else {
                       let found = explore(action, depth + 1);
                       if (found != null)
                           return found;
                   }
               });
           };
           return explore(this.state, 0);
       }
       /**
       @internal
       */
       forceAll() {
           while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {
               if (!this.forceReduce()) {
                   this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
                   break;
               }
           }
           return this;
       }
       /**
       Check whether this state has no further actions (assumed to be a direct descendant of the
       top state, since any other states must be able to continue
       somehow). @internal
       */
       get deadEnd() {
           if (this.stack.length != 3)
               return false;
           let { parser } = this.p;
           return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&
               !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);
       }
       /**
       Restart the stack (put it back in its start state). Only safe
       when this.stack.length == 3 (state is directly below the top
       state). @internal
       */
       restart() {
           this.state = this.stack[0];
           this.stack.length = 0;
       }
       /**
       @internal
       */
       sameState(other) {
           if (this.state != other.state || this.stack.length != other.stack.length)
               return false;
           for (let i = 0; i < this.stack.length; i += 3)
               if (this.stack[i] != other.stack[i])
                   return false;
           return true;
       }
       /**
       Get the parser used by this stack.
       */
       get parser() { return this.p.parser; }
       /**
       Test whether a given dialect (by numeric ID, as exported from
       the terms file) is enabled.
       */
       dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
       shiftContext(term, start) {
           if (this.curContext)
               this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
       }
       reduceContext(term, start) {
           if (this.curContext)
               this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
       }
       /**
       @internal
       */
       emitContext() {
           let last = this.buffer.length - 1;
           if (last < 0 || this.buffer[last] != -3)
               this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
       }
       /**
       @internal
       */
       emitLookAhead() {
           let last = this.buffer.length - 1;
           if (last < 0 || this.buffer[last] != -4)
               this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
       }
       updateContext(context) {
           if (context != this.curContext.context) {
               let newCx = new StackContext(this.curContext.tracker, context);
               if (newCx.hash != this.curContext.hash)
                   this.emitContext();
               this.curContext = newCx;
           }
       }
       /**
       @internal
       */
       setLookAhead(lookAhead) {
           if (lookAhead > this.lookAhead) {
               this.emitLookAhead();
               this.lookAhead = lookAhead;
           }
       }
       /**
       @internal
       */
       close() {
           if (this.curContext && this.curContext.tracker.strict)
               this.emitContext();
           if (this.lookAhead > 0)
               this.emitLookAhead();
       }
   }
   class StackContext {
       constructor(tracker, context) {
           this.tracker = tracker;
           this.context = context;
           this.hash = tracker.strict ? tracker.hash(context) : 0;
       }
   }
   // Used to cheaply run some reductions to scan ahead without mutating
   // an entire stack
   class SimulatedStack {
       constructor(start) {
           this.start = start;
           this.state = start.state;
           this.stack = start.stack;
           this.base = this.stack.length;
       }
       reduce(action) {
           let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;
           if (depth == 0) {
               if (this.stack == this.start.stack)
                   this.stack = this.stack.slice();
               this.stack.push(this.state, 0, 0);
               this.base += 3;
           }
           else {
               this.base -= (depth - 1) * 3;
           }
           let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
           this.state = goto;
       }
   }
   // This is given to `Tree.build` to build a buffer, and encapsulates
   // the parent-stack-walking necessary to read the nodes.
   class StackBufferCursor {
       constructor(stack, pos, index) {
           this.stack = stack;
           this.pos = pos;
           this.index = index;
           this.buffer = stack.buffer;
           if (this.index == 0)
               this.maybeNext();
       }
       static create(stack, pos = stack.bufferBase + stack.buffer.length) {
           return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
       }
       maybeNext() {
           let next = this.stack.parent;
           if (next != null) {
               this.index = this.stack.bufferBase - next.bufferBase;
               this.stack = next;
               this.buffer = next.buffer;
           }
       }
       get id() { return this.buffer[this.index - 4]; }
       get start() { return this.buffer[this.index - 3]; }
       get end() { return this.buffer[this.index - 2]; }
       get size() { return this.buffer[this.index - 1]; }
       next() {
           this.index -= 4;
           this.pos -= 4;
           if (this.index == 0)
               this.maybeNext();
       }
       fork() {
           return new StackBufferCursor(this.stack, this.pos, this.index);
       }
   }

   // See lezer-generator/src/encode.ts for comments about the encoding
   // used here
   function decodeArray(input, Type = Uint16Array) {
       if (typeof input != "string")
           return input;
       let array = null;
       for (let pos = 0, out = 0; pos < input.length;) {
           let value = 0;
           for (;;) {
               let next = input.charCodeAt(pos++), stop = false;
               if (next == 126 /* Encode.BigValCode */) {
                   value = 65535 /* Encode.BigVal */;
                   break;
               }
               if (next >= 92 /* Encode.Gap2 */)
                   next--;
               if (next >= 34 /* Encode.Gap1 */)
                   next--;
               let digit = next - 32 /* Encode.Start */;
               if (digit >= 46 /* Encode.Base */) {
                   digit -= 46 /* Encode.Base */;
                   stop = true;
               }
               value += digit;
               if (stop)
                   break;
               value *= 46 /* Encode.Base */;
           }
           if (array)
               array[out++] = value;
           else
               array = new Type(value);
       }
       return array;
   }

   class CachedToken {
       constructor() {
           this.start = -1;
           this.value = -1;
           this.end = -1;
           this.extended = -1;
           this.lookAhead = 0;
           this.mask = 0;
           this.context = 0;
       }
   }
   const nullToken = new CachedToken;
   /**
   [Tokenizers](#lr.ExternalTokenizer) interact with the input
   through this interface. It presents the input as a stream of
   characters, tracking lookahead and hiding the complexity of
   [ranges](#common.Parser.parse^ranges) from tokenizer code.
   */
   class InputStream {
       /**
       @internal
       */
       constructor(
       /**
       @internal
       */
       input, 
       /**
       @internal
       */
       ranges) {
           this.input = input;
           this.ranges = ranges;
           /**
           @internal
           */
           this.chunk = "";
           /**
           @internal
           */
           this.chunkOff = 0;
           /**
           Backup chunk
           */
           this.chunk2 = "";
           this.chunk2Pos = 0;
           /**
           The character code of the next code unit in the input, or -1
           when the stream is at the end of the input.
           */
           this.next = -1;
           /**
           @internal
           */
           this.token = nullToken;
           this.rangeIndex = 0;
           this.pos = this.chunkPos = ranges[0].from;
           this.range = ranges[0];
           this.end = ranges[ranges.length - 1].to;
           this.readNext();
       }
       /**
       @internal
       */
       resolveOffset(offset, assoc) {
           let range = this.range, index = this.rangeIndex;
           let pos = this.pos + offset;
           while (pos < range.from) {
               if (!index)
                   return null;
               let next = this.ranges[--index];
               pos -= range.from - next.to;
               range = next;
           }
           while (assoc < 0 ? pos > range.to : pos >= range.to) {
               if (index == this.ranges.length - 1)
                   return null;
               let next = this.ranges[++index];
               pos += next.from - range.to;
               range = next;
           }
           return pos;
       }
       /**
       @internal
       */
       clipPos(pos) {
           if (pos >= this.range.from && pos < this.range.to)
               return pos;
           for (let range of this.ranges)
               if (range.to > pos)
                   return Math.max(pos, range.from);
           return this.end;
       }
       /**
       Look at a code unit near the stream position. `.peek(0)` equals
       `.next`, `.peek(-1)` gives you the previous character, and so
       on.
       
       Note that looking around during tokenizing creates dependencies
       on potentially far-away content, which may reduce the
       effectiveness incremental parsing—when looking forward—or even
       cause invalid reparses when looking backward more than 25 code
       units, since the library does not track lookbehind.
       */
       peek(offset) {
           let idx = this.chunkOff + offset, pos, result;
           if (idx >= 0 && idx < this.chunk.length) {
               pos = this.pos + offset;
               result = this.chunk.charCodeAt(idx);
           }
           else {
               let resolved = this.resolveOffset(offset, 1);
               if (resolved == null)
                   return -1;
               pos = resolved;
               if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                   result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
               }
               else {
                   let i = this.rangeIndex, range = this.range;
                   while (range.to <= pos)
                       range = this.ranges[++i];
                   this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                   if (pos + this.chunk2.length > range.to)
                       this.chunk2 = this.chunk2.slice(0, range.to - pos);
                   result = this.chunk2.charCodeAt(0);
               }
           }
           if (pos >= this.token.lookAhead)
               this.token.lookAhead = pos + 1;
           return result;
       }
       /**
       Accept a token. By default, the end of the token is set to the
       current stream position, but you can pass an offset (relative to
       the stream position) to change that.
       */
       acceptToken(token, endOffset = 0) {
           let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
           if (end == null || end < this.token.start)
               throw new RangeError("Token end out of bounds");
           this.token.value = token;
           this.token.end = end;
       }
       getChunk() {
           if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
               let { chunk, chunkPos } = this;
               this.chunk = this.chunk2;
               this.chunkPos = this.chunk2Pos;
               this.chunk2 = chunk;
               this.chunk2Pos = chunkPos;
               this.chunkOff = this.pos - this.chunkPos;
           }
           else {
               this.chunk2 = this.chunk;
               this.chunk2Pos = this.chunkPos;
               let nextChunk = this.input.chunk(this.pos);
               let end = this.pos + nextChunk.length;
               this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
               this.chunkPos = this.pos;
               this.chunkOff = 0;
           }
       }
       readNext() {
           if (this.chunkOff >= this.chunk.length) {
               this.getChunk();
               if (this.chunkOff == this.chunk.length)
                   return this.next = -1;
           }
           return this.next = this.chunk.charCodeAt(this.chunkOff);
       }
       /**
       Move the stream forward N (defaults to 1) code units. Returns
       the new value of [`next`](#lr.InputStream.next).
       */
       advance(n = 1) {
           this.chunkOff += n;
           while (this.pos + n >= this.range.to) {
               if (this.rangeIndex == this.ranges.length - 1)
                   return this.setDone();
               n -= this.range.to - this.pos;
               this.range = this.ranges[++this.rangeIndex];
               this.pos = this.range.from;
           }
           this.pos += n;
           if (this.pos >= this.token.lookAhead)
               this.token.lookAhead = this.pos + 1;
           return this.readNext();
       }
       setDone() {
           this.pos = this.chunkPos = this.end;
           this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
           this.chunk = "";
           return this.next = -1;
       }
       /**
       @internal
       */
       reset(pos, token) {
           if (token) {
               this.token = token;
               token.start = pos;
               token.lookAhead = pos + 1;
               token.value = token.extended = -1;
           }
           else {
               this.token = nullToken;
           }
           if (this.pos != pos) {
               this.pos = pos;
               if (pos == this.end) {
                   this.setDone();
                   return this;
               }
               while (pos < this.range.from)
                   this.range = this.ranges[--this.rangeIndex];
               while (pos >= this.range.to)
                   this.range = this.ranges[++this.rangeIndex];
               if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                   this.chunkOff = pos - this.chunkPos;
               }
               else {
                   this.chunk = "";
                   this.chunkOff = 0;
               }
               this.readNext();
           }
           return this;
       }
       /**
       @internal
       */
       read(from, to) {
           if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
               return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
           if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
               return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
           if (from >= this.range.from && to <= this.range.to)
               return this.input.read(from, to);
           let result = "";
           for (let r of this.ranges) {
               if (r.from >= to)
                   break;
               if (r.to > from)
                   result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
           }
           return result;
       }
   }
   /**
   @internal
   */
   class TokenGroup {
       constructor(data, id) {
           this.data = data;
           this.id = id;
       }
       token(input, stack) {
           let { parser } = stack.p;
           readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
       }
   }
   TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
   TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
   // Tokenizer data is stored a big uint16 array containing, for each
   // state:
   //
   //  - A group bitmask, indicating what token groups are reachable from
   //    this state, so that paths that can only lead to tokens not in
   //    any of the current groups can be cut off early.
   //
   //  - The position of the end of the state's sequence of accepting
   //    tokens
   //
   //  - The number of outgoing edges for the state
   //
   //  - The accepting tokens, as (token id, group mask) pairs
   //
   //  - The outgoing edges, as (start character, end character, state
   //    index) triples, with end character being exclusive
   //
   // This function interprets that data, running through a stream as
   // long as new states with the a matching group mask can be reached,
   // and updating `input.token` when it matches a token.
   function readToken(data, input, stack, group, precTable, precOffset) {
       let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
       scan: for (;;) {
           if ((groupMask & data[state]) == 0)
               break;
           let accEnd = data[state + 1];
           // Check whether this state can lead to a token in the current group
           // Accept tokens in this state, possibly overwriting
           // lower-precedence / shorter tokens
           for (let i = state + 3; i < accEnd; i += 2)
               if ((data[i + 1] & groupMask) > 0) {
                   let term = data[i];
                   if (dialect.allows(term) &&
                       (input.token.value == -1 || input.token.value == term ||
                           overrides(term, input.token.value, precTable, precOffset))) {
                       input.acceptToken(term);
                       break;
                   }
               }
           let next = input.next, low = 0, high = data[state + 2];
           // Special case for EOF
           if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {
               state = data[accEnd + high * 3 - 1];
               continue scan;
           }
           // Do a binary search on the state's edges
           for (; low < high;) {
               let mid = (low + high) >> 1;
               let index = accEnd + mid + (mid << 1);
               let from = data[index], to = data[index + 1] || 0x10000;
               if (next < from)
                   high = mid;
               else if (next >= to)
                   low = mid + 1;
               else {
                   state = data[index + 2];
                   input.advance();
                   continue scan;
               }
           }
           break;
       }
   }
   function findOffset(data, start, term) {
       for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)
           if (next == term)
               return i - start;
       return -1;
   }
   function overrides(token, prev, tableData, tableOffset) {
       let iPrev = findOffset(tableData, tableOffset, prev);
       return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
   }

   // Environment variable used to control console output
   const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
   let stackIDs = null;
   function cutAt(tree, pos, side) {
       let cursor = tree.cursor(IterMode.IncludeAnonymous);
       cursor.moveTo(pos);
       for (;;) {
           if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
               for (;;) {
                   if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                       return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))
                           : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));
                   if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                       break;
                   if (!cursor.parent())
                       return side < 0 ? 0 : tree.length;
               }
       }
   }
   class FragmentCursor {
       constructor(fragments, nodeSet) {
           this.fragments = fragments;
           this.nodeSet = nodeSet;
           this.i = 0;
           this.fragment = null;
           this.safeFrom = -1;
           this.safeTo = -1;
           this.trees = [];
           this.start = [];
           this.index = [];
           this.nextFragment();
       }
       nextFragment() {
           let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
           if (fr) {
               this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
               this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
               while (this.trees.length) {
                   this.trees.pop();
                   this.start.pop();
                   this.index.pop();
               }
               this.trees.push(fr.tree);
               this.start.push(-fr.offset);
               this.index.push(0);
               this.nextStart = this.safeFrom;
           }
           else {
               this.nextStart = 1e9;
           }
       }
       // `pos` must be >= any previously given `pos` for this cursor
       nodeAt(pos) {
           if (pos < this.nextStart)
               return null;
           while (this.fragment && this.safeTo <= pos)
               this.nextFragment();
           if (!this.fragment)
               return null;
           for (;;) {
               let last = this.trees.length - 1;
               if (last < 0) { // End of tree
                   this.nextFragment();
                   return null;
               }
               let top = this.trees[last], index = this.index[last];
               if (index == top.children.length) {
                   this.trees.pop();
                   this.start.pop();
                   this.index.pop();
                   continue;
               }
               let next = top.children[index];
               let start = this.start[last] + top.positions[index];
               if (start > pos) {
                   this.nextStart = start;
                   return null;
               }
               if (next instanceof Tree) {
                   if (start == pos) {
                       if (start < this.safeFrom)
                           return null;
                       let end = start + next.length;
                       if (end <= this.safeTo) {
                           let lookAhead = next.prop(NodeProp.lookAhead);
                           if (!lookAhead || end + lookAhead < this.fragment.to)
                               return next;
                       }
                   }
                   this.index[last]++;
                   if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                       this.trees.push(next);
                       this.start.push(start);
                       this.index.push(0);
                   }
               }
               else {
                   this.index[last]++;
                   this.nextStart = start + next.length;
               }
           }
       }
   }
   class TokenCache {
       constructor(parser, stream) {
           this.stream = stream;
           this.tokens = [];
           this.mainToken = null;
           this.actions = [];
           this.tokens = parser.tokenizers.map(_ => new CachedToken);
       }
       getActions(stack) {
           let actionIndex = 0;
           let main = null;
           let { parser } = stack.p, { tokenizers } = parser;
           let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);
           let context = stack.curContext ? stack.curContext.hash : 0;
           let lookAhead = 0;
           for (let i = 0; i < tokenizers.length; i++) {
               if (((1 << i) & mask) == 0)
                   continue;
               let tokenizer = tokenizers[i], token = this.tokens[i];
               if (main && !tokenizer.fallback)
                   continue;
               if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                   this.updateCachedToken(token, tokenizer, stack);
                   token.mask = mask;
                   token.context = context;
               }
               if (token.lookAhead > token.end + 25 /* Safety.Margin */)
                   lookAhead = Math.max(token.lookAhead, lookAhead);
               if (token.value != 0 /* Term.Err */) {
                   let startIndex = actionIndex;
                   if (token.extended > -1)
                       actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                   actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                   if (!tokenizer.extend) {
                       main = token;
                       if (actionIndex > startIndex)
                           break;
                   }
               }
           }
           while (this.actions.length > actionIndex)
               this.actions.pop();
           if (lookAhead)
               stack.setLookAhead(lookAhead);
           if (!main && stack.pos == this.stream.end) {
               main = new CachedToken;
               main.value = stack.p.parser.eofTerm;
               main.start = main.end = stack.pos;
               actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
           }
           this.mainToken = main;
           return this.actions;
       }
       getMainToken(stack) {
           if (this.mainToken)
               return this.mainToken;
           let main = new CachedToken, { pos, p } = stack;
           main.start = pos;
           main.end = Math.min(pos + 1, p.stream.end);
           main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;
           return main;
       }
       updateCachedToken(token, tokenizer, stack) {
           let start = this.stream.clipPos(stack.pos);
           tokenizer.token(this.stream.reset(start, token), stack);
           if (token.value > -1) {
               let { parser } = stack.p;
               for (let i = 0; i < parser.specialized.length; i++)
                   if (parser.specialized[i] == token.value) {
                       let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                       if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                           if ((result & 1) == 0 /* Specialize.Specialize */)
                               token.value = result >> 1;
                           else
                               token.extended = result >> 1;
                           break;
                       }
                   }
           }
           else {
               token.value = 0 /* Term.Err */;
               token.end = this.stream.clipPos(start + 1);
           }
       }
       putAction(action, token, end, index) {
           // Don't add duplicate actions
           for (let i = 0; i < index; i += 3)
               if (this.actions[i] == action)
                   return index;
           this.actions[index++] = action;
           this.actions[index++] = token;
           this.actions[index++] = end;
           return index;
       }
       addActions(stack, token, end, index) {
           let { state } = stack, { parser } = stack.p, { data } = parser;
           for (let set = 0; set < 2; set++) {
               for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {
                   if (data[i] == 65535 /* Seq.End */) {
                       if (data[i + 1] == 1 /* Seq.Next */) {
                           i = pair(data, i + 2);
                       }
                       else {
                           if (index == 0 && data[i + 1] == 2 /* Seq.Other */)
                               index = this.putAction(pair(data, i + 2), token, end, index);
                           break;
                       }
                   }
                   if (data[i] == token)
                       index = this.putAction(pair(data, i + 1), token, end, index);
               }
           }
           return index;
       }
   }
   class Parse {
       constructor(parser, input, fragments, ranges) {
           this.parser = parser;
           this.input = input;
           this.ranges = ranges;
           this.recovering = 0;
           this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
           this.minStackPos = 0;
           this.reused = [];
           this.stoppedAt = null;
           this.lastBigReductionStart = -1;
           this.lastBigReductionSize = 0;
           this.bigReductionCount = 0;
           this.stream = new InputStream(input, ranges);
           this.tokens = new TokenCache(parser, this.stream);
           this.topTerm = parser.top[1];
           let { from } = ranges[0];
           this.stacks = [Stack.start(this, parser.top[0], from)];
           this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
               ? new FragmentCursor(fragments, parser.nodeSet) : null;
       }
       get parsedPos() {
           return this.minStackPos;
       }
       // Move the parser forward. This will process all parse stacks at
       // `this.pos` and try to advance them to a further position. If no
       // stack for such a position is found, it'll start error-recovery.
       //
       // When the parse is finished, this will return a syntax tree. When
       // not, it returns `null`.
       advance() {
           let stacks = this.stacks, pos = this.minStackPos;
           // This will hold stacks beyond `pos`.
           let newStacks = this.stacks = [];
           let stopped, stoppedTokens;
           // If a large amount of reductions happened with the same start
           // position, force the stack out of that production in order to
           // avoid creating a tree too deep to recurse through.
           // (This is an ugly kludge, because unfortunately there is no
           // straightforward, cheap way to check for this happening, due to
           // the history of reductions only being available in an
           // expensive-to-access format in the stack buffers.)
           if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {
               let [s] = stacks;
               while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }
               this.bigReductionCount = this.lastBigReductionSize = 0;
           }
           // Keep advancing any stacks at `pos` until they either move
           // forward or can't be advanced. Gather stacks that can't be
           // advanced further in `stopped`.
           for (let i = 0; i < stacks.length; i++) {
               let stack = stacks[i];
               for (;;) {
                   this.tokens.mainToken = null;
                   if (stack.pos > pos) {
                       newStacks.push(stack);
                   }
                   else if (this.advanceStack(stack, newStacks, stacks)) {
                       continue;
                   }
                   else {
                       if (!stopped) {
                           stopped = [];
                           stoppedTokens = [];
                       }
                       stopped.push(stack);
                       let tok = this.tokens.getMainToken(stack);
                       stoppedTokens.push(tok.value, tok.end);
                   }
                   break;
               }
           }
           if (!newStacks.length) {
               let finished = stopped && findFinished(stopped);
               if (finished) {
                   if (verbose)
                       console.log("Finish with " + this.stackID(finished));
                   return this.stackToTree(finished);
               }
               if (this.parser.strict) {
                   if (verbose && stopped)
                       console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                   throw new SyntaxError("No parse at " + pos);
               }
               if (!this.recovering)
                   this.recovering = 5 /* Rec.Distance */;
           }
           if (this.recovering && stopped) {
               let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                   : this.runRecovery(stopped, stoppedTokens, newStacks);
               if (finished) {
                   if (verbose)
                       console.log("Force-finish " + this.stackID(finished));
                   return this.stackToTree(finished.forceAll());
               }
           }
           if (this.recovering) {
               let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;
               if (newStacks.length > maxRemaining) {
                   newStacks.sort((a, b) => b.score - a.score);
                   while (newStacks.length > maxRemaining)
                       newStacks.pop();
               }
               if (newStacks.some(s => s.reducePos > pos))
                   this.recovering--;
           }
           else if (newStacks.length > 1) {
               // Prune stacks that are in the same state, or that have been
               // running without splitting for a while, to avoid getting stuck
               // with multiple successful stacks running endlessly on.
               outer: for (let i = 0; i < newStacks.length - 1; i++) {
                   let stack = newStacks[i];
                   for (let j = i + 1; j < newStacks.length; j++) {
                       let other = newStacks[j];
                       if (stack.sameState(other) ||
                           stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {
                           if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                               newStacks.splice(j--, 1);
                           }
                           else {
                               newStacks.splice(i--, 1);
                               continue outer;
                           }
                       }
                   }
               }
               if (newStacks.length > 12 /* Rec.MaxStackCount */)
                   newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);
           }
           this.minStackPos = newStacks[0].pos;
           for (let i = 1; i < newStacks.length; i++)
               if (newStacks[i].pos < this.minStackPos)
                   this.minStackPos = newStacks[i].pos;
           return null;
       }
       stopAt(pos) {
           if (this.stoppedAt != null && this.stoppedAt < pos)
               throw new RangeError("Can't move stoppedAt forward");
           this.stoppedAt = pos;
       }
       // Returns an updated version of the given stack, or null if the
       // stack can't advance normally. When `split` and `stacks` are
       // given, stacks split off by ambiguous operations will be pushed to
       // `split`, or added to `stacks` if they move `pos` forward.
       advanceStack(stack, stacks, split) {
           let start = stack.pos, { parser } = this;
           let base = verbose ? this.stackID(stack) + " -> " : "";
           if (this.stoppedAt != null && start > this.stoppedAt)
               return stack.forceReduce() ? stack : null;
           if (this.fragments) {
               let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
               for (let cached = this.fragments.nodeAt(start); cached;) {
                   let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                   if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
                       stack.useNode(cached, match);
                       if (verbose)
                           console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                       return true;
                   }
                   if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                       break;
                   let inner = cached.children[0];
                   if (inner instanceof Tree && cached.positions[0] == 0)
                       cached = inner;
                   else
                       break;
               }
           }
           let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);
           if (defaultReduce > 0) {
               stack.reduce(defaultReduce);
               if (verbose)
                   console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);
               return true;
           }
           if (stack.stack.length >= 15000 /* Rec.CutDepth */) {
               while (stack.stack.length > 9000 /* Rec.CutTo */ && stack.forceReduce()) { }
           }
           let actions = this.tokens.getActions(stack);
           for (let i = 0; i < actions.length;) {
               let action = actions[i++], term = actions[i++], end = actions[i++];
               let last = i == actions.length || !split;
               let localStack = last ? stack : stack.split();
               localStack.apply(action, term, end);
               if (verbose)
                   console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
               if (last)
                   return true;
               else if (localStack.pos > start)
                   stacks.push(localStack);
               else
                   split.push(localStack);
           }
           return false;
       }
       // Advance a given stack forward as far as it will go. Returns the
       // (possibly updated) stack if it got stuck, or null if it moved
       // forward and was given to `pushStackDedup`.
       advanceFully(stack, newStacks) {
           let pos = stack.pos;
           for (;;) {
               if (!this.advanceStack(stack, null, null))
                   return false;
               if (stack.pos > pos) {
                   pushStackDedup(stack, newStacks);
                   return true;
               }
           }
       }
       runRecovery(stacks, tokens, newStacks) {
           let finished = null, restarted = false;
           for (let i = 0; i < stacks.length; i++) {
               let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
               let base = verbose ? this.stackID(stack) + " -> " : "";
               if (stack.deadEnd) {
                   if (restarted)
                       continue;
                   restarted = true;
                   stack.restart();
                   if (verbose)
                       console.log(base + this.stackID(stack) + " (restarted)");
                   let done = this.advanceFully(stack, newStacks);
                   if (done)
                       continue;
               }
               let force = stack.split(), forceBase = base;
               for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {
                   if (verbose)
                       console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                   let done = this.advanceFully(force, newStacks);
                   if (done)
                       break;
                   if (verbose)
                       forceBase = this.stackID(force) + " -> ";
               }
               for (let insert of stack.recoverByInsert(token)) {
                   if (verbose)
                       console.log(base + this.stackID(insert) + " (via recover-insert)");
                   this.advanceFully(insert, newStacks);
               }
               if (this.stream.end > stack.pos) {
                   if (tokenEnd == stack.pos) {
                       tokenEnd++;
                       token = 0 /* Term.Err */;
                   }
                   stack.recoverByDelete(token, tokenEnd);
                   if (verbose)
                       console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                   pushStackDedup(stack, newStacks);
               }
               else if (!finished || finished.score < stack.score) {
                   finished = stack;
               }
           }
           return finished;
       }
       // Convert the stack's buffer to a syntax tree.
       stackToTree(stack) {
           stack.close();
           return Tree.build({ buffer: StackBufferCursor.create(stack),
               nodeSet: this.parser.nodeSet,
               topID: this.topTerm,
               maxBufferLength: this.parser.bufferLength,
               reused: this.reused,
               start: this.ranges[0].from,
               length: stack.pos - this.ranges[0].from,
               minRepeatType: this.parser.minRepeatTerm });
       }
       stackID(stack) {
           let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
           if (!id)
               stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
           return id + stack;
       }
   }
   function pushStackDedup(stack, newStacks) {
       for (let i = 0; i < newStacks.length; i++) {
           let other = newStacks[i];
           if (other.pos == stack.pos && other.sameState(stack)) {
               if (newStacks[i].score < stack.score)
                   newStacks[i] = stack;
               return;
           }
       }
       newStacks.push(stack);
   }
   class Dialect {
       constructor(source, flags, disabled) {
           this.source = source;
           this.flags = flags;
           this.disabled = disabled;
       }
       allows(term) { return !this.disabled || this.disabled[term] == 0; }
   }
   /**
   Holds the parse tables for a given grammar, as generated by
   `lezer-generator`, and provides [methods](#common.Parser) to parse
   content with.
   */
   class LRParser extends Parser$1 {
       /**
       @internal
       */
       constructor(spec) {
           super();
           /**
           @internal
           */
           this.wrappers = [];
           if (spec.version != 14 /* File.Version */)
               throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);
           let nodeNames = spec.nodeNames.split(" ");
           this.minRepeatTerm = nodeNames.length;
           for (let i = 0; i < spec.repeatNodeCount; i++)
               nodeNames.push("");
           let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
           let nodeProps = [];
           for (let i = 0; i < nodeNames.length; i++)
               nodeProps.push([]);
           function setProp(nodeID, prop, value) {
               nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
           }
           if (spec.nodeProps)
               for (let propSpec of spec.nodeProps) {
                   let prop = propSpec[0];
                   if (typeof prop == "string")
                       prop = NodeProp[prop];
                   for (let i = 1; i < propSpec.length;) {
                       let next = propSpec[i++];
                       if (next >= 0) {
                           setProp(next, prop, propSpec[i++]);
                       }
                       else {
                           let value = propSpec[i + -next];
                           for (let j = -next; j > 0; j--)
                               setProp(propSpec[i++], prop, value);
                           i++;
                       }
                   }
               }
           this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({
               name: i >= this.minRepeatTerm ? undefined : name,
               id: i,
               props: nodeProps[i],
               top: topTerms.indexOf(i) > -1,
               error: i == 0,
               skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
           })));
           if (spec.propSources)
               this.nodeSet = this.nodeSet.extend(...spec.propSources);
           this.strict = false;
           this.bufferLength = DefaultBufferLength;
           let tokenArray = decodeArray(spec.tokenData);
           this.context = spec.context;
           this.specializerSpecs = spec.specialized || [];
           this.specialized = new Uint16Array(this.specializerSpecs.length);
           for (let i = 0; i < this.specializerSpecs.length; i++)
               this.specialized[i] = this.specializerSpecs[i].term;
           this.specializers = this.specializerSpecs.map(getSpecializer);
           this.states = decodeArray(spec.states, Uint32Array);
           this.data = decodeArray(spec.stateData);
           this.goto = decodeArray(spec.goto);
           this.maxTerm = spec.maxTerm;
           this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
           this.topRules = spec.topRules;
           this.dialects = spec.dialects || {};
           this.dynamicPrecedences = spec.dynamicPrecedences || null;
           this.tokenPrecTable = spec.tokenPrec;
           this.termNames = spec.termNames || null;
           this.maxNode = this.nodeSet.types.length - 1;
           this.dialect = this.parseDialect();
           this.top = this.topRules[Object.keys(this.topRules)[0]];
       }
       createParse(input, fragments, ranges) {
           let parse = new Parse(this, input, fragments, ranges);
           for (let w of this.wrappers)
               parse = w(parse, input, fragments, ranges);
           return parse;
       }
       /**
       Get a goto table entry @internal
       */
       getGoto(state, term, loose = false) {
           let table = this.goto;
           if (term >= table[0])
               return -1;
           for (let pos = table[term + 1];;) {
               let groupTag = table[pos++], last = groupTag & 1;
               let target = table[pos++];
               if (last && loose)
                   return target;
               for (let end = pos + (groupTag >> 1); pos < end; pos++)
                   if (table[pos] == state)
                       return target;
               if (last)
                   return -1;
           }
       }
       /**
       Check if this state has an action for a given terminal @internal
       */
       hasAction(state, terminal) {
           let data = this.data;
           for (let set = 0; set < 2; set++) {
               for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {
                   if ((next = data[i]) == 65535 /* Seq.End */) {
                       if (data[i + 1] == 1 /* Seq.Next */)
                           next = data[i = pair(data, i + 2)];
                       else if (data[i + 1] == 2 /* Seq.Other */)
                           return pair(data, i + 2);
                       else
                           break;
                   }
                   if (next == terminal || next == 0 /* Term.Err */)
                       return pair(data, i + 1);
               }
           }
           return 0;
       }
       /**
       @internal
       */
       stateSlot(state, slot) {
           return this.states[(state * 6 /* ParseState.Size */) + slot];
       }
       /**
       @internal
       */
       stateFlag(state, flag) {
           return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;
       }
       /**
       @internal
       */
       validAction(state, action) {
           return !!this.allActions(state, a => a == action ? true : null);
       }
       /**
       @internal
       */
       allActions(state, action) {
           let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);
           let result = deflt ? action(deflt) : undefined;
           for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {
               if (this.data[i] == 65535 /* Seq.End */) {
                   if (this.data[i + 1] == 1 /* Seq.Next */)
                       i = pair(this.data, i + 2);
                   else
                       break;
               }
               result = action(pair(this.data, i + 1));
           }
           return result;
       }
       /**
       Get the states that can follow this one through shift actions or
       goto jumps. @internal
       */
       nextStates(state) {
           let result = [];
           for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {
               if (this.data[i] == 65535 /* Seq.End */) {
                   if (this.data[i + 1] == 1 /* Seq.Next */)
                       i = pair(this.data, i + 2);
                   else
                       break;
               }
               if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {
                   let value = this.data[i + 1];
                   if (!result.some((v, i) => (i & 1) && v == value))
                       result.push(this.data[i], value);
               }
           }
           return result;
       }
       /**
       Configure the parser. Returns a new parser instance that has the
       given settings modified. Settings not provided in `config` are
       kept from the original parser.
       */
       configure(config) {
           // Hideous reflection-based kludge to make it easy to create a
           // slightly modified copy of a parser.
           let copy = Object.assign(Object.create(LRParser.prototype), this);
           if (config.props)
               copy.nodeSet = this.nodeSet.extend(...config.props);
           if (config.top) {
               let info = this.topRules[config.top];
               if (!info)
                   throw new RangeError(`Invalid top rule name ${config.top}`);
               copy.top = info;
           }
           if (config.tokenizers)
               copy.tokenizers = this.tokenizers.map(t => {
                   let found = config.tokenizers.find(r => r.from == t);
                   return found ? found.to : t;
               });
           if (config.specializers) {
               copy.specializers = this.specializers.slice();
               copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
                   let found = config.specializers.find(r => r.from == s.external);
                   if (!found)
                       return s;
                   let spec = Object.assign(Object.assign({}, s), { external: found.to });
                   copy.specializers[i] = getSpecializer(spec);
                   return spec;
               });
           }
           if (config.contextTracker)
               copy.context = config.contextTracker;
           if (config.dialect)
               copy.dialect = this.parseDialect(config.dialect);
           if (config.strict != null)
               copy.strict = config.strict;
           if (config.wrap)
               copy.wrappers = copy.wrappers.concat(config.wrap);
           if (config.bufferLength != null)
               copy.bufferLength = config.bufferLength;
           return copy;
       }
       /**
       Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
       are registered for this parser.
       */
       hasWrappers() {
           return this.wrappers.length > 0;
       }
       /**
       Returns the name associated with a given term. This will only
       work for all terms when the parser was generated with the
       `--names` option. By default, only the names of tagged terms are
       stored.
       */
       getName(term) {
           return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
       }
       /**
       The eof term id is always allocated directly after the node
       types. @internal
       */
       get eofTerm() { return this.maxNode + 1; }
       /**
       The type of top node produced by the parser.
       */
       get topNode() { return this.nodeSet.types[this.top[1]]; }
       /**
       @internal
       */
       dynamicPrecedence(term) {
           let prec = this.dynamicPrecedences;
           return prec == null ? 0 : prec[term] || 0;
       }
       /**
       @internal
       */
       parseDialect(dialect) {
           let values = Object.keys(this.dialects), flags = values.map(() => false);
           if (dialect)
               for (let part of dialect.split(" ")) {
                   let id = values.indexOf(part);
                   if (id >= 0)
                       flags[id] = true;
               }
           let disabled = null;
           for (let i = 0; i < values.length; i++)
               if (!flags[i]) {
                   for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)
                       (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
               }
           return new Dialect(dialect, flags, disabled);
       }
       /**
       Used by the output of the parser generator. Not available to
       user code. @hide
       */
       static deserialize(spec) {
           return new LRParser(spec);
       }
   }
   function pair(data, off) { return data[off] | (data[off + 1] << 16); }
   function findFinished(stacks) {
       let best = null;
       for (let stack of stacks) {
           let stopped = stack.p.stoppedAt;
           if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
               stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&
               (!best || best.score < stack.score))
               best = stack;
       }
       return best;
   }
   function getSpecializer(spec) {
       if (spec.external) {
           let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;
           return (value, stack) => (spec.external(value, stack) << 1) | mask;
       }
       return spec.get;
   }

   // This file was generated by lezer-generator. You probably shouldn't edit it.
   const spec_identifier = {__proto__:null,mod:72, and:80, or:82, xor:84, in:88, to:90, not:104, true:122, false:122};
   const parser = LRParser.deserialize({
     version: 14,
     states: "0[OYQPOOOYQPO'#CaO}QPO'#CdO!XQPO'#CiO!dQPO'#CoO%VQPO'#CnQ'bQPOOOOQO'#D]'#D]OOQO'#D^'#D^OYQPO'#D[O'lQPO'#DtO*[QPO'#DtO*fQPO'#DtO-XQPO'#DtO/zQPO'#DtOOQO'#Dt'#DtOYQPO'#D[O0RQPO,58{O0YQPO'#DuO0jQPO,59OOOQO'#Ck'#CkO0rQPO'#CjO0}QPO'#DvO1VQPO,59TO1[QPO'#CpO1cQPO,59YOYQPO,59_O4XQPO,59aOOQO'#Cx'#CxOOQO'#Cy'#CyOOQO'#Cz'#CzOOQO'#C{'#C{OOQO'#C|'#C|O4^QPO'#C|OOQO'#C}'#C}OOQO'#DO'#DOO5UQPO'#DPOOQO'#DR'#DROOQO'#DS'#DSOOQO'#DT'#DTO8dQPO'#DXOYQPO,59cOYQPO,59cOYQPO,59cOYQPO,59cOYQPO,59cOYQPO,59cOYQPO,59cOYQPO,59cOOQO'#D`'#D`OOQO'#Da'#DaOOQO,59v,59vOOQO'#Dd'#DdOYQPO,59}OYQPO,59}OYQPO'#DpQ9zQPOOOOQO'#DP'#DPOYQPO,59cOYQPO,59cO:}QPO,59vOOQO'#Di'#DiOYQPO,5:RO%VQPO'#CnOOQO,5:W,5:WO<sQPO,59vOOQO1G.g1G.gOYQPO'#DmO=^QPO,5:aO}QPO'#DnO=lQPO1G.jOOQO1G.j1G.jOYQPO,59UO=tQPO'#DoO=|QPO,5:bOOQO1G.o1G.oO>UQPO,59[OOQO'#Cr'#CrOYQPO1G.wO@^QPO1G.yOOQO1G.{1G.{OOQO,59h,59hOCQQPO1G.}OCXQPO1G.}OExQPO1G.}OFPQPO1G.}OHmQPO1G.}OKZQPO1G.}OMhQPO1G.}ONXQPO1G.}ONcQPO1G/iONjQPO1G/iONqQPO,5:[OOQO-E7n-E7nO!#hQPO1G.}O!#oQPO1G.}O!#vQPO1G/mOOQO,59Y,59YO!$aQPO,5:XOOQO-E7k-E7kOOQO,5:Y,5:YOOQO-E7l-E7lOOQO7+$U7+$UO!$qQPO1G.pOOQO,5:Z,5:ZOOQO-E7m-E7mOOQO1G.v1G.vO!${QPO7+$cO!%fQPO'#CtOOQO7+$e7+$eOYQPO7+$eO!&]QPO7+%TO!'cQPO'#DXOYQPO7+%TO!(YQPO<<HPO!(aQPO<<HoOOQOAN=kAN=k",
     stateData: "!(}~O!gOSPOS~OSPOVQO[RO`_O!U`O!^[O!__O!kSO!xVO!yVO#RWO~OU!iPY!iP~PYO`eO!kdOZ!jP~OScXV![XY![Xa![Xj![Xt![Xx![Xy![Xz![X|![X}![X!e![X!l![X!m![X!n![X!o![X!p![X!q![X!r![X!s![X!t![X!u![X!v![X!w![X!x![X!y![X!z![X!{![X!|![X!}![X#O![X#P![X#Q![X#S![X#T![X#U![X#V![XR![XU![XX![XZ![X~OShO~OVjOaxOjkOt!ZOx![Oy!]Oz{O|!QO}!QO!mlO!nlO!olO!plO!qlO!rlO!smO!tnO!uoO!vpO!wqO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SO#U!UO~OY!XO#V!XO~P%[O!l!_OV!hXY!hXa!hXj!hXt!hXx!hXy!hXz!hX|!hX}!hX!e!hX!m!hX!n!hX!o!hX!p!hX!q!hX!r!hX!s!hX!t!hX!u!hX!v!hX!w!hX!x!hX!y!hX!z!hX!{!hX!|!hX!}!hX#O!hX#P!hX#Q!hX#S!hX#T!hX#U!hX#V!hXR!hXU!hXX!hXZ!hX~O!^!bO!kSO~P'lOSPO!kSOV!hXY!hXa!hXj!hXt!hXx!hXy!hXz!hX|!hX}!hX!e!hX!m!hX!n!hX!o!hX!p!hX!q!hX!r!hX!s!hX!t!hX!u!hX!v!hX!w!hX!x!hX!y!hX!z!hX!{!hX!|!hX!}!hX#O!hX#P!hX#Q!hX#S!hX#T!hX#U!hX#V!hXR!hXU!hXX!hXZ!hX~O!^!bO!kSOV!hXY!hXa!hXj!hXt!hXx!hXy!hXz!hX|!hX}!hX!e!hX!m!hX!n!hX!o!hX!p!hX!q!hX!r!hX!s!hX!t!hX!u!hX!v!hX!w!hX!x!hX!y!hX!z!hX!{!hX!|!hX!}!hX#O!hX#P!hX#Q!hX#S!hX#T!hX#U!hX#V!hXR!hXU!hXX!hXZ!hX~O!^!bO~P*fOR!dO~P%[OX!eOU!iXY!iXR!iX~P%[OU!iOY!gO~Oa!jOX^XZ^X~OX!kOZ!jX~OZ!mO~OR!iP~PYO!l!oOVbaYbaabajbatbaxbaybazba|ba}ba!^ba!eba!kba!mba!nba!oba!pba!qba!rba!sba!tba!uba!vba!wba!xba!yba!zba!{ba!|ba!}ba#Oba#Pba#Qba#Sba#Tba#Uba#VbaRbaUbaXbaZba~O!kdO~O!p!sOSpXVpX[pX`pX!UpX!^pX!_pX!kpX!xpX!ypX#RpX~OSsXVsXV!RXY!RX[sX`sXa!RXj!RXt!RXx!RXy!RXz!RX|!RX}!RX!UsX!^sX!_sX!e!RX!ksX!m!RX!n!RX!o!RX!p!RX!q!RX!r!RX!s!RX!t!RX!u!RX!v!RX!w!RX!xsX!x!RX!ysX!y!RX!z!RX!{!RX!|!RX!}!RX#O!RX#P!RX#Q!RX#RsX#S!RX#T!RX#U!RX#V!RXR!RXU!RXX!RXZ!RX~OS{XS!XXV{XV!XX[{X[!XX`{X`!XX!U{X!U!XX!^{X!^!XX!_{X!_!XX!k{X!k!XX!x{X!x!XX!y{X!y!XX#R{X#R!XX~OY!XO#V!XO~OVjOjkO!}uO#QwO#S!RO#T!SOY!Oa!e!Oa#V!OaR!OaU!OaX!OaZ!Oa~Oa!Oat!Oax!Oay!Oaz!Oa|!Oa}!Oa!m!Oa!n!Oa!o!Oa!p!Oa!q!Oa!r!Oa!s!Oa!t!Oa!u!Oa!v!Oa!w!Oa!x!Oa!y!Oa!z!Oa!{!Oa!|!Oa#O!Oa#P!Oa#U!Oa~P:SOY!Oa!e!Oa#V!OaR!OaU!OaX!OaZ!Oa~P%[OX!eOU!iaY!iaR!ia~OU#YOY!gO~O`eO!kdO~OX!kOZ!ja~OR#^O~OVjOjkOt!ZOx![Oy!]Oz{O|!QO}!QO!mlO!nlO!olO!plO!qlO!rlO!smO!tnO!uoO!vpO!wqO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SO#U!UO~OU#aOa#`O~P>ZOVjOaxOjkOt!ZOz{O|!QO}!QO!tnO!uoO!vpO!wqO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SOYkixkiyki!eki!mki!nki!oki!pki!qki!rki#Uki#VkiRkiUkiXkiZki~O!smO~P@hO!ski~P@hOVjOaxOjkOt!ZO|!QO}!QO!vpO!wqO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SOYkixkiykizki!eki!mki!nki!oki!pki!qki!rki!ski!tki#Uki#VkiRkiUkiXkiZki~O!uoO~PC`O!uki~PC`OVjOaxOjkOt!ZO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SOYkixkiykizki!eki!mki!nki!oki!pki!qki!rki!ski!tki!uki!vki!wki#Uki#VkiRkiUkiXkiZki~O|!QO}!QO~PFWOVjOjkOt!ZO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SOYkixkiykizki|ki}ki!eki!mki!nki!oki!pki!qki!rki!ski!tki!uki!vki!wki#Uki#VkiRkiUkiXkiZki~Oaki!xki!yki~PHwOVjOjkO!}uO#QwO#S!RO#T!SOYkixkiykizki|ki}ki!eki!mki!nki!oki!pki!qki!rki!ski!tki!uki!vki!wki#Uki#VkiRkiUkiXkiZki~Oakitki!xki!yki!zki!{ki!|ki#Oki#Pki~PKhO|ki}ki~PFWOa#cO~P>ZOa#dO~P>ZOY!da!e!da#V!da~P%[OVjOaxOjkOt!ZOz{O|!QO}!QO!mlO!nlO!olO!plO!qlO!rlO!smO!tnO!uoO!vpO!wqO!xrO!yrO!zsO!{sO!|tO!}uO#OvO#PvO#QwO#S!RO#T!SOYkiyki!eki#Uki#VkiRkiUkiXkiZki~Oxki~P! OOx![O~P! OOY!Zi!e!Zi#V!ZiR!ZiU!ZiX!ZiZ!Zi~P%[OU!aaX!aaY!aaR!aa~P%[OX^iZ^i~P%[OYeq!eeq#VeqReqUeqXeqZeq~P%[OShXVhX[hX`hX!UhX!^hX!_hX!khX!xhX!yhX#RhX~P8dOS{XS!XXV{XV!XX[{X[!XX`{X`!XX!U{X!U!XX!^{X!^!XX!_{X!_!XX!k{X!k!XX~PYOS!YXV!YX[!YX`!YX!U!YX!^!YX!_!YX!k!YX!x!YX!y!YX#R!YX~P8dOU#hO~P%[OY!Vy!e!Vy#V!VyR!VyU!VyX!VyZ!Vy~P%[O!^j~",
     goto: "2f!kPPPPP!lPP#`PPPP$O$n$tPP${%q&g$O&m&p'`'cP$O(R(e(x)^)s*Z*s*sP+^*s+^PPP+yPP$O,c,c-R-l-lP$O.X.i/R$O/U/zPP$O0O0U0[0bPPP0h2Y2c!Y^OPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eT!b[^!Z]OPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#e!Z_OPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eQfRR#[!kSeR!kR!rk!Y]OPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eX!bZ[]^!YTOPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eX!aZ[]^QiTR#T!aR!pi!ZZOPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eR#b!q!ZYOPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eqyUab!c!q!|!}#O#Q#R#S#U#Z#_#f#gszUab!c!q!t!|!}#O#Q#R#S#U#Z#_#f#gu{Uab!c!q!t!u!|!}#O#Q#R#S#U#Z#_#f#gw|Uab!c!q!t!u!v!|!}#O#Q#R#S#U#Z#_#f#gy}Uab!c!q!t!u!v!w!|!}#O#Q#R#S#U#Z#_#f#g}!OUab!c!q!t!u!v!w!x!{!|!}#O#Q#R#S#U#Z#_#f#g!P!PUab!c!q!t!u!v!w!x!y!{!|!}#O#Q#R#S#U#Z#_#f#g!T!PUab!^!c!q!t!u!v!w!x!y!z!{!|!}#O#Q#R#S#U#Z#_#f#g}!QUab!c!q!t!u!v!w!x!{!|!}#O#Q#R#S#U#Z#_#f#g!ZXOPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#e!P!TUab!c!q!t!u!v!w!x!y!{!|!}#O#Q#R#S#U#Z#_#f#g!T!TUab!^!c!q!t!u!v!w!x!y!z!{!|!}#O#Q#R#S#U#Z#_#f#gm!VUab!c!q!|!}#O#S#U#Z#_#f#g}!WUab!c!q!t!u!v!w!x!{!|!}#O#Q#R#S#U#Z#_#f#gR#e!}!YYOPQX`hjyz{|}!O!P!Q!V!W!X![!]!`!e!g!j!p#b#c#eX!bZ[]^T!`YZQ!fbR#V!fQ!hcR#X!hQ!lfR#]!lQ!YUR#P!YQUOQaPUbQh!gQ!^XQ!c`Q!qjQ!tyQ!uzQ!v{Q!w|Q!x}Q!y!OQ!z!PQ!{!QQ!|!VQ!}!WQ#O!XQ#Q![Q#R!]Q#S!`Q#U!eQ#Z!jQ#_!pQ#f#bT#g#c#eQcQQ!nhR#W!gRgR",
     nodeNames: "⚠ LineComment Expressions ) ( Grouping ] [ Matrix , ; } { Object Property PropertyName String : CallExpression FunctionName ArgumentList FunctionDeclaration AssignOp IndexExpression RangeOp PropertyExpression . BinaryExpression CompareOp BitOp BitOp BitOp BitOp ArithOp ArithOp ArithOp mod ArithOp ElWiseOp ElWiseOp and or xor RangeOp in to UnaryExpression ArithOp BitOp PercentageOp TransposeOp FactorialOp not TernaryExpression LogicOp RangeOp RangeOp AssignmentExpression Identifier AssignOp Number Boolean ImpliedMultiplication",
     maxTerm: 99,
     nodeProps: [
       ["openedBy", 3,"(",6,"[",11,"{"],
       ["closedBy", 4,")",7,"]",12,"}"]
     ],
     skippedNodes: [0,1],
     repeatNodeCount: 4,
     tokenData: "2j~RxXY#oYZ#tpq#oqr#yrs$Wst&Qtu&iuv'avw'fwx'kxy*Qyz*Vz{*[{|*a|}*f}!O*k!O!P*p!P!Q,[!Q!R,a!R![,{![!]0T!]!^0Y!^!_0_!_!`0t!`!a1R!a!b1h!c!}&i!}#O1m#P#Q1r#Q#R1w#R#S&i#T#o&i#o#p2U#p#q2Z#q#r2`#r#s2e%W/|&i4U7[&i$Nn%!b&i;(Z;(['Z~#tO!g~~#yO#V~~$OP#T~!_!`$R~$WO!n~~$ZXOY$WZ]$W^r$Wrs$vs#O$W#O#P${#P;'S$W;'S;=`%z<%lO$W~${O`~~%ORO;'S$W;'S;=`%X;=`O$W~%[YOY$WZ]$W^r$Wrs$vs#O$W#O#P${#P;'S$W;'S;=`%z;=`<%l$W<%lO$W~%}P;=`<%l$W~&VSP~OY&QZ;'S&Q;'S;=`&c<%lO&Q~&fP;=`<%l&Q~&nX!k~tu&i!Q![&i!c!}&i#R#S&i#T#o&i%W/|&i4U7[&i$Nn%!b&i;(Z;(['Z~'^P;=`<%l&i~'fO!|~~'kO!u~~'pX#S~OY(]Z](]^w(]wx$vx#O(]#O#P({#P;'S(];'S;=`)z<%lO(]~(`XOY(]Z](]^w(]wx$vx#O(]#O#P({#P;'S(];'S;=`)z<%lO(]~)ORO;'S(];'S;=`)X;=`O(]~)[YOY(]Z](]^w(]wx$vx#O(]#O#P({#P;'S(];'S;=`)z;=`<%l(]<%lO(]~)}P;=`<%l(]~*VOS~~*[OR~~*aO!z~~*fO!x~~*kOX~~*pO!y~~*uSj~z{+R!P!Q+W!Q![+]#Q#R,V~+WO#O~~+]O#P~~+bR!^~!Q![+]!g!h+k#X#Y+k~+nR{|+w}!O+w!Q![+}~+zP!Q![+}~,SP!^~!Q![+}~,[O#Q~~,aO!{~~,fV!^~!O!P+]!Q![,{!g!h+k#U#V-^#X#Y+k#c#d.W#l#m/Q~-QS!^~!O!P+]!Q![,{!g!h+k#X#Y+k~-aQ!Q!R-g!R!S-g~-lS!^~!O!P-x!Q!R-g!R!S-g#]#^+w~-}R!^~!Q!R-x!R!S-x#]#^+w~.ZQ!Q!Y.a#R#S.a~.fS!^~!O!P.r!Q!Y.a#R#S.a#]#^+w~.wR!^~!Q!Y.r#R#S.r#]#^+w~/TR!Q![/^!c!i/^#T#Z/^~/cT!^~!O!P/r!Q![/^!c!i/^#T#Z/^#]#^+w~/wS!^~!Q![/r!c!i/r#T#Z/r#]#^+w~0YOa~~0_OY~~0dQ!o~!^!_0j!_!`0o~0oO!v~~0tO!q~~0yP!l~!_!`0|~1RO!m~~1WQ!p~!_!`1^!`!a1c~1cO!r~~1hO!w~~1mO#U~~1rOV~~1wOU~~1|P!}~#p#q2P~2UO!t~~2ZO[~~2`O!s~~2eOZ~~2jO#R~",
     tokenizers: [0],
     topRules: {"Expressions":[0,2]},
     specialized: [{term: 73, get: (value) => spec_identifier[value] || -1}],
     tokenPrec: 2480
   });

   const parserWithMetadata = parser.configure({
       props: [
           styleTags({
               Identifier: tags.name,
               Boolean: tags.bool,
               String: tags.string,
               Number: tags.number,
               LineComment: tags.lineComment,
               PropertyName: tags.propertyName,
               ArithOp: tags.arithmeticOperator,
               ElWiseOp: tags.arithmeticOperator,
               BitOp: tags.bitwiseOperator,
               CompareOp: tags.compareOperator,
               LogicOp: tags.logicOperator,
               "( )": tags.paren,
               "[ ]": tags.squareBracket,
               "{ }": tags.brace,
           }),
           // indentNodeProp.add({
           //   Application: context => context.column(context.node.from) + context.unit
           // }),
           // foldNodeProp.add({
           //   Application: foldInside
           // })
       ]
   });
   const mathjsLanguage = LRLanguage.define({
       parser: parserWithMetadata,
       languageData: {
           commentTokens: { line: "#" },
       },
   });
   const mathjsCompletion = mathjsLanguage.data.of({
       autocomplete: completeFromList([
           { label: "defun", type: "keyword" },
           { label: "defvar", type: "keyword" },
           { label: "let", type: "keyword" },
           { label: "cons", type: "function" },
           { label: "car", type: "function" },
           { label: "cdr", type: "function" }
       ])
   });
   function mathjs() {
       return new LanguageSupport(mathjsLanguage, [mathjsCompletion]);
   }

   var _a;
   new EditorView({
       state: EditorState.create({
           doc: (_a = localStorage.getItem("doc")) !== null && _a !== void 0 ? _a : "",
           extensions: [
               basicSetup,
               mathjs(),
               renderInlineSuggestionPlugin,
               EditorView.updateListener.of((update) => {
                   if (update.docChanged) {
                       localStorage.setItem("doc", update.state.doc.toString());
                   }
               }),
           ],
       }),
       parent: document.body,
   });

})();
